<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>附录A. 丢包检测伪代码 on AUTUMN QUICHE</title>
    <link>/RFC9002_Chinese_Translation/Loss_Recovery_Pseudocode/</link>
    <description>Recent content in 附录A. 丢包检测伪代码 on AUTUMN QUICHE</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>cn</language><atom:link href="/RFC9002_Chinese_Translation/Loss_Recovery_Pseudocode/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>A.2. 感兴趣的常量</title>
      <link>/RFC9002_Chinese_Translation/Loss_Recovery_Pseudocode/A.2_Constants_of_Interest/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9002_Chinese_Translation/Loss_Recovery_Pseudocode/A.2_Constants_of_Interest/</guid>
      <description>在丢包恢复中使用到的常量是基于一系列RFC、论文和常用实践的组合。
 kPacketThreshold：  在基于数据包数量阈值的丢包检测法认定某数据包丢包前允许出现乱序数据包的最大数量。在第6.1.1章中推荐的值为3。
 kTimeThreshold：  在基于数据包发送时间阈值的丢包检测法认定某数据包丢包前允许出现乱序数据包的最长时间。它被指定为RTT倍率。在第6.1.2章中推荐的值为9/8。
 kGranularity：  计时器粒度。这是一个与系统相关的值，在第6.1.2章中推荐的值为1毫秒。
 kInitialRtt：  在对RTT进行采样前使用的RTT初始值。在第6.2.2章中推荐的值为333毫秒。
 kPacketNumberSpace：  用于枚举三个数据包号空间的枚举值。
  enum kPacketNumberSpace { Initial, Handshake, ApplicationData, } 
 </description>
    </item>
    
    <item>
      <title>A.3. 感兴趣的变量</title>
      <link>/RFC9002_Chinese_Translation/Loss_Recovery_Pseudocode/A.3_Variables_of_Interest/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9002_Chinese_Translation/Loss_Recovery_Pseudocode/A.3_Variables_of_Interest/</guid>
      <description>本节描述了实现丢包检测机制所需的变量。
 latest_rtt：  当接收到对于一个未曾确认过的数据包的确认时的最近一次的RTT测量值。
 smoothed_rtt：  当前连接的经平滑的RTT，有关计算方法详见第5.3章。
 rttvar：  RTT的偏差，有关计算方法详见第5.3章。
 min_rtt：  在一段时间内观测到的RTT最小值，并忽略确认延迟，详见第5.2章。
 first_rtt_sample：  取得首份RTT样本的时间。
 max_ack_delay：  接收方有意拖延对处于应用数据数据包号空间中的数据包的确认的最长时间，其定义与同名传输参数一致（详见《QUIC传输》的第18.2章）。注意在接收到的ACK帧中的实际ack_delay可能会因为计时器延迟、数据包乱序或丢包的原因而超过该值。
 loss_detection_timer：  用于丢包检测的多用途计时器。
 pto_count：  在没有接收到确认的情况下PTO超时的触发次数。
 time_of_last_ack_eliciting_packet[kPacketNumberSpace]：  最近一个ACK触发包被发送时的时间。
 largest_acked_packet[kPacketNumberSpace]：  至今为止在该数据包号空间中发送过的最大数据包号。
 loss_time[kPacketNumberSpace]：  该数据包号空间中的下一个数据包会因为超过乱序数据包的时间阈值而被认定为丢包的时间。
 sent_packets[kPacketNumberSpace]：  该数据包号空间中数据包号与其对应的数据包信息之间的关联。在上文的附录A.1中已详细描述。
  </description>
    </item>
    
    <item>
      <title>A.4. 初始化</title>
      <link>/RFC9002_Chinese_Translation/Loss_Recovery_Pseudocode/A.4_Initialization/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9002_Chinese_Translation/Loss_Recovery_Pseudocode/A.4_Initialization/</guid>
      <description>在连接的一开始，以这种方式初始化丢包检测变量：
loss_detection_timer.reset() pto_count = 0 latest_rtt = 0 smoothed_rtt = kInitialRtt rttvar = kInitialRtt / 2 min_rtt = 0 first_rtt_sample = 0 for pn_space in [ Initial, Handshake, ApplicationData ]: largest_acked_packet[pn_space] = infinite time_of_last_ack_eliciting_packet[pn_space] = 0 loss_time[pn_space] = 0 
 </description>
    </item>
    
    <item>
      <title>A.5. 在发送数据包时</title>
      <link>/RFC9002_Chinese_Translation/Loss_Recovery_Pseudocode/A.5_On_Sending_a_Packet/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9002_Chinese_Translation/Loss_Recovery_Pseudocode/A.5_On_Sending_a_Packet/</guid>
      <description>在发送某个数据包后，有关该数据包的信息会被储存。OnPacketSent的参数已在上文的附录A.1.1中描述。
OnPacketSent的伪代码如下：
OnPacketSent(packet_number, pn_space, ack_eliciting, in_flight, sent_bytes): sent_packets[pn_space][packet_number].packet_number = packet_number sent_packets[pn_space][packet_number].time_sent = now() sent_packets[pn_space][packet_number].ack_eliciting = ack_eliciting sent_packets[pn_space][packet_number].in_flight = in_flight sent_packets[pn_space][packet_number].sent_bytes = sent_bytes if (in_flight): if (ack_eliciting): time_of_last_ack_eliciting_packet[pn_space] = now() OnPacketSentCC(sent_bytes) SetLossDetectionTimer() 
 </description>
    </item>
    
    <item>
      <title>A.6. 在接收到数据报时</title>
      <link>/RFC9002_Chinese_Translation/Loss_Recovery_Pseudocode/A.6_On_Receiving_a_Datagram/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9002_Chinese_Translation/Loss_Recovery_Pseudocode/A.6_On_Receiving_a_Datagram/</guid>
      <description>当服务器被抗放大上限阻止发送时，接收到的数据报能够为它解除禁言，即使该数据报中没有一个数据包成功得到处理。在这种情况下，需要重新设置PTO计时器。
OnDatagramReceived的伪代码如下：
OnDatagramReceived(datagram): // 如果该数据报能为服务器解禁， // 那么设置PTO计时器来避免死锁。 if (服务器被抗放大上限阻止发送): SetLossDetectionTimer() if loss_detection_timer.timeout &amp;lt; now(): // 假设抗放大上限仍生效， // 如果PTO会超时，那么执行它。 OnLossDetectionTimeout() 
 </description>
    </item>
    
    <item>
      <title>A.7. 在接收到确认时</title>
      <link>/RFC9002_Chinese_Translation/Loss_Recovery_Pseudocode/A.7_On_Receiving_an_Acknowledgment/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9002_Chinese_Translation/Loss_Recovery_Pseudocode/A.7_On_Receiving_an_Acknowledgment/</guid>
      <description>当接收到某ACK帧时，它可能新确认任意数量的数据包。
OnAckReceived和UpdateRtt的伪代码如下：
IncludesAckEliciting(packets): for packet in packets: if (packet.ack_eliciting): return true return false OnAckReceived(ack, pn_space): if (largest_acked_packet[pn_space] == infinite): largest_acked_packet[pn_space] = ack.largest_acked else: largest_acked_packet[pn_space] = max(largest_acked_packet[pn_space], ack.largest_acked) // `DetectAndRemoveAckedPackets`找到新确认的数据包 // 并将它们从`sent_packets`中移除。 newly_acked_packets = DetectAndRemoveAckedPackets(ack, pn_space) // 如果没有新确认的数据包，那么什么都不做。 if (newly_acked_packets.empty()): return // 如果最大已确认数据包是此次新确认的， // 并且此次至少确认一个ACK触发包，那么更新RTT。 if (newly_acked_packets.largest().packet_number == ack.largest_acked &amp;amp;&amp;amp; IncludesAckEliciting(newly_acked_packets)): latest_rtt = now() - newly_acked_packets.largest().time_sent UpdateRtt(ack.ack_delay) // 如果存在ECN信息，那么处理它们。 if (ACK frame contains ECN information): ProcessECN(ack, pn_space) lost_packets = DetectAndRemoveLostPackets(pn_space) if (!</description>
    </item>
    
    <item>
      <title>A.8. 设置丢包检测计时器</title>
      <link>/RFC9002_Chinese_Translation/Loss_Recovery_Pseudocode/A.8_Setting_the_Loss_Detection_Timer/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9002_Chinese_Translation/Loss_Recovery_Pseudocode/A.8_Setting_the_Loss_Detection_Timer/</guid>
      <description>QUIC的丢包检测使用一个计时器来检测所有超时事件，计时器的时长取决于计时器的模式，后者是在下文描述的数据包事件和计时器事件中指定的。下文定义的SetLossDetectionTimer展示了怎样设置这个计时器。
本算法可能导致计时器被设置到一个过去的时间，尤其是计时器没有被及时唤醒时。被设置到过去的时间的计时器会立即超时。
SetLossDetectionTimer的伪代码如下（其中^符号表示幂运算）：
GetLossTimeAndSpace(): time = loss_time[Initial] space = Initial for pn_space in [ Handshake, ApplicationData ]: if (time == 0 || loss_time[pn_space] &amp;lt; time): time = loss_time[pn_space]; space = pn_space return time, space GetPtoTimeAndSpace(): duration = (smoothed_rtt + max(4 * rttvar, kGranularity)) * (2 ^ pto_count) // 解死锁PTO从当前时间启动。 if (没有在途的ACK触发包): assert(!PeerCompletedAddressValidation()) if (有握手密钥): return (now() + duration), Handshake else: return (now() + duration), Initial pto_timeout = infinite pto_space = Initial for space in [ Initial, Handshake, ApplicationData ]: if (该space中没有在途的ACK触发包): continue; if (space == ApplicationData): // 除非握手已确认，否则跳过应用数据。 if (未确认握手): return pto_timeout, pto_space // 为应用数据空间将`max_ack_delay`和补偿纳入考量 duration += max_ack_delay * (2 ^ pto_count) t = time_of_last_ack_eliciting_packet[space] + duration if (t &amp;lt; pto_timeout): pto_timeout = t pto_space = space return pto_timeout, pto_space PeerCompletedAddressValidation(): // 假定客户端已隐式地验证了服务器的地址。 if (终端是服务器): return true // 当接收到受保护的数据包时， // 服务器完成地址验证。 return 已接收到对于握手的确认 || 握手已确认 SetLossDetectionTimer(): earliest_loss_time, _ = GetLossTimeAndSpace() if (earliest_loss_time !</description>
    </item>
    
    <item>
      <title>A.9. 在超时时</title>
      <link>/RFC9002_Chinese_Translation/Loss_Recovery_Pseudocode/A.9_On_Timeout/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9002_Chinese_Translation/Loss_Recovery_Pseudocode/A.9_On_Timeout/</guid>
      <description>当丢包检测计时器超时时，计时器的模式决定了需要采取的行动。
OnLossDetectionTimeout的伪代码如下：
OnLossDetectionTimeout(): earliest_loss_time, pn_space = GetLossTimeAndSpace() if (earliest_loss_time != 0): // 基于数据包发送时间阈值的丢包检测法。 lost_packets = DetectAndRemoveLostPackets(pn_space) assert(!lost_packets.empty()) OnPacketsLost(lost_packets) SetLossDetectionTimer() return if (没有在途的ACK触发包): assert(!PeerCompletedAddressValidation()) // 客户端发送了解死锁数据包：填充了初始数据包来挣得 // 更多的抗放大额度，握手数据包则证明了对地址的所有权。 if (有握手密钥): SendOneAckElicitingHandshakePacket() else: SendOneAckElicitingPaddedInitialPacket() else: // PTO。如果有新数据可用，那就发送，否则重传旧数据。 // 如果两者均不可用，那就发送一个Ping帧。 _, pn_space = GetPtoTimeAndSpace() SendOneOrTwoAckElicitingPackets(pn_space) pto_count++ SetLossDetectionTimer() 
 </description>
    </item>
    
    <item>
      <title>A.10. 检测丢包</title>
      <link>/RFC9002_Chinese_Translation/Loss_Recovery_Pseudocode/A.10_Detecting_Lost_Packets/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9002_Chinese_Translation/Loss_Recovery_Pseudocode/A.10_Detecting_Lost_Packets/</guid>
      <description>每次接收到ACK帧或时间阈值丢包检测计时器超时时，都会调用DetectAndRemoveLostPackets。该函数对响应数据包号空间中的已发送数据包（sent_packets）进行操作，并返回一份最新被认定为丢包的数据包的列表。
DetectAndRemoveLostPackets的伪代码如下：
DetectAndRemoveLostPackets(pn_space): assert(largest_acked_packet[pn_space] != infinite) loss_time[pn_space] = 0 lost_packets = [] loss_delay = kTimeThreshold * max(latest_rtt, smoothed_rtt) // 在数据包被认定为丢失前经过的最少时间，但不小于`kGranularity`。 loss_delay = max(loss_delay, kGranularity) // 在此时间之前发送的数据包被认定为丢包。 lost_send_time = now() - loss_delay foreach unacked in sent_packets[pn_space]: if (unacked.packet_number &amp;gt; largest_acked_packet[pn_space]): continue // 标记数据包为丢包，或设置一个它应该被标记为丢包的时间。 // 注意：这里使用`kPacketThreshold`的前提是 // 假定了在数据包号空间中没有由发送方引入的空档。 if (unacked.time_sent &amp;lt;= lost_send_time || largest_acked_packet[pn_space] &amp;gt;= unacked.packet_number + kPacketThreshold): sent_packets[pn_space].remove(unacked.packet_number) lost_packets.insert(unacked) else: if (loss_time[pn_space] == 0): loss_time[pn_space] = unacked.time_sent + loss_delay else: loss_time[pn_space] = min(loss_time[pn_space], unacked.</description>
    </item>
    
    <item>
      <title>A.11. 在启用初始密钥或握手密钥时</title>
      <link>/RFC9002_Chinese_Translation/Loss_Recovery_Pseudocode/A.11_Upon_Dropping_Initial_or_Handshake_Keys/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9002_Chinese_Translation/Loss_Recovery_Pseudocode/A.11_Upon_Dropping_Initial_or_Handshake_Keys/</guid>
      <description>当弃用初始密钥或握手密钥时，位于这些空间中的数据包会被丢弃，且丢包检测状态会被更新。
OnPacketNumberSpaceDiscarded的伪代码如下：
OnPacketNumberSpaceDiscarded(pn_space): assert(pn_space != ApplicationData) RemoveFromBytesInFlight(sent_packets[pn_space]) sent_packets[pn_space].clear() // 重置丢包检测计时器和PTO计时器。 time_of_last_ack_eliciting_packet[pn_space] = 0 loss_time[pn_space] = 0 pto_count = 0 SetLossDetectionTimer() 
 </description>
    </item>
    
  </channel>
</rss>
