<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>7.6. 持续拥塞 on Autumn Navigation</title>
    <link>/RFC9002_Chinese_Translation/Congestion_Control/Persistent_Congestion/</link>
    <description>Recent content in 7.6. 持续拥塞 on Autumn Navigation</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>cn</language><atom:link href="/RFC9002_Chinese_Translation/Congestion_Control/Persistent_Congestion/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>7.6.1. 时长</title>
      <link>/RFC9002_Chinese_Translation/Congestion_Control/Persistent_Congestion/7.6.1_Duration/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9002_Chinese_Translation/Congestion_Control/Persistent_Congestion/7.6.1_Duration/</guid>
      <description>持续拥塞的时长是以这种方式计算的：
(smoothed_rtt + max(4*rttvar, kGranularity) + max_ack_delay) * kPersistentCongestionThreshold 
 与第6.2章中的PTO计算式不同，该时长的计算式中也包含了max_ack_delay但无需关心发生丢包的数据包号空间。
该时长使得发送方能够在出现持续拥塞前发送的数据包数量与TCP用尾部丢失探测（详见《RFC8985》）和RTO（详见《RFC5681》）时能发送的数量一样，其中包括在PTO超时时发送的那些数据包。
更大的kPersistentCongestionThreshold值使得发送方对网络中的持续拥塞变得更不敏感，这会导致它向拥塞的网络中激进地继续发送数据包。过小的值会导致发送方不必要地检测到持续拥塞，降低发送方的吞吐量。
推荐将kPersistentCongestionThreshold的值设为3，这使得发送方的行为与在两个TLP后建立一个RTO的TCP发送方的行为几乎一致。
这种设计没有使用连续的PTO事件来识别持续拥塞，因为应用的行为模式会影响PTO的超时。举个例子，间歇地发送少量数据且在两次发送间存在静默期的发送方会在每次发送数据时重启PTO计时器，有可能使得PTO计时器很长时间都没有出现超时，哪怕它没有接收到任何确认。时长的计算使得发送方无需依赖PTO超时就能识别持续拥塞。</description>
    </item>
    
    <item>
      <title>7.6.2. 判定持续拥塞</title>
      <link>/RFC9002_Chinese_Translation/Congestion_Control/Persistent_Congestion/7.6.2_Establishing_Persistent_Congestion/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9002_Chinese_Translation/Congestion_Control/Persistent_Congestion/7.6.2_Establishing_Persistent_Congestion/</guid>
      <description>要使发送方判定持续拥塞，需要其接收到的确认能反映出有两个ACK触发包遭遇了丢包，并且：
  在所有数据包号空间中，这两个数据包的发送时间之间没有任何数据包是得到确认了的；
  这两个数据包的发送时间之差超过了持续拥塞的时长（详见第7.6.1章）；并且
  在这两个数据包被发送前，存在RTT样本。
  这两个数据包必须是触发ACK的，因为接收方仅被要求在其最大确认延迟之内确认触发ACK的数据包；详见《QUIC传输》的第13.2章。
不应该在没有RTT样本时就开始一段持续拥塞。在得到首份RTT样本前，发送方基于初始RTT（详见第6.2.2章）建立PTO计时器，它可能会比实际RTT要大。存在RTT样本的这项要求防止了发送方在几乎没有发送过探测包的情况下就开始识别持续拥塞。
由于网络拥塞不会受到数据包号空间的影响，所以持续拥塞应该将在所有数据包号空间中发送的数据包都考虑进来。尚未为全部数据包号空间建立状态数据的发送方或无法在不同数据包号空间间比较发送时间的QUIC实现可以仅使用得到确认的数据包号空间的状态数据。这种做法可能导致错误地识别到持续拥塞，但它不会引发漏判。
与TCP的发送方对RTO（详见《RFC5681》）作出的响应行为类似，当识别出持续拥塞时，发送方的拥塞窗口必须被缩小至拥塞窗口的最小值（kMinimumWindow）。</description>
    </item>
    
    <item>
      <title>7.6.3. 样例</title>
      <link>/RFC9002_Chinese_Translation/Congestion_Control/Persistent_Congestion/7.6.3_Example/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9002_Chinese_Translation/Congestion_Control/Persistent_Congestion/7.6.3_Example/</guid>
      <description>接下来的样例展示了发送方是怎样判定持续拥塞的。假设：
smoothed_rtt + max(4*rttvar, kGranularity) + max_ack_delay = 2 kPersistentCongestionThreshold = 3 
 考虑下列事件序列：
   时间 行为     t=0 发送1号数据包（应用数据）   t=1 发送2号数据包（应用数据）   t=1.2 接收到对于1号数据包的确认   t=2 发送3号数据包（应用数据）   t=3 发送4号数据包（应用数据）   t=4 发送5号数据包（应用数据）   t=5 发送6号数据包（应用数据）   t=6 发送7号数据包（应用数据）   t=8 发送8号数据包（PTO 1）   t=12 发送9号数据包（PTO 2）   t=12.2 接收到对于9号数据包的确认    表1</description>
    </item>
    
  </channel>
</rss>
