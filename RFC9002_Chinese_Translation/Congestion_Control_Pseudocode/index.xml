<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>附录B. 拥塞控制伪代码 on AUTUMN QUICHE</title>
    <link>/RFC9002_Chinese_Translation/Congestion_Control_Pseudocode/</link>
    <description>Recent content in 附录B. 拥塞控制伪代码 on AUTUMN QUICHE</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>cn</language><atom:link href="/RFC9002_Chinese_Translation/Congestion_Control_Pseudocode/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>B.1. 感兴趣的常量</title>
      <link>/RFC9002_Chinese_Translation/Congestion_Control_Pseudocode/B.1_Constants_of_Interest/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9002_Chinese_Translation/Congestion_Control_Pseudocode/B.1_Constants_of_Interest/</guid>
      <description>在拥塞控制中使用到的常量是基于一系列RFC、论文和常用实践的组合。
 kInitialWindow：  在途字节数的初始值，详见第7.2章。
 kMinimumWindow：  拥塞窗口的最小字节数，详见第7.2章。
 kLossReductionFactor：  当检测到新的丢包事件而缩小拥塞窗口时使用的缩放因子。在第7章中推荐的值为0.5。
 kPersistentCongestionThreshold：  用于判定持续拥塞的时间量，它被指定为PTO倍率。在第7.6章中推荐的值为3。
  </description>
    </item>
    
    <item>
      <title>B.2. 感兴趣的变量</title>
      <link>/RFC9002_Chinese_Translation/Congestion_Control_Pseudocode/B.2_Variables_of_Interest/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9002_Chinese_Translation/Congestion_Control_Pseudocode/B.2_Variables_of_Interest/</guid>
      <description>本节描述了实现拥塞控制机制所需的变量。
 max_datagram_size：  发送方当前的最大载荷尺寸。其中不包含UDP或IP头部。最大的数据包尺寸会被用于计算拥塞窗口。终端基于其路径最大传输单元（PMTU；详见《QUIC传输》的第14.2章）来设置该值，且不会低于1200字节。
 ecn_ce_counters[kPacketNumberSpace]：  该数据包号空间中由对端在ACK帧中为ECN-CE计数器报告的最大值。该值被用于检测ECN-CE计数是否增加。
 bytes_in_flight：  所有已发送的、包含至少一个ACK触发帧或填充帧的且尚未得到确认或被认定为丢包的数据包以字节为单位的尺寸总和。其中不包含IP或UDP头部，但是包含QUIC头部和带有关联数据的认证加密（AEAD）开销。仅包含ACK帧的数据包不会被计入bytes_in_flight以确保拥塞控制不会妨碍拥塞反馈。
 congestion_window：  允许的在途字节数的最大值。
 congestion_recovery_start_time：  因为检测到丢包或ECN而进入当前恢复期的时间。当在此时间后发送的数据包得到确认时，QUIC会退出拥塞恢复。
 ssthresh：  慢启动以字节为单位的阈值。当拥塞窗口尺寸低于ssthresh时，就会处于慢启动状态，并且窗口会随着得到确认的字节数增长而扩大。
  拥塞控制的伪代码还访问了一些来自丢包恢复伪代码中的变量。</description>
    </item>
    
    <item>
      <title>B.3. 初始化</title>
      <link>/RFC9002_Chinese_Translation/Congestion_Control_Pseudocode/B.3_Initialization/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9002_Chinese_Translation/Congestion_Control_Pseudocode/B.3_Initialization/</guid>
      <description>在连接的一开始，以这种方式初始化拥塞控制变量：
congestion_window = kInitialWindow bytes_in_flight = 0 congestion_recovery_start_time = 0 ssthresh = infinite for pn_space in [ Initial, Handshake, ApplicationData ]: ecn_ce_counters[pn_space] = 0 
 </description>
    </item>
    
    <item>
      <title>B.4. 在发送数据包时</title>
      <link>/RFC9002_Chinese_Translation/Congestion_Control_Pseudocode/B.4_On_Packet_Sent/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9002_Chinese_Translation/Congestion_Control_Pseudocode/B.4_On_Packet_Sent/</guid>
      <description>只要被发送的数据包中包含非ACK帧，该数据包就会使得bytes_in_flight增长。
OnPacketSentCC(sent_bytes): bytes_in_flight += sent_bytes 
 </description>
    </item>
    
    <item>
      <title>B.5. 在数据包得到确认时</title>
      <link>/RFC9002_Chinese_Translation/Congestion_Control_Pseudocode/B.5_On_Packet_Acknowledgment/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9002_Chinese_Translation/Congestion_Control_Pseudocode/B.5_On_Packet_Acknowledgment/</guid>
      <description>该过程会被丢包检测的OnAckReceived调用，并且会被传入在sent_packets中最新的已确认数据包（acked_packets）。
在拥塞回避状态下，为拥塞窗口尺寸使用整型来表达的实现者应该小心的进行除法操作，并且可以使用在《RFC3465》的第2.1章中建议的替代方案。
InCongestionRecovery(sent_time): return sent_time &amp;lt;= congestion_recovery_start_time OnPacketsAcked(acked_packets): for acked_packet in acked_packets: OnPacketAcked(acked_packet) OnPacketAcked(acked_packet): if (!acked_packet.in_flight): return; // 从`bytes_in_flight`中移除 bytes_in_flight -= acked_packet.sent_bytes // 如果是受到应用或流量控制的限制， // 那么不要扩大拥塞窗口。 if (IsAppOrFlowControlLimited()) return // 在恢复期不要扩大拥塞窗口。 if (InCongestionRecovery(acked_packet.time_sent)): return if (congestion_window &amp;lt; ssthresh): // 慢启动。 congestion_window += acked_packet.sent_bytes else: // 拥塞回避。 congestion_window += max_datagram_size * acked_packet.sent_bytes / congestion_window 
 </description>
    </item>
    
    <item>
      <title>B.6. 在响应新的拥塞事件时</title>
      <link>/RFC9002_Chinese_Translation/Congestion_Control_Pseudocode/B.6_On_New_Congestion_Event/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9002_Chinese_Translation/Congestion_Control_Pseudocode/B.6_On_New_Congestion_Event/</guid>
      <description>该过程会在检测到新的拥塞事件时被ProcessECN和OnPacketsLost 调用。如果此时并不处于恢复期，那么就会启动恢复期，立即降低慢启动阈值并且缩小拥塞窗口。
OnCongestionEvent(sent_time): // 如果已经处于恢复期，那么不进行任何动作。 if (InCongestionRecovery(sent_time)): return // 进入恢复期。 congestion_recovery_start_time = now() ssthresh = congestion_window * kLossReductionFactor congestion_window = max(ssthresh, kMinimumWindow) // 可以发送一个数据包来加速丢包检测。 MaybeSendOnePacket() 
 </description>
    </item>
    
    <item>
      <title>B.7. 处理ECN信息</title>
      <link>/RFC9002_Chinese_Translation/Congestion_Control_Pseudocode/B.7_Process_ECN_Information/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9002_Chinese_Translation/Congestion_Control_Pseudocode/B.7_Process_ECN_Information/</guid>
      <description>该过程会在从对端接收到具有ECN相关字段的ACK帧时被调用。
ProcessECN(ack, pn_space): // 如果由对端报告的`ECN-CE`计数增加了， // 那么这可能是一次新的拥塞事件。 if (ack.ce_counter &amp;gt; ecn_ce_counters[pn_space]): ecn_ce_counters[pn_space] = ack.ce_counter sent_time = sent_packets[ack.largest_acked].time_sent OnCongestionEvent(sent_time) 
 </description>
    </item>
    
    <item>
      <title>B.8. 在丢包时</title>
      <link>/RFC9002_Chinese_Translation/Congestion_Control_Pseudocode/B.8_On_Packets_Lost/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9002_Chinese_Translation/Congestion_Control_Pseudocode/B.8_On_Packets_Lost/</guid>
      <description>该过程会在DetectAndRemoveLostPackets将数据包认定为丢包时被调用。
OnPacketsLost(lost_packets): sent_time_of_last_loss = 0 // 从`bytes_in_flight`中移除遭遇丢包的数据包。 for lost_packet in lost_packets: if lost_packet.in_flight: bytes_in_flight -= lost_packet.sent_bytes sent_time_of_last_loss = max(sent_time_of_last_loss, lost_packet.time_sent) // 如果在途数据包遭遇丢包，那么触发拥塞事件。 if (sent_time_of_last_loss != 0): OnCongestionEvent(sent_time_of_last_loss) // 如果这些数据包的丢包表明了持续拥塞， // 那么重置拥塞窗口。 // 只考虑在取得首份RTT样本后发送的数据包。 if (first_rtt_sample == 0): return pc_lost = [] for lost in lost_packets: if lost.time_sent &amp;gt; first_rtt_sample: pc_lost.insert(lost) if (InPersistentCongestion(pc_lost)): congestion_window = kMinimumWindow congestion_recovery_start_time = 0 
 </description>
    </item>
    
    <item>
      <title>B.9. 从在途字节数中移除被丢弃的数据包</title>
      <link>/RFC9002_Chinese_Translation/Congestion_Control_Pseudocode/B.9_Removing_Discarded_Packets_from_Bytes_in_Flight/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9002_Chinese_Translation/Congestion_Control_Pseudocode/B.9_Removing_Discarded_Packets_from_Bytes_in_Flight/</guid>
      <description>当初始密钥或握手密钥被弃用时，在这些空间中发送的数据包不再被计入在途字节数中。
RemoveFromBytesInFlight的伪代码如下：
RemoveFromBytesInFlight(discarded_packets): // 从在途字节数中移除所有未得到确认的数据包。 foreach packet in discarded_packets: if packet.in_flight bytes_in_flight -= size 
 </description>
    </item>
    
  </channel>
</rss>
