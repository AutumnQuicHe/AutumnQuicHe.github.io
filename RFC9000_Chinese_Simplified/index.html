
<!DOCTYPE html>

<html lang="cn" xml:lang="cn" xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta content="Hugo 0.93.0-DEV" name="generator"/>
<meta content="text/html; charset=utf-8" http-equiv="content-type"/>
<meta content="width=device-width, initial-scale=1.0, maximum-scale=1" name="viewport"/>
<title>RFC9000中文：QUIC传输协议</title>
<link href="https://avatars.githubusercontent.com/u/107357402" rel="shortcut icon" type="image/x-icon"/>
<link href="https://fonts.googleapis.com/css?family=Open+Sans" rel="stylesheet"/>
<link href="/css/styles.css" rel="stylesheet"/>
<link href="/RFC9000_Chinese_Simplified/css/RFC9000.css" rel="stylesheet"/>
<link href="/RFC9000_Chinese_Simplified/index.xml" rel="alternate" title="RFC9000中文：QUIC传输协议" type="application/rss+xml">
</link></head>
<body>
<div class="sidebar sidebar-rfc9000">
<div class="navigation">
<div><a href="/">秋愧遲</a></div>
<h1 class="site-title"><a href="/RFC9000_Chinese_Simplified/">RFC9000中文：QUIC传输协议</a></h1>
<nav class="internal">
<ul>
<li>
<a href="#RFC9000_QUIC">RFC9000 QUIC：一种基于UDP的安全多路复用传输协议</a>
<ul>
<li><a href="#Forword">前言</a></li>
<li><a href="#Abstract">摘要</a></li>
<li><a href="#Status_of_This_Memo">备忘状态</a></li>
<li><a href="#Copyright_Notice">版权声明</a></li>
</ul>
</li>
<li>
<a href="#Overview">1. 综述</a>
<ul>
<li><a href="#1.1_Document_Structure">1.1. 文档结构</a></li>
<li><a href="#1.2_Terms_and_Definitions">1.2. 术语及定义</a></li>
<li><a href="#1.3_Notational-Conventions">1.3. 标准规范</a></li>
</ul>
</li>
<li>
<a href="#2_Streams">2. 流</a>
<ul>
<li><a href="#2.1_Stream_Types_and_Identifiers">2.1. 流类型及标识符</a></li>
<li><a href="#2.2_Sending_and_Receiving_Data">2.2. 数据发送与接收</a></li>
<li><a href="#2.3_Stream_Prioritization">2.3. 流优先级</a></li>
<li><a href="#2.4._Operations_on_Streams">2.4. 流操作</a></li>
</ul>
</li>
<li>
<a href="#3_Stream_States">3. 流状态</a>
<ul>
<li><a href="#3.1_Sending_Stream_States">3.1. 流发送状态</a></li>
<li><a href="#3.2_Receiving_Stream_States">3.2. 接收流状态</a></li>
<li><a href="#3.3_Permitted_Frame_Types">3.3. 许可帧</a></li>
<li><a href="#3.4_Bidirectional_Stream_States">3.4. 双向流状态</a></li>
<li><a href="#3.5_Solicited_State_Transitions">3.5. 请求状态转换</a></li>
</ul>
</li>
<li>
<a href="#4_Flow_Control">4. 流量控制</a>
<ul>
<li><a href="#4.1_Data_Flow_Control">4.1. 数据流量控制</a></li>
<li><a href="#4.2_Increasing_Flow_Control_Limits">4.2. 提高流量控制限制</a></li>
<li><a href="#4.3_Flow_Control_Performance">4.3. 流量控制性能</a></li>
<li><a href="#4.4_Handling_Stream_Cancellation">4.4. 处理流取消</a></li>
<li><a href="#4.5_Stream_Final_Size">4.5. 流的最终数据量</a></li>
<li><a href="#4.6_Controlling_Concurrency">4.6. 并发控制</a></li>
</ul>
</li>
<li>
<a href="#5_Connections">5. 连接</a>
<ul>
<li>
<a href="#5.1_Connection_ID">5.1 连接ID</a>
<ul>
<li><a href="#5.1.1_Issuing_Connection_IDs">5.1.1 发布连接ID</a></li>
<li><a href="#5.1.2_Consuming_and_Retiring_Connection_IDs">5.1.2 消耗及撤销连接ID</a></li>
</ul>
</li>
<li>
<a href="#5.2_Matching_Packets_to_Connections">5.2 数据包与连接如何匹配</a>
<ul>
<li><a href="#5.2.1_Client_Packet_Handling">5.2.1 客户端数据包处理</a></li>
<li><a href="#5.2.2_Server_Packet_Handling">5.2.2 服务端数据包处理</a></li>
<li><a href="#5.2.3_Considerations_for_Simple_Load_Balancers">5.2.3 关于简单负载均衡</a></li>
</ul>
</li>
<li><a href="#5.3_Operations_on_Connections">5.3 连接操作</a></li>
</ul>
</li>
<li>
<a href="#6_Version_Negotiation">6. 版本协商</a>
<ul>
<li><a href="#6.1_Sending_Version_Negotiation_Packets">6.1 发送版本协商包</a></li>
<li><a href="#6.2_Handling_Version_Negotiation_Packets">6.2 处理版本协商包</a></li>
<li><a href="#6.3_Using_Reserved_Versions">6.3 使用保留版本</a></li>
</ul>
</li>
<li>
<a href="#7_Cryptographic_and_Transport_Handshake">7. 加密与传输握手</a>
<ul>
<li><a href="#7.1_Example_Handshake_Flows">7.1. 握手流程示例</a></li>
<li><a href="#7.2_Negotiating_Connection_IDs">7.2. 协商连接ID</a></li>
<li><a href="#7.3_Authenticating_Connection_IDs">7.3. 验证连接ID</a></li>
<li>
<a href="#7.4_Transport_Parameters">7.4. 加密与传输握手</a>
<ul>
<li><a href="#7.4.1_Values_of_Transport_Parameters_for_0_RTT">7.4.1. 0-RTT传输参数</a></li>
<li><a href="#7.4.2_New_Transport_Parameters">7.4.2. 新传输参数</a></li>
</ul>
</li>
<li><a href="#7.5_Cryptographic_Message_Buffering">7.5. 加密信息缓存</a></li>
</ul>
</li>
<li>
<a href="#8_Address_Validation">8. 地址验证</a>
<ul>
<li>
<a href="#8.1_Address_Validation_during_Connection_Establishment">8.1 连接建立期间的地址验证</a>
<ul>
<li><a href="#8.1.1_Token_Construction">8.1.1 令牌构建</a></li>
<li><a href="#8.1.2_Address_Validation_Using_Retry_Packets">8.1.2 使用重试数据包进行地址验证</a></li>
<li><a href="#8.1.3_Address_Validation_for_Future_Connections">8.1.3 为将来的连接进行地址验证</a></li>
<li><a href="#8.1.4_Address_Validation_Token_Integrity">8.1.4 地址验证令牌完整性</a></li>
</ul>
</li>
<li>
<a href="#8.2_Path_Validation">8.2 路径验证</a>
<ul>
<li><a href="#8.2.1_Initiating_Path_Validation">8.2.1 发起地址验证</a></li>
<li><a href="#8.2.2_Path_Validation_Responses">8.2.2 路径验证的响应</a></li>
<li><a href="#8.2.3_Successful_Path_Validation">8.2.3 地址验证通过</a></li>
<li><a href="#8.2.4_Failed_Path_Validation">8.2.4 地址验证失败</a></li>
</ul>
</li>
</ul>
</li>
<li>
<a href="#9_Connection_Migration">9. 连接迁移</a>
<ul>
<li><a href="#9.1_Probing_a_New_Path">9.1 探测新路径</a></li>
<li><a href="#9.2_Initiating_Connection_Migration">9.2 发起连接迁移</a></li>
<li>
<a href="#9.3_Responding_to_Connection_Migration">9.3 响应连接迁移</a>
<ul>
<li><a href="#9.3.1_Peer_Address_Spoofing">9.3.1 来自对端的地址伪造</a></li>
<li><a href="#9.3.2_On-Path_Address_Spoofing">9.3.2 来自路径上设备的地址伪造</a></li>
<li><a href="#9.3.3_Off-Path_Packet_Forwarding">9.3.3 来自非路径上设备的数据包转发</a></li>
</ul>
</li>
<li><a href="#9.4_Loss_Detection_and_Congestion_Control">9.4 丢包检测和拥塞控制</a></li>
<li><a href="#9.5_Privacy_Implications_of_Connection_Migration">9.5 连接迁移对隐私的影响</a></li>
<li>
<a href="#9.6_Server%27s_Preferred_Address">9.6 服务器的首选地址</a>
<ul>
<li><a href="#9.6.1_Communicating_a_Preferred_Address">9.6.1 传达首选地址</a></li>
<li><a href="#9.6.2_Migration_to_a_Preferred_Address">9.6.2 迁移至首选地址</a></li>
<li><a href="#9.6.3_Interaction_of_Client_Migration_and_Preferred_Address">9.6.3 客户端迁移与首选地址的交互</a></li>
</ul>
</li>
<li><a href="#9.7_Use_of_IPv6_Flow_Label_and_Migration">9.7 迁移与IPv6流标签的使用</a></li>
</ul>
</li>
<li>
<a href="#10_Connection_Termination">10. 连接终止</a>
<ul>
<li>
<a href="#10.1_Idle_Timeout">10.1 空闲超时</a>
<ul>
<li><a href="#10.1.1_Liveness_Testing">10.1.1 存活确认</a></li>
<li><a href="#10.1.2_Deferring_Idle_Timeout">10.1.2 推迟空闲超时</a></li>
</ul>
</li>
<li>
<a href="#10.2_Immediate_Close">10.2 立即关闭</a>
<ul>
<li><a href="#10.2.1_Closing_Connection_State">10.2.1 连接的关闭状态</a></li>
<li><a href="#10.2.2_Draining_Connection_State">10.2.2 连接的排空状态</a></li>
<li><a href="#10.2.3_Immediate_Close_during_the_Handshake">10.2.3 在握手期间立即关闭</a></li>
</ul>
</li>
<li>
<a href="#10.3_Stateless_Reset">10.3 无状态重置</a>
<ul>
<li><a href="#10.3.1_Detecting_a_Stateless_Reset">10.3.1 检测无状态重置</a></li>
<li><a href="#10.3.2_Calculating_a_Stateless_Reset_Token">10.3.2 计算无状态重置令牌</a></li>
<li><a href="#10.3.3_Looping">10.3.3 死循环</a></li>
</ul>
</li>
</ul>
</li>
<li>
<a href="#11_Error_Handling">11. 错误处理</a>
<ul>
<li><a href="#11.1_Connection_Errors">11.1 连接错误</a></li>
<li><a href="#11.2_Stream_Errors">11.2 流错误</a></li>
</ul>
</li>
<li>
<a href="#12_Packets_and_Frames">12. 数据包与帧</a>
<ul>
<li><a href="#12.1_Protected_Packets">12.1 受保护的数据包</a></li>
<li><a href="#12.2_Coalescing_Packets">12.2 合并数据包</a></li>
<li><a href="#12.3_Packet_Numbers">12.3 数据包号</a></li>
<li><a href="#12.4_Frames_and_Frame_Types">12.4 帧和帧类型</a></li>
<li><a href="#12.5_Frames_and_Number_Spaces">12.5 帧和数据包号空间</a></li>
</ul>
</li>
<li>
<a href="#13_Packetization_and_Reliability">13. 分包与可靠性</a>
<ul>
<li><a href="#13.1_Packet_Processing">13.1 数据包处理</a></li>
<li>
<a href="#13.2_Generating_Acknowledgments">13.2 生成确认</a>
<ul>
<li><a href="#13.2.1_Sending_ACK_Frames">13.2.1 发送ACK帧</a></li>
<li><a href="#13.2.2_Acknowledgment_Frequency">13.2.2 确认频率</a></li>
<li><a href="#13.2.3_Managing_ACK_Ranges">13.2.3 管理ACK块</a></li>
<li><a href="#13.2.4_Limiting_Ranges_by_Tracking_ACK_Frames">13.2.4 通过追踪ACK帧来限制块</a></li>
<li><a href="#13.2.5_Measuring_and_Reporting_Host_Delay">13.2.5 测量和报告主机延迟</a></li>
<li><a href="#13.2.6_ACK_Frames_and_Packet_Protection">13.2.6 ACK帧和数据包保护</a></li>
<li><a href="#13.2.7_PADDING_Frames_Consume_Congestion_Window">13.2.7 填充帧消耗拥塞窗口</a></li>
</ul>
</li>
<li><a href="#13.3_Retransmission_of_Information">13.3 信息重传</a></li>
<li>
<a href="#13.4_Explicit_Congestion_Notification">13.4 显式拥塞通知</a>
<ul>
<li><a href="#13.4.1_Reporting_ECN_Counts">13.4.1 报告ECN计数</a></li>
<li>
<a href="#13.4.2_ECN_Validation">13.4.2 ECN验证</a>
<ul>
<li><a href="#13.4.2.1_Receiving_ACK_Frames_with_ECN_Counts">13.4.2.1 接收具有ECN计数的ACK帧</a></li>
<li><a href="#13.4.2.2_ECN_Validation_Outcomes">13.4.2.2 ECN验证结果</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<a href="#14_Datagram_Size">14. 数据报尺寸</a>
<ul>
<li><a href="#14.1_Initial_Datagram_Size">14.1 初始数据报尺寸</a></li>
<li>
<a href="#14.2_Path_Maximum_Transmission_Unit">14.2 路径最大传输单元</a>
<ul>
<li><a href="#14.2.1_Handling_of_ICMP_Messages_by_PMTUD">14.2.1 使用PMTUD处理ICMP消息</a></li>
</ul>
</li>
<li>
<a href="#14.3_Datagram_Packetization_Layer_PMTU_Discovery">14.3 数据报分包层PMTU发现</a>
<ul>
<li><a href="#14.3.1_DPLPMTUD_and_Initial_Connectivity">14.3.1 DPLPMTUD与初始连接</a></li>
<li><a href="#14.3.2_Validating_the_Network_Path_with_DPLPMTUD">14.3.2 用DPLPMTUD验证网络路径</a></li>
<li><a href="#14.3.3_Handling_of_ICMP_Messages_by_DPLPMTUD">14.3.3 使用DPLPMTUD处理ICMP消息</a></li>
</ul>
</li>
<li>
<a href="#14.4_Sending_QUIC_PMTU_Probes">14.4 发送QUIC的PMTU探测包</a>
<ul>
<li><a href="#14.4.1_PMTU_Probes_Containing_Source_Connection_ID">14.4.1 包含源连接ID的PMTU探测包</a></li>
</ul>
</li>
</ul>
</li>
<li>
<a href="#15_Versions">15. 版本</a>
</li>
<li>
<a href="#16_Variable-Length_Integer_Encoding">16. 可变长度整型编码</a>
</li>
<li>
<a href="#17_Packet_Formats">17. 数据包格式</a>
<ul>
<li><a href="#17.1_Packet_Number_Encoding_and_Decoding">17.1 数据包号编码与解码</a></li>
<li>
<a href="#17.2_Long_Header_Packets">17.2 长包头数据包</a>
<ul>
<li><a href="#17.2.1_Version_Negotiation_Packet">17.2.1 版本协商数据包</a></li>
<li>
<a href="#17.2.2_Initial_Packet">17.2.2 初始数据包</a>
<ul>
<li><a href="#17.2.2.1_Abandoning_Initial_Packets">17.2.2.1 停用初始数据包</a></li>
</ul>
</li>
<li><a href="#17.2.3_0-RTT">17.2.3 0-RTT</a></li>
<li><a href="#17.2.4_Handshake_Packet">17.2.4 握手数据包</a></li>
<li>
<a href="#17.2.5_Retry_Packet">17.2.5 重试数据包</a>
<ul>
<li><a href="#17.2.5.1_Sending_a_Retry_Packet">17.2.5.1 发送重试数据包</a></li>
<li><a href="#17.2.5.2_Handling%20a%20Retry%20Packet">17.2.5.2 处理重试数据包</a></li>
<li><a href="#17.2.5.3_Continuing_a_Handshake_after_Retry">17.2.5.3 重试后继续握手</a></li>
</ul>
</li>
</ul>
</li>
<li>
<a href="#17.3_Short_Header_Packets">17.3 短包头数据包</a>
<ul>
<li><a href="#17.3.1_1-RTT_Packet">17.3.1 1-RTT数据包</a></li>
</ul>
</li>
<li><a href="#17.4_Latency_Spin_Bit">17.4 延迟自旋比特位</a></li>
</ul>
</li>
<li>
<a href="#18_Transport_Parameter_Encoding">18. 传输参数编码</a>
<ul>
<li><a href="#18.1_Reserved_Transport_Parameters">18.1 保留传输参数</a></li>
<li><a href="#18.2_Transport_Parameter_Definitions">18.2 传输参数定义</a></li>
</ul>
</li>
<li>
<a href="#19_Frame_Types_and_Formats">19. 帧类型与格式</a>
<ul>
<li><a href="#19.1_PADDING_Frames">19.1 填充帧</a></li>
<li><a href="#19.2_PING_Frames">19.2 Ping帧</a></li>
<li>
<a href="#19.3_ACK_Frames">19.3 ACK帧</a>
<ul>
<li><a href="#19.3.1_ACK_Ranges">19.3.1 ACK块</a></li>
<li><a href="#19.3.2_ECN_Counts">19.3.2 ECN计数</a></li>
</ul>
</li>
<li><a href="#19.4_RESET_STREAM_Frames">19.4 重置帧</a></li>
<li><a href="#19.5_STOP_SENDING_Frames">19.5 停止发送帧</a></li>
<li><a href="#19.6_CRYPTO_Frames">19.6 加密帧</a></li>
<li><a href="#19.7_NEW_TOKEN_Frames">19.7 新令牌帧</a></li>
<li><a href="#19.8_STREAM_Frames">19.8 流帧</a></li>
<li><a href="#19.9_MAX_DATA_Frames">19.9 最大数据量帧</a></li>
<li><a href="#19.10_MAX_STREAM_DATA_Frames">19.10 最大流数据量帧</a></li>
<li><a href="#19.11_MAX_STREAMS_Frames">19.11 最大流帧</a></li>
<li><a href="#19.12_DATA_BLOCKED_Frames">19.12 数据阻塞帧</a></li>
<li><a href="#19.13_STREAM_DATA_BLOCKED_Frames">19.13 流数据阻塞帧</a></li>
<li><a href="#19.14_STREAMS_BLOCKED_Frames">19.14 流阻塞帧</a></li>
<li><a href="#19.15_NEW_CONNECTION_ID_Frames">19.15 新连接ID帧</a></li>
<li><a href="#19.16_RETIRE_CONNECTION_ID_Frames">19.16 停用连接ID帧</a></li>
<li><a href="#19.17_PATH_CHALLENGE_Frames">19.17 通道挑战帧</a></li>
<li><a href="#19.18_PATH_RESPONSE_Frames">19.18 回复通道帧</a></li>
<li><a href="#19.19_CONNECTION_CLOSE_Frames">19.19 连接关闭帧</a></li>
<li><a href="#19.20_HANDSHAKE_DONE_Frames">19.20 握手完成帧</a></li>
<li><a href="#19.21_Extension_Frames">19.21 扩展帧</a></li>
</ul>
</li>
<li>
<a href="#20_Error_Codes">20. 错误码</a>
<ul>
<li><a href="#20.1_Transport_Error_Codes">20.1. 传输层错误码</a></li>
<li><a href="#20.2_Application_Protocol_Error_Codes">20.2 应用协议错误码</a></li>
</ul>
</li>
<li>
<a href="#21_Security_Considerations">21. 关于安全性的考量</a>
<ul>
<li>
<a href="#21.1_Overview_of_Security_Properties">21.1. 安全性概述</a>
<ul>
<li>
<a href="#21.1.1_Handshake">21.1.1. 握手</a>
<ul>
<li><a href="#21.1.1.1_Anti-Amplification">21.1.1.1. 抗放大</a></li>
<li><a href="#21.1.1.2_Server-Side_DoS">21.1.1.2. 针对服务器的拒绝服务</a></li>
<li><a href="#21.1.1.3_On-Path_Handshake_Termination">21.1.1.3. 在路径上的握手终止</a></li>
<li><a href="#21.1.1.4_Parameter_Negotiation">21.1.1.4. 参数协商</a></li>
</ul>
</li>
<li><a href="#21.1.2_Protected_Packets">21.1.2. 受保护的数据包</a></li>
<li>
<a href="#21.1.3_Connection_Migration">21.1.3. 连接迁移</a>
<ul>
<li><a href="#21.1.3.1_On-Path_Active_Attacks">21.1.3.1. 在路径上的主动攻击</a></li>
<li><a href="#21.1.3.2_Off-Path_Active_Attacks">21.1.3.2. 不在路径上的主动攻击</a></li>
<li><a href="#21.1.3.3_Limited_On-Path_Active_Attacks">21.1.3.3. 在受限路径上的主动攻击</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#21.2_Handshake_Denial_of_Service">21.2. 针对握手的拒绝服务攻击</a></li>
<li><a href="#21.3_Amplification_Attack">21.3. 放大攻击</a></li>
<li><a href="#21.4_Optimistic_ACK_Attack">21.4. 针对乐观ACK的攻击</a></li>
<li>
<a href="#21.5_Request_Forgery_Attacks">21.5. 请求伪造攻击</a>
<ul>
<li><a href="#21.5.1_Control_Options_for_Endpoints">21.5.1. 控制终端的途径</a></li>
<li><a href="#21.5.2_Request_Forgery_with_Client_Initial_Packets">21.5.2. 使用客户端初始数据包的请求伪造</a></li>
<li><a href="#21.5.3_Request_Forgery_with_Preferred_Addresses">21.5.3. 使用首选地址的请求伪造</a></li>
<li><a href="#21.5.4_Request_Forgery_with_Spoofed_Migration">21.5.4. 使用虚假迁移的请求伪造</a></li>
<li><a href="#21.5.5_Request_Forgery_with_Version_Negotiation">21.5.5. 使用版本协商的请求伪造</a></li>
<li><a href="#21.5.6_Generic_Request_Forgery_Countermeasures">21.5.6. 针对请求伪造的通用对抗措施</a></li>
</ul>
</li>
<li><a href="#21.6_Slowloris_Attacks">21.6. 慢速连接攻击</a></li>
<li><a href="#21.7_Stream_Fragmentation_and_Reassembly_Attacks">21.7. 流分段与重组攻击</a></li>
<li><a href="#21.8_Stream_Commitment_Attack">21.8. 流占用攻击</a></li>
<li><a href="#21.9_Peer_Denial_of_Service">21.9. 来自对端的拒绝服务攻击</a></li>
<li><a href="#21.10_Explicit_Congestion_Notification_Attacks">21.10. 显式拥塞通知攻击</a></li>
<li><a href="#21.11_Stateless_Reset_Oracle">21.11. 无状态重置泄密</a></li>
<li><a href="#21.12_Version_Downgrade">21.12. 版本降级</a></li>
<li><a href="#21.13_Targeted_Attacks_by_Routing">21.13. 通过路由的定向攻击</a></li>
<li><a href="#21.14_Traffic_Analysis">21.14. 流量分析</a></li>
</ul>
</li>
<li>
<a href="#22_IANA_Considerations">22. 关于IANA的考量</a>
<ul>
<li>
<a href="#22.1_Registration_Policies_for_QUIC_Registries">22.1. QUIC注册表中注册项的规范</a>
<ul>
<li><a href="#22.1.1_Provisional_Registrations">22.1.1. 临时注册项</a></li>
<li><a href="#22.1.2_Selecting_Codepoints">22.1.2. 挑选码点</a></li>
<li><a href="#22.1.3_Reclaiming_Provisional_Codepoints">22.1.3. 释放临时码点</a></li>
<li><a href="#22.1.4_Permanent_Registrations">22.1.4. 永久注册项</a></li>
</ul>
</li>
<li><a href="#22.2_QUIC_Versions_Registry">22.2. QUIC版本注册表</a></li>
<li><a href="#22.3_QUIC_Transport_Parameters_Registry">22.3. QUIC传输参数注册表</a></li>
<li><a href="#22.4_QUIC_Frame_Types_Registry">22.4. QUIC帧类型注册表</a></li>
<li><a href="#22.5_QUIC_Transport_Error_Codes_Registry">22.5. QUIC传输层错误码注册表</a></li>
</ul>
</li>
<li>
<a href="#23_References">23. 参考文献</a>
<ul>
<li><a href="#23.1_Normative_References">23.1. 规范性参考文献</a></li>
<li><a href="#23.2_Informative_References">23.2. 资料性参考文献</a></li>
</ul>
</li>
<li>
<a href="#Appendix_A_Pseudocode">附录A. 伪代码</a>
<ul>
<li><a href="#A.1_Sample_Variable-Length_Integer_Decoding">A.1. 可变长度整型解码样例</a></li>
<li><a href="#A.2_Sample_Packet_Number_Encoding_Algorithm">A.2. 数据包号编码算法样例</a></li>
<li><a href="#A.3_Sample_Packet_Number_Decoding_Algorithm">A.3. 数据包号解码算法样例</a></li>
<li><a href="#A.4_Sample_ECN_Validation_Algorithm">A.4. ECN验证算法样例</a></li>
</ul>
</li>
<li>
<a href="#Contributors">贡献者</a>
</li>
<li>
<a href="#Authors_Addresses">联系作者</a>
</li>
</ul>
</nav>
<nav class="external">
<ul id="shortcuts">
</ul>
<br/>
</nav>
</div>
<div class="version">
            generated on Nov 7, 2022
    </div>
</div>
<div class="content">
<section class="page" id="RFC9000_QUIC">
<h1>
<a href="#RFC9000_QUIC">RFC9000 QUIC：一种基于UDP的安全多路复用传输协议</a>
</h1>
<div class="content">
<br/>
<br/>
<table border="3" frame="void" rules="none">
<tr>
<td>状态：</td>
<td colspan="2">建议标准</td>
</tr>
<tr>
<td>更多信息：</td>
<td colspan="2">
<a href="https://datatracker.ietf.org/doc/rfc9000">数据追踪</a>|
      <a href="https://datatracker.ietf.org/ipr/search/?rfc=9000&amp;submit=rfc">知识产权</a>|
      <a href="https://www.rfc-editor.org/info/rfc9000">信息页</a>
</td>
</tr>
<tr>
<td>组织：</td>
<td colspan="2">互联网工程工作组（IETF）</td>
</tr>
<tr>
<td>RFC编号：</td>
<td colspan="2">
<a href="https://www.rfc-editor.org/info/rfc9000">9000</a>
</td>
</tr>
<tr>
<td>分类：</td>
<td colspan="2">标准追踪</td>
</tr>
<tr>
<td>出版时间：</td>
<td colspan="2">2021年5月</td>
</tr>
<tr>
<td>国际标准期刊编号：</td>
<td colspan="2">2070-1721</td>
</tr>
<tr>
<td>作者：</td>
<td>J. Iyengar, Ed. <br/><i>Fastly</i></td>
<td>M. Thomson, Ed. <br/><i>Mozilla</i></td>
</tr>
</table>
</div>
</section>
<section class="page" id="Forword">
<h2>
<a href="#Forword">前言</a>
</h2>
<div class="content">
<p>本文是QUIC传输层协议的网络规范文档译文，尚未完成翻译，欢迎指正。</p>
</div>
</section>
<section class="page" id="Abstract">
<h2>
<a href="#Abstract">摘要</a>
</h2>
<div class="content">
<p>本文定义了QUIC传输协议的核心。QUIC是能支持应用程序进行有流量控制的多流结构化通信机制，支持低延迟连接建立和网络迁移。QUIC自带机密、完整的安全措施，能广泛支持各种各样的部署。有关文档描述了QUIC如何将TLS的密钥协商、丢包检测及众多拥塞控制算法整合。</p>
</div>
</section>
<section class="page" id="Status_of_This_Memo">
<h2>
<a href="#Status_of_This_Memo">备忘状态</a>
</h2>
<div class="content">
<p>本文是互联网标准追踪文档。</p>
<p>本文产自互联网工程任务组（IETF），已接受公开审查，并由互联网互联网工程指导委员会（IESG）批准出版。更多互联网标准相关信息详见<a href="https://datatracker.ietf.org/doc/rfc7841/">RFC 7841</a>第2章。</p>
<p>关于本文当前状态、勘误及反馈方式等相关信息请移步<a href="https://www.rfc-editor.org/info/rfc9000">https://www.rfc-editor.org/info/rfc9000</a>。</p>
</div>
</section>
<section class="page" id="Copyright_Notice">
<h2>
<a href="#Copyright_Notice">版权声明</a>
</h2>
<div class="content">
<p>版权所有（c）2021 IETF信托及确认为文档作者的个人。保留所有权利。</p>
<p>本文遵守BCP 78及在本文发布之日起生效的IETF信托涉及IETF文档的法律条文（<a href="https://trustee.ietf.org/license-info">https://trustee.ietf.org/license-info</a>）。请仔细阅读相关条文，因为其描述了你对本文所有的权利及限制。从本文中摘录的代码组件必须包含信托法律条文第4.e章的简版BSD License文件，并且不附带任何该文件所描述的保证。</p>
</div>
</section>
<section class="page" id="Overview">
<h1>
<a href="#Overview">1. 综述</a>
</h1>
<div class="content">
<p>QUIC是一个安全通用传输协议。本文定义了第1版QUIC，支持《<a href="../RFC8999_Chinese_Simplified">QUIC不变量</a>》所定义的独立版本功能。</p>
<p>QUIC是一个面向连接的协议，在客户端及服务端之间建立有状态的交互。</p>
<p>QUIC握手由密钥协商及传输参数协商组成。QUIC集成了TLS握手《<a href="https://www.rfc-editor.org/info/rfc8446">TLS13</a>》，同时以自定义的帧保护数据包。更多关于TLS与QUIC集成的细节描述详见《<a href="/RFC9001_Chinese_Simplified">QUIC-TLS</a>》。握手过程被设计成支持尽早交换应用数据（0-RTT），包含一个需要通过某种形式的提前交流或配置来开启的客户端选项。</p>
<p>终端通过QUIC交流是以交互QUIC数据包的形式实现的。大多数数据包装载着一个或多个在终端间搬运控制信息和应用数据的帧。QUIC会验证每个包的内容，并根据实际情况对每个数据包进行加密。QUIC数据包通过UDP报文<sup>《<a href="https://www.rfc-editor.org/info/rfc768">UDP</a>》</sup>传输从而能够更好地支持现有的系统及网络环境。</p>
<p>应用层协议通过流在QUIC连接上交换信息，每条流都是有序的字节序列。流的类型分两种：双向流，支持双端发送数据；以及单向流，只支持一端发送数据。QUIC使用一种基于额度的方案来限制流的创建以及每条流可以发送的数据量。</p>
<p>QUIC以提供必要反馈的方式实现可靠传输及拥塞控制，《<a href="../RFC9002_Chinese_Simplified">QUIC恢复</a>》第6章描述了QUIC的一种数据丢失及恢复算法；QUIC通过拥塞控制避免网络拥塞，《<a href="../RFC9002_Chinese_Simplified">QUIC恢复</a>》第7章描述了QUIC的一种典型拥塞控制算法。</p>
<p>QUIC连接不会严格限制在一条单独的网络通道上。连接迁移根据连接标识符将连接迁移到一个新的网络通道上。当前版本QUIC只支持客户端进行连接迁移。在改变网络或地址映射——如NAT重定向——后，这个设计使连接仍然能够继续下去而不会断开。</p>
<p>有多种方式可以关闭连接。应用程序可以平滑关闭连接；双端可以协商一个超时时间段在超时后关闭连接；触发错误能够立即断开连接；一端失去状态后也能通过一种无状态机制关闭连接。</p>
</div>
</section>
<section class="page" id="1.1_Document_Structure">
<h2>
<a href="#1.1_Document_Structure">1.1. 文档结构</a>
</h2>
<div class="content">
<p>本文描述了QUIC协议的核心部分，文章组织如下：</p>
<ul>
<li>
<p><a href="#Overview">第1章</a><strong>流</strong>是QUIC支持的基本服务抽象层。</p>
<ul>
<li><a href="#2_Streams">第2章</a>描述流相关的核心概念，</li>
<li><a href="#3_Stream_States">第3章</a>提供一个流状态的参考模型，</li>
<li><a href="#4_Flow_Control">第4章</a>概述流量控制的过程。</li>
</ul>
</li>
<li>
<p><strong>连接</strong>是QUIC终端交流的上下文。</p>
<ul>
<li><a href="#5_Connections">第5章</a>描述连接相关的核心概念，</li>
<li><a href="#6_Version_Negotiation">第6章</a>描述版本协商</li>
<li><a href="#7_Cryptographic_and_Transport_Handshake">第7章</a>详细描述连接建立的过程，</li>
<li><a href="#8_Address_Validation">第8章</a>描述地址验证及危险的拒绝服务迁移攻击，</li>
<li><a href="#9_Connection_Migration">第9章</a>描述终端如何将一个连接迁移到新的网络通道上，</li>
<li><a href="#10_Connection_Termination">第10章</a>列举关闭一个已打开连接的各个方式，以及</li>
<li><a href="#11_Error_Handling">第11章</a>给流与连接错误处理提供指导。</li>
</ul>
</li>
<li>
<p><strong>数据包</strong>和<strong>帧</strong>是QUIC交流的基本单元。</p>
<ul>
<li><a href="#12_Packets_and_Frames">第12章</a>描述数据包与帧相关的概念，</li>
<li><a href="#13_Packetization_and_Reliability">第13章</a>定义数据传输、重传和确认的模型，以及</li>
<li><a href="#14_Datagram_Size">第14章</a>描述指定携带QUIC数据包的数据报大小的规则。</li>
</ul>
</li>
<li>
<p>最后，QUIC协议要素的编码细节描述在：</p>
<ul>
<li><a href="#15_Versions">第15章</a>版本，</li>
<li><a href="#16_Variable-Length_Integer_Encoding">第16章</a>整型编码，</li>
<li><a href="#17_Packet_Formats">第17章</a>数据包头部，</li>
<li><a href="#18_Transport_Parameter_Encoding">第18章</a>传输参数，</li>
<li><a href="#19_Frame_Types_and_Formats">第19章</a>帧，以及</li>
<li><a href="#20_Error_Codes">第20章</a>错误。</li>
</ul>
</li>
</ul>
<p>相关文档《<a href="../RFC9002_Chinese_Simplified">QUIC恢复</a>》描述QUIC的数据丢失检测及拥塞控制，《<a href="/RFC9001_Chinese_Simplified">QUIC-TLS</a>》描述TLS及其他加密机制的使用。</p>
<p>本文定义了QUIC版本1，支持《<a href="../RFC8999_Chinese_Simplified">QUIC不变量</a>》所定义的不变量。</p>
<p>若引用QUIC版本1，请引用本文。若引用QUIC支持的独立版本的某个子集，请引用《<a href="../RFC8999_Chinese_Simplified">QUIC不变量</a>》。</p>
</div>
</section>
<section class="page" id="1.2_Terms_and_Definitions">
<h2>
<a href="#1.2_Terms_and_Definitions">1.2. 术语及定义</a>
</h2>
<div class="content">
<p>本文中的关键字“<em><strong>必须</strong></em>（<strong>MUST</strong>）”、“<em><strong>必须不</strong></em>（<strong>MUST NOT</strong>）”、“<em><strong>需要</strong></em>（<strong>REQUIRED</strong>）”、“<em><strong>强烈要求</strong></em>（<strong>SHALL</strong>）”、“<em><strong>强烈要求不</strong></em>（<strong>SHALL NOT</strong>）”、“<em><strong>应该</strong></em>（<strong>SHOULD</strong>）”、“<em><strong>不应该</strong></em>（<strong>SHOULD NOT</strong>）”、“<em><strong>推荐</strong></em>（<strong>RECOMMENDED</strong>）”、“<em><strong>不推荐</strong></em>（<strong>NOT RECOMMENDED</strong>）”、“<em><strong>可以</strong></em>（<strong>MAY</strong>）”，以及“<em><strong>可选</strong></em>（<strong>OPTIONAL</strong>）”应理解为BCP 14 《<a href="https://www.rfc-editor.org/info/rfc2119">RFC2119</a>》《<a href="https://www.rfc-editor.org/info/rfc8174">RFC8174</a>》所描述的，当且仅当它们像本段一样以斜体加粗方式出现的时候。</p>
<p>本文常用术语列述如下：</p>
<p>QUIC：本文描述的传输协议。QUIC是名称，不是首字母缩写。</p>
<p>终端（Endpoint）：一个能够以创建、接收及处理QUIC数据包参与QUIC连接的实体。QUIC终端有两种类型：客户端（client）及服务端（server）。</p>
<p>客户端：初始化QUIC连接的终端。</p>
<p>服务端：接收QUIC连接的终端。</p>
<p>QUIC数据包：QUIC的一个可以封装进UDP报文中的完整处理单元。单个UDP报文可以封装进一个或多个QUIC数据包。</p>
<p>ACK触发包：一个包含除确认帧（ACK）、填充帧（PADDING）及连接关闭帧（CONNECTION_CLOSE）外的帧的QUIC数据包。接收方收到这类包会发确认，详见<a href="#13.2.1_Sending_ACK_Frames">第13.2.1章</a>。</p>
<p>帧：一个结构化的协议信息单元。帧有多种类型，不同类型的帧携带不同类型的信息。帧由QUIC数据包承载。</p>
<p>地址：当使用不受限制，由IP版本、IP地址及UDP端口号构成的元组表示网络通道的一端。</p>
<p>连接ID：终端用来标识一条QUIC连接的标识符。每个终端选择一个或多个连接ID，从而在对端发送给本端的QUIC包中包含这些连接ID。该值对对端是不透明的。</p>
<p>流：QUIC连接上一个单向或双向的有序字节通道。一个QUIC连接可以同时承载多条流。</p>
<p>应用：一个使用QUIC发送及接收数据的实体。</p>
<p>本文使用术语“QUIC数据包”、“UDP报文”及“IP数据包”表示相应协议的传输单元。换言之，一个或多个QUIC包被封装到一个UDP报文里，最终封装到一个IP数据包中。</p>
</div>
</section>
<section class="page" id="1.3_Notational-Conventions">
<h2>
<a href="#1.3_Notational-Conventions">1.3. 标准规范</a>
</h2>
<div class="content">
<p>本文数据包及帧的图解使用一种定制格式，目的是总结而不是定义协议元素。文中定义了完整的语义及详细的结构。</p>
<p>复杂的字段被命名后，由紧随命名的一个以一对花括号括起来的字段列表描述，列表中的字段以逗号分隔。</p>
<p>单个字段包括长度信息、带正号的定值、可选值或本字段的副本。单个字段使用下述标准规范，且所有长度都以比特为单位：</p>
<p><code>x (A)</code>: 表示<code>x</code>是<code>A</code>比特长度</p>
<p><code>x (i)</code>: 表示<code>x</code>是一个使用<a href="#16_Variable-Length_Integer_Encoding">第16章</a>描述的变量长度编码的整型值</p>
<p><code>x (A..B)</code>: 表示<code>x</code>的长度可以是从<code>A</code>到<code>B</code>的所有值，省略<code>A</code>表示最小零位，并且省略<code>B</code>表示没有设置上限。这种格式的值总是以字符边界结束。</p>
<p><code>x (L) = C</code>: 表示<code>x</code>有一个定值<code>C</code>，且<code>x</code>的长度为<code>L</code>，<code>L</code>可以用上述任何长度格式</p>
<p><code>x (L) = C..D</code>: 表示x的值介于<code>C</code>到<code>D</code>之间，包括边界值<code>C</code>和<code>D</code>，<code>L</code>表示长度，同上</p>
<p><code>[x (L)]</code>: 表示<code>x</code>是一个可选的值，长度为<code>L</code></p>
<p><code>x (L) ...</code>: 表示<code>x</code>重复0次或以上次数，且每个实例长度为<code>L</code></p>
<p>本文使用网络字节序（也就是大端）值。字段每个字节的各个比特从高位到低位排列。</p>
<p>约定单个字段通过使用复合字段的名称引用复合字段。</p>
</div>
</section>
<section class="page" id="2_Streams">
<h1>
<a href="#2_Streams">2. 流</a>
</h1>
<div class="content">
<p>QUIC的流给应用提供了一个轻量、有序的字节流抽象，可以是单向或双向的。</p>
<p>流可以通过发送数据创建。其他有关流管理的过程——结束、取消及流量控制——均是以引入最小开销为前提设计的。例如，一个流帧（<a href="#19.8_STREAM_Frames">第19.8章</a>）能够开启、承载数据以及关闭一条流。流也能长时间存在并持续连接的整个生命周期。</p>
<p>流能够被双端的任何一端创建，与其他流并发发送数据，以及被取消。QUIC不给不同流之间的数据提供任何形式的顺序保证。</p>
<p>QUIC允许任意数量的流并发，也允许任意量的数据在任何流上发送，不过这必须接受流量控制的限制及流数量的限制，详见<a href="#4_Flow_Control">第4章</a>。</p>
</div>
</section>
<section class="page" id="2.1_Stream_Types_and_Identifiers">
<h2>
<a href="#2.1_Stream_Types_and_Identifiers">2.1. 流类型及标识符</a>
</h2>
<div class="content">
<p>流可以是单向或双向的。单向流往一个方向传输数据：从流发起端向对端发送；双向流允许双端向对端发送数据。</p>
<p>在连接中，流以一个数字值标识，称为流ID。一个流ID是一个62比特的整数（<code>0</code>-<code>2<sup>62</sup>-1</code>），且与同连接中其他流的流ID严格区分。流ID编码为一个可变长度整型，详见<a href="#16_Variable-Length_Integer_Encoding">第16章</a>。一个QUIC终端<em><strong>必须不</strong></em>能在同一个连接的不同流上重复使用同一个数值作为流ID。</p>
<p>流ID的最小有效位（0x01）标识流的发起者。客户端发起的流的ID是偶数（该位被置为0），服务端发起的流的ID是奇数（该位被置为1）。</p>
<p>流ID的次小有效位（0x02）标识流是双向流（该位被置为0）抑或单向流（该位被置为1）。</p>
<p>也就是说，流ID的最小两个有效位用来标识一条流是总共四种流类型中的哪一种，总结在如下<a href="#Table_1_Stream_ID_Types">表1</a>中：</p>
<div class="block ref" id="Table_1_Stream_ID_Types">
<table>
<thead>
<tr>
<th style="text-align:left">位</th>
<th style="text-align:left">流类型</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">0x00</td>
<td style="text-align:left">客户端创建的双向流</td>
</tr>
<tr>
<td style="text-align:left">0x01</td>
<td style="text-align:left">服务端创建的双向流</td>
</tr>
<tr>
<td style="text-align:left">0x02</td>
<td style="text-align:left">客户端创建的单向流</td>
</tr>
<tr>
<td style="text-align:left">0x03</td>
<td style="text-align:left">服务端创建的单向流</td>
</tr>
</tbody>
</table>
<p><a href="#Table_1_Stream_ID_Types">表1：流类型</a></p>
</div>
<p>每种流类型的流空间从其最小值开始（依次从0x00到0x03）；每种流的每个流ID根据创建顺序依次线性递增。如果不按顺序地使用了一个流ID，将导致相同流类型的所有具有更小的流ID的流都被开启。</p>
</div>
</section>
<section class="page" id="2.2_Sending_and_Receiving_Data">
<h2>
<a href="#2.2_Sending_and_Receiving_Data">2.2. 数据发送与接收</a>
</h2>
<div class="content">
<p>流帧（<a href="#19.8_STREAM_Frames">第19.8章</a>）封装应用层发送的数据。终端使用流帧的流ID及偏移字段整理数据。</p>
<p>终端<em><strong>必须</strong></em>将流数据以一个有序字节流传递给应用层。传递一个有序字节流需要终端缓存任何接收到的乱序数据，直到到达了建议的流量控制限制的上限。</p>
<p>QUIC对于传递流的无序数据并没有做额外的打算。然而，实现上 <em><strong>可以</strong></em>选择支持传递无序数据给应用层接收。</p>
<p>终端可以从一条流的同一个偏移位置多次接收数据。如果数据已经被接收过了，就会直接被丢弃。处在任何偏移位置的数据如果被重复发送，其<em><strong>必须不</strong></em>能更改。终端<em><strong>可以</strong></em>将在流的同一偏移处收到不同数据的情况视为PROTOCOL_VIOLATION类型（违反协议）的连接错误。</p>
<p>流是一个抽象的有序字节流，QUIC不感知除此以外的任何结构。流帧的边界在数据被传输、丢包后重传以及被传递给应用层接收者后，不会继续保留。</p>
<p>终端<em><strong>必须不</strong></em>能在对端设置的流量控制限制之外发送任何数据。流量控制详见<a href="#4_Flow_Control">第4章</a>。</p>
</div>
</section>
<section class="page" id="2.3_Stream_Prioritization">
<h2>
<a href="#2.3_Stream_Prioritization">2.3. 流优先级</a>
</h2>
<div class="content">
<p>如果资源以正确的优先级分配给多条流，那么流的多路复用可以对应用性能产生显著影响。</p>
<p>QUIC并不支持交换优先级信息，相反，其依赖从应用层接收的优先级信息。</p>
<p>QUIC在实现上<em><strong>应该</strong></em>提供某种方法使得应用层能够因此确定各条流的相对优先级。一种实现是使用应用层提供的信息决定分配多少资源来激活流。</p>
</div>
</section>
<section class="page" id="2.4._Operations_on_Streams">
<h2>
<a href="#2.4._Operations_on_Streams">2.4. 流操作</a>
</h2>
<div class="content">
<p>本文没有定义QUIC API，而是定义了一系列流操作相关的函数可以用于应用层协议的构建。应用层协议可以假定QUIC有关实现提供了本章描述的操作对应的接口。为一个特定应用层协议设计实现的QUIC协议可能仅仅提供该协议需要的这些操作。</p>
<p>在流的发送部分，应用层协议可以：</p>
<ul>
<li>写数据，只有当流量控制给数据写出留足空间（<a href="#4.1_Data_Flow_Control">第4.1章</a>）才能成功写出；</li>
<li>结束流（清理并关闭），发送一个设置FIN位为1的流帧（<a href="#19.8_STREAM_Frames">第19.8章</a>）；</li>
<li>重置流（中止并关闭），当流未处在终止状态时发送一个RESET_STREAM帧（<a href="#19.4_RESET_STREAM_Frames">第19.4章</a>）。</li>
</ul>
<p>在流的接收部分，应用层协议可以：</p>
<ul>
<li>读数据，以及</li>
<li>中止读取流数据并请求关闭流，该操作可能需要发送STOP_SENDING帧（<a href="#19.5_STOP_SENDING_Frames">第19.5章</a>）。</li>
</ul>
<p>应用层协议也可以请求在流状态改变的时候收到通知信息，包括当对端开启或重置流、对端中止流数据读取、有新数据可以读取、以及数据可以写出或因流控不能写出。</p>
</div>
</section>
<section class="page" id="3_Stream_States">
<h1>
<a href="#3_Stream_States">3. 流状态</a>
</h1>
<div class="content">
<p>本章描述流的发送及接收相关组件。有两个状态机需要描述：一个是关于终端传输数据（<a href="#3.1_Sending_Stream_States">第3.1章</a>）的流，另一个是关于终端接收数据（<a href="#3.2_Receiving_Stream_States">第3.2章</a>）的流。</p>
<p>单向流用到发送或接收的其中一个状态机，取决于流类型及终端角色。双向流双端都会用到两个状态机。在极大程度上，不论单向流还是双向流，在使用这两个状态机上是没有区别的。相对而言打开一条双向流会稍微复杂一些，因为同时打开发送和接收端意味着在两个方向上同时打开流。</p>
<p>本章展示的状态机极具信息量。本文使用流状态描述不同类型帧在何时以何种方式发送的相关规则，以及当收到不同类型的帧时应作出的反应。即使这些状态机目的在于指导如何实现QUIC协议，但其并不意味着限制QUIC实现的方式。一个QUIC实现完全可以定义不同的状态机，只要其行为与本文所述状态机的具体实现一致即可。</p>
<blockquote>
<p>注意：在某些情况下，单个事件或操作可能导致多个状态转换。例如，对于流的发送端，如果发送一个FIN置位的<strong>流帧</strong>可能导致两个状态转换：从“就绪”状态转到“发送”状态，然后从“发送”状态转到“数据发送完毕”状态。</p>
</blockquote>
</div>
</section>
<section class="page" id="3.1_Sending_Stream_States">
<h2>
<a href="#3.1_Sending_Stream_States">3.1. 流发送状态</a>
</h2>
<div class="content">
<p><a href="#Figure_2_States_for_Sending_Parts_of_Streams">图2</a>展示了通过流向对端发送发送数据的状态。</p>
<div class="block ref" id="Figure_2_States_for_Sending_Parts_of_Streams">
<img src="/RFC9000_Chinese_Simplified/images/Figure_2_States_for_Sending_Parts_of_Streams.svg"/>
<p><a href="#Figure_2_States_for_Sending_Parts_of_Streams">图2：流数据发送部分状态</a></p>
</div>
<p>终端发起的流的发送部分（客户端发起的流类型是0和2，1和3则是由服务端发起的）由应用层打开。用于发送的流数据可能被缓存起来。</p>
<p>发送首个<strong>流帧</strong>（STREAM）或<strong>流阻塞帧</strong>（STREAM_DATA_BLOCKED）使流的发送部分进入“发送”状态。QUIC实现可以选择延迟分配流ID直到其发送首个<strong>流帧</strong>并进入“发送”状态，这样可以实现更好的流优先级。</p>
<p>由对端发起的双向流的发送部分（服务端发起的流类型是0，客户端发起的是1）在接收部分创建时就已处于“就绪”状态，并从此状态开始。</p>
<p>在“发送”状态，终端通过<strong>流帧</strong>传输——必要时重传——流数据。终端遵从其对端设置的流量控制限制，同时持续接收与处理<strong>最大流数据帧</strong>（MAX_STREAM_DATA）。当发送过程被流的流量控制限制（<a href="#4.1_Data_Flow_Control">第4.1章</a>）所阻塞时，处在“发送”状态的终端会生成<strong>流阻塞帧</strong>。</p>
<p>在应用层表示所有应用数据及一个带FIN置位的<strong>流帧</strong>都发送完成后，流的发送部分进入“发送完成”状态。从这个状态开始，终端只会做必要的数据重传。在对端收到最终流下标前，都有可能收到<strong>最大流数据帧</strong>。处于此状态的终端可以忽略任何其收到的<strong>最大流数据帧</strong>，这样是安全的。</p>
<p>当所有流数据都被成功确认后，发送部分进入“接收完成”状态，这是一个最终状态。</p>
<p>处在“就绪”、“发送”及“发送完成”状态中的任何一个状态时，应用层都可以提出取消发送流数据。相应地，终端也可能从其对端收到一个<strong>停止发送帧</strong>（STOP_SENDING）。不论哪种情况，终端都会发送<strong>流重置帧</strong>（RESET_STREAM），随后流进入“重置发送”状态。</p>
<p>终端<em><strong>可以</strong></em>发送一个<strong>流重置帧</strong>作为流的首个帧，这会导致该流的发送部分开启然后立即转到“重置发送”状态。</p>
<p>一旦一个包含<strong>流重置帧</strong>的数据包被确认，流的发送部分即进入“重置接收”状态，这也是一个最终状态。</p>
</div>
</section>
<section class="page" id="3.2_Receiving_Stream_States">
<h2>
<a href="#3.2_Receiving_Stream_States">3.2. 接收流状态</a>
</h2>
<div class="content">
<p><a href="#Figure_3_States_for_Receiving_Parts_of_Streams">图3</a>展示了通过流从对端接收数据的状态。流的接收部分只会反映对端流发送部分的一些状态。流的接收部分不能追踪发送部分那些不可见的状态，例如“就绪”状态。相反，流的接收部分追踪向应用层传递的数据，其中一些数据对发送端不可见。</p>
<div class="block ref" id="Figure_3_States_for_Receiving_Parts_of_Streams">
<img src="/RFC9000_Chinese_Simplified/images/Figure_3_States_for_Receiving_Parts_of_Streams.svg"/>
<p><a href="#Figure_3_States_for_Receiving_Parts_of_Streams">图3：流数据接收部分状态</a></p>
</div>
<p>由对端发起的流（客户端发起的流类型是1和3，服务端发起的是0和2）的接收部分在收到该流的第一个<strong>流帧</strong>、<strong>流阻塞帧</strong>或<strong>流重置帧</strong>时创建。对于由对端创建的双向流，发送部分收到<strong>最大流数据帧</strong>或<strong>停止发送帧</strong>时也会创建该流的接收部分。流的接收部分的初始状态是“接受”状态。</p>
<p>由本端发起的双向流（客户端发起的流类型是0，服务端发起的是1），当其发送部分进入“就绪”状态时，其接收部分进入“接收”状态。</p>
<p>终端在收到<strong>最大流数据帧</strong>或<strong>停止发送帧</strong>后打开一条双向流。接收到一条未开启的流的<strong>最大流数据帧</strong>意味着对端已经开启了该流，并开始支持流量控制额度。而接收到一条未开启流的<strong>停止发送帧</strong>意味着对端不会再从该流接收数据。无论这两种帧的哪一种都可能先于<strong>流帧</strong>或<strong>流阻塞帧</strong>到达本端，原因是包丢失或乱序。</p>
<p>在一条流创建前，所有数值小于该流ID的同类型流都<em><strong>必须</strong></em>被创建。这样能确保双端流的创建次序保持一致。</p>
<p>在“接收”状态，终端接收<strong>流帧</strong>和<strong>流阻塞帧</strong>。传入数据将被缓存，并可以按照正确顺序重组以便递给应用层。随着应用层不断消耗数据，缓冲区重新空出来，终端发送<strong>最大流数据帧</strong>告知对端可以发送更多数据。</p>
<p>当收到一个带FIN置位的<strong>流帧</strong>时，数据的最终大小确定下来，详见<a href="#4.5_Stream_Final_Size">第4.5章</a>。流的接收部分随后转到“数据量确认”状态。在此状态，终端不再需要发送<strong>最大流数据帧</strong>，只需要接收重传数据即可。</p>
<p>一旦收完了一条流的所有数据，流的接收部分转入“接收完成”状态。这可能发生在收到导致转入“数据量确认”状态的同一个<strong>流帧</strong>后。在所有数据都收完后，可以丢弃该流的任何<strong>流帧</strong>或<strong>流阻塞帧</strong>。</p>
<div class="block note">
<p><strong>秋航注</strong>：意思是说，在收到<strong>流帧</strong>后，接收方可能转入“接收量确认”状态；紧接着，状态再次流转到“接收完成”状态。中间这句原译为：</p>
<blockquote>
<p>在接收到导致状态转换到“接收量确认”的<strong>流帧</strong>后，可能同时导致转入“接收完成”状态。</p>
</blockquote>
</div>
<p>“接收完成”状态会一直持续直到数据全部传递到应用层。一旦流数据传递完成，即转到“读取完成”状态，这是一个最终状态。</p>
<p>如果在“接收”或“数据量确认”状态收到一个<strong>流重置帧</strong>，将导致流转到“重置接收”状态。这可能打断流数据传递到应用层。</p>
<p><strong>流重置帧</strong>也有可能在所有流数据都收完后才收到（即在“接收完成”阶段）。同样地，也可能在收完<strong>流重置帧</strong>后收到了剩下的流数据（即在“重置接收”状态）。在QUIC的具体实现上，可以自由选择如何处理这两种情况。</p>
<p>发送<strong>流重置帧</strong>意味着终端不能保证流数据的传输。然而，并没有要求在收到<strong>流重置帧</strong>后不传输流数据。QUIC实现<em><strong>可以</strong></em>打断流数据的传输，丢弃任何没有被消耗的数据，并通知对端收到了<strong>流重置帧</strong>。如果流数据完成了接收并被缓存起来以供应用层读取，此时收到<strong>流重置帧</strong>信号，则该信号可能被抑制或扣留。如果<strong>流重置帧</strong>被抑制，流的接收部分仍然维持在“接收完成”状态。</p>
<p>一旦应用层收到流被重置的信号，流的接收部分转到“重置读取”阶段，这是一个最终状态。</p>
</div>
</section>
<section class="page" id="3.3_Permitted_Frame_Types">
<h2>
<a href="#3.3_Permitted_Frame_Types">3.3. 许可帧</a>
</h2>
<div class="content">
<p>流的发送端发送的帧只有三种能同时影响发送端和接收端状态：<strong>流帧</strong>（<a href="#19.8_STREAM_Frames">第19.8章</a>）、<strong>流阻塞帧</strong>（<a href="#19.13_STREAM_DATA_BLOCKED_Frames">第19.13章</a>），以及<strong>流重置帧</strong>（<a href="#19.4_RESET_STREAM_Frames">第19.4章</a>）。</p>
<p>发送端<em><strong>必须不</strong></em>在最终状态（“接收完成”或“重置接收”）发送任何这些帧。当流处在“重置发送”或任何最终状态时——也就是说，在发送完一个<strong>流重置帧</strong>后，发送端<em><strong>必须不</strong></em>发送<strong>流帧</strong>或<strong>流阻塞帧</strong>。接收端可以在任何状态接收这三种帧，原因在于被延迟的包可能携带这些帧。</p>
<p>流的接收端发送<strong>最大流数据帧</strong>（<a href="#19.19_CONNECTION_CLOSE_Frames">第19.19章</a>）及<strong>停止发送帧</strong>（<a href="#19.5_STOP_SENDING_Frames">第19.5章</a>）。</p>
<p>接收端只可以在“接收”状态发送<strong>最大流数据帧</strong>。接收端<em><strong>可以</strong></em>在任何尚未收到过<strong>流重置帧</strong>的状态——也就是除“重置接收”、“重置读取”之外的状态，发送一个<strong>停止发送帧</strong>。然而，在“接收完成”状态发送<strong>停止发送帧</strong>意义不大，因为所有流数据都已经收到了。由于可能存在数据包延迟，因此发送端可以在任何状态接收这两种帧。</p>
</div>
</section>
<section class="page" id="3.4_Bidirectional_Stream_States">
<h2>
<a href="#3.4_Bidirectional_Stream_States">3.4. 双向流状态</a>
</h2>
<div class="content">
<p>双向流同时包括接收部分和发送部分。QUIC的实现可以将双向流的状态表示成发送及接收流状态的组合状态。在最简单的模型里，当发送和接收部分均处在非最终状态时，表示流处于“打开”状态；当两者均处于最终状态时，表示流处于“关闭”状态。</p>
<p><a href="#Table_2_Possible_Mapping_of_Stream_States_to_HTTP2">表2</a>展示了一个更复杂的双向流状态映射，粗略对应HTTP/2（<a href="https://www.rfc-editor.org/info/rfc7540">HTTP2</a>）中定义的流状态。这表明流的发送或接收部分多个状态映射到同一个组合状态。注意这仅仅是一个可能的映射，这种映射需要数据全部被确认后才能转入“关闭”或“半关闭”状态。</p>
<div class="block ref" id="Table_2_Possible_Mapping_of_Stream_States_to_HTTP2">
<table>
<thead>
<tr>
<th style="text-align:left">发送部分</th>
<th style="text-align:left">接收部分</th>
<th style="text-align:left">组合状态</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">无流、就绪</td>
<td style="text-align:left">无流、接收<sup>①</sup></td>
<td style="text-align:left">空闲</td>
</tr>
<tr>
<td style="text-align:left">就绪、发送、发送完成</td>
<td style="text-align:left">接收、数据量确认</td>
<td style="text-align:left">打开</td>
</tr>
<tr>
<td style="text-align:left">就绪、发送、发送完成</td>
<td style="text-align:left">接收完成、读取完成</td>
<td style="text-align:left">半关闭（对端）</td>
</tr>
<tr>
<td style="text-align:left">就绪、发送、发送完成</td>
<td style="text-align:left">重置接收、重置读取</td>
<td style="text-align:left">半关闭（对端）</td>
</tr>
<tr>
<td style="text-align:left">接收完成</td>
<td style="text-align:left">接收、数据量确认</td>
<td style="text-align:left">半关闭（本端）</td>
</tr>
<tr>
<td style="text-align:left">重置发送、重置接收</td>
<td style="text-align:left">接收、数据量确认</td>
<td style="text-align:left">半关闭（本端）</td>
</tr>
<tr>
<td style="text-align:left">重置发送、重置接收</td>
<td style="text-align:left">接收完成、读取完成</td>
<td style="text-align:left">关闭</td>
</tr>
<tr>
<td style="text-align:left">重置发送、重置接收</td>
<td style="text-align:left">重置接收、重置读取</td>
<td style="text-align:left">关闭</td>
</tr>
<tr>
<td style="text-align:left">接收完成</td>
<td style="text-align:left">接收完成、读取完成</td>
<td style="text-align:left">关闭</td>
</tr>
<tr>
<td style="text-align:left">接收完成</td>
<td style="text-align:left">重置接收、重置读取</td>
<td style="text-align:left">关闭</td>
</tr>
</tbody>
</table>
<p><a href="#Table_2_Possible_Mapping_of_Stream_States_to_HTTP2">表2：流状态到HTTP/2间可能的映射方式</a></p>
</div>
<blockquote>
<p>注意（①）：如果一条流尚未被创建或其接收部分处于“接收”状态而尚未收到任何帧，则流处于“空闲”状态。</p>
</blockquote>
</div>
</section>
<section class="page" id="3.5_Solicited_State_Transitions">
<h2>
<a href="#3.5_Solicited_State_Transitions">3.5. 请求状态转换</a>
</h2>
<div class="content">
<p>如果应用层不再需要流接收到的数据，应用层可以中止流的读取，并指定一个应用层错误码。</p>
<p>如果流处在“接收”或“数据量确认”状态，传输层<em><strong>应该</strong></em>发送一个<strong>停止发送帧</strong>通知对端及时在反方向关闭流。这通常表明接收方应用层不再读取流接收到的数据，但这并不意味着传入的数据一定会被忽略。</p>
<p>在发送完<strong>停止发送帧</strong>后收到的<strong>流帧</strong>仍然会被连接及流级别的流量控制统计，即使这些帧可能在接收时即被丢弃。</p>
<p><strong>停止发送帧</strong>请求接收端发送一个<strong>流重置帧</strong>。如果流处在“就绪”或“发送”状态，收到<strong>停止发送帧</strong>的一端<em><strong>必须</strong></em>发送一个<strong>流重置帧</strong>。如果流处在“发送完成”状态，终端<em><strong>可以</strong></em>推迟发送<strong>流重置帧</strong>直到含有未发完数据的数据包被确认或明确的被丢弃。如果任何未发完数据得到明确被丢弃了，终端<em><strong>应该</strong></em>发送一个<strong>流重置帧</strong>而非重传数据。</p>
<p>终端<em><strong>应该</strong></em>从<strong>停止发送帧</strong>复制错误码到要发出的<strong>流重置帧</strong>，但是其可以使用任何应用层错误码。发送<strong>停止发送帧</strong>的终端<em><strong>可以</strong></em>忽略任何随后被流接收到的<strong>流重置帧</strong>里的错误码。</p>
<p><strong>停止发送帧</strong><em><strong>应该</strong></em>只能在流尚未被对端重置前发送出去。<strong>停止发送帧</strong>主要在流的“接收”或“数据量确认”状态使用。</p>
<p>如果包含前一个<strong>停止发送帧</strong>的数据包丢失了，终端应当发送另一个<strong>停止发送帧</strong>。然而，一旦流收到了所有流数据或一个<strong>流重置帧</strong>——也就是说流处在“接收”或“数据量确认”之外的状态——发送<strong>停止发送帧</strong>就不再必要了。</p>
<p>如果双向流的一端想要将流的两个方向同时关闭，那么其可以通过发送一个<strong>流重置帧</strong>关闭一个方向，并发送一个<strong>停止发送帧</strong>促使相反方向也迅速得到关闭。</p>
</div>
</section>
<section class="page" id="4_Flow_Control">
<h1>
<a href="#4_Flow_Control">4. 流量控制</a>
</h1>
<div class="content">
<p>接收方需要限制缓存数据量以防发送方速度太快造成冲击或被恶意发送方消耗大量内存。为了让接收方能够限制连接的内存占用，不仅每条流有单独的流量控制，所有流也作为一个整体在连接层面有统一的流量控制。QUIC接收方控制发送方在一条流上以及任何时刻在所有流上可以发送的最大数据量，详见<a href="#4.1_Data_Flow_Control">第4.1章</a>或<a href="#4.2_Increasing_Flow_Control_Limits">第4.2章</a>。</p>
<p>同样地，为了限制连接并发，QUIC终端控制对方可以同时开启的最大流数量，详见<a href="#4.6_Controlling_Concurrency">第4.6章</a>。</p>
<p>通过<strong>加密帧</strong>发送的数据不像流数据那样受流量控制制约。QUIC依赖于加密协议的实现来避免这些数据被过量缓存，详见《<a href="/RFC9001_Chinese_Simplified">QUIC-TLS</a>》。为了防止在多个层次过量缓存数据，QUIC实现<em><strong>应该</strong></em>为加密协议实现提供一套接口以供其交流缓存区限制。</p>
</div>
</section>
<section class="page" id="4.1_Data_Flow_Control">
<h2>
<a href="#4.1_Data_Flow_Control">4.1. 数据流量控制</a>
</h2>
<div class="content">
<p>QUIC使用一个基于限制的流量控制模型，接收者给出其准备在给定流或整个连接上准备接收的总字节数的上限。这使得QUIC中存在两层数据流量控制：</p>
<ul>
<li>流的流量控制：通过限制每条流可以发送的数据量，防止单条流耗尽一条连接的全部接收缓冲区；</li>
<li>连接流量控制：通过限制所有流经由<strong>流帧</strong>可以发送的数据量，防止发送方超过连接接收方的缓冲区容量。</li>
</ul>
<p>发送方发送数据<em><strong>必须不</strong></em>能超过上述任何一个限制。</p>
<p>接收方在握手过程中（<a href="#7.4_Transport_Parameters">第7.4章</a>）通过传输参数为所有流设置初始的流接收缓存区上限。随后，接收方发送<strong>最大流数据帧</strong>（<a href="#19.10_MAX_STREAM_DATA_Frames">第19.10章</a>）或<strong>最大数据帧</strong>（<a href="#19.9_MAX_DATA_Frames">第19.9章</a>）以告知对方提高流接收缓存区上限。</p>
<p>接收方可以通过发送一个含相关流ID的<strong>最大流数据帧</strong>告知对方提高流接收缓存区上限。<strong>最大流数据帧</strong>表示流的最大绝对字节偏移量。接收方可以根据当前流消耗数据的偏移量确定后续发出的流量控制的偏移量。</p>
<p>接收方可以通过发送一个<strong>最大数据帧</strong>告知对方提高连接的接收缓存区上限，亦即所有流绝对字节偏移量之和的上限。接收方维护一个在所有流上累计接收数据的总字节数，用以检查是否超过了连接或流流量控制上限。接收方可以基于在所有流上消耗数据总字节数确定后续发出的最大数据偏移量。</p>
<p>接收方发布连接或流的流量控制上限若低于之前的上限，这不是错误，只是这个更低的上限不会生效而已。</p>
<p>如果发送方违反了推荐的连接或流的流量控制上限，接收方<em><strong>必须</strong></em>以FLOW_CONTROL_ERROR类型错误关闭连接，更多错误处理相关细节详见<a href="#11_Error_Handling">第11章</a>。</p>
<p>发送方<em><strong>必须</strong></em>忽略任何不会提高流量控制上限的<strong>最大流数据帧</strong>或<strong>最大数据帧</strong>。</p>
<p>如果发送方发送数据达到了流量控制上限，其将不能再发送新数据，且应认为其被阻塞住了。发送方<em><strong>应该</strong></em>发送一个<strong>流数据阻塞帧</strong>或<strong>数据阻塞帧</strong>来告知接收方其有数据要写出但是被流量控制所阻塞。如果发送方被阻塞的时间超过空等超时时间（<a href="#10.1_Idle_Timeout">第10.1章</a>），接收方可以关闭连接，即便发送方有可传输的数据。为了保持连接不被关闭，在没有可引发ACK的数据包处于传输中时，被流量控制限制所阻塞的发送方<em><strong>应该</strong></em>定期发送一个<strong>流数据阻塞帧</strong>或<strong>数据阻塞帧</strong>。</p>
</div>
</section>
<section class="page" id="4.2_Increasing_Flow_Control_Limits">
<h2>
<a href="#4.2_Increasing_Flow_Control_Limits">4.2. 提高流量控制限制</a>
</h2>
<div class="content">
<p>QUIC实现决定什么时候以什么额度通过<strong>最大流数据帧</strong>及<strong>最大数据帧</strong>提高流量控制限制，但是本章提出了一些注意事项。</p>
<p>为了避免阻塞发送方，接收方<em><strong>可以</strong></em>在一个往返时间（RTT）内多次发送一个<strong>最大流数据帧</strong>或<strong>最大数据帧</strong>，或者尽可能早地发送，从而为帧的丢失及随后的恢复留出时间。</p>
<p>控制帧也会引入连接开销。也就是说频繁发送<strong>最大流数据帧</strong>及<strong>最大数据帧</strong>做极其微小的调整是不可取的。另一方面，如果更新不够频繁，每次更新时就要对接收方上限做更大幅度的提升以防发送方被阻塞，使得接收方耗费需要更多资源。因此，确定决定接收方推荐上限需要权衡资源耗费与连接开销。</p>
<p>接收方可以使用一个常见于TCP实现的基于往返时间及接收数据应用层消耗速率的自动调谐机制来调整推荐接收上限的频率和增量。作为优化，终端只有在有其他帧要发送时才可以发送流量控制相关帧，以确保流量控制不会导致额外的数据包发送。</p>
<p>被阻塞发送方不一定发送<strong>流阻塞帧</strong>或<strong>数据阻塞帧</strong>。因此，接收方<em><strong>必须不</strong></em>能在发送<strong>最大流数据帧</strong>及<strong>最大数据帧</strong>前等待接收<strong>流阻塞帧</strong>或<strong>数据阻塞帧</strong>，否则可能导致发送方在连接的其余部分被阻塞。即使发送方发送了这些帧，等待它们也会导致发送方至少被阻塞一个完整的往返周期。</p>
<p>当终端在阻塞期间收到可发送数据额度时，它可能会回复大量数据，造成短暂的拥塞，详见《<a href="../RFC9002_Chinese_Simplified">QUIC恢复</a>》<a href="../RFC9002_Chinese_Simplified/#7.7_Pacing">第7.7章</a>有关终端如何避免这类拥塞的讨论。</p>
<div class="block note">
<p><strong>秋航注</strong>：这里将credit翻译为额度、增量等，指的是<strong>最大流数据帧</strong>及<strong>最大数据帧</strong>所带来的接收方新流量控制上限相对之前的提升量，这个提升量是发送方后续可发送新数据的空间。</p>
</div>
</div>
</section>
<section class="page" id="4.3_Flow_Control_Performance">
<h2>
<a href="#4.3_Flow_Control_Performance">4.3. 流量控制性能</a>
</h2>
<div class="content">
<p>如果终端不能确保其对端始终在该连接上有大于对端带宽时延积的流量控制额度，其接收吞吐量将被流量控制限制。</p>
<p>包丢失会导致接收缓冲区出现空隙，从而阻碍应用层消耗数据并释放接收缓冲空间。</p>
<p>及时发送流量控制上限更新能提高性能。发送只包含流量控制更新的数据包会增加网络负载，对性能产生不利影响。将流量控制更新与其他帧一起发出，例如如ACK帧，可以降低此类更新带来的消耗。</p>
</div>
</section>
<section class="page" id="4.4_Handling_Stream_Cancellation">
<h2>
<a href="#4.4_Handling_Stream_Cancellation">4.4. 处理流取消</a>
</h2>
<div class="content">
<p>终端之间最终必须在每条流消耗的流量控制额度上达成一致，从而能够计算出连接级流量控制的字节数。</p>
<p>收到<strong>流重置帧</strong>后，终端就会关闭相应流的状态，并忽略后续从该流上收到的数据。</p>
<p><strong>流重置帧</strong>会立即中止流的一个方向。对于一条双向流，<strong>流重置帧</strong>不会影响另一个方向的数据流。双端<em><strong>必须</strong></em>给一条流尚未关闭的方向维持流量控制状态直到该方向转入终止状态。</p>
<div class="block note">
<p><strong>秋航注</strong>：“中止”与“终止”的区别在于“中止”强调突然地、异常地结束一个过程，而“终止”没有这种强调意味。可以认为，“终止”包含流程的正常结束和异常“中止”两种情况。</p>
</div>
</div>
</section>
<section class="page" id="4.5_Stream_Final_Size">
<h2>
<a href="#4.5_Stream_Final_Size">4.5. 流的最终数据量</a>
</h2>
<div class="content">
<p>流的最终数据量是流消耗的流量控制额度的总量。假设流的每个连续的字节只被发送一次，那么其最终数据量就是发出的总字节数。更一般地来说，这比流上发送的最大偏移的字节高1，若无字节发送则为0。</p>
<p>不管流是如何终止的，发送方始终试图将流的最终数据量可靠地发送给接收方。最终数据量是 带有FIN置位的<strong>流帧</strong>的Offset（下标）和Length（长度）字段值的总和，注意这些字段可能是隐式的。或者，<strong>流重置帧</strong>的Final Size字段也可以携带最终数据量值。这保证了双端发送方在该流上消耗的流量控制额度上达成一致。</p>
<p>终端在流的接收部分转入“数据量确认”或“重置接收”状态（<a href="#3_Stream_States">第3章</a>）后将得知最终数据量。接收方<em><strong>必须</strong></em>根据流的最终数据量在其连接层流量控制上统计该流发送的字节数。</p>
<p>终端<em><strong>必须不</strong></em>能在大于或等于最终数据量的流上发送数据。</p>
<p>一旦流的最终数据量得到确认，就不能再更改。如果收到<strong>流重置帧</strong>或<strong>流帧</strong>表示要修改流的最终数据量，终端<em><strong>应该</strong></em>回复一个FINAL_SIZE_ERROR类型的错误，更多细节详见<a href="#11_Error_Handling">第11章</a>有关错误处理部分。接收方<em><strong>应该</strong></em>将收到达到或超过最终数据量数据的情况视为FINAL_SIZE_ERROR类型的错误，即使是在关闭后收到的。并不强制要求生成这些错误，因为终端若要做到这一点往往意味着终端需要给已关闭流维持一个最终数据量状态，也就意味着需要增加一个重要的状态确认。</p>
</div>
</section>
<section class="page" id="4.6_Controlling_Concurrency">
<h2>
<a href="#4.6_Controlling_Concurrency">4.6. 并发控制</a>
</h2>
<div class="content">
<p>终端限制对端累计可以开启的流的数量。只有流ID小于<code>(max_streams * 4 + first_stream_id_of_type)</code>的流可以被开启，详见<a href="#Table_1_Stream_ID_Types">表1</a>。初始限制由传输参数设置，详见<a href="#18.2_Transport_Parameter_Definitions">第18.2章</a>。随后的限制由<strong>最大流帧</strong>推出，详见<a href="#19.11_MAX_STREAMS_Frames">第19.11章</a>。针对单向及双向流由单独的限制。</p>
<p>如果经由<code>max_streams</code>传输参数或<strong>最大流帧</strong>收到的值大于2<sup>60</sup>，这将使得最大流ID不能表示为变长整数，详见<a href="#16_Variable-Length_Integer_Encoding">第16章</a>。如果收到了这两者的其中一个，<em><strong>必须</strong></em>立即关闭连接：如果这个值是通过传输参数收到的，就以TRANSPORT_PARAMETER_ERROR错误关闭连接；如果是通过帧收到的，就以FRAME_ENCODING_ERROR错误关闭连接，详见<a href="#10.2_Immediate_Close">第10.2章</a>。</p>
<p>终端<em><strong>必须不</strong></em>能触达对端设置的流数量限制。终端收到一个有个触达其设置的流数量上限的流ID的帧的情况<em><strong>必须</strong></em>视为STREAM_LIMIT_ERROR类型的连接错误，更多有关错误梳理的细节详见<a href="#11_Error_Handling">第11章</a>。</p>
<p>一旦接收方通过<strong>最大流帧</strong>推荐了一个流数量上限，再推荐一个更小的上限将不再生效。<em><strong>必须</strong></em>忽略不会提高流数量上限的<strong>最大流帧</strong>。</p>
<p>正如流及连接层流量控制，本文让实现者来决定通过<strong>最大流帧</strong>发布的流数量上限的时间及数值。QUIC实现可以选择在流关闭时提高流数量上限，从而保持对端可以使用的流的数量大体对等。</p>
<p>终端因对端设置的流数量上限而不能再开启新流时，<em><strong>应该</strong></em>发送一个<strong>流阻塞帧</strong>（<a href="#19.14_STREAMS_BLOCKED_Frames">第19.14章</a>）。可以认为这个信号主要用于调试。终端<em><strong>必须不</strong></em>能在告知额外额度前等待这个信号，因为这样做的话意味着对端会被阻塞至少一个往返周期，且若对端选择不发<strong>流阻塞帧</strong>时则等待可能会是无限期的。</p>
</div>
</section>
<section class="page" id="5_Connections">
<h1>
<a href="#5_Connections">5. 连接</a>
</h1>
<div class="content">
<p>QUIC连接在客户端与服务端之间共享状态。</p>
<p>QUIC连接从握手开始。在握手的过程中，双端使用加密握手协议（<a href="/RFC9001_Chinese_Simplified">QUIC-TLS</a>）创建一个共享密钥并协商应用协议。握手过程（<a href="#7_Cryptographic_and_Transport_Handshake">第7章</a>）确认双端的交流意愿（<a href="#8.1_Address_Validation_during_Connection_Establishment">第8.1章</a>），并确立连接的各项参数（<a href="#7.4_Transport_Parameters">第7.4章</a>）。</p>
<p>应用层协议可以在连接握手阶段使用连接，但这种使用是有所限制的。0-RTT准许客户端在收到服务端回复前发送应用数据，但是没有抵御回放攻击的措施，详见《<a href="/RFC9001_Chinese_Simplified">QUIC-TLS</a>》第9.2章。服务端也可以在收到客户端的最终加密握手信息前发送应用数据，此时服务端尚未确认客户端的身份，也未确认客户端是否存活。应用层协议可以在安全性与降低延迟之间权衡，以决定是否使用这些功能。</p>
<p>连接ID（<a href="#5_Connections">第5章</a>）的存在使得连接可以迁移到新的网络通道上，这不仅可以是终端的主动选择，也可以是在网络中间件发生变更后的被动选择。<a href="#9_Connection_Migration">第9章</a>描述了如何缓解连接迁移带来的安全和隐私问题。</p>
<p>对于不再需要的连接，有几种方法可以让客户端和服务端将其关闭，详见<a href="#10_Connection_Termination">第10章</a>。</p>
</div>
</section>
<section class="page" id="5.1_Connection_ID">
<h2>
<a href="#5.1_Connection_ID">5.1 连接ID</a>
</h2>
<div class="content">
<p>每条连接拥有一组连接标识符，也就是连接ID，每个连接ID都能标识这条连接。连接ID是由终端独立选择的，每个终端选择连接ID供对端使用。</p>
<p>连接ID的主要功能是确保底层协议（UDP、IP及更底层的协议栈）发生地址变更时不会导致一个QUIC连接的数据包被传输到错误的QUIC终端上。终端使用特殊实现的（且可能特殊部署的）方式选择连接ID，这将使得具有该连接ID的数据包能够路由回终端，并在接收时能够正确识别。</p>
<p>终端使用多个连接ID从而使观察者无法在没有终端协助的情况下将发送的数据包识别为同一个连接的数据包，详见<a href="#9.5_Privacy_Implications_of_Connection_Migration">第9.5章</a>。</p>
<p>连接ID<em><strong>必须不</strong></em>能包含任何能够被外部观察者（这里指的是不会与发信者合作的人）用于将其关联到该连接的其他连接ID的信息。举个简单的例子，这意味着同一个连接ID不能在同一个连接上被多次发送。</p>
<p>长包头数据包包含源连接ID和目标连接ID字段，这些字段用来设置新连接的连接ID，更多细节详见<a href="#7.2_Negotiating_Connection_IDs">第7.2章</a>。</p>
<p>短包头数据包（<a href="#17.3_Short_Header_Packets">第17.3章</a>）只包含目标连接ID并省略显式长度。目标连接ID字段的长度被认为已经为对端所知。使用基于连接ID进行路由调度的负载均衡器的终端可以在连接ID的固定长度或使用编码上与负载均衡器达成一致。在一个固定的位置可以编码一个显式的长度，从而可以根据长度安置整个连接ID，使其仍可被负载均衡器使用。</p>
<p>一个版本协商（<a href="#17.2.1_Version_Negotiation_Packet">第17.2.1章</a>）包回显客户端选择的连接ID，不仅为了确保到客户端的路由是正确的，也为了证明这个数据包是对客户端发送的数据包的回应。</p>
<p>当一个连接ID不需要路由到正确的终端上时，可能使用一个零长度的连接ID。然而，多个连接复用同一个本地IP地址和端口时，如果使用零长度的连接ID，将在存在对端连接迁移、NAT重绑定及客户端端口复用的情况下导致失败，除非可以肯定没有使用这些协议特性。</p>
<p>当一个终端使用一个非零长度连接ID，它必须确保对端有一定量的连接ID可供选择给发往本端的数据包使用。这些连接ID通过NEW_CONNECTION_ID帧提供（<a href="#19.15_NEW_CONNECTION_ID_Frames">第19.15章</a>）。</p>
</div>
</section>
<section class="page" id="5.1.1_Issuing_Connection_IDs">
<h3>
<a href="#5.1.1_Issuing_Connection_IDs">5.1.1 发布连接ID</a>
</h3>
<div class="content">
<p>当<code>新连接ID帧</code>或<code>撤销连接ID帧</code>指向同一个值时，每个连接ID都有一个相关联的序列号用于协助检测。一个终端发出的初始连接ID是通过握手阶段（<a href="#17.2_Long_Header_Packets">第17.2章</a>）的长包头的源连接ID字段发送的。初始连接ID的序列号是0。如果发送了传输参数<code>preferred_address</code>（推荐地址），发出的连接ID的序列号就是1。</p>
<p>额外的连接ID通过<code>新连接ID帧</code>（<a href="#19.5_STOP_SENDING_Frames">第19.5章</a>）传输给对方。新发出的连接ID的序列号<em><strong>必须</strong></em>递增1。客户端给其发出的第一个目标连接ID字段的连接ID及重试包的连接ID不会分配序列号。</p>
<p>当一个终端发出一个连接ID，其<em><strong>必须</strong></em>在连接存活期间或在对端通过<code>撤销连接ID帧</code>（<a href="#19.16_RETIRE_CONNECTION_ID_Frames">第19.16章</a>）取消连接前接收携带该连接ID的数据包。连接ID被发出且没有被取消，即是活跃的；任何活跃的连接ID在连接任何时间、对其任何类型的数据包都可以有效使用。这包括被服务端通过推荐地址传输参数发出的连接ID。</p>
<p>终端<em><strong>应该</strong></em>确保其对端有足够数量可用且未使用的连接ID。终端使用<code>active_connection_id_limit</code>（活跃连接ID限制）传输参数指定它们想要维持的活跃连接ID的数目。一个终端<em><strong>必须不</strong></em>能提供超过对端限制数目的连接ID。如果<code>新连接ID帧</code>也要求终止任何多余的连接ID，终端<em><strong>可以</strong></em>通过在“撤销前”字段包含一个足够大的值来发送临时超过对端限制数量的连接ID。</p>
<p>终端可以根据<code>新连接ID帧</code>的“撤销前”字段内容添加一些活跃连接ID并终止其他连接ID。在处理完一个<code>新连接ID帧</code>，添加及撤销一些活跃连接ID后，如果活跃连接ID数量仍然超过<code>active_connection_id_limit</code>传输参数建议的值，终端<em><strong>必须</strong></em>以<code>CONNECTION_ID_LIMIT_ERROR</code>（连接ID限制）错误关闭连接。</p>
<p>当对端撤销一个连接ID后，终端<em><strong>应该</strong></em>提供一个新的连接ID。如果终端提供的连接ID数目小于对端<code>active_connection_id_limit</code>值，则其<em><strong>可以</strong></em>在收到一个包含之前撤销的连接ID的数据包时提供一个新的连接ID。终端<em><strong>可以</strong></em>限制为每条连接发布的连接ID总数来避免连接ID耗尽的风险，见<a href="#10.3.2_Calculating_a_Stateless_Reset_Token">第10.3.2章</a>。终端也<em><strong>可以</strong></em>限制连接ID的发布以降低其维护的通道层面的状态量，例如通道验证状态，因为对端可能有多少连接ID就用多少通道与其交互。</p>
<p>启动连接迁移且需要非零长度连接ID的终端<em><strong>应该</strong></em>确保其连接ID池对端可得，从而使对端能在连接迁移时用新的连接ID，因为如果连接ID池耗尽，对端将无法回复。</p>
<p>在握手阶段选择零长度连接ID的终端不能发布新的连接ID。通过任何通道发往一个这样的终端的所有包使用零长度目标连接ID字段。</p>
</div>
</section>
<section class="page" id="5.1.2_Consuming_and_Retiring_Connection_IDs">
<h3>
<a href="#5.1.2_Consuming_and_Retiring_Connection_IDs">5.1.2 消耗及撤销连接ID</a>
</h3>
<div class="content">
<p>终端可以在连接期间任何时候将其与对端交互的连接ID更改为另一个可用的连接ID。在对端进行迁移连接时，终端会消耗连接ID，更多详见<a href="#9.5_Privacy_Implications_of_Connection_Migration">第9.5章</a>。</p>
<p>终端维护一个接收自对端的连接ID集合，其中每个ID均可用于发送数据包。当终端想要停止使用一个连接ID，其可以发送一个<code>撤销连接ID帧</code>给对端。发送一个<code>撤销连接ID帧</code>意味着将不会再次使用该连接ID，同时请求对端通过<code>新连接ID帧</code>换一个新的连接ID。</p>
<p>如<a href="#9.5_Privacy_Implications_of_Connection_Migration">第9.5章</a>所述，终端限制使用一个连接ID从一个单一本地地址向一个单一目标地址发送数据包。当使用连接ID的本地或目标地址不再活跃的时候，终端<em><strong>应该</strong></em>撤销这些连接ID。</p>
<p>在特定场合，终端可能需要停止接收先前发布的连接ID。这种终端会通过发送带有值已增加的“撤销前”字段的<code>新连接ID帧</code>使对端停用这些连接ID。终端<em><strong>应该</strong></em>继续接收先前发布的连接ID直到它们被对端撤销。如果终端不能再处理指定的连接ID，其<em><strong>可以</strong></em>关闭连接。</p>
<p>一旦收到一个值增加的“撤销前”字段，对端<em><strong>必须</strong></em>停止使用相关连接ID，并在添加新提供的连接ID到活跃连接ID集合之前，通过<code>撤销连接ID帧</code>停用这些连接ID。这么安排使得终端能够替换全部活跃连接ID，而不会出现对端没有可用连接ID的情况，也不会使活跃连接ID数超过对端传输参数<code>active_connection_id_limit</code>设下的限制，详见<a href="#18.2_Transport_Parameter_Definitions">第18.2章</a>。无法停止使用连接ID可能导致连接错误，因为发布端可能不能在当前连接上继续使用这些连接ID。</p>
<p>如果<code>撤销连接ID帧</code>尚未被确认，那么终端<em><strong>应该</strong></em>限制本地已撤销连接ID的数量。终端<em><strong>应该</strong></em>允许发送中及可追踪的<code>撤销连接ID帧</code>数量至少是传输参数<code>active_connection_id_limit</code>值的两倍。终端<em><strong>必须不</strong></em>在没有撤销一个连接ID前忘记它，尽管其<em><strong>可以</strong></em>选择将仍然使用达到该限制而需要被撤销的连接ID的情况视为一个<code>CONNECTION_ID_LIMIT_ERROR</code>类型的连接错误。</p>
<p>在收到撤销由先前的“撤销前”字段指定的全部连接ID的<code>撤销连接ID帧</code>前，终端<em><strong>不应该</strong></em>发布更新“撤销前”字段。</p>
</div>
</section>
<section class="page" id="5.2_Matching_Packets_to_Connections">
<h2>
<a href="#5.2_Matching_Packets_to_Connections">5.2 数据包与连接如何匹配</a>
</h2>
<div class="content">
<p>入包在接收时进行分类。数据包可能被关联到一个已存在的连接，也可能（在服务端）创建一个新连接。</p>
<p>终端尝试将数据包与现有连接关联起来。如果数据包有关联到一个已存在的连接的非零目标连接ID，QUIC将在相应连接上处理该数据包。注意一条连接可以对应不止一个连接ID，详见<a href="#5.1_Connection_ID">第5.1章</a>。</p>
<p>如果一个数据包的目标连接ID是零长度的，而且其地址信息与终端用来标识零长度连接ID的连接匹配，则QUIC将该数据包作为该连接的一部分处理。终端可以只使用目标IP和端口，也可以同时使用源地址和目标地址作为标识，尽管这样会使连接像<a href="#5.1_Connection_ID">第5.1章</a>描述的那样变得脆弱。</p>
<p>对任何不属于已存在连接的数据包，终端都可以发送一个无状态重置（<a href="#10.3_Stateless_Reset">第10.3章</a>）。无状态重置使对端能更快地识别连接变得不可用的情况。</p>
<p>初始化、重试或版本协商这种缺乏强完整性保护的无效包<em><strong>可以</strong></em>被丢弃。如果终端在发生错误前处理了这些包的内容，终端<em><strong>必须</strong></em>产生一个连接错误，或完全恢复处理期间所做的所有变更。</p>
</div>
</section>
<section class="page" id="5.2.1_Client_Packet_Handling">
<h3>
<a href="#5.2.1_Client_Packet_Handling">5.2.1 客户端数据包处理</a>
</h3>
<div class="content">
<p>发往客户端的有效数据包往往包含一个与客户端选择的值匹配的目标连接ID。选择接收零长度连接ID的客户端可以使用本地地址和端口识别一个连接。不能与已存在连接匹配的数据包——基于目标连接ID或目标连接ID为零长度时基于本地IP地址和端口——将被丢弃。</p>
<p>由于数据包乱序或丢失，客户端可能收到使用尚未算出的密钥加密的数据包。客户端<em><strong>可以</strong></em>丢弃这些包，也<em><strong>可以</strong></em>缓存起来以备后续数据包使其可以计算出密钥。</p>
<p>如果客户端收到一个包使用了与初始化阶段选择不同的QUIC版本，其<em><strong>必须</strong></em>丢弃该包。</p>
</div>
</section>
<section class="page" id="5.2.2_Server_Packet_Handling">
<h3>
<a href="#5.2.2_Server_Packet_Handling">5.2.2 服务端数据包处理</a>
</h3>
<div class="content">
<p>如果服务端收到一个来自不支持版本的数据包而其又足够初始化某个支持版本的新连接，服务端<em><strong>应该</strong></em>发送一个版本协商包，详见<a href="#6.1_Sending_Version_Negotiation_Packets">第6.1章</a>。服务端<em><strong>可以</strong></em>限制其回复的版本协商包的数量。服务端<em><strong>必须</strong></em>丢弃属于不支持版本的小包。</p>
<p>一个不支持版本的第一个包可以对任何与具体版本有关的字段使用不同语义和编码。尤其是不同的版本可能使用不同的数据包保护密钥。不支持一个特定版本的服务端不太可能解密数据包的有效负载或正确解释其内容。当数据报文足够长时，服务端<em><strong>应该</strong></em>回复一个版本协商包。</p>
<p>有一个支持版本或没有版本字段的数据包通过连接ID或——对于零长度连接ID的数据包——本地地址和端口与一个连接匹配，这些包在该连接上处理；否则，服务端继续做如下处理。</p>
<p>如果数据包是完全符合规范的初始化包，则服务端继续进行握手（<a href="#7_Cryptographic_and_Transport_Handshake">第7章</a>）。服务端会指派为客户端选择的版本。</p>
<p>如果服务端拒绝接收一个新连接，它<em><strong>应该</strong></em>发送一个带<code>连接关闭帧</code>的初始化包给客户端，其中<code>连接关闭帧</code>的错误码设置为<code>CONNECTION_REFUSED</code>（连接拒绝）。</p>
<p>如果数据包是一个0-RTT包，服务端<em><strong>可以</strong></em>进行有限数量的缓存，因为后续预期会收到初始化包。由于客户端不可能先于收到服务端回复发送握手包，所以服务端<em><strong>应该</strong></em>忽略任何这样的包。</p>
<p>服务端<em><strong>必须</strong></em>丢弃任何其他场合收到的数据包。</p>
</div>
</section>
<section class="page" id="5.2.3_Considerations_for_Simple_Load_Balancers">
<h3>
<a href="#5.2.3_Considerations_for_Simple_Load_Balancers">5.2.3 关于简单负载均衡</a>
</h3>
<div class="content">
<p>服务端部署可以仅仅使用源与目的IP地址和端口在服务器之间进行负载均衡。改变客户端IP地址或端口可能导致数据包被转发到错误的服务器上。这种服务端部署可以从如下方法中选择一个用于在客户端地址变换时维持连接。</p>
<ul>
<li>服务端可以使用带外机制，根据连接ID将数据包转发到正确的服务器；</li>
<li>如果服务器可以使用固定的IP地址或端口，且不同于客户端初始建联时访问的那个，它们可以使用传输参数<code>preferred_address</code>（推荐地址）请求客户端迁移到那个固定的地址上。
注意客户端可以选择不使用推荐地址。</li>
</ul>
<p>服务端的一台服务器如果不支持在客户端改变地址时维持连接，其<em><strong>应该</strong></em>通过传输参数<code>disable_active_migration</code>（关闭活动迁移）告知对端当前不支持连接迁移。在客户端预先拿到<code>preferred_address</code>参数后，传输参数<code>disable_active_migration</code>将不能阻止客户端进行连接迁移。</p>
<p>应用本简单形式负载均衡进行部署后，服务端<em><strong>必须</strong></em>避免创建无状态重置指示，详见<a href="#21.11_Stateless_Reset_Oracle">第21.11章</a>。</p>
</div>
</section>
<section class="page" id="5.3_Operations_on_Connections">
<h2>
<a href="#5.3_Operations_on_Connections">5.3 连接操作</a>
</h2>
<div class="content">
<p>本文没有定义QUIC的API，而是定义了一系列有关QUIC连接的函数，用于应用层协议进行依赖。应用层协议可以假设一个QUIC的实现提供了一个包括本章所述操作的接口。针对一个特定应用层协议而设计的实现可能只提供该协议用到的那些操作。</p>
<p>当实现用户端时，应用层协议可以：</p>
<ul>
<li>创建一个连接，开始进行<a href="#7_Cryptographic_and_Transport_Handshake">第7章</a>描述的交互过程；</li>
<li>如果支持，启用早期数据功能；</li>
<li>当早期数据被服务端接受或拒绝时，收到通知。</li>
</ul>
<p>当实现服务端时，应用层协议可以：</p>
<ul>
<li>监听传入的连接，准备进行<a href="#7_Cryptographic_and_Transport_Handshake">第7章</a>描述的交互过程；</li>
<li>如果支持早期数据，在发送给客户端的TLS恢复ticket中嵌入应用层控制数据；</li>
<li>如果支持早期数据，从接收自客户端的恢复ticket中恢复应用层控制数据，并根据该信息接受或拒绝早期数据。</li>
</ul>
<p>当同时实现客户端及服务端时，应用层协议可以：</p>
<ul>
<li>如传输参数（<a href="#7.4_Transport_Parameters">第7.4章</a>）所述，为每种类型允许的流的配置最小的初始数量；</li>
<li>通过设置流级别及连接级别的流量控制限制，限制接收缓存区资源分配；</li>
<li>识别握手已经成功结束抑或仍在进行中；</li>
<li>保持连接不被默认关闭，即通过PING帧（<a href="#19.2_PING_Frames">第19.2章</a>）或其他请求使得传输层在空闲超时（<a href="#10.1_Idle_Timeout">第10.1章</a>）前发送额外的帧；以及</li>
<li>立即关闭连接（<a href="#10.2_Immediate_Close">第10.2章</a>）。</li>
</ul>
</div>
</section>
<section class="page" id="6_Version_Negotiation">
<h1>
<a href="#6_Version_Negotiation">6. 版本协商</a>
</h1>
<div class="content">
<p>版本协商使得服务端可以表明其不支持客户端使用的版本。服务端发送一个版本协商包用于回复任何可能导致创建新连接的数据包，更多细节详见<a href="#5.2_Matching_Packets_to_Connections">第5.2章</a>。</p>
<p>客户端发送的第一个包的大小决定服务端是否发送版本协商包。支持多个QUIC版本的客户端<em><strong>应该</strong></em>确保其发出的第一个UDP报文的大小合乎其支持的所有版本的最小数据报文大小中的最大值，必要时可以用<strong>填充帧</strong>补齐（<a href="#19.1_PADDING_Frames">第19.1章</a>）。这确保如果有相互支持的版本，服务端能够响应。如果收到的报文小于一个不同版本的最小数据包大小，服务端可能不会发出版本协商包。</p>
</div>
</section>
<section class="page" id="6.1_Sending_Version_Negotiation_Packets">
<h2>
<a href="#6.1_Sending_Version_Negotiation_Packets">6.1 发送版本协商包</a>
</h2>
<div class="content">
<p>如果客户端选择的版本服务端不接受，服务端会响应一个版本协商包，详见<a href="#17.2.1_Version_Negotiation_Packet">第17.2.1章</a>。版本协商包包含一个服务端支持的版本的列表。终端<em><strong>必须不</strong></em>能给一个版本协商包回应一个版本协商包。</p>
<p>这个系统允许服务端处理不支持的数据包而不保持状态。即使作为响应发出的初始包或版本协商包都可能丢失，客户端也会发新的包直到收到回复或放弃建连尝试。</p>
<p>服务端<em><strong>可以</strong></em>限制其发送版本协商包的数量。例如，能识别0-RTT包的服务端可能会选择不发送版本协商包来响应0-RTT包，而是期望最终能收到初始包。</p>
</div>
</section>
<section class="page" id="6.2_Handling_Version_Negotiation_Packets">
<h2>
<a href="#6.2_Handling_Version_Negotiation_Packets">6.2 处理版本协商包</a>
</h2>
<div class="content">
<p>设计版本协商包的目的是为了让QUIC能够给未来定义的功能协商QUIC版本用于连接。未来标准追踪规范可能改变支持多版本QUIC对于收到的用于回复给试图使用这个版本建立连接的版本协商包进行应对的实现方式。</p>
<p>仅仅支持这个版本的客户端如果收到一个版本协商包，其<em><strong>必须</strong></em>放弃当前建联尝试，除非是下述两种例外：如果已经收到且成功处理任何其他类型的包，客户端<em><strong>必须</strong></em>忽略任何版本协商包；客户端<em><strong>必须</strong></em>忽略包含其选择的QUIC版本的版本协商包。</p>
<p>如何执行版本协商留作由未来标准追踪规范定义的未来工作。特别是，未来工作将确保在抵御版本降级攻击时具有健壮性，详见<a href="#21.12_Version_Downgrade">第21.12章</a>。</p>
</div>
</section>
<section class="page" id="6.3_Using_Reserved_Versions">
<h2>
<a href="#6.3_Using_Reserved_Versions">6.3 使用保留版本</a>
</h2>
<div class="content">
<p>对于将来使用新版本QUIC的服务端，客户端需要正确处理不支持的版本。一些版本号（如<code>0x?a?a?a?a</code>，见<a href="#15_Versions">第15章</a>）保留作包含版本号的字段。</p>
<p>终端<em><strong>可以</strong></em>添加保留版本到任意未知或不支持版本中会被忽略的字段，用以测试对端是否正确地忽略了该值。例如，终端可以发版本协商包中包含一个保留版本，详见<a href="#17.2.1_Version_Negotiation_Packet">第17.2.1章</a>)。终端<em><strong>可以</strong></em>发送一个保留版本的数据包来测试对端是否会正确丢弃该包。</p>
</div>
</section>
<section class="page" id="7_Cryptographic_and_Transport_Handshake">
<h1>
<a href="#7_Cryptographic_and_Transport_Handshake">7. 加密与传输握手</a>
</h1>
<div class="content">
<p>QUIC通过将加密与传输握手组合最小化连接建立的延迟。QUIC使用<strong>加密帧</strong>（详见<a href="#19.6_CRYPTO_Frames">第19.6章</a>）传递加密握手信息。本文所定义的QUIC版本标识为<code>0x00000001</code>，使用《<a href="/RFC9001_Chinese_Simplified">QUIC-TLS</a>》描述的TLS，而不同的QUIC版本可能表面其使用了不同的加密握手协议。</p>
<p>QUIC可靠、有序地传递加密握手数据。QUIC数据包保护用于尽可能多地对握手协议进行加密。加密握手{&lt; req_level MUST &gt;}具备如下属性：</p>
<ul>
<li>密钥交换是认证的，需要
<ul>
<li>服务端总是经过认证的，且</li>
<li>客户端是否经过认证是可选的，且</li>
<li>每个连接生成不同且不相关的密钥，且</li>
<li>密钥材料对0-RTT和1-RTT数据包均可提供保护。</li>
</ul>
</li>
<li>双端传输参数值的交换是认证的，且对服务端传输参数提供机密性保护。</li>
<li>应用层协议的认证协商（为此，TLS使用的是应用层协议协商——<a href="https://www.rfc-editor.org/info/rfc7301">ALPN</a>）。</li>
</ul>
<p><strong>加密帧</strong>可以在不同数据包号空间发送（详见<a href="#12.3_Packet_Numbers">第12.3章</a>）。在每个数据包号空间，<strong>加密帧</strong>用来确保加密握手数据有序传递的偏移量都是从0开始的。</p>
<p><a href="#Figure_4_Simplified_QUIC_Handshake">图4</a>展示了一个简化的握手及用于推动握手进程的数据包与帧的交换。如果可以的话，尽量在握手期间交换应用层数据，并用星号（"*"）表示。一旦完成握手，终端就能自由交换应用层数据。</p>
<div class="block ref" id="Figure_4_Simplified_QUIC_Handshake">
<img src="/RFC9000_Chinese_Simplified/images/Figure_4_Simplified_QUIC_Handshake.svg"/>
<p><a href="#Figure_4_Simplified_QUIC_Handshake">图4：简版QUIC握手</a></p>
</div>
<p>终端可以使用握手期间发送的数据包来测试是否支持显式拥塞通知（ECN），详见<a href="#13.4_Explicit_Congestion_Notification">第13.4章</a>。终端通过观察用于确认其发送的首个数据包的<strong>ACK帧</strong>是否携带ECN计数，验证是否支持ECN，更多细节详见<a href="#13.4.2_ECN_Validation">第13.4.2章</a>。</p>
<p>终端<em><strong>必须</strong></em>明确地协商应用层协议。这避免了对使用中的协议还存在分歧的情况。</p>
</div>
</section>
<section class="page" id="7.1_Example_Handshake_Flows">
<h2>
<a href="#7.1_Example_Handshake_Flows">7.1. 握手流程示例</a>
</h2>
<div class="content">
<p>关于TLS如何与QUIC整合的更多细节详见《<a href="/RFC9001_Chinese_Simplified">QUIC-TLS</a>》，但在此举出一些范例。用以支持客户端地址验证的这种交换的一个扩展详见<a href="#8.1.2_Address_Validation_Using_Retry_Packets">第8.1.2章</a>。</p>
<p>一旦完成任何地址验证交换，加密握手将用于协商密钥。加密握手由初始包（<a href="#17.2.2_Initial_Packet">第17.2.2章</a>）和握手包（<a href="#17.2.4_Handshake_Packet">第17.2.4章</a>）携带。</p>
<p><a href="#Figure_5_Example_1-RTT_Handshake">图5</a>展示了1-RTT握手过程的概况。每行展示一个QUIC数据包，首先展示其包类型和包号，紧接着展示这类包通常包含的帧。例如首包通常是初始包，包号是0，且包含一个携带ClientHello内容的<strong>加密帧</strong>。</p>
<p>多个QUIC包——甚至包类型各不相同——可以合并成一个UDP报文，详见<a href="#12.2_Coalescing_Packets">第12.2章</a>。因此，这次握手可能由仅仅4个或更少的UDP报文组成（受限于协议固有的诸如拥塞控制和反放大机制）。例如，服务端的首个报文包含初始包、握手包及包含“0.5-RTT数据”的1-RTT包。</p>
<div class="block ref" id="Figure_5_Example_1-RTT_Handshake">
<img src="/RFC9000_Chinese_Simplified/images/Figure_5_Example_1-RTT_Handshake.svg"/>
<p><a href="#Figure_5_Example_1-RTT_Handshake">图5：1-RTT握手示例</a></p>
</div>
<p><a href="#Figure_6_Example_0-RTT_Handshake">图6</a>是一个0-RTT握手连接的示例，并且其中一个数据包携带0-RTT数据。注意，如<a href="#12.3_Packet_Numbers">第12.3章</a>所述，服务端在1-RTT包中对0-RTT数据进行确认，并且客户端发送的1-RTT包处于同一个包号空间。</p>
<div class="block ref" id="Figure_6_Example_0-RTT_Handshake">
<img src="/RFC9000_Chinese_Simplified/images/Figure_6_Example_0-RTT_Handshake.svg"/>
<p><a href="#Figure_6_Example_0-RTT_Handshake">图6：0-RTT握手示例</a></p>
</div>
</div>
</section>
<section class="page" id="7.2_Negotiating_Connection_IDs">
<h2>
<a href="#7.2_Negotiating_Connection_IDs">7.2. 协商连接ID</a>
</h2>
<div class="content">
<p>连接ID用于确保数据包稳定路由，详见<a href="#5.1_Connection_ID">第5.1章</a>。长包头包含两个连接ID：目标连接ID由接收方指定并用于提供稳定路由；源连接ID供对端设置为目标连接ID。</p>
<p>在握手期间，带有长包头（详见<a href="#17.2_Long_Header_Packets">第17.2章</a>）的数据包用于设置双端所使用的连接ID。每端的源连接ID会作为发往该端的数据包的目标连接ID。在处理完首个初始数据包后，每端将后续发送数据包的目标连接ID字段值设置为其接收的源连接ID字段值。</p>
<p>当客户端发送初始包之前未从服务端收到过初始数据包或重试数据包，则生成不可预测值填充发送的初始包的目标连接ID字段。目标连接ID的长度<em><strong>必须</strong></em>至少8字节。客户端在一条连接上<em><strong>必须</strong></em>使用同一个目标连接ID，直到收到服务端发来的数据包为止。</p>
<p>客户端发送的首个初始数据包的目标连接ID字段用于确定初始数据包的包保护密钥。这些密钥在收到重试数据包后变更，详见<a href="/RFC9001_Chinese_Simplified">QUIC-TLS</a><a href="#5.2_Matching_Packets_to_Connections">第5.2章</a>。</p>
<p>客户端选择一个值填充源连接ID字段，并设置源连接ID长度字段以标识其长度。</p>
<p>客户端发送的首个0-RTT数据包使用其发送的首个初始数据包一致的源连接ID和目标连接ID。</p>
<p>在首次收到从服务端发来的初始数据包或重试数据包后，客户端将服务的提供的源连接ID作为后续发送数据包的目标连接ID，包括任何0-RTT包。这意味着客户端可能需要在连接建立阶段将目标连接ID字段的值变更两次：一次是响应服务端发来的重试数据包，一次是响应服务端发来的初始数据包。一旦客户端收到一个从服务端发来的有效的初始数据包，则其<em><strong>必须</strong></em>丢弃在该连接上后续接收到的任何带有不同源连接ID值的数据包。</p>
<p>客户端<em><strong>必须</strong></em>在收到首个初始数据包或首个重试数据包后，更改其后续发送数据包时的目标连接ID值。服务端<em><strong>必须</strong></em>基于收到的首个初始数据包设置发送数据包的目标连接ID。任何针对目标连接ID的后续改动，只允许通过<strong>新连接ID帧</strong>携带的值进行；如果后续的初始数据包包含不同的源连接ID，则<em><strong>必须</strong></em>将该包丢弃。这避免了对多个具有不同源连接ID的初始数据包进行无状态处理可能导致的不可预测的结果。</p>
<p>终端发出的目标连接ID可以在一条连接的生命周期内变更，尤其是在响应连接迁移（<a href="#9_Connection_Migration">第9章</a>），详见<a href="#5.1.1_Issuing_Connection_IDs">第5.1.1章</a>。</p>
</div>
</section>
<section class="page" id="7.3_Authenticating_Connection_IDs">
<h2>
<a href="#7.3_Authenticating_Connection_IDs">7.3. 验证连接ID</a>
</h2>
<div class="content">
<p>终端在握手期间的连接ID做出的选择，通过包括传输参数的所有的值验证，详见<a href="#7.4_Transport_Parameters">第7.4章</a>。这确保所有用于握手的连接ID也同时通过加密握手得到认证了。</p>
<p>终端将其发出的首个初始数据包的源连接ID字段值包含在<code>initial_source_connection_id</code>传输参数中，详见<a href="#18.2_Transport_Parameter_Definitions">第18.2章</a>。服务端将其接收到的首个初始数据包中的目标连接ID值包含在<code>original_destination_connection_id</code>传输参数中；如果服务端发送了一个重试数据包，则其对应的是发送该包之前收到的首个初始数据包。如果发送重试数据包，服务端也会将重试数据包的源连接ID字段包含在<code>retry_source_connection_id</code>传输参数中。</p>
<p>来自对端的传输参数中的值<em><strong>必须</strong></em>与终端在其发送的（对于服务端，则同时包括其接收到的）初始数据包的目标连接ID和源连接ID字段所使用的值保持一致。终端<em><strong>必须</strong></em>验证其接收到的传输参数匹配接收到的连接ID值。将连接ID值包含在传输参数中并认证，从而确保攻击者不能在握手期间通过插入携带有攻击者选择的连接ID的数据包影响连接ID的选择。</p>
<p>终端<em><strong>必须</strong></em>将任意终端缺失<code>initial_source_connection_id</code>传输参数以及服务端缺失<code>original_destination_connection_id</code>传输参数视为<code>TRANSPORT_PARAMETER_ERROR</code>类型的连接错误。</p>
<p>终端<em><strong>必须</strong></em>将下述情况视为<code>TRANSPORT_PARAMETER_ERROR</code>或<code>PROTOCOL_VIOLATION</code>类型的连接错误：</p>
<ul>
<li>服务端在接收到一个重试数据包后，缺失<code>retry_source_connection_id</code>传输参数，</li>
<li>未接收到重试数据包，但是却存在<code>retry_source_connection_id</code>传输参数，或</li>
<li>从对端接收到的传输参数中的值与发送的初始数据包中相应目标连接ID或源连接ID字段不一致。</li>
</ul>
<p>如果选择了一个零长度连接ID，则相应的传输参数包含一个零长度值。</p>
<p><a href="#Figure_7_Use_of_Connection_IDs_in_a_Handshake">图7</a>展示了一个完整握手过程中连接ID的使用（其中DCID表示目标连接ID，SCID表示源连接ID）。图中展示了初始数据包如何交换，以及随后1-RTT数据包的交换，其中包括握手期间创建的连接ID。</p>
<div class="block ref" id="Figure_7_Use_of_Connection_IDs_in_a_Handshake">
<img src="/RFC9000_Chinese_Simplified/images/Figure_7_Use_of_Connection_IDs_in_a_Handshake.svg"/>
<p><a href="#Figure_7_Use_of_Connection_IDs_in_a_Handshake">图7：握手期间连接ID的使用</a></p>
</div>
<p><a href="#Figure_8_Use_of_Connection_IDs_in_a_Handshake_with_Retry">图8</a>展示了包含重试数据包的握手过程。</p>
<div class="block ref" id="Figure_8_Use_of_Connection_IDs_in_a_Handshake_with_Retry">
<img src="/RFC9000_Chinese_Simplified/images/Figure_8_Use_of_Connection_IDs_in_a_Handshake_with_Retry.svg"/>
<p><a href="#Figure_8_Use_of_Connection_IDs_in_a_Handshake_with_Retry">图8：使用重试数据包的握手中连接ID的使用</a></p>
</div>
<p>在上述两种情况（<a href="#Figure_7_Use_of_Connection_IDs_in_a_Handshake">图7</a>和<a href="#Figure_8_Use_of_Connection_IDs_in_a_Handshake_with_Retry">图8</a>）下，客户端设置其<code>initial_source_connection_id</code>传输参数值为<code>C1</code>。</p>
<p>当握手过程没有出现重试数据包（<a href="#Figure_7_Use_of_Connection_IDs_in_a_Handshake">图7</a>），服务端设置<code>original_destination_connection_id</code>为<code>S1</code>（注意该值是客户端选择的），设置<code>initial_source_connection_id</code>为<code>S3</code>。在这种情况下，服务端不包含<code>retry_source_connection_id</code>传输参数。</p>
<p>When the handshake includes a Retry (Figure 8), the server sets original_destination_connection_id to S1, retry_source_connection_id to S2, and initial_source_connection_id to S3.</p>
<p>当握手过程出现了重试数据包（<a href="#Figure_8_Use_of_Connection_IDs_in_a_Handshake_with_Retry">图8</a>），服务端设置<code>original_destination_connection_id</code>为<code>S1</code>，设置<code>retry_source_connection_id</code>为<code>S2</code>，设置<code>initial_source_connection_id</code>为<code>S3</code>。</p>
</div>
</section>
<section class="page" id="7.4_Transport_Parameters">
<h2>
<a href="#7.4_Transport_Parameters">7.4. 加密与传输握手</a>
</h2>
<div class="content">
<p>连接建立期间，双端对各自的传输参数作出验证声明。终端必须遵守每个参数定义的约束规范，每个参数的描述包括其处理规则。</p>
<p>传输参数由每个终端单方面声明。每个终端可以独立选择传输参数的值而不依赖于对端的选择。</p>
<p>传输参数的编码详见<a href="#18_Transport_Parameter_Encoding">第18章</a>.</p>
<p>QUIC在加密握手阶段包含编码的传输参数。一旦握手完成，由对端声明的传输参数就生效了。每个终端都需要验证对端提供的参数值。</p>
<p>每个传输参数的具体定义详见<a href="#18.2_Transport_Parameter_Definitions">第18.2章</a>。</p>
<p>终端<em><strong>必须</strong></em>将收到无效的传输参数值的情况视为一个<code>TRANSPORT_PARAMETER_ERROR</code>类型连接错误。</p>
<p>终端<em><strong>必须不</strong></em>能在一个特定的传输参数扩展中传输同一个参数超过1次。终端<em><strong>应该</strong></em>将收到重复的传输参数的情况视为一个<code>TRANSPORT_PARAMETER_ERROR</code>类型连接错误。</p>
<p>终端使用传输参数认证握手期间的连接ID协商，详见<a href="#7.3_Authenticating_Connection_IDs">第7.3章</a>。</p>
<p>ALPN（详见<a href="https://www.rfc-editor.org/info/rfc7301">ALPN</a>）允许客户端在连接建立期间提供多个应用协议。客户端包含的传输参数对客户端提供的所有应用协议生效。应用协议可以指定传输参数值，例如初始流控上限。然而，应用协议对传输参数值设置限制，可能导致因为限制冲突使得客户端不能提供多种应用协议支持。</p>
</div>
</section>
<section class="page" id="7.4.1_Values_of_Transport_Parameters_for_0_RTT">
<h3>
<a href="#7.4.1_Values_of_Transport_Parameters_for_0_RTT">7.4.1. 0-RTT传输参数</a>
</h3>
<div class="content">
<p>是否使用0-RTT取决于客户端和服务端使用的传输参数是否由同一个旧连接协商的。为了开启0-RTT，终端需要保存服务端传输参数的值及在连接上收到的任何会话票据（session ticket）。终端也需要保存其他任何应用协议或加密握手所需要的信息，详见《<a href="/RFC9001_Chinese_Simplified">QUIC-TLS</a>》的<a href="#4.6_Controlling_Concurrency">第4.6章</a>。保存的传输参数的值在使用会话票据尝试进行0-RTT建连时使用。</p>
<p>保存的传输参数适用于新连接，直到握手完成，客户端开始发送1-RTT数据包为止。一旦握手完成，客户端就启用握手过程中创建的传输参数。不是所有的传输参数都需要保存，因为部分参数不会在后续连接中生效，或是在0-RTT建连期间不起作用。</p>
<p>定义新的传输参数（详见<a href="#7.4.2_New_Transport_Parameters">第7.4.2章</a>）时，<em><strong>必须</strong></em>明确说明其作为0-RTT参数进行保存是否是强制性的、可选的，或必须禁止的。客户端不需要保存一个其不能处理的传输参数。</p>
<p>客户端<em><strong>必须不</strong></em>使用下述参数的保存值：<code>ack_delay_exponent</code>、<code>max_ack_delay</code>、<code>initial_source_connection_id</code>、<code>original_destination_connection_id</code>、<code>preferred_address</code>、<code>retry_source_connection_id</code>，以及<code>stateless_reset_token</code>。客户端<em><strong>必须</strong></em>使用握手期间服务端给出的新值。如果服务端没有提供新的值，就使用默认值。</p>
<p>试图发送0-RTT数据的客户端<em><strong>必须</strong></em>保存所有其他服务端需要使用且可以处理的传输参数。服务端可以保存这些传输参数，或在会话票据中保存这些参数值的一份具备完整性保护的备份，并在收到0-RTT数据后恢复其具体信息。</p>
<p>如果服务端收到了0-RTT数据，服务端<em><strong>必须不</strong></em>能放宽任何限制，或采用任何其他可能与客户端发来的0-RTT数据产生冲突的值。尤其需要注意的是，服务端在接收0-RTT数据后，<em><strong>必须不</strong></em>可为下述参数（详见<a href="#18.2_Transport_Parameter_Definitions">第18.2章</a>）设置一个低于保存值的值：</p>
<ul>
<li><code>active_connection_id_limit</code></li>
<li><code>initial_max_data</code></li>
<li><code>initial_max_stream_data_bidi_local</code></li>
<li><code>initial_max_stream_data_bidi_remote</code></li>
<li><code>initial_max_stream_data_uni</code></li>
<li><code>initial_max_streams_bidi</code></li>
<li><code>initial_max_streams_uni</code></li>
</ul>
<p>删除特定传输参数，或为之设置一个零值，可能导致启用0-RTT数据但却不可用。允许发送应用数据的传输参数的适当子集<em><strong>应该</strong></em>被设置为非零值，以支持0-RTT。这包括：<code>initial_max_data</code>和（1）<code>initial_max_streams_bidi</code>及<code>initial_max_stream_data_bidi_remote</code>，或（2）<code>initial_max_streams_uni</code>及<code>initial_max_stream_data_uni</code>。</p>
<p>服务端可能给流设置的初始流控上限大于保存的0-RTT数据包中由客户端设置的值。一旦握手完成，客户端必须根据更新后的<code>initial_max_stream_data_bidi_remote</code>及<code>initial_max_stream_data_uni</code>的值更新所有发送流的流控上限。</p>
<p>服务端<em><strong>可以</strong></em>保存并恢复先前发送的<code>max_idle_timeout</code>、<code>max_udp_payload_size</code>及<code>disable_active_migration</code>参数的值，以及在选择更小值后拒绝0-RTT。当接收0-RTT数据可能同时降低连接性能时，调低这些参数的值。特别是调低<code>max_udp_payload_size</code>可能导致丢包，导致性能与直接拒绝0-RTT数据相比变得更差。</p>
<p>当服务端不支持恢复后的值时，其<em><strong>必须</strong></em>拒绝0-RTT数据。</p>
<p>当在0-RTT数据包中发送帧时，客户端<em><strong>必须</strong></em>只使用保存的传输参数；更重要的是，它<em><strong>必须不</strong></em>能使用服务端更新后的传输参数，或使用从1-RTT数据包接收到的帧。在握手过程中传输参数更新的值只适用于1-RTT数据包。例如，保存的传输参数中的流控上限值适用于所有的0-RTT数据包，即使这些值通过握手或通过1-RTT数据包发送的帧调大了。服务端<em><strong>可以</strong></em>将在0-RTT数据中使用更新后的传输参数视为一个<code>PROTOCOL_VIOLATION</code>类型的连接错误。</p>
</div>
</section>
<section class="page" id="7.4.2_New_Transport_Parameters">
<h3>
<a href="#7.4.2_New_Transport_Parameters">7.4.2. 新传输参数</a>
</h3>
<div class="content">
<p>新传输参数可以用于协商新的协议行为。终端<em><strong>必须</strong></em>忽略其不支持的传输参数。缺失某个传输参数会因此禁用掉任何可选的、通过该参数协商的协议特性。正如<a href="#18.1_Reserved_Transport_Parameters">第18.1章</a>所述，保留某些标识符是为了满足这个需求。</p>
<p>对于一个传输参数，如果客户端不能识别，则客户端可以将其丢弃，并尝试在随后的连接中尝试0-RTT。然而，如果客户端对一个丢弃的传输参数添加了支持，那么其在尝试0-RTT时就有可能与传输参数设置的限制出现冲突。新传输参数可以通过设置一个最保守的默认值避免该问题。客户端可以通过保存所有参数避免该问题，即使其中一些参数目前尚不支持。</p>
<p>新传输参数根据<a href="#22.3_QUIC_Transport_Parameters_Registry">第22.3章</a>描述的规则进行注册。</p>
</div>
</section>
<section class="page" id="7.5_Cryptographic_Message_Buffering">
<h2>
<a href="#7.5_Cryptographic_Message_Buffering">7.5. 加密信息缓存</a>
</h2>
<div class="content">
<p>QUIC实现需要维护一个用于保存乱序接收到的加密数据的缓存区。由于<strong>加密帧</strong>没有流量控制，终端有可能强制对端缓存无限量的数据。</p>
<p>QUIC实现<em><strong>必须</strong></em>支持缓存至少4096字节从乱序<strong>加密帧</strong>收到的数据。终端<em><strong>可以</strong></em>选择允许在握手期间缓存更多的数据。更大的缓存上限意味着可以交换更大的密钥或证书。终端的缓存区大小不必在整个连接生命周期内保持不变。</p>
<p>握手期间无法缓存<strong>加密帧</strong>可能导致连接失败。如果终端的缓存区在握手期间溢出，则其可以通过暂时扩大缓存空间确保握手完成。如果终端不扩大其缓存，则其<em><strong>必须</strong></em>以错误码<code>CRYPTO_BUFFER_EXCEEDED</code>关闭连接。</p>
<p>Once the handshake completes, if an endpoint is unable to buffer all data in a CRYPTO frame, it MAY discard that CRYPTO frame and all CRYPTO frames received in the future, or it MAY close the connection with a CRYPTO_BUFFER_EXCEEDED error code. Packets containing discarded CRYPTO frames MUST be acknowledged because the packet has been received and processed by the transport even though the CRYPTO frame was discarded.</p>
<p>一旦握手完成，如果终端不能缓存<strong>加密帧</strong>中的全部数据，那么其<em><strong>可以</strong></em>丢弃该帧及其随后收到的所有<strong>加密帧</strong>，也<em><strong>可以</strong></em>以错误码<code>CRYPTO_BUFFER_EXCEEDED</code>关闭连接。<em><strong>必须</strong></em>确认包含被丢弃的<strong>加密帧</strong>的数据包，因为该数据包已经被接收且被传输层处理了，即使是以丢弃<strong>加密帧</strong>的方式处理的。</p>
</div>
</section>
<section class="page" id="8_Address_Validation">
<h1>
<a href="#8_Address_Validation">8. 地址验证</a>
</h1>
<div class="content">
<p>地址验证确保终端不会被用于流量放大攻击。在这种攻击中，一个填写了指向受害者的假源地址信息的数据包被发送给服务器。如果服务器在响应那个数据包时生成了更多或更大的数据包，攻击者就能使用这台服务器向受害者发送比攻击者自己能发送的还要多的数据。</p>
<p>针对放大攻击的主要防御手段是验证对端有能力在它声称的传输地址接收数据包。因此，在从一个未经验证的地址接收到数据包后，终端<em><strong>必须</strong></em>限制它向未经验证的地址发送的数据量为它从那个地址接收到的数据量的三倍。这个对于响应尺寸的上限被称为抗放大上限。</p>
<p>在连接建立期间（详见<a href="#8.1_Address_Validation_during_Connection_Establishment">第8.1章</a>）和连接迁移期间（详见<a href="#8.2_Path_Validation">第8.2章</a>）都会进行地址验证。</p>
</div>
</section>
<section class="page" id="8.1_Address_Validation_during_Connection_Establishment">
<h2>
<a href="#8.1_Address_Validation_during_Connection_Establishment">8.1 连接建立期间的地址验证</a>
</h2>
<div class="content">
<p>连接建立为两侧终端隐式提供了地址验证。具体来说，接收到一个受握手密钥保护的数据包证实了对端已成功处理了初始数据包。一旦终端成功处理了来自对端的握手数据包，它就能将对端地址认定为已验证。</p>
<p>除此之外，如果对端使用了一个由终端选择的连接ID并且连接ID包含至少64位的熵，那么终端<em><strong>可以</strong></em>将对端地址认定为已验证。</p>
<p>对客户端来说，它的首个初始数据包中目标连接ID字段的值允许它有机会验证服务器的地址，只要服务器能成功处理任一数据包。来自服务器的初始数据包会受到从那个目标连接ID字段的值衍生的密钥的保护（详见《<a href="../RFC9001_Chinese_Simplified">QUIC-TLS</a>》的<a href="../RFC9001_Chinese_Simplified/#5.2_Initial_Secrets">第5.2章</a>）。另一方面，这个值会被服务器在版本协商包（详见<a href="#6_Version_Negotiation">第6章</a>）中被回显，或在重试数据包的完整性标签中被使用（详见《<a href="../RFC9001_Chinese_Simplified">QUIC-TLS</a>》的<a href="../RFC9001_Chinese_Simplified/#5.8_Retry_Packet_Integrity">第5.8章</a>）。</p>
<p>在验证客户端地址前，服务器发送的字节数<em><strong>必须不</strong></em>超过已接收字节数三倍。这就限制了所有能用伪造源地址的方式实施的放大攻击的量级。出于在地址验证前避免放大攻击的目的，服务器<em><strong>必须</strong></em>统计在数据报中接收的载荷的字节数，每个数据报都是归属于唯一的某条连接的。这里的数据报既包括了含有被成功处理的数据包的数据报，也包括了含有被全部丢弃的数据包的数据报。</p>
<p>客户端<em><strong>必须</strong></em>确保包含初始数据包的UDP数据报含有至少1200字节的UDP载荷，不够就加<strong>填充帧</strong>。发送扩充过的数据报的客户端允许服务器在完成地址验证前发送更多数据。</p>
<p>如果来自服务器的初始数据包或握手数据包遭遇丢包，并且客户端没有发送额外的初始数据包或握手数据包，那么这会引发死锁。当客户端已经接收到了所有它发出的数据的确认但服务器抵达了抗放大上限，那么死锁就会发生。在这种情况下，当客户端没有理由发送额外的数据包时，服务器将无法发送更多数据因为它还没有验证过客户端的地址。为了避免这种死锁，客户端<em><strong>必须</strong></em>在一个探测包超时（PTO）的时候发送一个数据包；详见《<a href="../RFC9002_Chinese_Simplified">QUIC恢复</a>》的<a href="../RFC9002_Chinese_Simplified/#6.2_Probe_Timeout">第6.2章</a>。具体来说，如果客户端没有握手密钥，那么它<em><strong>必须</strong></em>用包含至少1200字节的UDP数据报发送一个初始数据包，否则发送的是握手数据包。</p>
<p>服务器可能想要在开始加密握手前验证客户端地址。QUIC使用一个包含在初始数据包的令牌以在完成握手前提供地址验证。这个令牌是在连接建立期间通过重试数据包（详见<a href="#8.1.2_Address_Validation_Using_Retry_Packets">第8.1.2章</a>），或在之前的连接中通过<strong>新令牌帧</strong>（详见<a href="#8.1.3_Address_Validation_for_Future_Connections">第8.1.3章</a>），分发给客户端的。</p>
<p>除了在地址验证通过前被施加发送限制之外，服务器还在能发送的内容上被拥塞控制器所设置的上限所限制。客户端则仅受拥塞控制器的限制。</p>
</div>
</section>
<section class="page" id="8.1.1_Token_Construction">
<h3>
<a href="#8.1.1_Token_Construction">8.1.1 令牌构建</a>
</h3>
<div class="content">
<p>构建在<strong>新令牌帧</strong>或重试数据包中发送的令牌时，<em><strong>必须</strong></em>使用一种能够令服务器识别出令牌提供给客户端的途径的方法。这些令牌被携带于相同字段中但是需要服务器进行不同的处理。</p>
</div>
</section>
<section class="page" id="8.1.2_Address_Validation_Using_Retry_Packets">
<h3>
<a href="#8.1.2_Address_Validation_Using_Retry_Packets">8.1.2 使用重试数据包进行地址验证</a>
</h3>
<div class="content">
<p>当接收到客户端的初始数据包时，服务器可以通过发送包含令牌的重试数据包（详见<a href="#17.2.5_Retry_Packet">第17.2.5章</a>）来请求地址验证。接收到重试数据包之后，客户端<em><strong>必须</strong></em>在为那条连接发送的所有初始数据包中重复这个令牌。</p>
<p>作为处理包含了曾在重试数据包中提供的令牌的初始数据包的回应，服务器不能再发送重试数据包；它只能拒绝那条连接或允许连接继续进行。</p>
<p>只要不存在攻击者为它自己的地址生成一个有效令牌（详见<a href="#8.1.4_Address_Validation_Token_Integrity">第8.1.4章</a>）的可能性，并且客户端有能力将那个令牌返回给服务器，就能证实客户端接收到了令牌。</p>
<p>服务器还能使用重试数据包来推迟连接建立所需的状态数据和处理的成本。要求服务器提供一个不同的连接ID，以及在<a href="#18.2_Transport_Parameter_Definitions">第18.2章</a>中定义的传输参数<code>original_destination_connection_id</code>（原始目标连接ID），能强制服务器表明它，或和它一起工作的实体，从客户端接收到了原始的初始数据包。提供一个不同的连接ID还确保服务器对后续数据包如何路由有一定的控制能力。这可以被用来将连接指向不同的服务器实例。</p>
<p>如果服务器接收到了一个除了无效的重试令牌字段外都合法的客户端初始数据包，那么它能肯定客户端不会接收另一个重试令牌。服务器可以丢弃这样的数据包，并且允许客户端以超时的形式检测到本次握手的失败，但这会对客户端施加强烈的延迟惩罚。取而代之的是，服务器<em><strong>应该</strong></em>使用错误<code>INVALID_TOKEN</code>（无效令牌）立即关闭（详见<a href="#10.2_Immediate_Close">第10.2章</a>）连接。注意，服务器在这个时候还没有为连接建立任何状态数据所以不会进入到关闭状态。</p>
<p><a href="#Figure_9_Example_Handshake_with_Retry">图9</a>展示的是关于重试数据包的使用的流程图。</p>
<div class="block ref" id="Figure_9_Example_Handshake_with_Retry">
<img src="/RFC9000_Chinese_Simplified/images/Figure_9_Example_Handshake_with_Retry.svg"/>
<p><a href="#Figure_9_Example_Handshake_with_Retry">图9：使用重试的握手样例</a></p>
</div>
</div>
</section>
<section class="page" id="8.1.3_Address_Validation_for_Future_Connections">
<h3>
<a href="#8.1.3_Address_Validation_for_Future_Connections">8.1.3 为将来的连接进行地址验证</a>
</h3>
<div class="content">
<p>在一条连接进行期间，服务器<em><strong>可以</strong></em>向客户端提供一个可以被用于后续连接的地址验证令牌。地址验证对于0-RTT特别重要，因为服务器响应0-RTT数据时可能向客户端发送大量的数据。</p>
<p>服务器使用<strong>新令牌帧</strong>（详见<a href="#19.7_NEW_TOKEN_Frames">第19.7章</a>）来向客户端提供一个可以被用于验证将来的连接的地址验证令牌。在将来的连接中，客户端将这个令牌包含在初始数据包中来提供地址验证。客户端<em><strong>必须</strong></em>将令牌包含在所有它发送的初始数据包中，除非有重试数据包将令牌替换为新的值。客户端<em><strong>必须不</strong></em>在将来的连接中使用重试数据包里提供的令牌。服务器<em><strong>可以</strong></em>丢弃任何没有携带期望的令牌的初始数据包。</p>
<p>不像为重试数据包创建的令牌要被立即使用掉，在<strong>新令牌帧</strong>中发送的令牌即使经过了一段时间也能使用。因此，令牌<em><strong>应该</strong></em>具有一个过期时间，它既可以是一个显式的过期时间，也可以是一个可以被用来动态计算过期时间的签发时间戳。服务器可以将过期时间存储起来或将它以加密的形式包含在令牌中。</p>
<p>使用<strong>新令牌帧</strong>签发的令牌<em><strong>必须不</strong></em>包含会令观察者将之关联到被签发令牌所在的连接上的信息。例如，它不能包含先前的连接ID或地址信息，除非这些值是经过加密的。除了因为先前发送的<strong>新令牌帧</strong>遭遇丢包而重新发送的那些帧外，服务器<em><strong>必须</strong></em>确保它发送的任何<strong>新令牌帧</strong>在所有客户端间都是唯一的。允许服务器区分令牌是来自重试数据包还是<strong>新令牌帧</strong>的信息还会被并非服务器的实体访问到。</p>
<p>客户端的端口号在两条不同的连接间保持相同是不太可能的；因此验证端口不太可能成功。</p>
<p>如果与某服务器间的连接具有权威性（例如，服务器的名称是被包含在证书中的），那么在<strong>新令牌帧</strong>中接收到的令牌应该适用于这台服务器。当客户端连接到一台服务器且它对此服务器仍保有对此服务器适用的且未使用的令牌时，它<em><strong>应该</strong></em>在初始数据包的令牌字段中使用令牌。使用令牌可以允许服务器不需要额外花费往返时间就验证客户端地址。客户端<em><strong>必须不</strong></em>在连接到服务器时使用不适用于此服务器的令牌，除非客户端知道签发令牌的服务器和它正在连接的服务器是共享令牌的管理机制的。客户端<em><strong>可以</strong></em>使用来自任何先前与那台服务器的连接的令牌。</p>
<p>令牌允许服务器将令牌签发时所在的连接和任何它被使用时所在的连接间的网络活动关联起来。想要打破在某个服务器上的身份连续性的客户端可以丢弃使用<strong>新连接帧</strong>提供的令牌。相反，在重试数据包中获取的令牌<em><strong>必须</strong></em>在连接尝试期间被立即使用且不能被用于后续的连接尝试。</p>
<p>客户端<em><strong>不应该</strong></em>在不同的连接尝试间重用来自<strong>新令牌帧</strong>的令牌。重用令牌使得连接会被网络路径上的实体关联起来；详见<a href="#9.5_Privacy_Implications_of_Connection_Migration">第9.5章</a>。</p>
<p>客户端可能在单条连接上接收到数个令牌。只要记得防止可关联性，任何令牌可以被用于任何连接尝试。服务器可以发送额外的令牌既可以为多次连接尝试提供地址验证，又可以取代可能会变为无效的旧令牌。对于客户端来说，这种不明确的目的意味着发送最近的未使用的令牌是最有可能有效的。尽管保存并使用更旧的令牌没有负面影响，但是客户端可以将更旧的令牌视为更不太可能会对此服务器的地址验证有效。</p>
<p>当服务器接收到具有地址验证令牌的初始数据包时，它<em><strong>必须</strong></em>尝试验证令牌，除非它已经完成了地址验证。如果令牌是无效的，那么服务器<em><strong>应该</strong></em>表现得就好像客户端的地址未经验证一样，这包括在必要时发送重试数据包。使用<strong>新令牌帧</strong>和重试数据包提供的令牌能够被服务器区分（详见<a href="#8.1.1_Token_Construction">第8.1.1章</a>），并且后者会被更严格地验证。如果验证通过，服务器随后<em><strong>应该</strong></em>允许握手继续进行。</p>
<blockquote>
<p>注意：将客户端地址视为未经验证的而不是丢弃数据包的原因是，客户端可能是在之前的连接中从<strong>新令牌帧</strong>中获得令牌的，并且如果服务器丢失过状态，它就可能无法验证令牌，此时若丢弃数据包则会导致连接失败。</p>
</blockquote>
<p>在无状态的设计中，服务器可以使用经过加密和认证的令牌来将信息传递给客户端，随后从中恢复信息并用它来验证客户端的地址。令牌没有被整合进加密握手，所以它们是未经认证的。这意味着，客户端将可以重用令牌。为了避免利用这一属性的攻击，服务器可以将令牌中的信息限制为仅仅验证客户端地址时所需要的那些信息。</p>
<p>客户端<em><strong>可以</strong></em>将从一条连接中获取的令牌用于任何使用相同版本的连接尝试。当选择使用的令牌时，客户端不需要考虑正在尝试的连接的其他属性，包括应用协议、会话票证或其他连接属性的可能的选择。</p>
</div>
</section>
<section class="page" id="8.1.4_Address_Validation_Token_Integrity">
<h3>
<a href="#8.1.4_Address_Validation_Token_Integrity">8.1.4 地址验证令牌完整性</a>
</h3>
<div class="content">
<p>地址验证令牌<em><strong>必须</strong></em>是难以猜测的。在令牌中包含一个有着至少128位的熵的随机值会是足够的，但是这需要服务器记录它发送给客户端的值。</p>
<p>基于令牌的方案允许服务器将关于验证的状态数据带来的负载转移到客户端上。要使这种设计正常工作，令牌<em><strong>必须</strong></em>被能够抵御客户端修改或伪造的完整性保护所覆盖。要是没有完整性保护，恶意的客户端就能生成或猜测会被服务器接收的令牌值。只有服务器需要访问令牌的完整性保护密钥。</p>
<p>对令牌制定单一的定义良好的格式是没有必要的，因为服务器即使生成者又是消费者。在重试数据包中发送的令牌<em><strong>应该</strong></em>包含允许服务器验证客户端数据包中的源IP地址和端口是否保持不变的信息。</p>
<p>在<strong>新令牌帧</strong>中发送的令牌<em><strong>必须</strong></em>包含允许服务器验证客户端的IP地址是否和令牌签发时的值一致的信息。服务器可以使用来自<strong>新令牌帧</strong>的令牌来做出不发送重试数据包的决定，即使客户端地址已经改变。如果客户端的IP地址已经改变，那么服务器<em><strong>必须</strong></em>遵守抗放大上限；详见<a href="#8_Address_Validation">第8章</a>。注意，由于NAT的存在，这项要求可能不足以保护其他共享NAT的主机免于放大攻击。</p>
<p>攻击者可能在DDoS攻击中重放令牌来将服务器用作放大器。为了抵御这种攻击，服务器<em><strong>必须</strong></em>确保令牌的重放是被阻止或限制的。服务器<em><strong>应该</strong></em>确保在重试数据包中发送的令牌仅会在一段较短时间内被接受，因为它们会被客户端立即返回。在<strong>新令牌帧</strong>（详见<a href="#19.7_NEW_TOKEN_Frames">第19.7章</a>）中提供的令牌应该有更长的有效时间但是<em><strong>不应该</strong></em>能被多次接受。建议服务器尽可能只允许令牌被使用一次；令牌<em><strong>可以</strong></em>包含关于客户端的额外信息来进一步缩减适用范围或重用机会。</p>
</div>
</section>
<section class="page" id="8.2_Path_Validation">
<h2>
<a href="#8.2_Path_Validation">8.2 路径验证</a>
</h2>
<div class="content">
<p>两侧终端在连接迁移期间（详见<a href="#9_Connection_Migration">第9章</a>）都会使用路径验证以在地址发生变化后验证可达性。在路径验证中，终端会测试特定的本地地址和特定的对端地址间的可达性，这里的地址指的是IP地址和端口的二元组。</p>
<p>路径验证测试的是在一条路径上发送给对端的数据包有没有被对端接收到。使用地址验证是为了确保从正在迁移的对端接收到的数据包携带着的源地址不是伪造的。</p>
<p>地址验证并不验证对端能够在返回的方向上发送数据。确认不能被用于返回路径的验证，因为它们携带的熵不够并且可能是伪造的。不同终端独立判断一条路径在各自方向上的可达性，因此返回方向的可达性只能由对端建立。</p>
<p>任一终端都可以在任意时间使用路径验证。例如，某个终端可能想在对端沉默了一段时间后检查对端是否还位于原来的地址上。</p>
<p>路径验证不是被作为NAT遍历机制设计出来的。尽管这里描述的机制可能对创建支持NAT遍历的NAT绑定也是有效的，但我们期望的是某个终端在还没有在一条路径上发送过数据包时就能够接收到数据包。有效的NAT遍历需要额外的同步机制，但这里没有提供。</p>
<p>终端<em><strong>可以</strong></em>在地址验证时将<strong>通道挑战帧</strong>和<strong>回复通道帧</strong>与其他类型的帧一起使用。特别是，终端可以在路径最大传输单元发现（PMTUD）中一起使用<strong>填充帧</strong>和<strong>通道挑战帧</strong>；详见<a href="#14.2.1_Handling_of_ICMP_Messages_by_PMTUD">第14.2.1章</a>。终端还可以在发送<strong>回复通道帧</strong>时带上自己的<strong>通道挑战帧</strong>。</p>
<p>终端在从新的本地地址发送探测包时使用新的连接ID；详见<a href="#9.5_Privacy_Implications_of_Connection_Migration">第9.5章</a>。当探测新路径时，终端得确保对端有一个可以用来响应的未使用的连接ID。只要对端的<code>active_connection_id_limit</code>（活跃连接ID上限）允许，在同一个数据包中同时发送<strong>新连接ID帧</strong>和<strong>通道挑战帧</strong>可以确保对端在发送响应时有一个未使用的连接ID。</p>
<p>终端可以选择同时探测数条路径。同时探测的路径数量受到对端目前已提供的额外连接ID数量的限制，因为每次为探测包使用新的本地地址时都需要一个未曾使用的连接ID。</p>
</div>
</section>
<section class="page" id="8.2.1_Initiating_Path_Validation">
<h3>
<a href="#8.2.1_Initiating_Path_Validation">8.2.1 发起地址验证</a>
</h3>
<div class="content">
<p>要发起路径验证，终端在要被验证的路径上发送一个包含不可预测的载荷的<strong>通道挑战帧</strong>。</p>
<p>终端<em><strong>可以</strong></em>发送多个<strong>通道挑战帧</strong>以抵御数据包丢包。然而，终端<em><strong>不应该</strong></em>使用同一个数据包发送这些<strong>通道挑战帧</strong>。</p>
<p>在用包含<strong>通道挑战帧</strong>的数据包探测新路径时，终端<em><strong>不应该</strong></em>发送得比初始数据包还要频繁。这确保连接迁移不会比建立新连接施加更多负载给新路径。</p>
<p>终端<em><strong>必须</strong></em>在每个<strong>通道挑战帧</strong>中使用不可预测的数据以使得它能将对端的响应与对应的<strong>通道挑战帧</strong>关联起来。</p>
<p>终端<em><strong>必须</strong></em>将包含<strong>通道挑战帧</strong>的数据报扩充至至少1200字节，这个在允许的最大数据报尺寸中的最小值，除非那条路径的抗放大上限不允许发送那么大的数据报。发送这个尺寸的UDP数据报确保终端与对端间的网络路径能够承载QUIC数据包；详见<a href="#14_Datagram_Size">第14章</a>。</p>
<p>当终端因为抗放大上限而不能将数据报扩充至1200字节时，路径的MTU将不会被验证。为了确保路径的MTU足够大，终端必须通过在至少1200字节的数据报中发送<strong>通道挑战帧</strong>的方式进行第二次路径验证。这次额外的验证可以在<strong>回复通道帧</strong>被成功接收到之后再进行，也可以等到在路径上收到了足够数量的字节而使得发送一个大一点的数据包也不会超过抗放大上限的时候再进行。</p>
<p>不像其他需要扩充数据报的情况，如果数据报包含了<strong>通道挑战帧</strong>或<strong>回复通道帧</strong>，那么终端<em><strong>必须不</strong></em>丢弃看起来过小的数据报。</p>
</div>
</section>
<section class="page" id="8.2.2_Path_Validation_Responses">
<h3>
<a href="#8.2.2_Path_Validation_Responses">8.2.2 路径验证的响应</a>
</h3>
<div class="content">
<p>当接收到<strong>通道挑战帧</strong>时，终端<em><strong>必须</strong></em>响应<strong>回复通道帧</strong>，并在其中回显<strong>通道挑战帧</strong>里的数据。除非被拥塞控制限制，终端<em><strong>必须不</strong></em>推迟传输包含<strong>回复通道帧</strong>的数据包。</p>
<p><strong>回复通道帧</strong><em><strong>必须</strong></em>在接收到<strong>通道挑战帧</strong>的网络路径上发送。这确保对端的路径验证仅当路径在两个方向上同时可用时才通过。这项要求<em><strong>必须不</strong></em>被发起路径验证的终端强制执行，因为这会使得针对迁移的攻击变为可能；详见<a href="#9.3.3_Off-Path_Packet_Forwarding">第9.3.3章</a>。</p>
<p>终端<em><strong>必须</strong></em>将包含<strong>回复通道帧</strong>的数据报扩充至至少1200字节，这个在允许的最大数据报尺寸中的最小值。这样就能验证这条路径在两个方向上都能够承载这个尺寸的数据报。然而如果产生的数据超过了抗放大上限，那么终端<em><strong>必须不</strong></em>扩充包含<strong>回复通道帧</strong>的数据报。这种情况应只会发生在接收到的<strong>通道挑战帧</strong>没有用扩充过的数据报发送时。</p>
<p>终端<em><strong>必须不</strong></em>在响应单个<strong>通道挑战帧</strong>时发送超过一个<strong>回复通道帧</strong>；详见<a href="#13.3_Retransmission_of_Information">第13.3章</a>。对端应当根据需要发送更多<strong>通道挑战帧</strong>来唤起额外的<strong>回复通道帧</strong>。</p>
</div>
</section>
<section class="page" id="8.2.3_Successful_Path_Validation">
<h3>
<a href="#8.2.3_Successful_Path_Validation">8.2.3 地址验证通过</a>
</h3>
<div class="content">
<p>当接收到的<strong>回复通道帧</strong>包含着曾在<strong>通道挑战帧</strong>中发送的数据时，地址验证通过。在任何网络路径上接收到的<strong>回复通道帧</strong>所验证的路径都是发送<strong>通道挑战帧</strong>时使用的那条。</p>
<p>如果终端在一个未扩充至至少1200字节的数据报中发送<strong>通道挑战帧</strong>，并且它的响应验证了对端地址，那么该路径就是验证通过的，但这不包括路径的MTU。于是，终端现在可以发送超过已接收数据量三倍的数据。然而，终端<em><strong>必须</strong></em>使用经扩充的数据包发起另一次路径验证，来验证这条路径支持所需的MTU。</p>
<p>接收到对包含<strong>通道挑战帧</strong>的数据包的确认这一事实并不能作为合适的验证方法，因为确认可以是被恶意对端伪造出来的。</p>
</div>
</section>
<section class="page" id="8.2.4_Failed_Path_Validation">
<h3>
<a href="#8.2.4_Failed_Path_Validation">8.2.4 地址验证失败</a>
</h3>
<div class="content">
<p>仅当发起地址验证的终端放弃了验证地址的尝试时，地址验证失败。</p>
<p>终端<em><strong>应该</strong></em>基于倒计时放弃地址验证。在设置倒计时时，QUIC实现要注意新路径可能有着比原来的路径更长的往返时间。<em><strong>推荐</strong></em>使用的值是当前PTO和新路径PTO（使用《<a href="../RFC9002_Chinese_Simplified">QUIC恢复</a>》中定义的<code>kInitialRtt</code>）中的较大值的三倍。</p>
<p>这个倒计时使得在地址验证失败前可以经过数个PTO，于是一两个<strong>通道挑战帧</strong>或<strong>回复通道帧</strong>的丢包不会引起整个路径验证的失败。</p>
<p>注意，终端可能在新路径上接收到包含其他类型的帧的数据包，但是要使得路径验证通过，具有正确数据的<strong>回复通道帧</strong>是必需的。</p>
<p>当终端放弃地址验证时，它将这条路径认定为不可用。这不一定会暗示连接的失败——终端可以通过其他合适的路径继续发送数据包。如果没有路径可用，终端可以等待出现一条新的可用路径或关闭连接。没有通往对端的有效网络路径的终端<em><strong>可以</strong></em>用连接错误<code>NO_VIABLE_PATH</code>（无可行通道）来发送信号，不过这只有在有网络路径存在但是不支持所需的MTU（详见<a href="#14_Datagram_Size">第14章</a>）的情况下才可行。</p>
<p>地址验证可能因为除了失败外的其他原因而被放弃。这主要会发生在对旧路径进行验证期间发起了前往新路径的连接迁移时。</p>
</div>
</section>
<section class="page" id="9_Connection_Migration">
<h1>
<a href="#9_Connection_Migration">9. 连接迁移</a>
</h1>
<div class="content">
<p>连接ID的使用使得连接能经受住终端地址（IP地址和端口）的变化，例如由终端迁移至新的网络环境而引起的变化。本章描述了终端迁移至新地址的过程。</p>
<p>QUIC的设计要求终端在握手过程中保持稳定的地址。在握手确认前，终端<em><strong>必须不</strong></em>发起连接迁移，详见《<a href="../RFC9001_Chinese_Simplified">QUIC-TLS</a>》的<a href="../RFC9001_Chinese_Simplified/#4.1.2_Handshake_Confirmed">第4.1.2章</a>。</p>
<p>如果对端发送了传输参数<code>disable_active_migration</code>（禁止活跃迁移），终端在握手过程中还<em><strong>必须不</strong></em>从不同于当前地址的本地地址发送数据包（包括探测数据包，详见<a href="#9.1_Probing_a_New_Path">第9.1章</a>），除非终端已经对来自对端的传输参数<code>preferred_address</code>（首选地址）作出反应。如果对端违反了这项要求，终端<em><strong>必须</strong></em>要么丢弃来自那条路径的传入数据包而不创建无状态重置，要么用路径验证来应对并且允许对端迁移。创建无状态重置或关闭连接将允许网络中的第三方用伪造或操作被观察的流量的方式使得连接被关闭。</p>
<p>不是所有的对端地址变化都是有意的，或活跃的，迁移。对端可能经历NAT重绑定：一种因中间设备，通常是NAT，为数据流分配新的传出端口或甚至新的出口IP地址而引起的地址变化。如果终端检测到任何与对端地址相关的变化，那么它<em><strong>必须</strong></em>进行地址验证（详见<a href="#8.2_Path_Validation">第8.2章</a>），除非它先前已经验证过那个地址。</p>
<p>当终端没有经过验证的路径来发送数据包时，它<em><strong>可以</strong></em>丢弃连接的状态数据。在丢弃连接的状态数据前，有能力进行连接迁移的终端<em><strong>可以</strong></em>等待新的可用地址。</p>
<p>本文档限制连接迁移为仅客户端可以发起，除非是在<a href="#9.6_Server's_Preferred_Address">第9.6章</a>中描述的情况。客户端负责发起所有迁移。服务器在它们从某客户端地址接收到非探测数据包（详见<a href="#9.1_Probing_a_New_Path">第9.1章</a>）前，不会向那个地址发送非探测数据包。如果客户端从一个未知的服务器地址接收到了数据包，那么客户端<em><strong>必须</strong></em>丢弃这些数据包。</p>
</div>
</section>
<section class="page" id="9.1_Probing_a_New_Path">
<h2>
<a href="#9.1_Probing_a_New_Path">9.1 探测新路径</a>
</h2>
<div class="content">
<p>在将连接迁移到新的本地地址前，终端<em><strong>可以</strong></em>使用地址验证（详见<a href="#8.2_Path_Validation">第8.2章</a>）从新的本地地址探测对端的可达性。地址验证的失败仅仅意味着新路径对此条连接来说无法使用。地址验证的失败不会引起连接被关闭，除非不存在其他可替代的有效路径。</p>
<p><strong>通道挑战帧</strong>、<strong>回复通道帧</strong>、<strong>新连接ID帧</strong>和<strong>填充帧</strong>都属于“探测帧”，而其他类型的帧都是“非探测帧”。仅仅包含探测帧的数据包是“探测数据包”，而包含了其他类型的帧的数据包就是“非探测数据包”。</p>
</div>
</section>
<section class="page" id="9.2_Initiating_Connection_Migration">
<h2>
<a href="#9.2_Initiating_Connection_Migration">9.2 发起连接迁移</a>
</h2>
<div class="content">
<p>终端可以通过从新的本地地址发送包含非探测帧的数据包的方式来迁移连接。</p>
<p>每个终端都会在连接建立期间验证对端的地址。因此，正在迁移的终端可以在知道对端在其当前地址上愿意接收数据的前提下向对端发送数据。于是，终端不需要先验证对端的地址就可以迁移至新的本地地址。</p>
<p>为了在新的路径上建立可达性，终端在新路径上发起路径验证（详见<a href="#8.2_Path_Validation">第8.2章</a>）。终端<em><strong>可以</strong></em>推迟路径验证，直到对端向它的新地址发送下一个非探测帧之时。</p>
<p>在迁移时，新路径可能不支持终端当前的发送速率。因此，终端如<a href="#9.4_Loss_Detection_and_Congestion_Control">第9.4章</a>所描述的那样重置它的拥塞控制器和RTT预估。</p>
<p>新的路径可能不具有相同的ECN功能。因此，终端如<a href="#13.4_Explicit_Congestion_Notification">第13.4章</a>所描述的那样验证ECN功能。</p>
</div>
</section>
<section class="page" id="9.3_Responding_to_Connection_Migration">
<h2>
<a href="#9.3_Responding_to_Connection_Migration">9.3 响应连接迁移</a>
</h2>
<div class="content">
<p>从新的对端地址接收到一个包含非探测帧的数据包表明对端已经迁移到那个地址。</p>
<p>如果接收方承认这次迁移，那它<em><strong>必须</strong></em>改向新的对端地址发送后续数据包，并且，如果还没有发起，则<em><strong>必须</strong></em>发起路径验证（详见<a href="#8.2_Path_Validation">第8.2章</a>）来验证对端对那个地址的所有权。如果接收方没有来自对端的尚未使用的连接ID，那么在对端提供一个之前它将无法在新路径上发送任何数据，详见<a href="#9.5_Privacy_Implications_of_Connection_Migration">第9.5章</a>。</p>
<p>终端仅在响应具有最大数据包号的非探测数据包时改变他将数据包发向的地址。这确保终端不会在接收到乱序数据包时将数据包发向旧的对端地址。</p>
<p>终端<em><strong>可以</strong></em>向未经验证的对端地址发送数据，但它<em><strong>必须</strong></em>抵御如<a href="#9.3.1_Peer_Address_Spoofing">第9.3.1章</a>和<a href="#9.3.2_On-Path_Address_Spoofing">第9.3.2章</a>所述的潜在攻击。如果对端地址最近被见到过，那么终端<em><strong>可以</strong></em>跳过验证。特别是，如果终端在检测到某些形式的虚假迁移后返回先前验证过的路径，那么跳过地址验证并恢复丢包检测和拥塞控制状态可以减少由攻击带来的性能影响。</p>
<p>终端在改变它将非探测数据包发向的地址后，它可以放弃为其他地址进行的路径验证。</p>
<p>接收到一个来自新对端地址的数据包可能是对端遭遇NAT重绑定的结果。</p>
<p>在验证新的客户端地址后，服务器<em><strong>应该</strong></em>向客户端发送新的地址验证令牌（详见<a href="#8_Address_Validation">第8章</a>）。</p>
</div>
</section>
<section class="page" id="9.3.1_Peer_Address_Spoofing">
<h3>
<a href="#9.3.1_Peer_Address_Spoofing">9.3.1 来自对端的地址伪造</a>
</h3>
<div class="content">
<p>对端有可能伪造它的源地址来使得终端向不愿意接收的主机发送过量数据。如果终端发送的数据量比正在伪造的对端发送的要多得多，那么连接迁移可能被用来放大攻击者能够向受害者发送的数据量。</p>
<p>如<a href="#9.3_Responding_to_Connection_Migration">第9.3章</a>中所述，终端应该验证对端的新地址以确认对端在新地址上拥有处理能力。在对端的地址被认定为有效前，终端限制它向那个地址发送的数据量，详见<a href="#8_Address_Validation">第8章</a>。如果没有这个限制，终端就要承担被用于针对毫无戒备的受害者的拒绝服务攻击的风险。</p>
<p>如果终端如上文一般跳过了对端地址验证，那么它就不需要限制它的发送速率。</p>
</div>
</section>
<section class="page" id="9.3.2_On-Path_Address_Spoofing">
<h3>
<a href="#9.3.2_On-Path_Address_Spoofing">9.3.2 来自路径上设备的地址伪造</a>
</h3>
<div class="content">
<p>在路径上的攻击者可以通过拷贝并转发具有伪造地址的数据包并使它比原始数据包更早到达的方式引发虚假的连接迁移。具有伪造地址的数据包将被视为来自连接迁移，而原始数据包将被视为重复并被丢弃。在一次虚假迁移之后，对源地址的验证将会失败，因为在源地址上的实体没有读取或响应发给它的<strong>通道挑战帧</strong>所需的加密密钥，哪怕它真的想这么做。</p>
<p>为了保护连接免于因为这样的虚假迁移而失败，当对于新对端地址的验证失败后，终端<em><strong>必须</strong></em>回退并使用最后一个经验证的对端地址。除此之外，从合法对端地址接收到具有最大数据包号的数据包，将触发另一次连接迁移。这将使得对虚假迁移的地址的验证被放弃，其中正包括由注入单个数据包的攻击者发起的迁移。</p>
<p>如果终端没有关于最后一个经验证的对端地址的状态，它<em><strong>必须</strong></em>以丢弃所有此连接的状态数据的方式静默地关闭连接。这会造成这条连接上的新数据包被以常规方式处理。例如，终端<em><strong>可以</strong></em>在响应将来的传入数据包时发送无状态重置。</p>
</div>
</section>
<section class="page" id="9.3.3_Off-Path_Packet_Forwarding">
<h3>
<a href="#9.3.3_Off-Path_Packet_Forwarding">9.3.3 来自非路径上设备的数据包转发</a>
</h3>
<div class="content">
<p>不在路径上的但能观察数据包的攻击者可以将真实数据包的副本转发到终端上。如果数据包副本比真实数据包更早到达，这就会表现得像是NAT重绑定一样。任何真实数据包都会因为重复而被丢弃。如果攻击者有能力继续转发数据包，它就有可能使得迁移的路径经过攻击者。这会使得攻击者位于路径上，给予它观察或丢弃任何后续数据包的能力。</p>
<p>这种形式的攻击要求攻击者使用一条有着和终端间的直连路径近乎相似的特征的路径。如果发送的数据包相对较少，或数据包丢包与计划的攻击同时发生，那么这种攻击的成功率就更加可靠。</p>
<p>在原始路径上接收到的会增加最大的已接收到的数据包号的非探测数据包将使得终端移动回那条路径。在这条路径上引发数据包增加了攻击失败的可能性。因此，这种攻击的抵御依赖于触发数据包交换。</p>
<p>在响应一个看起来很像的迁移时，终端<em><strong>必须</strong></em>使用<strong>通道挑战帧</strong>验证先前的活跃路径。这能在那条路径上引入新数据包的发送。如果那条路径不再可用，那么验证路径的尝试会超时并失败；如果路径时可用的但是不再被需要，验证就会成功但是仅仅使得那条路径上被多发送了几个探测数据包。</p>
<p>在活跃路径上接收到<strong>通道挑战帧</strong>的终端<em><strong>应该</strong></em>在发送非探测数据包作为响应。如果这个非探测数据包比任何攻击者创建的副本到达得都要早，这就能使得连接被迁移回原始路径。任何后续去往另一条路径的迁移都会重启上述整个过程。</p>
<p>这种防御是不完美的，但是它不被认为是一个严肃的问题。如果在尝试过数次原始路径的情况下，通过攻击者的路径还总是比原始路径更快，那么这很难说究竟是一次攻击，还是对路由的优化。</p>
<p>终端还可以使用启发式的方法来提升对这种形式的攻击的检测。例如，如果最近在旧路径上接收到过数据包，那么NAT重绑定是不太可能发生的；类似地，重绑定在IPv6路径上是很少见的。终端也可以寻找有没有重复的数据包。或者换个思路，连接ID上的改变更有可能表明这是一次有意的迁移，而不是一次攻击。</p>
</div>
</section>
<section class="page" id="9.4_Loss_Detection_and_Congestion_Control">
<h2>
<a href="#9.4_Loss_Detection_and_Congestion_Control">9.4 丢包检测和拥塞控制</a>
</h2>
<div class="content">
<p>新路径上的可用功能可能和旧路径上的不一样。在旧路径上发送的数据包<em><strong>必须不</strong></em>被计入新路径的拥塞控制或RTT预估中。</p>
<p>当承认对端对它新地址的所有权时，终端<em><strong>必须</strong></em>立即将新路径的拥塞控制器和往返时间预估器重置为初始值（详见《<a href="../RFC9002_Chinese_Simplified">QUIC恢复</a>》的<a href="../RFC9002_Chinese_Simplified/#A.3_Variables_of_Interest">附录A.3</a>和<a href="../RFC9002_Chinese_Simplified/#B.3_Initialization">附录B.3</a>），除非对端地址的改变仅仅是换了个端口。因为仅改变端口通常是NAT重绑定或其他中间设备活动的结果，终端在这种情况下<em><strong>可以</strong></em>沿用拥塞控制状态和往返时间预估，而不是将它们重置为初始值。在来自旧路径的拥塞控制状态被沿用至具有完全不同特征的新路径上时，发送方一开始可能传输得过于激进，直到拥塞控制器和RTT预估器适应下来为止。一般来说，建议QUIC实现在沿用旧值至新路径时要谨慎。</p>
<p>在迁移期间，当终端发送数据和探测包自/至不同地址时，接收方一侧可能出现很明显的乱序，这是因为使用两条不同路径会有不同的往返时间。来自不同路径上的数据包的接收方仍然要为所有接收到的数据包发送<strong>ACK帧</strong>。</p>
<p>尽管在连接迁移期间会用到多条路径，但是最少只要使用单个拥塞控制上下文和单个丢包恢复上下文（如《<a href="../RFC9002_Chinese_Simplified">QUIC恢复</a>》中所述）就足够应对了。比如，终端可以推迟切换至新的拥塞控制上下文，直到它确认不再需要旧路径（就像<a href="#9.3.3_Off-Path_Packet_Forwarding">第9.3.3章</a>中描述的情形一样）。</p>
<p>发送方可以将探测数据包视作特例，以使得它们的丢包检测是独立的且不会使得拥塞控制器过度地抑制它的发送速率。当发送<strong>通道挑战帧</strong>时，终端可以设置一个单独的倒计时，并当相应的<strong>回复通道帧</strong>被接收到时取消倒计时。如果倒计时在<strong>回复通道帧</strong>前归零，终端可以发送一个新的<strong>通道挑战帧</strong>并且启动一个时间更长的倒计时。这个倒计时<em><strong>应该</strong></em>如《<a href="../RFC9002_Chinese_Simplified">QUIC恢复</a>》的<a href="../RFC9002_Chinese_Simplified/#6.2.1_Computing_PTO">第6.2.1章</a>描述的那样被设置，并且<em><strong>必须不</strong></em>变得越来越严格。</p>
</div>
</section>
<section class="page" id="9.5_Privacy_Implications_of_Connection_Migration">
<h2>
<a href="#9.5_Privacy_Implications_of_Connection_Migration">9.5 连接迁移对隐私的影响</a>
</h2>
<div class="content">
<p>在不同网络路径上使用相同的连接ID将允许被动观察者从那些路径上将网络活动互相关联起来。在不同网络间移动的终端可能不希望它们的网络活动被不是对端的任何实体给关联起来，所以当从不同的本地地址发送时，会使用不同的连接ID，如<a href="#5.1_Connection_ID">第5.1章</a>所讨论的那样。为了使这个方法有效，终端应该确保它们提供的那些连接ID不会被任何其他实体找出相关性。</p>
<p>终端随时<em><strong>可以</strong></em>改变传输时所用的目标连接ID为一个从未在别的路径上使用过的值。</p>
<p>当发送自不止一个本地地址时——例如在如<a href="#9.2_Initiating_Connection_Migration">第9.2章</a>所描述的发起连接迁移时或在如<a href="#9.1_Probing_a_New_Path">第9.1章</a>所描述的探测新网络路径时——终端<em><strong>必须不</strong></em>重用连接ID。</p>
<p>类似地，当发送至不止一个目标地址时，终端<em><strong>必须不</strong></em>重用连接ID。由于不受对端控制的网络条件变化，终端可能从一个新的源地址接收到具有相同目标连接ID字段值的数据包，这时它<em><strong>可以</strong></em>在使用新的远程地址时继续使用当前连接ID，但是仍然从相同的本地地址发送。</p>
<p>以上有关重用连接ID的要求仅适用于数据包发送，因为数据包发送时的连接ID不变但是数据包传输的路径发生意想不到的变化的情况是有可能的。例如，在网络经过一段时间的沉默后，客户端恢复发送时，NAT重绑定可能使得数据包在一条新路径上被发送。终端如<a href="#9.3_Responding_to_Connection_Migration">第9.3章</a>所描述的那样响应这类事件。</p>
<p>为每条新网络路径上双向发送的数据包使用不同的连接ID消除了连接ID对于从不同网络路径中的相同连接间将数据包互相关联的作用。而头部保护确保了数据包号不能被用来关联网络活动。但这无法阻止数据包的其他属性，例如计时和尺寸，被用于关联网络活动。</p>
<p>终端<em><strong>不应该</strong></em>在对端申请了零长度连接ID时发起迁移，因为经过新路径的流量与经过旧路径的会很容易地被关联起来。如果服务器有能力将具有零长度连接ID的数据包与正确的那条连接关联起来，那么这就意味着服务器正使用其他信息来解除数据包的多路复用。举个例子，服务器可以给每个客户端提供唯一的地址——比如通过使用HTTP替代服务（详见《<a href="https://www.rfc-editor.org/info/rfc7838">ALTSVC</a>》）。这类能允许不同网络路径上的数据包被正确路由的信息同样能允许非对端的实体关联这些路径上的网络活动。</p>
<p>在沉默一段时间后，客户端在发送流量时可能希望通过切换至新连接ID、源UDP端口或IP地址（详见《<a href="https://www.rfc-editor.org/info/rfc8981">RFC8981</a>》）的方法减少网络活动的可关联性。改变用来发送数据包的地址同时会使得服务器检测到连接迁移。这确保了用于支持迁移的机制即使是对没有经历NAT重绑定或实际迁移的客户端来说也是用得上的。改变地址会使得对端重置它的拥塞控制状态（详见<a href="#9.4_Loss_Detection_and_Congestion_Control">第9.4章</a>），所以地址<em><strong>应该</strong></em>仅偶尔地被改变。</p>
<p>耗尽可用连接ID的终端既不能探测新路径或发起迁移，也不能响应探测包或对端发起的迁移。为了确保迁移可行并且在不同路径上发送的数据包不会被关联，终端<em><strong>应该</strong></em>在对端迁移前提供新连接ID，详见<a href="#5.1.1_Issuing_Connection_IDs">第5.1.1章</a>。如果对端可能已经耗尽了可用的连接ID，正在迁移的那个终端可以在所有在新网络路径上发送的数据包中包含一个<strong>新连接ID帧</strong>。</p>
</div>
</section>
<section class="page" id="9.6_Server's_Preferred_Address">
<h2>
<a href="#9.6_Server%27s_Preferred_Address">9.6 服务器的首选地址</a>
</h2>
<div class="content">
<p>QUIC允许服务器在一个IP地址上接受连接，然后在握手之后立刻尝试将这些连接转移到一个更优先使用的地址。这在客户端起初连接到由多个服务器共享的地址但想优先使用一个单播地址来确保连接稳定性时尤其有用。本节描述了这种将连接迁移到首选服务器地址的协议。</p>
<p>在这份文档制定的QUIC规范版本中，在连接途中迁移到新服务器地址是不受支持的。如果客户端在还没有发起一次前往新服务器地址的迁移的情况下就从那个地址接收到了数据包，那么客户端<em><strong>应该</strong></em>丢弃这些数据包。</p>
</div>
</section>
<section class="page" id="9.6.1_Communicating_a_Preferred_Address">
<h3>
<a href="#9.6.1_Communicating_a_Preferred_Address">9.6.1 传达首选地址</a>
</h3>
<div class="content">
<p>服务器通过在TLS握手中包含传输参数<code>preferred_address</code>的方式传达首选地址。</p>
<p>服务器<em><strong>可以</strong></em>为每一种地址族（IPv4和IPv6）传达首选地址，以允许客户端选择一个最适合它们网络连接的地址。</p>
<p>一旦握手被确认，客户端就<em><strong>应该</strong></em>选择客户端提供的两个地址中的一个并发起地址验证（详见<a href="#8.2_Path_Validation">第8.2章</a>）。客户端从传输参数<code>preferred_address</code>或<strong>新连接ID帧</strong>中获取并使用任何之前没用过的活跃连接ID来构建数据包。</p>
<p>只要路径验证通过，客户端就<em><strong>应该</strong></em>开始使用新连接ID向新服务器地址发送所有将来的数据包，并且不再使用旧服务器地址。如果地址验证失败，那么客户端<em><strong>必须</strong></em>将所有将来的数据包继续发到服务器的原始IP地址。</p>
</div>
</section>
<section class="page" id="9.6.2_Migration_to_a_Preferred_Address">
<h3>
<a href="#9.6.2_Migration_to_a_Preferred_Address">9.6.2 迁移至首选地址</a>
</h3>
<div class="content">
<p>迁移至首选地址的客户端<em><strong>必须</strong></em>在迁移前验证它选择的地址，详见<a href="#21.5.3_Request_Forgery_with_Preferred_Addresses">第21.5.3章</a>。</p>
<p>服务器可能在接受一条连接后的任何时间接收到一个发到它的首选IP地址的数据包。如果这个数据包包含了<strong>通道挑战帧</strong>，那么服务器就要像<a href="#8.2_Path_Validation">第8.2章</a>所描述的那样发送<strong>回复通道帧</strong>。服务器<em><strong>必须</strong></em>保持从它的原始地址发送非探测数据包，直到它在首选地址上接收到了来自客户端的非探测数据包并且它对新路径完成了验证。</p>
<p>服务器<em><strong>必须</strong></em>从它的首选地址探测通向客户端的路径。这有助于抵御由攻击者发起的虚假迁移。</p>
<p>一旦服务器完成了路径验证并且在首选地址上收到了具有新的最大数据包号的非探测数据包，它就开始仅仅从首选IP地址向客户端发送非探测数据包。如果服务器在旧IP地址上接收到了属于这条连接的更加新的数据包，那么服务器<em><strong>应该</strong></em>丢弃它们。服务器<em><strong>可以</strong></em>继续处理在旧IP地址上接收到的被延误的数据包。</p>
<p>服务器在传输参数<code>preferred_address</code>中提供的地址仅对提供地址时所处的连接有效。客户端<em><strong>必须不</strong></em>将它们用于其他连接，包括从当前连接恢复的连接。</p>
</div>
</section>
<section class="page" id="9.6.3_Interaction_of_Client_Migration_and_Preferred_Address">
<h3>
<a href="#9.6.3_Interaction_of_Client_Migration_and_Preferred_Address">9.6.3 客户端迁移与首选地址的交互</a>
</h3>
<div class="content">
<p>客户端可能想要在迁移到服务器的首选地址前先进行一次连接迁移。在这种情况下，客户端<em><strong>应该</strong></em>从它的新地址同时对原始的和首选的服务器地址进行路径验证。</p>
<p>如果对服务器首选地址的路径验证通过了，那么客户端<em><strong>必须</strong></em>放弃对原始地址的验证并且迁移至服务器的首选地址。如果对服务器首先地址的路径验证失败了但是对服务器原始地址的的验证成功了，那么客户端<em><strong>可以</strong></em>迁移到它的新地址，并且继续向服务器的原始地址发送数据。</p>
<p>如果在服务器的首选地址接收到的数据包有着与在握手期间观测到的值不同的客户端源地址，那么服务器<em><strong>必须</strong></em>如<a href="#9.3.1_Peer_Address_Spoofing">第9.3.1章</a>和<a href="#9.3.2_On-Path_Address_Spoofing">第9.3.2章</a>描述的那样保护自己免受潜在的攻击。除了有意的同时迁移，这种情况还会因为客户端的网络在访问服务器首选地址时使用了不同的NAT绑定而发生。</p>
<p>服务器<em><strong>应该</strong></em>在接收到来自不同地址的探测数据包时向客户端的新地址发起路径验证，详见<a href="#8_Address_Validation">第8章</a>。</p>
<p>迁移到新地址的客户端<em><strong>应该</strong></em>使用与服务器正使用的地址族一致的首选地址。</p>
<p>由传输参数<code>preferred_address</code>提供的连接ID不是特定于参数中提供的地址的。提供这个连接ID是为了客户端有一个可以用来迁移的连接ID，但客户端<em><strong>可以</strong></em>在任何路径上使用这个连接ID。</p>
</div>
</section>
<section class="page" id="9.7_Use_of_IPv6_Flow_Label_and_Migration">
<h2>
<a href="#9.7_Use_of_IPv6_Flow_Label_and_Migration">9.7 迁移与IPv6流标签的使用</a>
</h2>
<div class="content">
<p>使用IPv6发送数据的终端<em><strong>应该</strong></em>应用符合《<a href="https://www.rfc-editor.org/info/rfc6437">RFC6437</a>》要求的IPv6流标签，除非本地API不允许设置IPv6流标签。</p>
<p>流标签的生成<em><strong>必须</strong></em>被设计得能够最小化被关联到之前使用过的流标签的可能性，因为固定的流标签将使得多条路径上的网络活动被关联起来，详见<a href="#9.5_Privacy_Implications_of_Connection_Migration">第9.5章</a>。</p>
<p>《<a href="https://www.rfc-editor.org/info/rfc6437">RFC6437</a>》建议用伪随机函数衍生数据的方式来生成流标签。在生成流标签时除了源地址和目标地址外还包含目标连接ID字段，可以确保流标签和其他能观测到的标识值是同步变化的。使用将这些输入和一个本地秘密值进行组合的加密哈希函数是实现这项要求的方法之一。</p>
</div>
</section>
<section class="page" id="10_Connection_Termination">
<h1>
<a href="#10_Connection_Termination">10. 连接终止</a>
</h1>
<div class="content">
<p>共有三种方法可以终止一个已建立的QUIC连接：</p>
<ul>
<li>
<p>空闲超时（详见<a href="#10.1_Idle_Timeout">第10.1章</a>）</p>
</li>
<li>
<p>立即关闭（详见<a href="#10.2_Immediate_Close">第10.2章</a>）</p>
</li>
<li>
<p>无状态重置（详见<a href="#10.3_Stateless_Reset">第10.3章</a>）</p>
</li>
</ul>
<p>如果终端没有可以用来发送数据包的网络路径，那么它<em><strong>可以</strong></em>丢弃连接状态，详见<a href="#8.2_Path_Validation">第8.2章</a>。</p>
</div>
</section>
<section class="page" id="10.1_Idle_Timeout">
<h2>
<a href="#10.1_Idle_Timeout">10.1 空闲超时</a>
</h2>
<div class="content">
<p>如果任一终端在其传输参数（详见<a href="#18.2_Transport_Parameter_Definitions">第18.2章</a>）中指定了<code>max_idle_timeout</code>（最大空闲超时时间），且某个连接持续空闲的时间超过了两个终端宣告的<code>max_idle_timeout</code>中的较小值，那么这个连接就会被静默关闭，并且它的状态会被丢弃。</p>
<p>每个终端都宣告<code>max_idle_timeout</code>，但是只取两个值中较小的那一个（或只取有效的那个值，如果只有一个终端宣告了非零值）作为终端使用的有效值。通过宣告<code>max_idle_timeout</code>，终端承诺，如果它要在空闲时间还未达到上述有效值时就放弃一条连接，那么它会发起立即关闭（详见<a href="#10.2_Immediate_Close">第10.2章</a>）。</p>
<p>当成功接收且处理了一个来自对端的数据包时，终端重启它的空闲计时器。当正要发送ACK触发包时，如果自上一次接收并处理数据包后还没有发送过任何ACK触发包，那么终端也会重启它的空闲计时器。在发送数据包时重启这个计时器确保新的活动被发起后连接不会被马上关闭。</p>
<p>为了避免过小的空闲超时时间，终端<em><strong>必须</strong></em>提高空闲超时时间至少到当前探测包超时时间（PTO）的三倍。这使得在空闲超时前有充足的时间供数个探测包被发送和丢失。</p>
</div>
</section>
<section class="page" id="10.1.1_Liveness_Testing">
<h3>
<a href="#10.1.1_Liveness_Testing">10.1.1 存活确认</a>
</h3>
<div class="content">
<p>在临近正在生效的超时时间时发送数据包的终端需要承担数据包被对端丢弃的风险，因为在这些数据包到达之前，对端的空闲时间可能已经逾期。</p>
<p>如果对端可能距离超时所剩的时间不多了，例如不到一个PTO，那么终端可以发送一个<strong>Ping帧</strong>或其他引发确认的帧来测试连接是否存活，详见《<a href="../RFC9002_Chinese_Simplified">QUIC恢复</a>》的<a href="../RFC9002_Chinese_Simplified/#6.2_Probe_Timeout">第6.2章</a>。这在没有可用的应用数据以供安全地重发时尤其有用。注意，哪些数据可以安全地重发是由应用决定的。</p>
</div>
</section>
<section class="page" id="10.1.2_Deferring_Idle_Timeout">
<h3>
<a href="#10.1.2_Deferring_Idle_Timeout">10.1.2 推迟空闲超时</a>
</h3>
<div class="content">
<p>如果终端正在等待响应数据但是没有或无法发送应用数据，那么终端可能需要发送ACK触发包以避免空闲超时。</p>
<p>QUIC实现可以向应用提供选项来推迟空闲超时。当应用希望避免丢失已经和一条连接关联的状态但不希望花时间重新交换应用数据，那么就可以使用这个选项。开启这个选项时，终端可以定期发送一个<strong>Ping帧</strong>（详见<a href="#19.2_PING_Frames">第19.2章</a>），这会使得对端重置自己的空闲超时定时器。如果这包含<strong>Ping帧</strong>的数据包是自上一次接收到数据包后发送的第一个ACK触发包，那么发送这个包还会重置当前终端的空闲超时定时器。发送<strong>Ping帧</strong>会使得对端用确认来响应，这也会重置当前终端的空闲超时定时器。</p>
<p>使用QUIC的应用协议<em><strong>应该</strong></em>提供有关合适的推迟空闲超时的时机的指导。不必要地发送<strong>Ping帧</strong>可能对性能有负面影响。</p>
<p>如果一条连接上在一段超过用传输参数<code>max_idle_timeout</code>协商的时间内，没有数据包被发送或接收，那么这条连接会超时，详见<a href="#10_Connection_Termination">第10章</a>。然而，网络中间设备的状态可能比那个时间更早地超时。尽管《<a href="https://www.rfc-editor.org/info/rfc4787">RFC4787</a>》中的第5条要求推荐了每2分钟的超时间隔，但是经验表明至少要每30秒发送一次数据包才能避免大多数中间设备丢失有关UDP流量的状态，详见《<a href="https://doi.org/10.1145/1879141.1879174">GATEWAY</a>》。</p>
</div>
</section>
<section class="page" id="10.2_Immediate_Close">
<h2>
<a href="#10.2_Immediate_Close">10.2 立即关闭</a>
</h2>
<div class="content">
<p>终端发送<strong>连接关闭帧</strong>（详见<a href="#19.19_CONNECTION_CLOSE_Frames">第19.19章</a>）来立即终止连接。<strong>连接关闭帧</strong>使得所有流都被立即关闭；开放的流可以被假定为被隐式重置。</p>
<p>在发送<strong>连接关闭帧</strong>之后，终端立即进入关闭状态，详见<a href="#10.2.1_Closing_Connection_State">第10.2.1章</a>。在收到<strong>连接关闭帧</strong>之后，终端进入排空状态，详见<a href="#10.2.2_Draining_Connection_State">第10.2.2章</a>。</p>
<p>对协议的违背将引发立即关闭。</p>
<p>在应用协议计划关闭一条连接后，可以使用立即关闭。这时可能是应用协议协商了一次正常关闭。应用协议可以交换用于两侧应用终端协商关闭连接的消息，在那之后请求QUIC关闭连接。当QUIC因此关闭连接后，带着由应用提供的错误码的<strong>连接关闭帧</strong>会被用于向对端发送关闭的信号。</p>
<p>关闭和排空状态用于确保连接被干净地关闭，以及延误的和乱序的数据包被正确地丢弃。这些状态的持续时间<em><strong>应该</strong></em>至少为当前PTO间隔（定义于《<a href="../RFC9002_Chinese_Simplified">QUIC恢复</a>》）的三倍大小。</p>
<p>在退出关闭或排空状态前就处理连接的状态数据，可能导致终端在收到被延误的数据包时不必要地发起无状态重置。有一些备用手段来确保被延误的数据包不会引起响应的终端，比如那些有能力关闭UDP套接字的终端，<em><strong>可以</strong></em>更早地结束连接的状态以更快地恢复可用资源。始终保持一个套接字开放以接受新连接的服务器<em><strong>不应该</strong></em>过早结束关闭或排空状态。</p>
<p>一旦终端的关闭或排空状态结束，它就<em><strong>应该</strong></em>丢弃所有连接状态数据。终端在响应任何将来的属于这条连接的传入数据包时，<em><strong>可以</strong></em>发送无状态重置。</p>
</div>
</section>
<section class="page" id="10.2.1_Closing_Connection_State">
<h3>
<a href="#10.2.1_Closing_Connection_State">10.2.1 连接的关闭状态</a>
</h3>
<div class="content">
<p>终端发起立即关闭后进入关闭状态。</p>
<p>在关闭状态下，终端仅保留足够用于创建包含<strong>连接关闭帧</strong>的数据包和用于区分数据包是否属于此条已关闭连接的信息。处于关闭状态的终端发送包含<strong>连接关闭帧</strong>的数据包来响应任何属于这条连接的传入数据包。</p>
<p>终端<em><strong>应该</strong></em>限制它在关闭状态下创建数据包的速率。比如，终端可以在响应接收到的数据包前等待足够的数据包或时间，且等待的数据包数量或时间长短是逐渐增长的。</p>
<p>终端选择的连接ID和QUIC版本是区分数据包是否属于一条关闭状态的连接的充分信息；终端<em><strong>可以</strong></em>丢弃所有其他连接状态数据。处于关闭状态的终端没有必要处理任何接收到的帧。终端<em><strong>可以</strong></em>为传入数据包保留数据包保护密钥用于读取和处理<strong>连接关闭帧</strong>。</p>
<p>当进入关闭状态时，终端<em><strong>可以</strong></em>丢弃数据包保护密钥，然后在响应任何接收到的UDP数据报时都发送包含<strong>连接关闭帧</strong>的数据包。然而，丢弃了数据包保护密钥的终端没有能力区分并丢弃不合法的数据包。为了避免被用于放大攻击，这样的终端<em><strong>必须</strong></em>限制它发出的数据包尺寸总和不超过它接收到的且属于这条连接的数据包尺寸总和的三倍。为了最小化终端为关闭状态的连接所维护的状态数据，终端<em><strong>可以</strong></em>在响应任何接收到的数据包时发送完全相同的数据包。</p>
<blockquote>
<p>注意：允许在关闭状态下重传完全相同的数据包是“每个数据包都必须使用新的数据包号”要求的一个特例，详见<a href="#12.3_Packet_Numbers">第12.3章</a>。发送新的数据包号主要是用于丢包恢复和拥塞控制，但这两者都和一个已关闭的连接关系不大。重传这最后一个数据包需要的状态数据更少。</p>
</blockquote>
<p>当处于关闭状态时，终端可能从新的源地址接收到数据包，这可能是连接迁移的结果；详见<a href="#9_Connection_Migration">第9章</a>。处于关闭状态的终端<em><strong>必须</strong></em>要么丢弃从未经验证的地址接收到的数据包，要么限制它发向未经验证的地址的数据包尺寸总和，使其小于它从那个地址接收到的数据包的尺寸总和。</p>
<p>处于关闭状态的终端不应处理密钥更新（详见《<a href="../RFC9001_Chinese_Simplified">QUIC-TLS</a>》的<a href="../RFC9001_Chinese_Simplified/#6_Key_Update">第6章</a>）。密钥更新可能阻止终端从关闭状态转移到排空状态，因为终端将失去处理后续接收到的数据包的能力，但这没有什么影响。</p>
</div>
</section>
<section class="page" id="10.2.2_Draining_Connection_State">
<h3>
<a href="#10.2.2_Draining_Connection_State">10.2.2 连接的排空状态</a>
</h3>
<div class="content">
<p>一旦终端接收到<strong>连接关闭帧</strong>，他就会进入排空状态，这表明对端已处于关闭或排空状态。虽然在其他方面都和关闭状态一致，不过处于排空状态的终端<em><strong>必须不</strong></em>发送任何数据包。一旦连接处于排空状态，就没有必要再保留数据包保护密钥了。</p>
<p>接收到<strong>连接关闭帧</strong>的终端<em><strong>可以</strong></em>再进入排空状态前发送一个包含<strong>连接关闭帧</strong>的数据包，并且，如若合适，使用<code>NO_ERROR</code>（无错误）代码。除此之外，终端<em><strong>必须不</strong></em>发送更多数据包。不这么做会导致两个终端间保持不断交换<strong>连接关闭帧</strong>的状态，直到其中一个终端退出关闭状态。</p>
<p>如果终端接收到了<strong>连接关闭帧</strong>，那么它<em><strong>可以</strong></em>从关闭状态进入排空状态，这表明对端也处于关闭或排空状态。在这种情况下，排空状态会在原来关闭状态应该结束时结束。换句话说，终端使用相同的状态结束时机但是不再在这条连接上传输数据包。</p>
</div>
</section>
<section class="page" id="10.2.3_Immediate_Close_during_the_Handshake">
<h3>
<a href="#10.2.3_Immediate_Close_during_the_Handshake">10.2.3 在握手期间立即关闭</a>
</h3>
<div class="content">
<p>发送<strong>连接关闭帧</strong>时，要确保对端会处理这个帧。通常来说，这意味着将这个帧放到具有最高级别的数据包保护的数据包中发送，以避免数据包被丢弃。在握手确认后（详见《<a href="../RFC9001_Chinese_Simplified">QUIC-TLS</a>》的<a href="../RFC9001_Chinese_Simplified/#4.1.2_Handshake_Confirmed">第4.1.2章</a>），终端<em><strong>必须</strong></em>在1-RTT数据包中发送任何<strong>连接关闭帧</strong>。然而，在确认握手前，更高级的数据包保护密钥有可能在对端那还不可用，所以<em><strong>可以</strong></em>使用具有较低数据包保护级别的数据包多发送一个<strong>连接关闭帧</strong>。具体来说：</p>
<ul>
<li>
<p>客户端总是知道服务器有没有握手密钥（详见<a href="#17.2.2.1_Abandoning_Initial_Packets">第17.2.2.1章</a>），但是服务器不确定客户端有没有握手密钥。在这种条件下，服务器<em><strong>应该</strong></em>用握手数据包和初始数据包各发送一个<strong>连接关闭帧</strong>来确保它们中的至少一个是客户端可以处理的。</p>
</li>
<li>
<p>在0-RTT数据包中发送<strong>连接关闭帧</strong>的客户端不能确信服务器会同意0-RTT的使用。用初始数据包发送<strong>连接关闭帧</strong>使得服务器更有可能接收到关闭的信号，哪怕应用错误码可能不会被接收到。</p>
</li>
<li>
<p>在确认握手前，对端可能无法处理1-RTT数据包，所以终端<em><strong>应该</strong></em>用握手数据包和1-RTT数据包各发送一个<strong>连接关闭帧</strong>。服务器则<em><strong>应该</strong></em>用初始数据包发送<strong>连接关闭帧</strong>。</p>
</li>
</ul>
<p>用初始数据包或握手数据包发送类型为<code>0x1d</code>的<strong>连接关闭帧</strong>会暴露应用状态或被用于更改应用状态。用初始数据包或握手数据包发送时，必须将类型为<code>0x1d</code>的<strong>连接关闭帧</strong>替换为类型为<code>0x1c</code>的<strong>连接关闭帧</strong>。否则，有关应用状态的信息可能被泄露。终端在转换<strong>连接关闭帧</strong>的类型到<code>0x1c</code>时<em><strong>必须</strong></em>清除原因语句字段的值，并且<em><strong>应该</strong></em>使用<code>APPLICATION_ERROR</code>（应用错误）代码。</p>
<p>用不同数据包类型发送的<strong>连接关闭帧</strong>可以被合并至单个UDP数据报中；详见<a href="#12.2_Coalescing_Packets">第12.2章</a>。</p>
<p>终端可以用初始数据包发送<strong>连接关闭帧</strong>。这时可能是在响应接收自初始数据包或握手数据包的未通过认证的信息。这样的立即关闭行为可能将合法的连接暴露在拒绝服务攻击之下。QUIC对于握手过程中来自路径上设备的攻击并不提供防御措施；详见<a href="#21.2_Handshake_Denial_of_Service">第21.2章</a>。然而，如果牺牲发向合法对端的关于错误的反馈，并且终端直接丢弃不合法的数据包而不是用<strong>关闭连接帧</strong>终止连接，那么部分形式的拒绝服务攻击对于攻击者来说会变得更难实施。出于这个原因，如果在缺乏认证的数据包中检测出了错误，那么终端<em><strong>可以</strong></em>丢弃数据包而不是选择立即关闭。</p>
<p>尚未建立状态的终端，例如在初始数据包中检测到错误的服务器，并不会进入关闭状态。在发送<strong>连接关闭帧</strong>时，没有关于连接的状态的终端不会进入关闭或排空状态。</p>
</div>
</section>
<section class="page" id="10.3_Stateless_Reset">
<h2>
<a href="#10.3_Stateless_Reset">10.3 无状态重置</a>
</h2>
<div class="content">
<p>如果终端无法访问连接的状态数据，那么无状态重置将是其最后手段。崩溃或中断可能造成对端持续向一个没有正常地维持连接的终端发送数据。终端<em><strong>可以</strong></em>在接收到一个它无法关联到某个活跃连接的数据包时发送无状态重置作为响应。</p>
<p>无状态重置不适合用来表明在活跃连接中出现的错误。想要传达致命的连接错误这一消息的终端在有能力的情况下<em><strong>必须</strong></em>使用<strong>连接关闭帧</strong>。</p>
<p>为了支持无状态重置，终端会签发一个无状态重置令牌，它是一个难以猜测的16字节长的值。如果对端后续收到了无状态重置，也就是一个以那个无状态重置令牌结尾的UDP数据报，那么对端将立即结束这条连接。</p>
<p>每个无状态重置令牌都是特定于某个连接ID的。终端签发无状态重置令牌时，将它的值包含在<strong>新连接ID帧</strong>的无状态重置令牌字段中。服务器还可以在握手期间签发传输参数<code>stateless_reset_token</code>（无状态重置令牌），它会被应用到服务器在握手期间选择的连接ID上。这些信息交换是受到加密保护的，所以只有客户端和服务器知道它们的值。注意，客户端不能使用传输参数<code>stateless_reset_token</code>，因为它们的传输参数没有可信度保护。</p>
<p>当令牌关联的连接ID被<strong>停用连接ID帧</strong>（详见<a href="#19.16_RETIRE_CONNECTION_ID_Frames">第19.16章</a>）停用时，令牌将失效。</p>
<p>如果终端接收到了它无法处理的数据包，那么它会以这种形式发送一个数据包：</p>
<div class="block ref" id="Figure_10_Stateless_Reset">
<pre tabindex="0"><code>无状态重置 {
  固定比特位 (2) = 1,
  不可预测的比特位 (38..),
  无状态重置令牌 (128),
}
</code></pre><p><a href="#Figure_10_Stateless_Reset">图10：无状态重置</a></p>
</div>
<p>这种设计确保无状态重置——尽可能地——无法和常规的短包头数据包区分。</p>
<p>无状态重置使用从数据包头部的最前面两个比特位开始的一整个UDP数据报。首个字节的剩余部分和在它之后任意数量的字节都<em><strong>应该</strong></em>被设置为无法分辨是不是随机的值。数据报的最后16个字节包含了无状态重置令牌。</p>
<p>对于不是意图的接收方的实体来说，无状态重置看起来就是一个短包头数据包。为了让无状态重置表现得像一个合法QUIC数据包，不可预测的比特位应该使用至少38比特的数据（或者说5字节并去掉两个固定比特位）。</p>
<p>如果接收方要求使用连接ID，那么那作为结果的至少21个字节并不保证无状态重置很难与其他数据包区分。为了做到这一点，终端<em><strong>应该</strong></em>确保所有它发送的数据包都比它要求对端在数据包中包含的最小的连接ID的长度要长至少22字节，不够就加<strong>填充帧</strong>。这么做能确保所有对端发出的无状态重置都无法和发送给当前终端的合法数据包区分。在发送无状态重置来响应一个不超过43字节的数据包时，终端<em><strong>应该</strong></em>发送一个比它要响应的那个数据包要短一个字节的无状态重置。</p>
<p>以上数值假设了无状态重置令牌和数据包保护AEAD的最小扩充量具有相同长度。如果终端协商了具有更大的最小扩充量的数据包保护方案，那么就需要额外的不可预测字节。</p>
<p>终端发送的无状态重置尺寸<em><strong>必须不</strong></em>是它接收到的数据包的三倍或更大，以免被用于放大攻击。<a href="#10.3.3_Looping">第10.3.3章</a>描述了无状态重置尺寸的额外限制。</p>
<p>终端<em><strong>必须</strong></em>丢弃因过小而不合法的QUIC数据包。举个例子，在使用《<a href="/RFC9001_Chinese_Simplified">QUIC-TLS</a>》中定义的AEAD函数组时，小于21字节的短包头数据包永远不可能合法。</p>
<p>终端<em><strong>必须</strong></em>将无状态重置以短包头数据包的格式发送。然而，终端<em><strong>必须</strong></em>将任何以有效无状态重置令牌结尾的数据包视作无状态重置，因为其他QUIC版本可能允许使用长包头。</p>
<p>终端<em><strong>可以</strong></em>在响应长包头数据包时发送无状态重置。在无状态重置令牌在对端处可用前发送无状态重置是没有效果的。在本QUIC版本中，只能在连接建立期间使用长包头数据包。由于无状态重置令牌只有在连接建立完成或临近完成时才可用，忽略长包头数据包的效果和发送无状态重置的效果可能是一样的。</p>
<p>终端不能从短包头数据包中判断源连接ID；因此，它不能在无状态重置中设置目标连接ID。于是目标连接ID会和之前发送的数据包中使用的值不一样。随机的目标连接ID能使连接ID表现得像是迁移至由<strong>新连接ID帧</strong>提供的新连接ID的结果；详见<a href="#19.15_NEW_CONNECTION_ID_Frames">第19.15章</a>。</p>
<p>使用随机的连接ID会有两个问题：</p>
<ul>
<li>
<p>数据包可能无法抵达对端。如果目标连接ID在路由至对端时起关键作用，那么该数据包可能被错误地路由。作为响应，这可能会触发另一个无状态重置；详见<a href="#10.3.3_Looping">第10.3.3章</a>。没有被正确路由的无状态重置使得错误检测和恢复机制失去效果。在这种情况下，终端需要依靠其他方法——比如计时器——来检测连接已失败。</p>
</li>
<li>
<p>随机生成的连接ID可以被不是对端的其他实体识别为可能的无状态重置。偶尔使用不同的连接ID的终端可以对此引入一些不确定性。</p>
</li>
</ul>
<p>这样的无状态重置设计是特定于QUIC版本1的。支持多个QUIC版本的终端创建的无状态重置应该可以被支持所有当前终端所支持的版本（或所有在当前终端丢失状态前可能支持的版本）的对端接受。新QUIC版本的设计者应当注意上述这一点，并且要么(1)重用当前设计，要么(2)使用数据包除了最后16个字节之外的某个部分来携带数据。</p>
</div>
</section>
<section class="page" id="10.3.1_Detecting_a_Stateless_Reset">
<h3>
<a href="#10.3.1_Detecting_a_Stateless_Reset">10.3.1 检测无状态重置</a>
</h3>
<div class="content">
<p>终端使用UDP数据报末尾的16个字节检测可能的无状态重置。终端记录所有无状态重置令牌，这些令牌关联着连接ID和终端最近发送的数据报的目标远程地址。这些令牌来自<strong>新连接ID帧</strong>的无状态重置令牌字段和服务器的传输参数，但不包含那些与未使用的或已停用的连接ID关联的无状态重置令牌。终端通过比较数据报的最后16个字节和所有与发送数据报的远程地址关联的无状态重置令牌，来将接收到的数据报识别为无状态重置。</p>
<p>这种比较可以为每个传入数据报进行。如果来自某个数据报的数据包被成功处理了，那么终端<em><strong>可以</strong></em>跳过这个检查。然而，如果一个传入数据报的首个数据包不能与一条连接关联上，或不能被解密，那么<em><strong>必须</strong></em>进行这种比较。</p>
<p>终端<em><strong>必须不</strong></em>为任何关联到它尚未使用或已停用的连接ID上的无状态重置令牌做检查。</p>
<p>在将数据报和无状态重置令牌的值比较时，终端<em><strong>必须</strong></em>在不泄露令牌的值的前提下进行比较。比如，用固定时间进行比较能保护无状态重置令牌免于利用计时侧信道的信息泄露。另一种方法是存储并比较经转换的无状态重置令牌值而不是原始的令牌值，这种转换指的是使用密钥并在密码学上安全的伪随机函数（例如数据块加密算法和散列消息认证码（HMAC，详见《<a href="https://www.rfc-editor.org/info/rfc2104">RFC2104</a>》））。终端不必保护有关数据包是否被成功解密和有效的无状态重置令牌数量的信息。</p>
<p>如果数据报的最后16个字节与无状态重置令牌的值一致，那么终端<em><strong>必须</strong></em>进入排空状态，并且在此连接上不再发送数据包。</p>
</div>
</section>
<section class="page" id="10.3.2_Calculating_a_Stateless_Reset_Token">
<h3>
<a href="#10.3.2_Calculating_a_Stateless_Reset_Token">10.3.2 计算无状态重置令牌</a>
</h3>
<div class="content">
<p>无状态重置令牌<em><strong>必须</strong></em>难以被猜测。为了创建无状态重置令牌，终端可以为每一个它创建的连接随机生成（详见《<a href="https://www.rfc-editor.org/info/rfc4086">RANDOM</a>》）一个秘密值。然而，当集群中有多个实例时它会带来协调上的问题，以及在终端丢失状态时带来存储上的问题。无状态重置是为了处理状态丢失的情况而专门设计的，因此这个方法不是最理想的。</p>
<p>通过使用以固定密钥和由终端选择的连接ID（详见<a href="#5.1_Connection_ID">第5.1章</a>）作为输入的伪随机函数来生成令牌，单个固定密钥可以被用于与同一个终端有关的所有连接。终端可以使用HMAC（详见《<a href="https://www.rfc-editor.org/info/rfc2104">RFC2104</a>》）（例如，<code>HMAC(固定密钥, 连接ID)</code>）或基于HMAC的密钥衍生函数（HKDF，详见《<a href="https://www.rfc-editor.org/info/rfc5869">RFC5869</a>》）（例如，使用固定密钥作为输入密钥材料，使用连接ID作为盐）。这个函数的输出被截断至16字节来作为连接的无状态重置令牌。</p>
<p>丢失状态的终端可以使用相同的方法来生成有效的无状态重置令牌。连接ID来自终端接收到的那个数据包。</p>
<p>这种设计要求对端总是在数据包中发送连接ID，这样终端才可以使用来自数据包的连接ID来重置连接。使用这种设计的终端<em><strong>必须</strong></em>要么为所有连接使用相同长度的连接ID，要么将连接ID长度编码进连接ID以使得它可以在没有状态的情况下恢复。除此之外，它不能提供零长度连接ID。</p>
<p>泄露无状态重置令牌将允许任何实体终止连接，所以一个令牌值只能被使用一次。这种选择无状态重置令牌的方法意味着相同连接ID和固定密钥的组合<em><strong>必须不</strong></em>被用于另一个连接。如果共享同一个固定密钥的实例还使用了相同的连接ID，或者攻击者可以使数据包被路由到没有状态但是使用相同固定密钥的实例，那么就有可能发起拒绝服务攻击；详见<a href="#21.11_Stateless_Reset_Oracle">第21.11章</a>。如果一个连接ID所在的连接已通过使用无状态重置令牌的方法重置过，那么在共享相同固定密钥的节点上<em><strong>必须不</strong></em>将这个连接ID用于新的连接。</p>
<p>同一个无状态重置令牌<em><strong>必须不</strong></em>被用于多个连接ID。终端不需要将新的令牌值与所有先前的值进行比较，但是重复的值<strong>可能</strong>被视作类型为<code>PROTOCOL_VIOLATION</code>（协议违反）的连接错误。</p>
<p>注意，无状态重置不受到任何加密保护。</p>
</div>
</section>
<section class="page" id="10.3.3_Looping">
<h3>
<a href="#10.3.3_Looping">10.3.3 死循环</a>
</h3>
<div class="content">
<p>无状态重置的设计使得在不知道无状态重置令牌的情况下无法将它与合法的数据包区分开来。举例来说，如果一个服务器往另一个服务器发送了无状态重置，那么作为响应它可能收到另一个无状态重置，这会导致无尽的数据包交换。</p>
<p>终端<em><strong>必须</strong></em>确保每一个它发出的无状态重置都比触发它的数据包要小，除非终端维护着足以避免死循环的状态数据。在循环出现的情况下，这使得数据包最终变得过小而不能触发响应。</p>
<p>终端可以记录它已发送的无状态重置数量并且一旦到达限制数量就不再创建新的无状态重置。为不同的远程地址使用单独的限制可以确保其他对端或连接已到达限制时还能够使用无状态重置来关闭连接。</p>
<p>取决于对端的连接ID长度，小于41字节的无状态重置可能被观察者识别为无状态重置。反过来，对小型数据包不响应无状态重置可能导致无状态重置不能有效地检测连接损坏但是只有小型数据包被发送的情况；这样的失败可能只能被其他方法检测出来，例如计时器。</p>
</div>
</section>
<section class="page" id="11_Error_Handling">
<h1>
<a href="#11_Error_Handling">11. 错误处理</a>
</h1>
<div class="content">
<p>检测到错误的终端<em><strong>应该</strong></em>向对端发送出现了这个错误的信号。传输层和应用层的错误都会影响整条连接，详见<a href="#11.1_Connection_Errors">第11.1章</a>。只有应用层的错误可以被隔离到单条流上，详见<a href="#11.2_Stream_Errors">第11.2章</a>。</p>
<p>在发送信号的帧中<em><strong>应该</strong></em>使用最合适的错误码（详见<a href="#10_Connection_Termination">第10章</a>）。这份规范中在描述错误情形的地方会定义这时候使用的错误码；尽管这些定义被称作”要求“，但是不同的实现策略可能导致最终报告不同的错误。特别是，终端在检测到错误情形时，<em><strong>可以</strong></em>使用任何适用的错误码；通用的错误码（比如<code>PROTOCOL_VIOLATION</code>（协议违背）或<code>INTERNAL_ERROR</code>（内部错误））总是可以用在其他错误码可以用的地方。</p>
<p>对于可以使用<strong>连接关闭帧</strong>或<strong>流重置帧</strong>来发送信号的错误，不适合使用无状态重置（<a href="#10.3_Stateless_Reset">第10.3章</a>）。具有足够的状态数据来在连接上发送帧的终端<em><strong>必须不</strong></em>使用无状态重置。</p>
</div>
</section>
<section class="page" id="11.1_Connection_Errors">
<h2>
<a href="#11.1_Connection_Errors">11.1 连接错误</a>
</h2>
<div class="content">
<p>如果出现的错误会导致连接变得不可用，比如违背了协议语义或损坏了可能影响整条连接的状态数据，那么必须使用<strong>连接关闭帧</strong>（详见<a href="#19.19_CONNECTION_CLOSE_Frames">第19.19章</a>）来发送信号。</p>
<p>与应用相关的协议的错误出现时，使用帧类型为<code>0x1d</code>的<strong>连接关闭帧</strong>来发送信号。与传输相关的错误，包括所有在这份文档中描述的错误，都用帧类型为<code>0x1c</code>的<strong>连接关闭帧</strong>来携带。</p>
<p>携带<strong>连接关闭帧</strong>的数据包可能会遭遇丢包。终端<em><strong>应该</strong></em>准备好当在一条已终止的连接上收到更多数据包时，重传包含<strong>连接关闭帧</strong>的数据包。限制重传的次数和发送这个最终的数据包的时机能够限制在已终止的连接上投入的资源。</p>
<p>选择不重传<strong>连接关闭帧</strong>的终端需要承担对端错失首个包含<strong>连接关闭帧</strong>的数据包的风险。在一条已终止的连接上继续接收数据的终端，其唯一可用的机制是启动无状态重置的流程（<a href="#10.3_Stateless_Reset">第10.3章</a>）。</p>
<p>鉴于初始数据包的AEAD不提供强力的认证，终端<em><strong>可以</strong></em>丢弃不合法的初始数据包。即使在本规范要求产生连接错误的地方，丢弃初始数据包也是允许的。只有终端不能处理某个数据包中的帧或回退所有已处理部分产生的副作用时，它才能丢弃这个数据包。丢弃不合法的初始数据包可以被用来减少拒绝服务产生的风险，详见<a href="#21.2_Handshake_Denial_of_Service">第21.2章</a>。</p>
</div>
</section>
<section class="page" id="11.2_Stream_Errors">
<h2>
<a href="#11.2_Stream_Errors">11.2 流错误</a>
</h2>
<div class="content">
<p>如果一个应用层错误仅影响了单个流且它所在的连接处于可以恢复的状态，那么终端可以发送一个使用适当的错误码的<strong>流重置帧</strong>（详见<a href="#19.4_RESET_STREAM_Frames">第19.4章</a>）来仅仅终止受影响的流。</p>
<p>对流进行重置而不通知应用协议会使得应用协议进入不可恢复的状态。<strong>流重置</strong>帧<em><strong>必须</strong></em>只能由使用QUIC的应用协议发起。</p>
<p>在<strong>流重置帧</strong>中携带的应用错误码的语义是由应用协议定义的。只有应用协议有能力终止一条流。应用协议的本地实例直接调用API，远程实例则可以使用会自动触发<strong>流重置帧</strong>的<strong>停止发送帧</strong>。</p>
<p>应用协议<em><strong>应该</strong></em>定义规则来处理被任一终端提前取消的流。</p>
</div>
</section>
<section class="page" id="12_Packets_and_Frames">
<h1>
<a href="#12_Packets_and_Frames">12. 数据包与帧</a>
</h1>
<div class="content">
<p>QUIC终端间用交换数据包的方式交流。数据包具有可信度和完整性保护，详见<a href="#12.1_Protected_Packets">第12.1章</a>。数据包是由UDP数据报携带的，详见<a href="#12.2_Coalescing_Packets">第12.2章</a>。</p>
<p>本QUIC版本在连接建立期间使用长包头，详见<a href="#17.2_Long_Header_Packets">第17.2章</a>。具有长包头的数据包分别是初始数据包（详见<a href="#17.2.2_Initial_Packet">第17.2.2章</a>）、0-RTT数据包（<a href="#17.2.3_0-RTT">第17.2.3章</a>）、握手数据包（<a href="#17.2.4_Handshake_Packet">第17.2.4章</a>）和重试数据包（<a href="#17.2.5_Retry_Packet">第17.2.5章</a>）。版本协商过程使用与版本无关的具有长包头的数据包，详见<a href="#17.2.1_Version_Negotiation_Packet">第17.2.1章</a>。</p>
<p>具有短包头的数据包是为了最小化开销而设计的，它们被用于连接建立之后且1-RTT密钥可用时，详见<a href="#17.3_Short_Header_Packets">第17.3章</a>。</p>
</div>
</section>
<section class="page" id="12.1_Protected_Packets">
<h2>
<a href="#12.1_Protected_Packets">12.1 受保护的数据包</a>
</h2>
<div class="content">
<p>根据数据包类型不同，QUIC数据包具有不同级别的加密保护。有关数据包保护的细节，详见《<a href="/RFC9001_Chinese_Simplified">QUIC-TLS</a>》；本节对这种保护做了概述。</p>
<p>版本协商数据包没有加密保护，详见《<a href="../RFC8999_Chinese_Simplified">QUIC不变量</a>》。</p>
<p>重试数据包使用AEAD函数（带有关联数据的认证加密，详见《<a href="https://www.rfc-editor.org/info/rfc5116">AEAD</a>》）来保护数据包免于意外修改。</p>
<p>初始数据包也使用AEAD函数，函数的密钥是用一个在传输中对外界可见的值衍生出来的。因此初始数据包不具有有效的可信度保护。使用初始数据包保护是为了确保数据包发送方是存在于当前网络路径上的。任何接收到来自客户端的初始数据包的实体都能重建出一个密钥，这个密钥既能让它们读取数据包的内容，也可以让它们创建出能被任一终端认证成功的初始数据包。AEAD函数还保护初始数据包免于意外修改。</p>
<p>其他所有数据包都受衍生自加密握手的密钥保护。加密握手确保了只有正在交流的终端才能够接收到用于握手数据包、0-RTT数据包和1-RTT数据包的相应密钥。受0-RTT和1-RTT密钥保护的数据包具有强力的可信度和完整性保护。</p>
<p>某些数据包类型中出现的数据包号字段具有可替代的可信度保护，这种保护被用作头部保护的一部分，详见《<a href="../RFC9001_Chinese_Simplified">QUIC-TLS</a>》的<a href="../RFC9001_Chinese_Simplified/#5.4_Header_Protection">第5.4章</a>。在给定的数据包号空间中，受保护的数据包号会随着数据包的发送而增加，详见<a href="#12.3_Packet_Numbers">第12.3章</a>。</p>
</div>
</section>
<section class="page" id="12.2_Coalescing_Packets">
<h2>
<a href="#12.2_Coalescing_Packets">12.2 合并数据包</a>
</h2>
<div class="content">
<p>初始数据包（详见<a href="#17.2.2_Initial_Packet">第17.2.2章</a>）、0-RTT数据包（<a href="#17.2.3_0-RTT">第17.2.3章</a>）和握手数据包（<a href="#17.2.4_Handshake_Packet">第17.2.4章</a>）包含可以用来判断数据包末尾位置的长度字段。这个长度既包括数据包号字段也包括载荷字段，这两个字段都被可信地保护着的，一开始它们的长度都是未知的。但只要头部保护被移除，就能知道载荷字段的长度。</p>
<p>使用长度字段，发送方可以将数个QUIC数据包合并至单个UDP数据报中。这可以减少为了完成加密握手并开始发送数据所需的UDP数据报数量。这也可以被用于构造路径最大传输单元（PMTU）探测包，详见<a href="#14.4.1_PMTU_Probes_Containing_Source_Connection_ID">第14.4.1章</a>。接收方<em><strong>必须</strong></em>有能力处理被合并的数据包。</p>
<p>用加密级别递增（初始、0-RTT、握手、1-RTT；详见《<a href="../RFC9001_Chinese_Simplified">QUIC-TLS</a>》的<a href="../RFC9001_Chinese_Simplified/#4.1.4_Encryption_Level_Changes">第4.1.4章</a>）的顺序合并数据包更有可能使接收方有能力一次性处理所有数据包。具有短包头的数据包并不包含长度，所以它只能作为最后一个数据包被包含进UDP数据报中。如果多个帧将以相同的加密级别发送，那么终端<em><strong>应该</strong></em>将它们包含在单个数据包中，而不是合并多个相同加密级别的数据包。</p>
<p>接收方<em><strong>可以</strong></em>根据UDP数据报包含的第一个数据包的信息来做路由。发送方<em><strong>必须不</strong></em>将具有不同连接ID的QUIC数据包合并至单个UDP数据报中。如果后续的某个数据包的目标连接ID字段与数据报中第一个数据包的值不同，那么接收方<em><strong>应该</strong></em>忽略这个数据包。</p>
<p>任何被合并至单个UDP数据报的QUIC数据包都是独立且完整的。被合并的QUIC数据包的接收方<em><strong>必须</strong></em>独立处理每个QUIC数据包并单独确认它们，就好像它们是作为不同UDP数据报的载荷被接收的。例如，如果对一个数据包的解密失败了（因为密钥出于某个理由而不可用），那么接收方<em><strong>可以</strong></em>要么丢弃这个数据包要么缓存它以供将来处理，并且<em><strong>必须</strong></em>尝试处理余下的数据包。</p>
<p>重试数据包（详见<a href="#17.2.5_Retry_Packet">第17.2.5章</a>）、版本协商数据包（<a href="#17.2.1_Version_Negotiation_Packet">第17.2.1章</a>）和具有短包头的数据包（<a href="#17.3_Short_Header_Packets">第17.3章</a>）并不包含长度字段，因此在同一个UDP数据报中不能有其他数据包跟在它们后面。还要注意，不存在将重试数据包和版本协商数据包与另一个数据包合并的情况。</p>
</div>
</section>
<section class="page" id="12.3_Packet_Numbers">
<h2>
<a href="#12.3_Packet_Numbers">12.3 数据包号</a>
</h2>
<div class="content">
<p>数据包号是范围在<code>0</code>至<code>2<sup>62</sup>-1</code>中的整数。这个数值被用来为数据包保护决定加密随机值。每个终端为发送和接收分别维护单独的数据包号。</p>
<p>数据包号被限制在这个范围内是因为它们需要在<strong>ACK帧</strong>（详见<a href="#19.3_ACK_Frames">第19.3章</a>）的最大确认数字段中被完整表示。然而在长包头或短包头中表示时，数据包号被截断并被编码至1至4字节中，详见<a href="#17.1_Packet_Number_Encoding_and_Decoding">第17.1章</a>。</p>
<p>版本协商数据包（详见<a href="#17.2.1_Version_Negotiation_Packet">第17.2.1章</a>）和重试数据包（<a href="#17.2.5_Retry_Packet">第17.2.5章</a>）并不包含数据包号。</p>
<p>在QUIC中，数据包号被划分到三个空间里：</p>
<dl>
<dt>初始空间（Initial space）：</dt>
<dd>
<p>所有初始数据包（详见<a href="#17.2.2_Initial_Packet">第17.2.2章</a>）都在这个空间中。</p>
</dd>
<dt>握手空间（Handshake space）：</dt>
<dd>
<p>所有握手数据包（详见<a href="#17.2.4_Handshake_Packet">第17.2.4章</a>）都在这个空间中。</p>
</dd>
<dt>应用数据空间（Application data space）：</dt>
<dd>
<p>所有0-RTT数据包（详见<a href="#17.2.3_0-RTT">第17.2.3章</a>）和1-RTT数据包（<a href="#17.3.1_1-RTT_Packet">第17.3.1章</a>）都在这个空间中。</p>
</dd>
</dl>
<p>如《<a href="/RFC9001_Chinese_Simplified">QUIC-TLS</a>》所述，每种数据包类型使用不同的保护密钥。</p>
<p>概念上，数据包号空间是数据包被处理和确认的上下文。初始数据包只能使用初始数据包保护密钥发送，也只能在初始数据包中被确认。类似地，握手数据包使用握手加密级别发送，且只能在握手数据包中被确认。</p>
<p>这样，在不同数据包号空间中发送的数据的加密得到了强制隔离。每个空间中的数据包号都从<code>0</code>开始。在相同数据包号空间中发送的后续数据包<em><strong>必须</strong></em>将数据包号增加至少<code>1</code>。</p>
<p>0-RTT数据和1-RTT数据出现在相同数据包号空间，是为了使得丢包检测算法在这两种数据包类型间更好实现。</p>
<p>在一条连接的同一个数据包号空间中，QUIC终端<em><strong>必须不</strong></em>重用数据包号。如果发送用的数据包号到达了<code>2<sup>62</sup>-1</code>，发送方<em><strong>必须</strong></em>关闭连接但不发送任何<strong>连接关闭帧</strong>或更多数据包；终端<em><strong>可以</strong></em>发送一个无状态重置（详见<a href="#10.3_Stateless_Reset">第10.3章</a>）以响应将来它接收到的数据包。</p>
<p>除非接收方确信它没有处理过另一个具有相同数据包号空间和数据包号的数据包，否则它<em><strong>必须</strong></em>丢弃眼前刚去除保护的数据包。出于在《<a href="../RFC9001_Chinese_Simplified">QUIC-TLS</a>》的<a href="../RFC9001_Chinese_Simplified/#9.5_Header_Protection_Timing_Side_Channels">第9.5章</a>中所述的原因，<em><strong>必须</strong></em>在移除数据包保护后进行这个去除重复的步骤。</p>
<p>为了检测重复的目的而追踪一个个数据包的终端会面临状态数据不断扩容的风险。检测重复所需的数据可以通过维护一个最小的数据包号来限制，低于这个数据包号的数据包都会被立即丢弃。使用任何最小的数据包号时，都要考虑往返时间可能发生的大幅度变化，原因之一是对端可能用更大的往返时间来探测网络路径，详见<a href="#9_Connection_Migration">第9章</a>。</p>
<p>有关数据包号在发送方的编码和在接收方的解码，详见<a href="#17.1_Packet_Number_Encoding_and_Decoding">第17.1章</a>。</p>
</div>
</section>
<section class="page" id="12.4_Frames_and_Frame_Types">
<h2>
<a href="#12.4_Frames_and_Frame_Types">12.4 帧和帧类型</a>
</h2>
<div class="content">
<p>如<a href="#Figure_11_QUIC_Payload">图11</a>所示，移除数据包保护后的QUIC数据包，其载荷由一系列完整的帧组成。版本协商数据包、无状态重置数据包和重试数据包中不包含帧。</p>
<div class="block ref" id="Figure_11_QUIC_Payload">
<pre tabindex="0"><code>数据包载荷 {
  帧 (8..) ...,
}
</code></pre><p><a href="#Figure_11_QUIC_Payload">图11：QUIC载荷</a></p>
</div>
<p>包含帧的数据包载荷<em><strong>必须</strong></em>包含至少1个帧，<em><strong>可以</strong></em>包含多个帧和多种帧类型。终端<em><strong>必须</strong></em>将接收到不包含帧的数据包的情况视作类型为<code>PROTOCOL_VIOLATION</code>（协议违背）的连接错误。帧总是能被放进单个QUIC数据包中且不能横跨多个数据包。</p>
<p>任何帧的开头都是表明其类型的帧类型字段，后面跟着额外的与类型相关的字段：</p>
<div class="block ref" id="Figure_12_Generic_Frame_Layout">
<pre tabindex="0"><code>帧 {
  帧类型 (i),
  与类型相关的字段 (..),
}
</code></pre><p><a href="#Figure_12_Generic_Frame_Layout">图12：通用的帧结构</a></p>
</div>
<p><a href="#Table_3_Frame_Types">表3</a>罗列并概述了有关本规范中定义的各种帧类型的信息。表后是对于这份概述的描述。</p>
<div class="block ref" id="Table_3_Frame_Types">
<table>
<thead>
<tr>
<th style="text-align:left">类型值</th>
<th style="text-align:left">帧类型名称</th>
<th style="text-align:left">定义</th>
<th style="text-align:left">数据包类型</th>
<th style="text-align:left">特殊规则</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">0x00</td>
<td style="text-align:left">填充帧</td>
<td style="text-align:left"><a href="#19.1_PADDING_Frames">第19.1章</a></td>
<td style="text-align:left">IH01</td>
<td style="text-align:left">NP</td>
</tr>
<tr>
<td style="text-align:left">0x01</td>
<td style="text-align:left">Ping帧</td>
<td style="text-align:left"><a href="#19.2_PING_Frames">第19.2章</a></td>
<td style="text-align:left">IH01</td>
<td></td>
</tr>
<tr>
<td style="text-align:left">0x02-0x03</td>
<td style="text-align:left">ACK帧</td>
<td style="text-align:left"><a href="#19.3_ACK_Frames">第19.3章</a></td>
<td style="text-align:left">IH_1</td>
<td style="text-align:left">NC</td>
</tr>
<tr>
<td style="text-align:left">0x04</td>
<td style="text-align:left">流重置帧</td>
<td style="text-align:left"><a href="#19.4_RESET_STREAM_Frames">第19.4章</a></td>
<td style="text-align:left">__01</td>
<td></td>
</tr>
<tr>
<td style="text-align:left">0x05</td>
<td style="text-align:left">停止发送帧</td>
<td style="text-align:left"><a href="#19.5_STOP_SENDING_Frames">第19.5章</a></td>
<td style="text-align:left">__01</td>
<td></td>
</tr>
<tr>
<td style="text-align:left">0x06</td>
<td style="text-align:left">加密帧</td>
<td style="text-align:left"><a href="#19.6_CRYPTO_Frames">第19.6章</a></td>
<td style="text-align:left">IH_1</td>
<td></td>
</tr>
<tr>
<td style="text-align:left">0x07</td>
<td style="text-align:left">新令牌帧</td>
<td style="text-align:left"><a href="#19.7_NEW_TOKEN_Frames">第19.7章</a></td>
<td style="text-align:left">___1</td>
<td></td>
</tr>
<tr>
<td style="text-align:left">0x08-0x0f</td>
<td style="text-align:left">流帧</td>
<td style="text-align:left"><a href="#19.8_STREAM_Frames">第19.8章</a></td>
<td style="text-align:left">__01</td>
<td style="text-align:left">F</td>
</tr>
<tr>
<td style="text-align:left">0x10</td>
<td style="text-align:left">最大数据量帧</td>
<td style="text-align:left"><a href="#19.9_MAX_DATA_Frames">第19.9章</a></td>
<td style="text-align:left">__01</td>
<td></td>
</tr>
<tr>
<td style="text-align:left">0x11</td>
<td style="text-align:left">最大流数据量帧</td>
<td style="text-align:left"><a href="#19.10_MAX_STREAM_DATA_Frames">第19.10章</a></td>
<td style="text-align:left">__01</td>
<td></td>
</tr>
<tr>
<td style="text-align:left">0x12-0x13</td>
<td style="text-align:left">最大流帧</td>
<td style="text-align:left"><a href="#19.11_MAX_STREAMS_Frames">第19.11章</a></td>
<td style="text-align:left">__01</td>
<td></td>
</tr>
<tr>
<td style="text-align:left">0x14</td>
<td style="text-align:left">数据阻塞帧</td>
<td style="text-align:left"><a href="#19.12_DATA_BLOCKED_Frames">第19.12章</a></td>
<td style="text-align:left">__01</td>
<td></td>
</tr>
<tr>
<td style="text-align:left">0x15</td>
<td style="text-align:left">流数据阻塞帧</td>
<td style="text-align:left"><a href="#19.13_STREAM_DATA_BLOCKED_Frames">第19.13章</a></td>
<td style="text-align:left">__01</td>
<td></td>
</tr>
<tr>
<td style="text-align:left">0x16-0x17</td>
<td style="text-align:left">流阻塞帧</td>
<td style="text-align:left"><a href="#19.14_STREAMS_BLOCKED_Frames">第19.14章</a></td>
<td style="text-align:left">__01</td>
<td></td>
</tr>
<tr>
<td style="text-align:left">0x18</td>
<td style="text-align:left">新连接ID帧</td>
<td style="text-align:left"><a href="#19.15_NEW_CONNECTION_ID_Frames">第19.15章</a></td>
<td style="text-align:left">__01</td>
<td style="text-align:left">P</td>
</tr>
<tr>
<td style="text-align:left">0x19</td>
<td style="text-align:left">撤销连接ID帧</td>
<td style="text-align:left"><a href="#19.16_RETIRE_CONNECTION_ID_Frames">第19.16章</a></td>
<td style="text-align:left">__01</td>
<td></td>
</tr>
<tr>
<td style="text-align:left">0x1a</td>
<td style="text-align:left">通道挑战帧</td>
<td style="text-align:left"><a href="#19.17_PATH_CHALLENGE_Frames">第19.17章</a></td>
<td style="text-align:left">__01</td>
<td style="text-align:left">P</td>
</tr>
<tr>
<td style="text-align:left">0x1b</td>
<td style="text-align:left">回复通道帧</td>
<td style="text-align:left"><a href="#19.18_PATH_RESPONSE_Frames">第19.18章</a></td>
<td style="text-align:left">___1</td>
<td style="text-align:left">P</td>
</tr>
<tr>
<td style="text-align:left">0x1c-0x1d</td>
<td style="text-align:left">连接关闭帧</td>
<td style="text-align:left"><a href="#19.19_CONNECTION_CLOSE_Frames">第19.19章</a></td>
<td style="text-align:left">ih01</td>
<td style="text-align:left">N</td>
</tr>
<tr>
<td style="text-align:left">0x1e</td>
<td style="text-align:left">握手完成帧</td>
<td style="text-align:left"><a href="#19.20_HANDSHAKE_DONE_Frames">第19.20章</a></td>
<td style="text-align:left">___1</td>
<td></td>
</tr>
</tbody>
</table>
<p><a href="#Table_3_Frame_Types">表3：帧类型</a></p>
</div>
<p>在<a href="#19_Frame_Types_and_Formats">第19章</a>中对各种帧类型的格式和语义进行了更详细的解释。本节的剩余部分对重要的和通用的信息做了概述。</p>
<p><strong>ACK帧</strong>、<strong>流帧</strong>、<strong>最大流帧</strong>、<strong>流阻塞帧</strong>和<strong>连接关闭帧</strong>中的帧类型字段额外携带着与帧相关的标志量。对其他帧来说，帧类型字段仅仅被用来区分帧类型。</p>
<p><a href="#Table_3_Frame_Types">表3</a>中的”数据包类型“一栏用以下字符表示每种帧类型可能出现在哪些数据包类型中：</p>
<dl>
<dt>I：</dt>
<dd>
<p>初始数据包（详见<a href="#17.2.2_Initial_Packet">第17.2.2章</a>）。</p>
</dd>
<dt>H：</dt>
<dd>
<p>握手数据包（详见<a href="#17.2.4_Handshake_Packet">第17.2.4章</a>）。</p>
</dd>
<dt>0：</dt>
<dd>
<p>0-RTT数据包（详见<a href="#17.2.3_0-RTT">第17.2.3章</a>）。</p>
</dd>
<dt>1：</dt>
<dd>
<p>1-RTT数据包（详见<a href="#17.3.1_1-RTT_Packet">第17.3.1章</a>）。</p>
</dd>
<dt>ih：</dt>
<dd>
<p>只有类型为<code>0x1c</code>的<strong>连接关闭帧</strong>能够出现在初始数据包或握手数据包中。</p>
</dd>
</dl>
<p>有关以上限制的细节，详见<a href="#12.5_Frames_and_Number_Spaces">第12.5章</a>。注意所有类型的帧都可以出现在1-RTT数据包中。终端<em><strong>必须</strong></em>将在某个类型的数据包中接收到该类型并不允许的帧的情况视作类型为<code>PROTOCOL_VIOLATION</code>的连接错误。</p>
<p><a href="#Table_3_Frame_Types">表3</a>的”特殊规则“一栏用以下字符表示了处理和创建各种类型的帧时遵循的特殊规则：</p>
<dl>
<dt>N：</dt>
<dd>
<p>如果数据包中包含的帧全都具有这个标记，那么这不是一个触发ACK的数据包，详见<a href="#13.2_Generating_Acknowledgments">第13.2章</a>。</p>
</dd>
<dt>C：</dt>
<dd>
<p>如果数据包中包含的帧全都具有这个标记，那么这个数据包不会被计入出于拥塞控制目的而计算的正在传输的字节数中，详见《<a href="../RFC9002_Chinese_Simplified">QUIC恢复</a>》。</p>
</dd>
<dt>P：</dt>
<dd>
<p>如果数据包中包含的帧全都具有这个标记，那么这个数据包可以在连接迁移期间被用于探测新的网络路径，详见<a href="#9.1_Probing_a_New_Path">第9.1章</a>。</p>
</dd>
<dt>F：</dt>
<dd>
<p>具有这种标记的帧的内容会受到流量控制，详见<a href="#4_Flow_Control">第4章</a>。</p>
</dd>
</dl>
<p><a href="#Table_3_Frame_Types">表3</a>的”数据包类型“和”特殊规则“并不出现在IANA注册表的QUIC帧类型中，详见<a href="#22.4_QUIC_Frame_Types_Registry">第22.4章</a>。</p>
<p>终端<em><strong>必须</strong></em>将接收到未知类型的帧的情况视作类型为<code>FRAME_ENCODING_ERROR</code>（帧编码错误）的连接错误。</p>
<p>本QUIC版本中所有类型的帧都是幂等的。也就是说，一个合法的帧即使被接收到多次，也不会引起意外的副作用或错误。</p>
<p>帧类型字段使用可变长度整型编码（详见<a href="#16_Variable-Length_Integer_Encoding">第16章</a>），但有一个例外。为了确保帧解析的实现简单且高效，帧类型<em><strong>必须</strong></em>使用最短的编码长度。对于这份文档中定义的帧类型来说，这意味着哪怕将这些值编码到双字节、四字节甚至八字节可变长度整型都是可行的，也要使用单字节编码。例如，尽管<code>0x4001</code>是值<code>1</code>在双字节下合法的可变长度整形编码，<strong>Ping帧</strong>的帧类型也总是被编码到值为<code>0x01</code>的单个字节。这条规则适用于所有目前的和将来的QUIC帧类型。如果终端收到的帧类型使用了比最低限度所需要长的编码，那么终端<em><strong>可以</strong></em>将此情况视作类型为<code>PROTOCOL_VIOLATION</code>的连接错误。</p>
</div>
</section>
<section class="page" id="12.5_Frames_and_Number_Spaces">
<h2>
<a href="#12.5_Frames_and_Number_Spaces">12.5 帧和数据包号空间</a>
</h2>
<div class="content">
<p>有一些类型的帧在某些数据包号空间中是被禁止的。这里的规则概述了TLS的规则，即与建立连接有关的帧通常能出现在任何数据包号空间的数据包中，而与传输数据有关的帧只能出现在应用数据空间中。</p>
<ul>
<li>
<p><strong>填充帧</strong>、<strong>Ping帧</strong>和<strong>加密帧</strong><em><strong>可以</strong></em>出现在任何数据包号空间中。</p>
</li>
<li>
<p>标志着QUIC层错误（类型为<code>0x1c</code>）的<strong>连接关闭帧</strong><em><strong>可以</strong></em>出现在任何数据包号空间中。标志着应用错误（类型为<code>0x1d</code>）的<strong>连接关闭帧</strong><em><strong>必须</strong></em>只能出现在应用数据空间中。</p>
</li>
<li>
<p><strong>ACK帧</strong><em><strong>可以</strong></em>出现在任何数据包号空间中，但是只能确认在同一个数据包号空间中的数据包。然而，如下文所述，0-RTT数据包不能包含<strong>ACK帧</strong>。</p>
</li>
<li>
<p>所有其他类型的帧<em><strong>必须</strong></em>只能出现在应用数据空间中。</p>
</li>
</ul>
<p>注意，不管出于什么理由，都不能在0-RTT数据包中发送以下类型的帧：<strong>ACK帧</strong>、<strong>加密帧</strong>、<strong>握手完成帧</strong>、<strong>新令牌帧</strong>、<strong>回复通道帧</strong>和<strong>撤销连接ID帧</strong>。服务器<em><strong>可以</strong></em>将在0-RTT数据包中接收到以上帧的情况视作类型为<code>PROTOCOL_VIOLATION</code>的连接错误。</p>
</div>
</section>
<section class="page" id="13_Packetization_and_Reliability">
<h1>
<a href="#13_Packetization_and_Reliability">13. 分包与可靠性</a>
</h1>
<div class="content">
<p>发送方可以在一个QUIC数据包中发送一个或多个帧，详见<a href="#12.4_Frames_and_Frame_Types">第12.4章</a>。</p>
<p>发送方可以通过在每个QUIC数据包中包含尽可能多的帧来最小化每个数据包消耗的带宽和计算资源。在发送一个被未完全利用的数据包前，发送方<em><strong>可以</strong></em>短暂等待一会，多收集几个帧，以避免发送出大量的小型数据包。QUIC实现<em><strong>可以</strong></em>使用有关应用发送习惯的知识或启发式的方法来决定要不要等和等多久。这一等待时间的长短是一个由QUIC实现做的决策，同时实现应该小心地保守地进行等待，因为任何等待都有可能增加应用所察觉到的延迟量。</p>
<p>流的多路复用是通过将来自多个流的<strong>流帧</strong>交错至一个或多个QUIC数据包中来实现的。单个QUIC数据包可以包含来自一个或多个流的数个<strong>流帧</strong>。</p>
<p>使用QUIC的益处之一是能避免复数流间的队头阻塞问题。当出现丢包时，只有那个数据包中的数据所属的流会被阻塞住并等待收到重传的数据，而其他流能够继续传输。注意，当单个QUIC数据包中包含来自多个流的数据时，丢失那个数据包将阻塞所有有关的流的传输。建议QUIC实现在发出去的数据包中包含尽可能少的流，来避免降低这些未完全利用的数据包的传输效率。</p>
</div>
</section>
<section class="page" id="13.1_Packet_Processing">
<h2>
<a href="#13.1_Packet_Processing">13.1 数据包处理</a>
</h2>
<div class="content">
<p>在数据包保护被成功移除且所有包含在数据包中的帧都被处理之前，<em><strong>必须不</strong></em>确认这个数据包。对于<strong>流帧</strong>，这个时机指其中的数据已经被置入队列，且准备被应用协议接收之时，但它不要求数据被分发和消费。</p>
<p>一旦数据包已经被完全处理，接收方通过发送一个或多个<strong>ACK帧</strong>来确认这个数据包的接收，这些<strong>ACK帧</strong>中包含被接收到的这个数据包的数据包号。</p>
<p>如果终端有能力检测出收到了一个它未发送过的数据包的确认的情况，它<em><strong>应该</strong></em>将这种情况视作一种类型为<code>PROTOCOL_VIOLATION</code>（协议违背）的错误。有关如何做到这件事，详见<a href="#21.4_Optimistic_ACK_Attack">第21.4章</a>。</p>
</div>
</section>
<section class="page" id="13.2_Generating_Acknowledgments">
<h2>
<a href="#13.2_Generating_Acknowledgments">13.2 生成确认</a>
</h2>
<div class="content">
<p>终端对所有它们接收到和处理过的数据包进行确认。然而，只有ACK触发包要求在最大的确认延迟之内发送一个<strong>ACK帧</strong>。对于不触发ACK的数据包，只有出于其他原因发送<strong>ACK帧</strong>时，才会确认它们。</p>
<p>当出于任何原因发送数据包时，如果最近没有发送过<strong>ACK帧</strong>，那么终端<em><strong>应该</strong></em>尝试包含一个这种帧。这么做有助于对端进行及时的丢包检测。</p>
<p>通常来说，如果一个接收方对每一个ACK触发包都响应一个<strong>ACK帧</strong>，那么这些来自接收方的频繁反馈可以改善丢包和拥塞响应，但这必须与它产生的额外负载相平衡。下文提供的指导旨在取得这种平衡。</p>
</div>
</section>
<section class="page" id="13.2.1_Sending_ACK_Frames">
<h3>
<a href="#13.2.1_Sending_ACK_Frames">13.2.1 发送ACK帧</a>
</h3>
<div class="content">
<p>所有数据包都<em><strong>应该</strong></em>被确认至少一次，ACK触发包<em><strong>必须</strong></em>在终端使用传输参数<code>max_ack_delay</code>（最大ACK延迟）沟通的最大延迟时间内被确认至少一次，详见<a href="#18.2_Transport_Parameter_Definitions">第18.2章</a>。<code>max_ack_delay </code>声明了一个显式的约定：终端承诺不会故意拖延<strong>ACK触发包</strong>的确认以致延迟时间超过那个约定值。如果它这么做了，那么超出量会积累到RTT预估值上，并且导致来自对端的无效的或延迟的重传。发送方使用接收方的<code>max_ack_delay</code>值来决定基于计时器的重传的超时时间，详见《<a href="../RFC9002_Chinese_Simplified">QUIC恢复</a>》的<a href="../RFC9002_Chinese_Simplified/#6.2_Probe_Timeout">第6.2章</a>。</p>
<p>除了以下例外，终端<em><strong>必须</strong></em>立即确认所有引发确认的初始数据包和握手数据包，并且在它宣告的<code>max_ack_delay</code>之内确认所有引发确认的0-RTT数据包和1-RTT数据包。终端如果在握手确认前就收到了握手数据包、0-RTT数据包和1-RTT数据包，那么它可能还没有用来解密这些数据包的数据包保护密钥。因此它可以缓存这些数据包，等得到了必要的密钥再确认它们。</p>
<p>由于仅包含<strong>ACK帧</strong>的数据包不受拥塞控制，终端在响应一个ACK触发包时，<em><strong>必须不</strong></em>发送超过一个这样的数据包。</p>
<p>终端在响应非ACK触发包时，<em><strong>必须不</strong></em>发送非ACK触发包，即便在接收到的数据包前存在数据包空档。这避免了用确认响应确认的无限循环，避免连接无法进入空闲状态。非ACK触发包最终会在终端响应其他事件而发送的<strong>ACK帧</strong>中被确认。</p>
<p>一味发送<strong>ACK帧</strong>的终端不会从对端收到确认，除非这些帧和ACK触发帧一起被包含在数据包中。当有新的ACK触发包要确认时，终端<em><strong>应该</strong></em>将这些<strong>ACK帧</strong>一块发送。当只有非ACK触发包要确认时，终端<em><strong>可以</strong></em>选择等接收到一个ACK触发包时再将这些<strong>ACK帧</strong>一块发送。</p>
<p>只发送非ACK触发包的终端可以选择偶尔添加一个ACK触发帧到这些数据包中以确保它能收到确认，详见<a href="#13.2.4_Limiting_Ranges_by_Tracking_ACK_Frames">第13.2.4章</a>。在那种情况下，终端<em><strong>必须不</strong></em>在所有本来不引发确认的数据包中都添加ACK触发帧，以避免用确认响应确认的无限循环。</p>
<p>为了辅助发送方的丢包检测，在以下情况中若收到一个ACK触发包，终端<em><strong>应该</strong></em>立即生成并发送<strong>ACK帧</strong>：</p>
<ul>
<li>
<p>当接收到的数据包的数据包号小于另一个已经被接收到的ACK触发包的时；</p>
</li>
<li>
<p>当接收到的数据包的数据包号大于已接收到的ACK触发包的数据包号最大值，且在它们之间有缺失的数据包时。</p>
</li>
</ul>
<p>类似地，标记了IP头部的ECN拥塞预警（CE）码点的数据包<em><strong>应该</strong></em>被立即确认，以减少对端对拥塞事件的响应时间。</p>
<p>对没有遵守以上指导的接收方，《<a href="../RFC9002_Chinese_Simplified">QUIC恢复</a>》中的算法应当是能适应的。即使如此，QUIC实现也应该在谨慎地考虑任何变更会对性能的影响之后，再违背这些要求，既要考虑对终端建立的连接的性能影响，也要考虑对网络中其他用户的性能影响。</p>
</div>
</section>
<section class="page" id="13.2.2_Acknowledgment_Frequency">
<h3>
<a href="#13.2.2_Acknowledgment_Frequency">13.2.2 确认频率</a>
</h3>
<div class="content">
<p>作为ACK触发包的响应而发送的确认，其频率是由接收方决定的。这个决策包含了一种权衡。</p>
<p>终端依靠及时的确认以检测丢包，详见《<a href="../RFC9002_Chinese_Simplified">QUIC恢复</a>》的<a href="../RFC9002_Chinese_Simplified/#6_Loss_Detection">第6章</a>。基于窗口的拥塞控制器，例如《<a href="../RFC9002_Chinese_Simplified">QUIC恢复</a>》的<a href="../RFC9002_Chinese_Simplified/#7_Congestion_Control">第7章</a>中描述的那个，依靠确认来管理它们的拥塞窗口。在这两种情况中，延迟确认都会对性能产生不利影响。</p>
<p>另一方面，降低仅携带确认的数据包的频率能同时减少两个终端在传输和处理上的资源消耗。它能提高在极端不对称的链路上的连接吞吐量，并使用返回路径的容量来减少因确认而产生的流量，详见《<a href="https://www.rfc-editor.org/info/rfc3449">RFC3449</a>》的<a href="https://www.rfc-editor.org/rfc/rfc3449.html#section-3">第3章</a>。</p>
<p>接收方在接收到至少两个ACK触发包后<em><strong>应该</strong></em>发送一个ACK帧。这一推荐做法本质上是通用的，并且和TCP终端行为（《<a href="https://www.rfc-editor.org/info/rfc5681">RFC5681</a>》）的推荐做法是一致的。有关网络条件的知识、有关对端拥塞控制器的知识或将来的研究和实验可能建议替代本做法的有着更好的性能特征的确认策略。</p>
<p>接收方<em><strong>可以</strong></em>在决定是否要发送<strong>ACK帧</strong>作为响应前先处理掉几个可用的数据包。</p>
</div>
</section>
<section class="page" id="13.2.3_Managing_ACK_Ranges">
<h3>
<a href="#13.2.3_Managing_ACK_Ranges">13.2.3 管理ACK块</a>
</h3>
<div class="content">
<p>被发送的<strong>ACK帧</strong>中包含一个或多个已确认数据包的块。包含对更早期的数据包的确认减少了因之前发送的<strong>ACK帧</strong>丢包而引起无效重传的可能性，代价是<strong>ACK帧</strong>会变得更大。</p>
<p><strong>ACK帧</strong><em><strong>应该</strong></em>始终确认最近接收到的数据包，同时接收到的数据包越是乱序，尽快发送更新后的<strong>ACK帧</strong>就越是重要，以避免对端将某个数据包认定为丢包而对其中包含的帧进行无效的重传。一个<strong>ACK帧</strong>应当能被放进单个QUIC数据包中。如果不能，那么更早期的块（有着最小的数据包号的那些）会被省略。</p>
<p>接收方限制它记录的ACK块（详见<a href="#19.3.1_ACK_Ranges">第19.3.1章</a>）的数量和在<strong>ACK帧</strong>中发送的ACK块的数量，这既是为了限制ACK帧的尺寸也是为了避免耗尽资源。在接收到对一个<strong>ACK帧</strong>的确认后，接收方<em><strong>应该</strong></em>停止追踪那些在帧中被确认的ACK块。发送方可以期待绝大多数数据包都被确认，但是QUIC不保证接收方处理的所有数据包的确认都被对端接收到。</p>
<p>因保留了许多ACK块而使得<strong>ACK帧</strong>变得过大是有可能的。接收方可以丢弃未被确认的ACK块以限制<strong>ACK帧</strong>的尺寸，代价是来自发送方的更多重传。如果一个ACK帧大到放不进一个数据包中，那么就有必要这么做。接收方还<em><strong>可以</strong></em>进一步限制<strong>ACK帧</strong>的尺寸来为其他帧腾出空间，或为了限制确认所消耗的数据包容量。</p>
<p>除非接收方能确信它后续接收到的数据包号不会落在某个ACK块中，否则它<em><strong>必须</strong></em>保留那个块。使用最少的状态来做到这一点的方法之一是维护一个最小的数据包号，它会随着块被丢弃而增大。</p>
<p>接收方可以丢弃所有ACK块，但是<em><strong>必须</strong></em>保留最大的已被成功处理的数据包号，因为它被用于从后续数据包中恢复数据包号，详见<a href="#17.1_Packet_Number_Encoding_and_Decoding">第17.1章</a>。</p>
<p>接收方<em><strong>应该</strong></em>在所有<strong>ACK帧</strong>中包含最大的已接收到的数据包号。这个最大确认数字段被用于在发送方一侧进行的ECN验证，使用一个比先前发送的<strong>ACK帧</strong>中的更小的值会造成ECN被不必要地禁用，详见<a href="#13.4.2_ECN_Validation">第13.4.2章</a>。</p>
<p><a href="#13.2.4_Limiting_Ranges_by_Tracking_ACK_Frames">第13.2.4章</a>描述了一个如何决定在各个<strong>ACK帧</strong>中分别确认哪些数据包的示例方法。尽管这个算法的目标是为每个已处理的数据包生成一个确认，但是确认依旧有可能遭遇丢包。</p>
</div>
</section>
<section class="page" id="13.2.4_Limiting_Ranges_by_Tracking_ACK_Frames">
<h3>
<a href="#13.2.4_Limiting_Ranges_by_Tracking_ACK_Frames">13.2.4 通过追踪ACK帧来限制块</a>
</h3>
<div class="content">
<p>当发送包含某个<strong>ACK帧</strong>的数据包时，可以记录那个帧中的最大确认数。当接收到包含某个<strong>ACK帧</strong>的数据包的确认时，如果某个数据包的数据包号小于等于为那个<strong>ACK帧</strong>记录的最大确认数，那么接收方就可以不再确认这个数据包。</p>
<p>只发送非ACK触发包，例如<strong>ACK帧</strong>，的接收方可能很长一段时间都接收不到确认。这会导致接收方需要为大量ACK帧的状态维护很长一段时间，同时它发送的<strong>ACK帧</strong>会不必要地变得特别大。在这种情况下，接收方可以偶尔，比如每经过一轮往返时间就进行一次，发送一个<strong>Ping帧</strong>或其他小型的ACK触发帧，来引发来自对端的ACK帧。</p>
<p>在<strong>ACK帧</strong>没有遇到丢包的情况下，这个算法在每至少1RTT内提供一次重排ACK块的机会。在<strong>ACK帧</strong>遇到丢包和乱序的情况下，这个方法并不能保证所有确认都在它们不再被包含进<strong>ACK帧</strong>前就被发送方接收到。数据包还有可能在接收时已经被打乱顺序，或者所有后续包含它们的数据包号的<strong>ACK帧</strong>都遇到丢包。在这种情况下，丢包恢复算法可能引起无效的重传，但是发送方会继续进行有效的传输。</p>
</div>
</section>
<section class="page" id="13.2.5_Measuring_and_Reporting_Host_Delay">
<h3>
<a href="#13.2.5_Measuring_and_Reporting_Host_Delay">13.2.5 测量和报告主机延迟</a>
</h3>
<div class="content">
<p>从具有最大数据包号的数据包被接收到的那一刻起，到对于它的确认被发送时，这期间的时间会作为一个被有意引入的延迟而被终端测量。终端将这个确认延迟编码在<strong>ACK帧</strong>的ACK延迟字段，详见<a href="#19.3_ACK_Frames">第19.3章</a>。这使得这个<strong>ACK帧</strong>的接收方能够获知这些有意引入的延迟并作出调整，当确认出现延误时这一调整对更好地评估路径RTT是很重要的。</p>
<p>在得到处理前，数据包可能被暂留在操作系统内核或主机的其他什么地方。在填写<strong>ACK帧</strong>的ACK延迟字段时，终端<em><strong>必须不</strong></em>在值中包括不受它控制的延迟。然而，终端<em><strong>应该</strong></em>在值中包含由缺少解密密钥造成的缓存延迟，因为这些延迟可以变得很大，而且有可能是非重复出现的。</p>
<p>当测量到的确认延迟比<code>max_ack_delay</code>大时，终端<em><strong>应该</strong></em>报告这个测量到的延迟。这个信息在握手期间延迟可能会很大的情况下是特别有用的，详见<a href="#13.2.1_Sending_ACK_Frames">第13.2.1章</a>。</p>
</div>
</section>
<section class="page" id="13.2.6_ACK_Frames_and_Packet_Protection">
<h3>
<a href="#13.2.6_ACK_Frames_and_Packet_Protection">13.2.6 ACK帧和数据包保护</a>
</h3>
<div class="content">
<p><strong>ACK帧</strong><em><strong>必须</strong></em>被携带于一个和正在确认的数据包的数据包号空间相同的数据包中，详见<a href="#12.1_Protected_Packets">第12.1章</a>。举个例子，受1-RTT密钥保护的数据包<em><strong>必须</strong></em>在同样被1-RTT密钥保护的数据包中被确认。</p>
<p>客户端发送的受0-RTT数据包保护的数据包<em><strong>必须</strong></em>被服务器在受1-RTT密钥保护的数据包中确认。这意味着如果服务器的加密握手消息被延误或丢失，则客户端有可能无法使用这些确认。注意，同样的限制还适用于服务器发送的受1-RTT密钥保护的其他数据。</p>
</div>
</section>
<section class="page" id="13.2.7_PADDING_Frames_Consume_Congestion_Window">
<h3>
<a href="#13.2.7_PADDING_Frames_Consume_Congestion_Window">13.2.7 填充帧消耗拥塞窗口</a>
</h3>
<div class="content">
<p>包含<strong>填充帧</strong>的数据包会被纳入拥塞控制的考量，详见《<a href="../RFC9002_Chinese_Simplified">QUIC恢复</a>》。而仅仅包含<strong>填充帧</strong>的数据包虽然会消耗拥塞窗口但是不会引发确认来恢复拥塞窗口。为了避免死锁，发送方<em><strong>应该</strong></em>确保每隔一段时间会发送一次除<strong>填充帧</strong>外的其他帧，来引发来自接收方的确认。</p>
</div>
</section>
<section class="page" id="13.3_Retransmission_of_Information">
<h2>
<a href="#13.3_Retransmission_of_Information">13.3 信息重传</a>
</h2>
<div class="content">
<p>被认定丢包的QUIC数据包不会被整个重传。被丢包的数据包中包含的帧也是这样。取而代之的是这些帧中可能携带的信息会按照需要在新的帧中被再次发送。</p>
<p>携带被认定为丢失的信息时，使用新的帧和数据包。一般来说，信息会在携带它的数据包被认定为丢包时被再次发送，同时当携带那个信息的数据包被确认时发送即停止。</p>
<ul>
<li>
<p>在<strong>加密帧</strong>中的数据按照《<a href="../RFC9002_Chinese_Simplified">QUIC恢复</a>》中的规则重新传输，直到所有数据都已被确认。当有关数据包号空间的密钥被弃用时，初始数据包和握手数据包的<strong>加密帧</strong>中的数据会被丢弃。</p>
</li>
<li>
<p>原本在<strong>流帧</strong>中发送的应用数据会在新的<strong>流帧</strong>被重传，除非终端已经为那条流发送了<strong>流重置帧</strong>。一旦终端发送了<strong>流重置帧</strong>，就不再需要发送<strong>流帧</strong>。</p>
</li>
<li>
<p>ACK帧携带最近的一系列确认和来自最大已确认数据包的确认延迟，如<a href="#13.2.1_Sending_ACK_Frames">第13.2.1章</a>所述。延误包含<strong>ACK帧</strong>的数据包的传输或重发旧的<strong>ACK帧</strong>会使得对端生成过高的RTT样本或不必要地禁用ECN。</p>
</li>
<li>
<p>流传输的中止信息只有在携带它的<strong>流重置帧</strong>被确认前且在所有流数据都被对端确认（也就是流的发送方进入“重置接收”或“接收完成”状态）前才能被发送。当再次发送时<em><strong>必须不</strong></em>改变<strong>流重置帧</strong>的内容。</p>
</li>
<li>
<p>类似地，被编码在<strong>停止发送帧</strong>帧中的取消流传输的请求，只有在流的接收方进入“接收完成”或“重置接收”状态前才能被发送，详见<a href="#3.5_Solicited_State_Transitions">第3.5章</a>。</p>
</li>
<li>
<p>当数据包丢包被检测到时，连接关闭的信号，包括那些包含<strong>连接关闭帧</strong>的数据包，不会被再次发送。有关重发这些信号，详见<a href="#10_Connection_Termination">第10章</a>。</p>
</li>
<li>
<p>当前连接的最大数据量是使用<strong>最大数据量帧</strong>发送的。如果包含最近发送的<strong>最大数据量帧</strong>的数据包被认定丢包或终端决定更新限制，那么更新后的值还是使用<strong>最大数据量帧</strong>发送。由于限制可以被频繁提高而造成大量不必要的<strong>最大数据量帧</strong>被发送出去，必须小心以避免过于频繁地发送这种帧，详见<a href="#4.2_Increasing_Flow_Control_Limits">第4.2章</a>。</p>
</li>
<li>
<p>当前最大流数据偏移量是使用<strong>最大流数据量帧</strong>发送的。像<strong>最大数据量帧</strong>一样，如果包含最近的<strong>最大流数据量帧</strong>的数据包遭遇丢包或限制被更新，那么就要发送更新后的值，并且小心以避免过于频繁地发送此类帧。当流的接收方进入“数据量确认”或“重置接收”状态时，终端<em><strong>应该</strong></em>不再发送<strong>最大流数据量帧</strong>。</p>
</li>
<li>
<p>对给定类型的流的限制是使用<strong>最大流帧</strong>发送的。像<strong>最大数据量帧</strong>一样，如果对于给定的流类型，包含其最近的<strong>最大流帧</strong>的数据包被认定丢包或限制被更新，那么就要发送更新后的值，并且小心以避免过于频繁地发送此类帧。</p>
</li>
<li>
<p>阻塞信号是在<strong>流阻塞帧</strong>、<strong>流数据阻塞帧</strong>和<strong>流阻塞帧</strong>中被携带的。<strong>流阻塞帧</strong>是连接层面上的，<strong>流数据阻塞帧</strong>是流层面上的，而<strong>流阻塞帧</strong>是在某种特定的流层面上的。当包含某一层面上的最近的上述帧的数据包遭遇丢包且仅当终端被阻塞于相应限制时，才发送一个新的帧。这些帧总是包含那个引起阻塞的限制在这些帧被传输时的值。</p>
</li>
<li>
<p>使用<strong>通道挑战帧</strong>的存活确认或路径验证检查每隔一段时间被发送一次，直到接收到与之匹配的<strong>回复通道帧</strong>或已经没有必要再做存活确认或路径验证检查。每次发送<strong>通道挑战帧</strong>时都使用不同的载荷。</p>
</li>
<li>
<p>响应路径验证时使用<strong>回复通道帧</strong>且仅发送一次。对端应当根据需要发送更多<strong>通道挑战帧</strong>来唤起额外的<strong>回复通道帧</strong>。</p>
</li>
<li>
<p>新的连接ID是使用<strong>新连接ID帧</strong>发送的，如果包含它们的数据包遭遇丢包，依旧用这种帧重传。这种帧重传时携带相同序列数值。类似地，撤销连接ID的信息是在<strong>撤销连接ID帧</strong>中被发送的，如果包含它们的数据包遭遇丢包，依旧用这种帧重传。</p>
</li>
<li>
<p><strong>新令牌帧</strong>在包含它们的数据包遭遇丢包时会被重传。除了直接比较帧的内容之外，没有提供特殊的方法来检测乱序和重复的<strong>新令牌帧</strong>。</p>
</li>
<li>
<p><strong>Ping帧</strong>和<strong>填充帧</strong>不包含信息，因此丢失的这两种帧不需要修复。</p>
</li>
<li>
<p><strong>握手完成帧</strong><em><strong>必须</strong></em>被重传，除非它已经被确认了。</p>
</li>
</ul>
<p>终端<em><strong>应该</strong></em>使数据重传优先于新数据发送，除非应用指定的优先级表明了相反的策略，详见<a href="#2.3_Stream_Prioritization">第2.3章</a>。</p>
<p>尽管鼓励发送方每次发送数据包时都使用最新的信息来装配帧，但是重传从丢包的数据包中拷贝来的帧数据这一行为并未被禁止。重传帧拷贝的发送方需要解决可用载荷大小上的降低，这是由数据包号长度、连接ID长度和路径MTU上的变化引起的。如果一个数据包包含了过时的帧，比如一个携带着比先前数据包中的值更小的最大数据量的<strong>最大数据量帧</strong>，那么接收方<em><strong>必须</strong></em>接收它们。</p>
<p>只要数据包已经被确认，发送方就<em><strong>应该</strong></em>避免重传来自这些数据包的信息。这包含数据包在被认定为丢包后又被确认的情况，这种情况会因为网络重排序而发生。这么做需要发送方在数据包被认定为丢包后保留有关它们的信息。发送方可以在丢弃此信息前保留一段足以允许重排序的时间，例如一个PTO（详见《<a href="../RFC9002_Chinese_Simplified">QUIC恢复</a>》的<a href="../RFC9002_Chinese_Simplified/#6.2_Probe_Timeout">第6.2章</a>），或基于其他事件做决定，例如到达内存限制。</p>
<p>在丢包检测时，发送方<em><strong>必须</strong></em>采取合适的拥塞控制措施。有关丢包检测和拥塞控制的细节，详见《<a href="../RFC9002_Chinese_Simplified">QUIC恢复</a>》。</p>
</div>
</section>
<section class="page" id="13.4_Explicit_Congestion_Notification">
<h2>
<a href="#13.4_Explicit_Congestion_Notification">13.4 显式拥塞通知</a>
</h2>
<div class="content">
<p>QUIC终端使用ECN（显式拥塞通知，详见《<a href="https://www.rfc-editor.org/info/rfc3168">RFC3168</a>》）来检测和响应网络拥塞。ECN允许终端在一个IP数据包的ECN字段中设置<code>ECN-Capable Transport</code>（<code>ECT</code>）码点。随后网络节点可以用设置ECN字段的<code>ECN-CE</code>码点的方法来表示拥塞，而不是直接丢弃数据包（详见《<a href="https://www.rfc-editor.org/info/rfc8087">RFC8087</a>》）。作为响应，终端通过降低发送速率来应对被对端报告的拥塞情况，详见《<a href="../RFC9002_Chinese_Simplified">QUIC恢复</a>》。</p>
<p>要启用ECN，要发送数据的QUIC终端首先判断一条路径是否支持ECN标记，还要判断对端是否会报告在IP头部接收到的ECN值，详见<a href="#13.4.2_ECN_Validation">第13.4.2章</a>。</p>
</div>
</section>
<section class="page" id="13.4.1_Reporting_ECN_Counts">
<h3>
<a href="#13.4.1_Reporting_ECN_Counts">13.4.1 报告ECN计数</a>
</h3>
<div class="content">
<p>要使用ECN，要求接收数据的终端从IP数据包读取ECN字段，但这不是在所有平台上都能做得到的。如果一个终端没有实现对ECN的支持或访问不了接收到的ECN字段，它就不会为它接收到的数据包报告ECN计数。</p>
<p>即使终端不会在它发送的数据包中设置ECN字段，它也<em><strong>必须</strong></em>为它接收到ECN标记提供反馈，除非访问不了。不报告ECN计数会使得发送方为这条连接禁用ECN。</p>
<p>当接收到一个具有<code>ECT(0)</code>、<code>ECT(1)</code>或<code>ECN-CE</code>码点的IP数据包，一个启用ECN的终端访问ECN字段并增加相应的<code>ECT(0)</code>、<code>ECT(1)</code>或<code>ECN-CE</code>计数。这些ECN计数会被包含在后续<strong>ACK帧</strong>中，详见<a href="#13.2_Generating_Acknowledgments">第13.2章</a>和<a href="#19.3_ACK_Frames">第19.3章</a>。</p>
<p>每个数据包号空间维护单独的确认状态和单独的ECN计数。被合并的QUIC数据包（详见<a href="#12.2_Coalescing_Packets">第12.2章</a>）共享相同的IP头部，所以每个被合并的QUIC数据包对应的ECN计数都要增加。</p>
<p>举例来说，若将QUIC的初始数据包、握手数据包和1-RTT数据包各一个合并至单个UDP数据报中，那么这三个数据包号空间的ECN计数都要分别基于同一个的IP头部的ECN字段来增加。</p>
<p>ECN计数仅当来自接收到的IP数据包的QUIC数据包被处理时才增加。于是，重复的QUIC数据包不会被处理所以就不会增加ECN计数；有关安全考量，详见<a href="#21.10_Explicit_Congestion_Notification_Attacks">第21.10章</a>。</p>
</div>
</section>
<section class="page" id="13.4.2_ECN_Validation">
<h3>
<a href="#13.4.2_ECN_Validation">13.4.2 ECN验证</a>
</h3>
<div class="content">
<p>故障的网络设备可能损坏或错误地丢弃携带非零ECN码点的数据包。为了在有这类设备存在的前提下确保连接，终端为每条网络路径验证ECN计数，并当检测到错误时在那条路径上禁用ECN。</p>
<p>要为一条新路径进行ECN验证：</p>
<ul>
<li>
<p>对于在一条新路径上发向对端的出站数据包，终端在早期的几个数据包的IP头部设置一个<code>ECT(0)</code>码点。</p>
</li>
<li>
<p>终端观察是否所有具有<code>ECT</code>码点的数据包最终都被视为丢包（详见《<a href="../RFC9002_Chinese_Simplified">QUIC恢复</a>》的<a href="../RFC9002_Chinese_Simplified/#6_Loss_Detection">第6章</a>），若是则表明ECN验证失败了。</p>
</li>
</ul>
<p>如果终端怀疑一个故障的网络设备正在丢弃具有<code>ECT</code>码点的IP数据包，那么它可以为路径上仅前十个出站数据包设置<code>ECT</code>码点，或以每三个PTO（详见《<a href="../RFC9002_Chinese_Simplified">QUIC恢复</a>》的<a href="../RFC9002_Chinese_Simplified/#6.2_Probe_Timeout">第6.2章</a>）一次的间隔设置。如果所有标记为非零ECN码点的数据包都接连遭遇丢包，那么它就可以基于标记行为会引发丢包的假设来禁用标记。</p>
<p>就这样，终端尝试为每一条新连接使用ECN并做验证，这包括切换到服务器的首选地址时和从活跃连接迁移到新路径时。<a href="#A.4_Sample_ECN_Validation_Algorithm">附录A.4</a>描述了一种可行的算法。</p>
<p>可能存在其他探测路径是否支持ECN的方法以及不同的标记策略。QUIC实现<em><strong>可以</strong></em>使用定义在RFC中的其他方法，详见《<a href="https://www.rfc-editor.org/info/rfc8311">RFC8311</a>》。使用了<code>ECT(1)</code>码点的实现需要用报告的<code>ECT(1)</code>计数进行ECN验证。</p>
</div>
</section>
<section class="page" id="13.4.2.1_Receiving_ACK_Frames_with_ECN_Counts">
<h4>
<a href="#13.4.2.1_Receiving_ACK_Frames_with_ECN_Counts">13.4.2.1 接收具有ECN计数的ACK帧</a>
</h4>
<div class="content">
<p>被网络错误地使用的<code>ECN-CE</code>标记会造成连接性能低下。因此接收到具有ECN计数的<strong>ACK帧</strong>的终端在使用前要验证它们。终端用比较新接收到的计数和那些在最近成功处理了的<strong>ACK帧</strong>中的计数的方法进行这项验证。任何在ECN计数上的增加都会被验证，这项验证基于被应用到最近在<strong>ACK帧</strong>中被确认的原始数据包上的ECN标记。</p>
<p>如果一个<strong>ACK帧</strong>最近确认了一个由终端发送的数据包且这个数据包被设置了<code>ECT(0)</code>或<code>ECT(1)</code>码点，同时相应的ECN计数并未在这个<strong>ACK帧</strong>中出现，那么ECN验证就会失败。这项检查能够检测出将ECN字段归零的网络元素或并不报告ECN标记的对端。</p>
<p>如果<code>ECT(0)</code>计数和<code>ECN-CE</code>计数的增加量的总和小于被新确认的且发送时具有<code>ECT(0)</code>标记的数据包的数量，那么ECN验证也会失败。类似地，如果<code>ECT(1)</code>计数和<code>ECN-CE</code>计数的增加量的总和小于被新确认的且发送时具有<code>ECT(1)</code>标记的数据包的数量，那么ECN验证也会失败。这些检查可以检测网络重设<code>ECN-CE</code>标记的行为。</p>
<p>在<strong>ACK帧</strong>有可能丢失的情况下，终端允许忽略对某个数据包的确认。因此<code>ECT(0)</code>、<code>ECT(1)</code>和<code>ECN-CE</code>的增加量的总和大于被一个<strong>ACK帧</strong>新确认的的数据包数量是有可能的。这就是为什么允许ECN计数大于被确认的数据包的总数。</p>
<p>为经过重排序的<strong>ACK帧</strong>验证ECN计数，其结果是不准确的。终端<em><strong>必须不</strong></em>因为处理一个没有增加最大已确认数据包号的<strong>ACK帧</strong>而将ECN验证结果记为失败。</p>
<p>如果接收到的<code>ECT(0)</code>或<code>ECT(1)</code>中任意一个的总计数，超过了已发送的具有的相应<code>ECT</code>码点的数据包总数，ECN验证就会失败。特别是，当终端接收到一个非零的ECN计数但那个相应的<code>ECT</code>码点从未使用过，验证就应失败。这项检查可以检测网络重设数据包的<code>ECT(0)</code>和<code>ECT(1)</code>的行为。</p>
</div>
</section>
<section class="page" id="13.4.2.2_ECN_Validation_Outcomes">
<h4>
<a href="#13.4.2.2_ECN_Validation_Outcomes">13.4.2.2 ECN验证结果</a>
</h4>
<div class="content">
<p>如果验证失败，那么终端<em><strong>必须</strong></em>禁用ECN。它在发送的IP数据包中不会再设置<code>ECT</code>码点，就当作网络路径或对端不支持ECN。</p>
<p>即使验证失败，终端也<em><strong>可以</strong></em>在连接中的任意时间对相同的路径重新验证ECN。终端可以继续定期尝试验证。</p>
<p>当验证成功后，终端<em><strong>可以</strong></em>继续在它发送的后续数据包中设置<code>ECT</code>码点，并认定这条路径是支持ECN的。网络路由和路径上的元素可能在连接中途发生变化；将来如果验证失败，则终端<em><strong>必须</strong></em>禁用ECN。</p>
</div>
</section>
<section class="page" id="14_Datagram_Size">
<h1>
<a href="#14_Datagram_Size">14. 数据报尺寸</a>
</h1>
<div class="content">
<p>一个UDP数据报可以包含一个或多个QUIC数据包。数据报尺寸指的是携带QUIC数据包的单个UDP数据报的UDP载荷总大小。数据报尺寸包含一个或多个QUIC数据包头部和受保护的载荷，但不包含UDP或IP头部。</p>
<p>最大数据报尺寸被定义为能够经由一条网络路径使用单个UDP数据报发送的最大的UDP载荷大小。如果某条网络路径支持的最大数据报尺寸不能达到1200字节，则<em><strong>必须不</strong></em>使用QUIC。</p>
<p>QUIC假设一个最小的IP数据包尺寸为至少1280字节。这是IPv6数据包的最小尺寸（见《<a href="https://www.rfc-editor.org/info/rfc8200">IPv6</a>》），同时被大多数现代IPv4网络所支持。假设使用最小的IP头部，IPv6时为40字节而IPv4时为20字节，以及大小为8字节的UDP头部，则可得到IPv6中的最大数据报尺寸为1232字节，而IPv4中的为1252字节。因此，现代的IPv4网络路径和所有的IPv6网络路径都应该有能力支持QUIC。</p>
<blockquote>
<p>注意：如果某条路径仅支持1280字节，即IPv6的最小MTU，那么要求支持1200字节的UDP载荷会限制IPv6扩展头部和IPv4选项的可用空间，前者被限制至32字节，后者被限制至52字节。</p>
</blockquote>
<p>任何超过1200字节的最大数据报尺寸都可以使用路径最大传输单元发现（PMTUD）（见<a href="#14.2.1_Handling_of_ICMP_Messages_by_PMTUD">第14.2.1章</a>）或数据报分包层PMTU发现（DPLPMTUD）（见<a href="#14.3_Datagram_Packetization_Layer_PMTU_Discovery">第14.3章</a>）。</p>
<p>强制执行传输参数<code>max_udp_payload_size</code>（<a href="#18.2_Transport_Parameter_Definitions">第18.2章</a>）可能成为一个额外的对最大数据报尺寸的限制。一旦这个值已知，发送方就可以避免超过这个限制。然而在获知这个传输参数的值之前，如果终端发送了比1200字节，这个在允许的最大数据报尺寸中的最小值，更大的数据报，那么终端就要承担数据报丢失的风险。</p>
<p>UDP数据报<em><strong>必须不</strong></em>在IP层被分段。在IPv4（《<a href="https://www.rfc-editor.org/info/rfc791">IPv4</a>》）中<em><strong>必须</strong></em>尽可能设置不要分段（DF）比特位来防止路径上的分段。</p>
<p>QUIC有时需要数据报不小于一个特定尺寸，比如<a href="#8.1_Address_Validation_during_Connection_Establishment">第8.1章</a>中的例子。然而，数据报的尺寸不会被认证。也就是说，如果终端接收到了某个尺寸的数据报，它不能确定发送方发送的是不是就是那个尺寸的数据报。因此，当终端接收到一个没有满足尺寸限制的数据报时，它<em><strong>必须不</strong></em>关闭那条连接；终端<em><strong>可以</strong></em>丢弃这样的数据报。</p>
</div>
</section>
<section class="page" id="14.1_Initial_Datagram_Size">
<h2>
<a href="#14.1_Initial_Datagram_Size">14.1 初始数据报尺寸</a>
</h2>
<div class="content">
<p>客户端<em><strong>必须</strong></em>通过向初始数据包增加<strong>填充帧</strong>或合并初始数据包的方式，对所有携带初始数据包的UDP数据报载荷进行扩充，至少扩充至1200字节，这个在允许的最大数据报尺寸中的最小值，详见<a href="#12.2_Coalescing_Packets">第12.2章</a>。初始数据包甚至可以和不合法的数据包合并，后者会被接收方丢弃。相似的，服务器<em><strong>必须</strong></em>对所有携带引发确认的初始数据包的UDP数据报载荷进行扩充，至少扩充至1200字节，这个在允许的最大数据报尺寸中的最小值。</p>
<p>以上述尺寸发送UDP数据报确保网络路径在两个方向上都支持一个合理的路径最大传输单元（PMTU）值。除此之外，扩充初始数据包的客户端有助于减少因服务器响应未经验证的客户端地址而引起的放大攻击的幅度，详见<a href="#8_Address_Validation">第8章</a>。</p>
<p>如果发送方确信网络路径和对端均支持它选择的数据报尺寸，那么包含初始数据包的数据报<em><strong>可以</strong></em>超过1200字节。</p>
<p>如果一个UDP数据报的载荷小于1200字节，这个在允许的最大数据报尺寸中的最小值，那么服务器<em><strong>必须</strong></em>丢弃这个数据报中的初始数据包。服务器还<em><strong>可以</strong></em>通过发送一个错误码为<code>PROTOCOL_VIOLATION</code>（协议违背）的<strong>连接关闭帧</strong>来立即关闭连接，详见<a href="#10.2.3_Immediate_Close_during_the_Handshake">第10.2.3章</a>。</p>
<p>服务器还<em><strong>必须</strong></em>限制它在验证客户端地址前发送的字节数，详见<a href="#8_Address_Validation">第8章</a>。</p>
</div>
</section>
<section class="page" id="14.2_Path_Maximum_Transmission_Unit">
<h2>
<a href="#14.2_Path_Maximum_Transmission_Unit">14.2 路径最大传输单元</a>
</h2>
<div class="content">
<p>PMTU指整个IP数据包的最大尺寸，包括IP头部、UDP头部和UDP载荷。UDP载荷包含一个或多个QUIC数据包头部和受保护的载荷。PMTU可能受路径特征影响因而随时间变化。终端的最大数据报尺寸指的是在某个给定时间，终端能发送的最大UDP载荷大小。</p>
<p>终端<em><strong>应该</strong></em>使用DPLPMTUD（<a href="#14.3_Datagram_Packetization_Layer_PMTU_Discovery">第14.3章</a>）或PMTUD（<a href="#14.2.1_Handling_of_ICMP_Messages_by_PMTUD">第14.2.1章</a>）来认定一条通向目的地的路径是否支持一个期望的最大数据报尺寸且无需分段。在缺失这些机制时，QUIC终端<em><strong>不应该</strong></em>发送比允许的最大数据报尺寸中的最小值还要大的数据报。</p>
<p>DPLPMTUD和PMTUD都会发送比当前的最大数据报尺寸更大的数据报，也就是<strong>PMTU探测包</strong>。所有不是在<strong>PMTU探测包</strong>中发送的QUIC数据包都<em><strong>应该</strong></em>具有适合最大数据报尺寸的尺寸以避免数据报被分段或丢弃（详见<a href="https://www.rfc-editor.org/info/rfc8085">RFC8085</a>）。</p>
<p>如果QUIC终端认定某对本地IP地址和远程IP地址间的PMTU达不到1200字节，这个在允许的最大数据报尺寸中的最小值，那么它<em><strong>必须</strong></em>在受影响的路径上立即停止发送QUIC数据包，除了那些在<strong>PMTU探测包</strong>中的或包含<strong>连接关闭帧</strong>的数据包。如果无法找到备选路径，那么终端<em><strong>可以</strong></em>终止连接。</p>
<p>每对本地地址和远程地址可以有不同的PMTU。因此实现了任何一种PMTU发现的QUIC实现<em><strong>应该</strong></em>为每一对本地IP地址和远程IP地址的组合维护一个最大数据报尺寸。</p>
<p>QUIC实现<em><strong>可以</strong></em>更保守地计算最大数据报尺寸以允许未知的隧道开销或IP头部选项/扩展。</p>
</div>
</section>
<section class="page" id="14.2.1_Handling_of_ICMP_Messages_by_PMTUD">
<h3>
<a href="#14.2.1_Handling_of_ICMP_Messages_by_PMTUD">14.2.1 使用PMTUD处理ICMP消息</a>
</h3>
<div class="content">
<p>PMTUD（详见《<a href="https://www.rfc-editor.org/info/rfc1191">RFC1191</a>》和《<a href="https://www.rfc-editor.org/info/rfc8201">RFC8201</a>》）依赖一种ICMP消息（也就是IPv6数据包过大（PTB）消息）的接收，这种消息表明了何时IP数据包由于超过本地路由器MTU而被丢弃。DPLPMTUD可以选择使用这些消息。使用这种ICMP消息潜在地容易受到路径上不能观察数据包但可能成功猜测到地址的实体的攻击。</p>
<p>如果一个ICMP消息宣称PMTU已降低，且降低至QUIC允许的最大数据报尺寸中的最小值以下，那么终端<em><strong>必须</strong></em>忽略它。</p>
<p>生成ICMP消息的要求（详见《<a href="https://www.rfc-editor.org/info/rfc1812">RFC1812</a>》和《<a href="https://www.rfc-editor.org/info/rfc4443">RFC4443</a>》）指出，被引用的数据包应该包含尽可能多的原始数据包且不超过当前IP版本的最小MTU。被引用的数据包的尺寸实际上可以更小，或信息可以更难以理解，如《<a href="https://www.rfc-editor.org/info/rfc8899">DPLPMTUD</a>》的<a href="https://www.rfc-editor.org/rfc/rfc8899.html#name-classical-path-mtu-discover">第1.1章</a>所述。</p>
<p>使用PMTUD的QUIC终端<em><strong>应该</strong></em>验证ICMP消息以免于如《<a href="https://www.rfc-editor.org/info/rfc8201">RFC8201</a>》和《<a href="https://www.rfc-editor.org/info/rfc8085">RFC8085</a>》的<a href="https://www.rfc-editor.org/rfc/rfc8085.html#section-5.2">第5.2章</a>所述的数据包注入。这种验证<em><strong>应该</strong></em>使用ICMP消息的载荷中提供的被引用数据包，来将这条消息与一条有关的传输连接相关联（详见《<a href="https://www.rfc-editor.org/info/rfc8899">DPLPMTUD</a>》的<a href="https://www.rfc-editor.org/rfc/rfc8899.html#name-validation-of-ptb-messages">第4.6.1章</a>）。ICMP消息验证<em><strong>必须</strong></em>在一个活跃的QUIC上下文中包含匹配的IP地址和UDP端口（详见《<a href="https://www.rfc-editor.org/info/rfc8085">RFC8085</a>》）以及，如果可以的话，连接ID。终端<em><strong>应该</strong></em>忽略所有未通过验证的ICMP消息。</p>
<p>终端<em><strong>必须不</strong></em>基于ICMP消息提高PMTU，详见《<a href="https://www.rfc-editor.org/info/rfc8899">DPLPMTUD</a>》的<a href="https://www.rfc-editor.org/rfc/rfc8899.html#name-features-required-to-provid">第3章</a>中的第6款。在QUIC的丢包检测算法认定被引用的数据包确实被丢失了之前，任何作为ICMP消息的响应而降低的QUIC最大数据报尺寸都<em><strong>可以</strong></em>是临时的。</p>
</div>
</section>
<section class="page" id="14.3_Datagram_Packetization_Layer_PMTU_Discovery">
<h2>
<a href="#14.3_Datagram_Packetization_Layer_PMTU_Discovery">14.3 数据报分包层PMTU发现</a>
</h2>
<div class="content">
<p>DPLPMTUD（详见《<a href="https://www.rfc-editor.org/info/rfc8899">DPLPMTUD</a>》）依赖对<strong>PMTU探测包</strong>中携带的QUIC数据包的丢失或确认进行追踪。DPLPMTUD中使用了<strong>填充帧</strong>的<strong>PMTU探测包</strong>实现了如《<a href="https://www.rfc-editor.org/info/rfc8899">DPLPMTUD</a>》的<a href="https://www.rfc-editor.org/rfc/rfc8899.html#name-plpmtu-probe-packets">第4.1章</a>所述的“使用填充数据进行探测”。</p>
<p>终端<em><strong>应该</strong></em>将<code>BASE_PLPMTU</code>（基本分包层路径最大传输单元）（详见《<a href="https://www.rfc-editor.org/info/rfc8899">DPLPMTUD</a>》的<a href="https://www.rfc-editor.org/rfc/rfc8899.html#name-dplpmtud-components">第5.1章</a>）的初始值设置为与QUIC允许的最大数据报尺寸中的最小值一致的值。<code>MIN_PLPMTU</code>（最小分包层路径最大传输单元）就是<code>BASE_PLPMTU</code>。</p>
<p>实现DPLPMTUD的QUIC终端为每一对本地IP地址和远程IP地址的组合维护一个DPLPMTUD最大数据包尺寸（MPS）（详见《<a href="https://www.rfc-editor.org/info/rfc8899">DPLPMTUD</a>》的<a href="https://www.rfc-editor.org/rfc/rfc8899.html#name-the-maximum-packet-size-mps">第4.4章</a>）。它对应着最大数据报尺寸。</p>
</div>
</section>
<section class="page" id="14.3.1_DPLPMTUD_and_Initial_Connectivity">
<h3>
<a href="#14.3.1_DPLPMTUD_and_Initial_Connectivity">14.3.1 DPLPMTUD与初始连接</a>
</h3>
<div class="content">
<p>从DPLPMTUD的视角看，QUIC是个进行过确认的分包层（PL）。因此QUIC发送方当QUIC连接的握手阶段完成时可以进入DPLPMTUD的<code>BASE</code>（基本）状态。</p>
</div>
</section>
<section class="page" id="14.3.2_Validating_the_Network_Path_with_DPLPMTUD">
<h3>
<a href="#14.3.2_Validating_the_Network_Path_with_DPLPMTUD">14.3.2 用DPLPMTUD验证网络路径</a>
</h3>
<div class="content">
<p>QUIC是一个进行过确认的<code>PL</code>（分包层）；因此当处于<code>SEARCH_COMPLETE</code>（搜索完成）状态时，QUIC的发送方不需要实现DPLPMTUD的<code>CONFIRMATION_TIMER</code>（确认计时器），详见《<a href="https://www.rfc-editor.org/info/rfc8899">DPLPMTUD</a>》的<a href="https://www.rfc-editor.org/rfc/rfc8899.html#name-state-machine">第5.2章</a>。</p>
</div>
</section>
<section class="page" id="14.3.3_Handling_of_ICMP_Messages_by_DPLPMTUD">
<h3>
<a href="#14.3.3_Handling_of_ICMP_Messages_by_DPLPMTUD">14.3.3 使用DPLPMTUD处理ICMP消息</a>
</h3>
<div class="content">
<p>如《<a href="https://www.rfc-editor.org/info/rfc8899">DPLPMTUD</a>》的<a href="https://www.rfc-editor.org/rfc/rfc8899.html#name-response-to-ptb-messages">第4.6章</a>所述，使用DPLPMTUD的终端在使用任何PTB信息前都需要验证接收到的那条ICMP消息。除了验证UDP端口外，QUIC还通过使用其他PL信息（例如，验证所有接收到的ICMP消息的被引用数据包中的连接ID）来验证一条ICMP消息。</p>
<p>如果某条ICMP消息被DPLPMTUD使用，那么还要考虑<a href="#14.2.1_Handling_of_ICMP_Messages_by_PMTUD">第14.2.1章</a>中描述的有关处理ICMP消息时的注意事项。</p>
</div>
</section>
<section class="page" id="14.4_Sending_QUIC_PMTU_Probes">
<h2>
<a href="#14.4_Sending_QUIC_PMTU_Probes">14.4 发送QUIC的PMTU探测包</a>
</h2>
<div class="content">
<p><strong>PMTU探测包</strong>是ACK触发包。</p>
<p>终端可以限制<strong>PMTU探测包</strong>的内容为<strong>Ping帧</strong>和<strong>填充帧</strong>，因为比当前最大数据报尺寸更大的数据包更有可能被网络所丢弃。因此丢失一个在<strong>PMTU探测包</strong>中携带的QUIC数据包并不是个可靠的拥塞依据且<em><strong>不应该</strong></em>触发拥塞控制的反应；详见《<a href="https://www.rfc-editor.org/info/rfc8899">DPLPMTUD</a>》的<a href="https://www.rfc-editor.org/rfc/rfc8899.html#name-features-required-to-provid">第3章</a>的第7款。然而<strong>PMTU探测包</strong>会消耗拥塞窗口，这会延迟应用的后续传输。</p>
</div>
</section>
<section class="page" id="14.4.1_PMTU_Probes_Containing_Source_Connection_ID">
<h3>
<a href="#14.4.1_PMTU_Probes_Containing_Source_Connection_ID">14.4.1 包含源连接ID的PMTU探测包</a>
</h3>
<div class="content">
<p>依赖目标连接ID字段来路由传入的QUIC数据包的终端，有可能需要连接ID被包含在<strong>PMTU探测包</strong>中，才能将产生的ICMP消息（详见<a href="#14.2.1_Handling_of_ICMP_Messages_by_PMTUD">第14.2.1章</a>）路由回正确的终端。</p>
<p>构建<strong>PMTU探测包</strong>的方法之一是将一个有长包头的数据包，例如握手数据包或0-RTT数据包（详见<a href="#17.2_Long_Header_Packets">第17.2章</a>），与一个短包头数据包合并（详见<a href="#12.2_Coalescing_Packets">第12.2章</a>）至单个UDP数据报中。如果产生的<strong>PMTU探测包</strong>到达了对端，那么具有长包头的数据包会被忽略，但是短包头数据包会被确认。如果<strong>PMTU探测包</strong>触发了一条ICMP消息，那么探测包的起始部分会被引用进那条消息。如果源连接ID字段在探测包被引用的部分里，它就能被用来路由或验证那条ICMP消息。</p>
<blockquote>
<p>注意：使用具有长包头的数据包的目的仅仅是确保ICMP消息中被引用的数据包里包含源连接ID字段。这个数据包并不需要是一个合法的数据包，并且即使当时那种数据包没有用处也可以发送它。</p>
</blockquote>
</div>
</section>
<section class="page" id="15_Versions">
<h1>
<a href="#15_Versions">15. 版本</a>
</h1>
<div class="content">
<p>QUIC版本使用一个32位无符号整型值来标识。</p>
<p>版本<code>0x00000000</code>被保留使用，以表示版本协商。本规范的版本使用数值<code>0x00000001</code>来标识。</p>
<p>其他QUIC版本的各种属性可能与本版本不同。《<a href="../RFC8999_Chinese_Simplified">QUIC不变量</a>》中描述了保证在协议不同版本间保持一致的一些QUIC属性。</p>
<p>如《<a href="/RFC9001_Chinese_Simplified">QUIC-TLS</a>》所述，版本为<code>0x00000001</code>的QUIC使用TLS作为加密握手协议。</p>
<p>版本号最高的16个有效位被清除的版本被保留使用，用于将来的IETF共识文档。</p>
<p>遵循<code>0x?a?a?a?a</code>模式的版本——也就是所有字节的四个低位都是<code>1010</code>（二进制）的那些版本号——被保留使用，用于强制执行版本协商。客户端或服务器<em><strong>可以</strong></em>宣称自己支持这些保留版本中的任意版本。</p>
<p>保留版本号绝不会表示一个真实的协议；客户端<em><strong>可以</strong></em>使用这些版本号中的一个并期望服务器会发起版本协商；服务器<em><strong>可以</strong></em>宣称自己支持这些版本中的一个，并期望客户端忽略这个值。</p>
</div>
</section>
<section class="page" id="16_Variable-Length_Integer_Encoding">
<h1>
<a href="#16_Variable-Length_Integer_Encoding">16. 可变长度整型编码</a>
</h1>
<div class="content">
<p>QUIC数据包和帧经常对非负整型值使用一种可变长度编码。这种编码确保较小的整型值能被编码到更少的字节中。</p>
<p>QUIC可变长度整型编码占用了首个字节最高的两个有效位，用它们来存储正在编码的整型值的字节长度的以<code>2</code>为底的对数值。整型值以网络字节序被编码进剩余比特位中。</p>
<p>这意味着被编码进1，2，4或8字节的整型值可以分别编码6，14，30和62位值。<a href="#Table_4_Summary_of_Integer_Encodings">表4</a>总结了这种编码的属性。</p>
<div class="block ref" id="Table_4_Summary_of_Integer_Encodings">
<table>
<thead>
<tr>
<th style="text-align:left">最高的2个有效位</th>
<th style="text-align:left">字节长度</th>
<th style="text-align:left">可用位数</th>
<th style="text-align:left">可表示范围</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">00</td>
<td style="text-align:left">1</td>
<td style="text-align:left">6</td>
<td style="text-align:left">0-63</td>
</tr>
<tr>
<td style="text-align:left">01</td>
<td style="text-align:left">2</td>
<td style="text-align:left">14</td>
<td style="text-align:left">0-16383</td>
</tr>
<tr>
<td style="text-align:left">10</td>
<td style="text-align:left">4</td>
<td style="text-align:left">30</td>
<td style="text-align:left">0-1073741823</td>
</tr>
<tr>
<td style="text-align:left">11</td>
<td style="text-align:left">8</td>
<td style="text-align:left">62</td>
<td style="text-align:left">0-4611686018427387903</td>
</tr>
</tbody>
</table>
<p><a href="#Table_4_Summary_of_Integer_Encodings">表4：整型编码概要</a></p>
</div>
<p>在<a href="#A.1_Sample_Variable-Length_Integer_Decoding">附录A.1</a>中可以找到一种解码算法的例子和一些样例编码。</p>
<p>值并不一定要被编码进正正好好最少的所需字节数，帧类型字段是主要的例外，详见<a href="#12.4_Frames_and_Frame_Types">第12.4章</a>。</p>
<p>版本（<a href="#15_Versions">第15章</a>），头部中发送的数据包号（<a href="#17.1_Packet_Number_Encoding_and_Decoding">第17.1章</a>）和长包头中的连接ID长度（<a href="#17.2_Long_Header_Packets">第17.2章</a>）使用整型值来描述但不使用本编码。</p>
</div>
</section>
<section class="page" id="17_Packet_Formats">
<h1>
<a href="#17_Packet_Formats">17. 数据包格式</a>
</h1>
<div class="content">
<p>所有数字值均以网络字节序（也就是大端）编码，并且所有的字段长度都以比特为单位。十六进制标记被用于描述字段的值。</p>
</div>
</section>
<section class="page" id="17.1_Packet_Number_Encoding_and_Decoding">
<h2>
<a href="#17.1_Packet_Number_Encoding_and_Decoding">17.1 数据包号编码与解码</a>
</h2>
<div class="content">
<p>数据包号是范围在<code>0</code>至<code>2<sup>62</sup>-1</code>中的整数（<a href="#12.3_Packet_Numbers">第12.3章</a>）。当在长包或短包的头部出现时 ，它们被编码在1至4字节中。通过仅使用数据包号的几个最低有效位，用于表示数据包号的比特位数量得以被减少。</p>
<p>经过编码的数据包号是受保护的，如《<a href="../RFC9001_Chinese_Simplified">QUIC-TLS</a>》<a href="../RFC9001_Chinese_Simplified/#5.4_Header_Protection">第5.4章</a>所述。</p>
<p>在接收到对于某数据包号空间的确认前，<em><strong>必须</strong></em>使用完整的数据包号；它不可以如下文所述那样被截断。</p>
<p>在接收到对于某数据包号空间的确认后，发送方<em><strong>必须</strong></em>使用一个足够大的数据包号尺寸，这个尺寸能够表示的范围大小至少是最大已确认数据包号和正在发送的数据包号之差的两倍。接收到该数据包的对端将正确解码数据包号，除非此包在传输过程中被延误得比很多更大编号的数据包更晚才被接收到。终端<em><strong>应该</strong></em>使用一个足够大的数据包号编码，使得即便此数据包比后续发送的数据包更晚到达，其数据包号也能被恢复。</p>
<p>于是，某数据包号编码的尺寸至少要比连续未被确认的数据包号的数量（包括此数据包本身）的以<code>2</code>为底的对数值大<code>1</code>比特。在<a href="#A.2_Sample_Packet_Number_Encoding_Algorithm">附录A.2</a>中可以找到数据包号编码的伪代码和一个样例。</p>
<p>在接收方一侧，数据包号的保护在恢复完整数据包号前被移除。完整的数据包号随后被重建，重建基于数据包中出现的包号有效比特位的数量和值，以及已接收的且成功认证的数据包中最大的数据包号。恢复完整的数据包号对于成功移除数据包保护很有必要。</p>
<p>一旦头部保护被移除，通过找到与下一个预期数据包更接近的数据包号值即可将数据包号解码。下一个预期数据包就是将最大的已接收数据包编号加上<code>1</code>。在<a href="#A.3_Sample_Packet_Number_Decoding_Algorithm">附录A.3</a>中可以找到数据包号解码的伪代码和一个样例。</p>
</div>
</section>
<section class="page" id="17.2_Long_Header_Packets">
<h2>
<a href="#17.2_Long_Header_Packets">17.2 长包头数据包</a>
</h2>
<div class="content">
<div class="block ref" id="Figure_13_Long_Header_Packet_Format">
<pre tabindex="0"><code>长包头数据包 {
  包头形式 (1) = 1,
  固定比特位 (1) = 1,
  长数据包类型 (2),
  类型特定比特位 (4),
  版本 (32),
  目标连接ID长度 (8),
  目标连接ID (0..160),
  源连接ID长度 (8),
  源连接ID (0..160),
  类型特定载荷 (..),
}
</code></pre><p><a href="#Figure_13_Long_Header_Packet_Format">图13：长包头数据包格式</a></p>
</div>
<p>长包头被用于在1-RTT密钥建立前发送的数据包。一旦有了1-RTT密钥，发送方就会改用短包头发送数据包（<a href="#17.3_Short_Header_Packets">第17.3章</a>）。长类型包头允许特殊数据包——例如版本协商数据包——以这种统一的固定长度的数据包格式呈现。使用长包头的数据包包含以下字段：</p>
<dl>
<dt>包头形式（Header Form）：</dt>
<dd>
<p>对于长包头，字节0（第一个字节）的最高有效位（<code>0x80</code>）被设置为<code>1</code>。</p>
</dd>
<dt>固定比特位（Fixed Bit）：</dt>
<dd>
<p>字节0中的下一个比特位（<code>0x40</code>）被设置为<code>1</code>，除非该包是一个版本协商数据包。此比特位为<code>0</code>的数据包表示它不是当前版本的合法数据包且<em><strong>必须</strong></em>被丢弃。此比特位为<code>1</code>允许QUIC与其他协议共存，详见《<a href="https://www.rfc-editor.org/info/rfc7983">RFC7983</a>》。</p>
</dd>
<dt>长数据包类型（Long Packet Type）：</dt>
<dd>
<p>字节0中的后两个比特位（掩码为<code>0x30</code>的那两个）包含了数据包类型。<a href="#Table_5_Long_Header_Packet_Types">表5</a>罗列了数据包类型。</p>
</dd>
<dt>类型特定比特位（Type-Specific Bits）：</dt>
<dd>
<p>字节0中最低的四个比特位（掩码为<code>0x0f</code>的那四个）的语义由数据包类型决定。</p>
</dd>
<dt>版本（Version）：</dt>
<dd>
<p>QUIC的版本是一个跟在第一个字节后的32比特长的字段。该字段表明了正在使用的QUIC版本并且决定了如何解释剩下的协议字段。</p>
</dd>
<dt>目标连接ID长度（Destination Connection ID Length）：</dt>
<dd>
<p>跟在版本后面的那个字节包含了这个字节后方的目标连接ID字段的长度。这个长度以字节为单位，且被编码为一个8位无符号整型值。在QUIC版本1中，该值<em><strong>必须不</strong></em>超过20字节。收到版本为<code>1</code>的长包头数据包且本字段的值超过<code>20</code>的终端必须丢弃它。为了正确构造一个版本协商数据包，服务器<em><strong>应该</strong></em>有能力从其他QUIC版本中读取更长的连接ID。</p>
</dd>
<dt>目标连接ID（Destination Connection ID）：</dt>
<dd>
<p>目标连接ID字段跟在目标连接ID长度字段后面，后者指出了本字段的长度。<a href="#7.2_Negotiating_Connection_IDs">第7.2章</a>更详细地描述了本字段的用法。</p>
</dd>
<dt>源连接ID长度（Source Connection ID Length）：</dt>
<dd>
<p>跟在目标连接ID后面的那个字节包含了这个字节后方的源连接ID字段的长度。这个长度以字节为单位，且被编码为一个8位无符号整型值。在QUIC版本1中，该值<em><strong>必须不</strong></em>超过20字节。收到版本为1的长包头数据包且本字段的值超过<code>20</code>的终端必须丢弃它。为了正确构造一个版本协商数据包，服务器<em><strong>应该</strong></em>有能力从其他QUIC版本中读取更长的连接ID。</p>
</dd>
<dt>源连接ID（Source Connection ID）：</dt>
<dd>
<p>源连接ID字段跟在源连接ID长度字段后面，后者指出了本字段的长度。<a href="#7.2_Negotiating_Connection_IDs">第7.2章</a>更详细地描述了本字段的用法。</p>
</dd>
<dt>类型特定载荷（Type-Specific Payload）：</dt>
<dd>
<p>数据包的剩余部分是类型特定的，如果有的话。</p>
</dd>
</dl>
<p>在此版本的QUIC中，定义了以下长包头数据包的类型：</p>
<div class="block ref" id="Table_5_Long_Header_Packet_Types">
<table>
<thead>
<tr>
<th style="text-align:left">类型</th>
<th style="text-align:left">名称</th>
<th style="text-align:left">章节</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">0x00</td>
<td style="text-align:left">初始</td>
<td style="text-align:left"><a href="#17.2.2_Initial_Packet">第17.2.2章</a></td>
</tr>
<tr>
<td style="text-align:left">0x01</td>
<td style="text-align:left">0-RTT</td>
<td style="text-align:left"><a href="#17.2.3_0-RTT">第17.2.3章</a></td>
</tr>
<tr>
<td style="text-align:left">0x02</td>
<td style="text-align:left">握手</td>
<td style="text-align:left"><a href="#17.2.4_Handshake_Packet">第17.2.4章</a></td>
</tr>
<tr>
<td style="text-align:left">0x03</td>
<td style="text-align:left">重试</td>
<td style="text-align:left"><a href="#17.2.5_Retry_Packet">第17.2.5章</a></td>
</tr>
</tbody>
</table>
<p><a href="#Table_5_Long_Header_Packet_Types">表5：长包头数据包类型</a></p>
</div>
<p>一个长包头数据包的包头形式比特位、目标和源连接ID长度、目标和源连接ID，以及版本字段是版本无关的。第一个字节的其他字段是版本特定的。有关怎样解释不同QUIC版本的数据包的细节，见《<a href="../RFC8999_Chinese_Simplified">QUIC不变量</a>》。</p>
<p>第一个字节的其他字段和载荷的解释方法取决于版本和数据包类型。接下来的章节会描述当前版本下，各种数据包类型对它们的特定语义。在这个版本的QUIC中，一些长包头数据包均包含了这些额外字段：</p>
<dl>
<dt>保留比特位（Reserved Bits）：</dt>
<dd>
<p>字节0的某两个比特位（掩码为<code>0x0c</code>的那两个）在多种数据包类型中都被保留使用。这些比特位被头部保护所保护，详见《<a href="../RFC9001_Chinese_Simplified">QUIC-TLS</a>》的<a href="../RFC9001_Chinese_Simplified/#5.4_Header_Protection">第5.4章</a>。在进行保护前，这两个比特位的值<em><strong>必须</strong></em>被设置为0。若在移除数据包保护和头部保护之后发现这些位被设置为非零值，则接收到该数据包的终端<em><strong>必须</strong></em>将该情况视作一个类型为<code>PROTOCOL_VIOLATION</code>的连接错误。仅在移除头部保护后就丢弃这样的数据包会使终端暴露于攻击之下，详见《<a href="../RFC9001_Chinese_Simplified">QUIC-TLS</a>》的<a href="../RFC9001_Chinese_Simplified/#9.5_Header_Protection_Timing_Side_Channels">第9.5章</a>。</p>
</dd>
<dt>数据包号长度（Packet Number Length）：</dt>
<dd>
<p>在包含数据包号字段的数据包类型中，字节0最低的两个有效位（掩码为<code>0x03</code>的那两个）包含数据包号字段的长度。该长度被编码为一个2位无符号整型值，这个值比数据包号字段的字节长度小<code>1</code>。也就是说，数据包号字段的长度等于这个字段的值加<code>1</code>。这些比特位被头部保护所保护，详见《<a href="../RFC9001_Chinese_Simplified">QUIC-TLS</a>》的<a href="../RFC9001_Chinese_Simplified/#5.4_Header_Protection">第5.4章</a>。</p>
</dd>
<dt>长度（Length）：</dt>
<dd>
<p>这是数据包剩余部分（也就是数据包号字段和载荷字段）的字节长度，被编码为一个可变长度整型值。</p>
</dd>
<dt>数据包号（Packet Number）：</dt>
<dd>
<p>这个字段的长度是1至4字节。数据包号被头部保护所保护，详见《<a href="../RFC9001_Chinese_Simplified">QUIC-TLS</a>》的<a href="../RFC9001_Chinese_Simplified/#5.4_Header_Protection">第5.4章</a>。数据包号字段的长度被编码进字节0的数据包号长度比特位，见上文。</p>
</dd>
<dt>数据包载荷（Packet Payload）：</dt>
<dd>
<p>这是数据包的载荷——包含一系列帧——它们被数据包保护所保护。</p>
</dd>
</dl>
</div>
</section>
<section class="page" id="17.2.1_Version_Negotiation_Packet">
<h3>
<a href="#17.2.1_Version_Negotiation_Packet">17.2.1 版本协商数据包</a>
</h3>
<div class="content">
<p>版本协商数据包（Version Negotiation packet）本质上不是版本特定的。客户端收到后，将根据版本字段值为<code>0</code>将其识别为版本协商数据包。</p>
<p>版本协商数据包是对一个包含了服务器不支持的版本的客户端数据包的响应。它只能被服务器发送。</p>
<p>一个版本协商数据包的结构如下：</p>
<div class="block ref" id="Figure_14_Version_Negotiation_Packet">
<pre tabindex="0"><code>版本协商数据包 {
  包头形式 (1) = 1,
  未使用 (7),
  版本 (32) = 0,
  目标连接ID长度 (8),
  目标连接ID (0...2040),
  源连接ID长度 (8),
  源连接ID (0...2040),
  支持的版本 (32) ...,
}
</code></pre><p><a href="#Figure_14_Version_Negotiation_Packet">图14：版本协商数据包</a></p>
</div>
<p>未使用字段中的值由服务器设置为任意值。客户端<em><strong>必须</strong></em>忽略此字段的值。当QUIC可能被与其他协议多路复用时（详见<a href="https://www.rfc-editor.org/info/rfc7983">RFC7983</a>），服务器<em><strong>应该</strong></em>将这个字段的最高有效位（<code>0x40</code>）设置为<code>1</code>以使得版本协商数据包看起来具有固定比特位字段。要注意的是其他版本的QUIC不一定做出类似的推荐。</p>
<p>版本协商数据包的版本字段<em><strong>必须</strong></em>被设置为<code>0x00000000</code>。</p>
<p>服务器在目标连接ID字段中使用的值<em><strong>必须</strong></em>来自接收到的那个数据包的源连接ID字段。源连接ID字段的值<em><strong>必须</strong></em>是从接收到的那个数据包的目标连接ID字段中拷贝来的，这是个来自客户端的随机选择的值。回显两个连接ID可以让客户端确信服务器收到了数据包，并且版本协商数据包不是由没有观察初始数据包的实体生成的。</p>
<p>将来版本的QUIC可以对连接ID的长度有不同要求。特别是，连接ID可能具有更小的最小长度或更大的最大长度。</p>
<p>版本协商数据包的剩余部分是一个列表，包含服务器支持的一个个32位长的版本号。</p>
<p>版本协商包不会被确认。它只会作为一个使用了不受支持的版本的数据包的响应而被发送，详见<a href="#5.2.2_Server_Packet_Handling">第5.2.2章</a>。</p>
<p>版本协商数据包不包含在其他使用了长包头形式的数据包中存在的数据包号和长度字段。因此，一个版本协商数据包消耗一整个UDP数据报。</p>
<p>服务器<em><strong>必须不</strong></em>对单个UDP数据报响应超过1个版本协商数据包。</p>
<p>有关版本协商的过程，详见<a href="#6_Version_Negotiation">第6章</a>。</p>
</div>
</section>
<section class="page" id="17.2.2_Initial_Packet">
<h3>
<a href="#17.2.2_Initial_Packet">17.2.2 初始数据包</a>
</h3>
<div class="content">
<p>初始数据包（Initial packet）使用类型值为<code>0x00</code>的长包头。它携带着发送自客户端和服务器的最初的<strong>加密帧</strong>以进行密钥交换，同时它还携带着任意方向的<strong>ACK帧</strong>。</p>
<div class="block ref" id="Figure_15_Initial_Packet">
<pre tabindex="0"><code>初始数据包 {
  包头形式 (1) = 1,
  固定比特位 (1) = 1,
  长数据包类型 (2) = 0,
  保留比特位 (2),
  数据包号长度 (2),
  版本 (32),
  目标连接ID长度 (8),
  目标连接ID (0..160),
  源连接ID长度 (8),
  源连接ID (0..160),
  令牌长度 (i),
  令牌 (..),
  长度 (i),
  数据包号 (8..32),
  数据包载荷 (8..),
}
</code></pre><p><a href="#Figure_15_Initial_Packet">图15：初始数据包</a></p>
</div>
<p>初始数据包包含长包头、长度字段和数据包号字段，详见<a href="#17.2_Long_Header_Packets">第17.2章</a>。首个字节包含保留比特位和数据包号长度比特位，详见<a href="#17.2_Long_Header_Packets">第17.2章</a>。在源连接ID和长度字段间，是初始数据包特有的两个额外字段。</p>
<dl>
<dt>令牌长度（Token Length）：</dt>
<dd>
<p>一个可变长度整型值，它指定了令牌字段以字节为单位的长度。如果不存在令牌，则该值为<code>0</code>。由服务器发送的初始数据包<em><strong>必须</strong></em>将令牌长度字段设置为0；收到一个令牌长度字段为非零值的客户端<em><strong>必须</strong></em>要么丢弃数据包，要么产生一个类型为<code>PROTOCOL_VIOLATION</code>的连接错误。</p>
</dd>
<dt>令牌（Token）：</dt>
<dd>
<p>先前由重试数据包或<strong>新令牌帧</strong>提供的令牌的值，详见<a href="#8.1_Address_Validation_during_Connection_Establishment">第8.1章</a>。</p>
</dd>
</dl>
<p>为了防止不感知版本的中间件的篡改，初始数据包由连接特定密钥和版本特定密钥（初始密钥）所保护，如<a href="/RFC9001_Chinese_Simplified">QUIC-TLS</a>中描述的那样。这种保护在面对有能力观测数据包的攻击者时并不能提供可信度或保证完整性，但是它能防止无法观察到数据包的攻击者伪造初始数据包。</p>
<p>客户端和服务器使用初始数据包这一类型，用于任何包含着初始加密握手消息的数据包。这包含所有需要新创建包含初始加密消息的数据包的情况，例如接收到一个重试数据包后被发送的的那个数据包，详见<a href="#17.2.5_Retry_Packet">第17.2.5章</a>。</p>
<p>服务器发送它的首个初始数据包，作为客户端初始包的响应。服务器<em><strong>可以</strong></em>发送多个初始数据包。加密密钥交换可能需要多轮往返或数据重传。</p>
<p>一个初始数据包的载荷包含一个（或多个）<strong>加密帧</strong>，每个<strong>加密帧</strong>包含一条加密握手消息，或数个<strong>ACK帧</strong>，或两者兼具。<strong>Ping帧</strong>、<strong>填充帧</strong>和类型为<code>0x1c</code>的<strong>连接关闭帧</strong>也是被允许的。终端收到包含其他帧的初始数据包后可以将该数据包作为虚假数据包丢弃或将其视为连接错误。</p>
<p>由客户端发出的首个数据包总是包含一个<strong>加密帧</strong>，这个<strong>加密帧</strong>包含首个加密握手消息的起始或所有部分。首个<strong>加密帧</strong>总是在偏移为<code>0</code>处起始，详见<a href="#7_Cryptographic_and_Transport_Handshake">第7章</a>。</p>
<p>注意如果服务器发送了一个TLS HelloRetryRequest（详见《<a href="../RFC9001_Chinese_Simplified">QUIC-TLS</a>》的<a href="../RFC9001_Chinese_Simplified/#4.7_HelloRetryRequest">第4.7章</a>），客户端将另外发送一系列初始数据包。这些初始数据包将继续进行加密握手，并且其包含的<strong>加密帧</strong>的起始位置将与第一轮初始数据包中的<strong>加密帧</strong>尺寸相匹配。</p>
</div>
</section>
<section class="page" id="17.2.2.1_Abandoning_Initial_Packets">
<h4>
<a href="#17.2.2.1_Abandoning_Initial_Packets">17.2.2.1 停用初始数据包</a>
</h4>
<div class="content">
<p>从客户端发送它的第一个握手数据包时起，它就不再发送和处理初始数据包。从服务器收到第一个握手数据包时起，它就不再发送和处理初始数据包。尽管可能有数据包仍在传输途中或等待确认，但从那一时刻起不再有初始数据包需要进行交换。此时，初始数据包保护密钥将被弃用（详见《<a href="../RFC9001_Chinese_Simplified">QUIC-TLS</a>》的<a href="../RFC9001_Chinese_Simplified/#4.9.1_Discarding_Initial_Keys">第4.9.1章</a>），一起被丢弃的还有丢包恢复与拥塞控制状态（详见《<a href="../RFC9002_Chinese_Simplified">QUIC恢复</a>》的<a href="../RFC9002_Chinese_Simplified/#6.4_Discarding_Keys_and_Packet_State">第6.4章</a>）。</p>
<p>当初始密钥被弃用时，<strong>加密帧</strong>中的所有数据都会被丢弃，且不再重传。</p>
</div>
</section>
<section class="page" id="17.2.3_0-RTT">
<h3>
<a href="#17.2.3_0-RTT">17.2.3 0-RTT</a>
</h3>
<div class="content">
<p>0-RTT数据包使用类型值为<code>0x01</code>的长包头，后面跟着长度和数据包号字段，详见<a href="#17.2_Long_Header_Packets">第17.2章</a>。首个字节包含保留比特位和数据包号长度比特位，详见<a href="#17.2_Long_Header_Packets">第17.2章</a>。0-RTT数据包被用来在握手完成前，携带来自客户端的“早期”数据，作为第一轮通信的一部分被发向服务器。</p>
<p>有关0-RTT数据及其局限的讨论，详见《<a href="https://www.rfc-editor.org/info/rfc8446">TLS13</a>》的<a href="https://www.rfc-editor.org/rfc/rfc8446.html#section-2.3">第2.3章</a>。</p>
<div class="block ref" id="Figure_16_0-RTT_Packet">
<pre tabindex="0"><code>初始数据包 {
  包头形式 (1) = 1,
  固定比特位 (1) = 1,
  长数据包类型 (2) = 1,
  保留比特位 (2),
  数据包号长度 (2),
  版本 (32),
  目标连接ID长度 (8),
  目标连接ID (0..160),
  源连接ID长度 (8),
  源连接ID (0..160),
  长度 (i),
  数据包号 (8..32),
  数据包载荷 (8..),
}
</code></pre><p><a href="#Figure_16_0-RTT_Packet">图16：0-RTT数据包</a></p>
</div>
<p>受0-RTT保护的数据包，与受1-RTT保护的数据包使用相同的数据包号空间。</p>
<p>在客户端接收到重试数据包时，0-RTT数据包有可能是被弄丢了，或者被服务器丢弃了。客户端<em><strong>应该</strong></em>在发送新的初始数据包后尝试用0-RTT数据包重新发送数据。所有新发送的数据包都<em><strong>必须</strong></em>使用新的数据包号；如<a href="#17.2.5.3_Continuing_a_Handshake_after_Retry">第17.2.5.3章</a>所述，重用数据包号可能使数据包保护失效。</p>
<p>客户端只有在握手完成后才会收到0-RTT数据包的确认，如《<a href="../RFC9001_Chinese_Simplified">QUIC-TLS</a>》的<a href="../RFC9001_Chinese_Simplified/#4.1.1_Handshake_Complete">第4.1.1章</a>所述。</p>
<p>一旦客户端开始处理来自服务器的1-RTT数据包，它就<em><strong>必须不</strong></em>再发送0-RTT数据包。这意味着0-RTT数据包不能包含任何对于来自1-RTT数据包中的帧的回复。比如说，客户端不能在0-RTT数据包中发送<strong>ACK帧</strong>，因为它只能被用来确认1-RTT数据包。<em><strong>必须</strong></em>用1-RTT数据包来携带对于1-RTT数据包的确认。</p>
<p>服务器必须视违反已记录的限制的情况为一个合适类型的连接错误（例如，超过流数据限制时使用<code>FLOW_CONTROL_ERROR</code>（流量控制错误））。</p>
</div>
</section>
<section class="page" id="17.2.4_Handshake_Packet">
<h3>
<a href="#17.2.4_Handshake_Packet">17.2.4 握手数据包</a>
</h3>
<div class="content">
<p>握手数据包（Handshake packet）使用类型值为<code>0x02</code>的长包头，后面跟着长度和数据包号字段，详见<a href="#17.2_Long_Header_Packets">第17.2章</a>。首个字节包含保留比特位和数据包号长度比特位，详见<a href="#17.2_Long_Header_Packets">第17.2章</a>。这种数据包被用来携带来自服务器和客户端的加密握手消息和确认。</p>
<div class="block ref" id="Figure_17_Handshake_Protected_Packet">
<pre tabindex="0"><code>握手数据包 {
  包头形式 (1) = 1,
  固定比特位 (1) = 1,
  长数据包类型 (2) = 2,
  保留比特位 (2),
  数据包号长度 (2),
  版本 (32),
  目标连接ID长度 (8),
  目标连接ID (0..160),
  源连接ID长度 (8),
  源连接ID (0..160),
  长度 (i),
  数据包号 (8..32),
  数据包载荷 (8..),
}
</code></pre><p><a href="#Figure_17_Handshake_Protected_Packet">图17：受握手保护的数据包</a></p>
</div>
<p>一旦客户端接收到了来自服务器的握手数据包，它就开始使用握手数据包来向服务器发送后续加密握手消息和确认。</p>
<p>握手数据包的目标连接ID字段包含一个由数据包接收方选择的连接ID；源连接ID包含的是数据包的发送方想要使用的连接ID，详见<a href="#7.2_Negotiating_Connection_IDs">第7.2章</a>。</p>
<p>握手数据包有它们自己的数据包号空间，因此由服务器发送的首个握手数据包使用的是值为<code>0</code>的数据包号。</p>
<p>这种数据包的载荷是<strong>加密帧</strong>，也可以包含<strong>Ping帧</strong>、<strong>填充帧</strong>或<strong>ACK帧</strong>。握手数据包<em><strong>可以</strong></em>包含类型为<code>0x1c</code>的<strong>连接关闭帧</strong>。若握手数据包中出现了其他种类的帧，则接收到该数据包的终端<em><strong>必须</strong></em>将该情况视作一个类型为<code>PROTOCOL_VIOLATION</code>（协议违背）的连接错误。</p>
<p>如初始数据包一样（详见<a href="#17.2.2.1_Abandoning_Initial_Packets">第17.2.2.1章</a>），当握手保护密钥被弃用时，握手数据包中的<strong>加密帧</strong>里的数据会被丢弃且不再重新传输。</p>
</div>
</section>
<section class="page" id="17.2.5_Retry_Packet">
<h3>
<a href="#17.2.5_Retry_Packet">17.2.5 重试数据包</a>
</h3>
<div class="content">
<p>如<a href="#Figure_18_Retry_Packet">图18</a>所示，重试数据包（Retry packet）使用类型值为<code>0x03</code>的长包头。它携带者由服务器创建的一个地址验证令牌。想要进行重试的服务器会使用它，详见<a href="#8.1_Address_Validation_during_Connection_Establishment">第8.1章</a>。</p>
<div class="block ref" id="Figure_18_Retry_Packet">
<pre tabindex="0"><code>重试数据包 {
  包头形式 (1) = 1,
  固定比特位 (1) = 1,
  长数据包类型 (2) = 3,
  未使用 (4),
  版本 (32),
  目标连接ID长度 (8),
  目标连接ID (0..160),
  源连接ID长度 (8),
  源连接ID (0..160),
  重试令牌 (..),
  重试完整性标签 (128),
}
</code></pre><p><a href="#Figure_18_Retry_Packet">图18：重试数据包</a></p>
</div>
<p>重试数据包不包含任何受保护的字段。未使用字段中的值被服务器设置为任意值；客户端<em><strong>必须</strong></em>忽略这些比特位。除了来自长包头的字段之外，它还包含以下额外字段：</p>
<dl>
<dt>重试令牌（Retry Token）：</dt>
<dd>
<p>服务器用来验证客户端的地址的不透明令牌。</p>
</dd>
<dt>重试完整性标签（Retry Integrity Tag）：</dt>
<dd>
<p>在《<a href="../RFC9001_Chinese_Simplified">QUIC-TLS</a>》的<a href="../RFC9001_Chinese_Simplified/#5.8_Retry_Packet_Integrity">第5.8章</a>（《重试完整性标签》）中定义。</p>
</dd>
</dl>
</div>
</section>
<section class="page" id="17.2.5.1_Sending_a_Retry_Packet">
<h4>
<a href="#17.2.5.1_Sending_a_Retry_Packet">17.2.5.1 发送重试数据包</a>
</h4>
<div class="content">
<p>服务器在填写目标连接ID时，使用客户端在初始数据包中填写的源连接ID的值。</p>
<p>服务器在源连接ID字段中使用自己选择的连接ID。这个值<em><strong>必须不</strong></em>与发送自客户端的数据包的目标连接ID字段相同。如果客户端发现一个重试数据包中包含的的源连接ID字段与它发送的初始数据包中的目标连接ID字段一致，那么它<em><strong>必须</strong></em>将这个数据包丢弃。客户端<em><strong>必须</strong></em>使用来自重试数据包中源连接ID字段的值，作为目标连接ID字段来发送后续数据包。</p>
<p>服务器<em><strong>可以</strong></em>发送重试数据包来回复初始数据包和0-RTT数据包。服务器可以丢弃或缓存它收到的0-RTT数据包。当服务器接收到数个初始数据包或0-RTT数据包时，它可以发送数个重试数据包。服务器<em><strong>必须不</strong></em>发送超过一个重试数据包以回应单个UDP数据报。</p>
</div>
</section>
<section class="page" id="17.2.5.2_Handling a Retry Packet">
<h4>
<a href="#17.2.5.2_Handling%20a%20Retry%20Packet">17.2.5.2 处理重试数据包</a>
</h4>
<div class="content">
<p>对于单次连接尝试，客户端<em><strong>必须</strong></em>接受和处理至多一个重试数据包。在客户端已经接收和处理来自服务器的初始数据包或重试数据包之后，它<em><strong>必须</strong></em>丢弃后续接收到的任何重试数据包。</p>
<p>对于重试完整性标签无法被验证的重试数据包，客户端<em><strong>必须</strong></em>丢弃它们，详见《<a href="../RFC9001_Chinese_Simplified">QUIC-TLS</a>》的<a href="../RFC9001_Chinese_Simplified/#5.8_Retry_Packet_Integrity">第5.8章</a>。这会降低攻击者注入重试数据包的能力并且保护重试数据包免于意外受损。客户端<em><strong>必须</strong></em>丢弃重试令牌字段长度为零的重试数据包。</p>
<p>作为重试数据包的回复，客户端使用包含了前者提供的重试令牌的初始数据包来继续连接的建立过程。</p>
<p>客户端使用来自重试数据包中源连接ID字段的值，作为这个初始数据包的目标连接ID字段。更改目标连接ID字段会改变用来保护初始数据包的密钥。客户端还将令牌字段设置为重试数据包中提供的令牌。客户端<em><strong>必须不</strong></em>更改源连接ID因为服务器可能将连接ID作为了它令牌验证逻辑的一部分，详见<a href="#8.1.4_Address_Validation_Token_Integrity">第8.1.4章</a>。</p>
<p>重试数据包不包含数据包号且不能被客户端显式确认。</p>
</div>
</section>
<section class="page" id="17.2.5.3_Continuing_a_Handshake_after_Retry">
<h4>
<a href="#17.2.5.3_Continuing_a_Handshake_after_Retry">17.2.5.3 重试后继续握手</a>
</h4>
<div class="content">
<p>后续来自客户端的初始数据包包含着来自重试数据包的连接ID和令牌值。客户端从重试数据包中拷贝源连接ID字段至目标连接ID字段并且持续使用它，直到接收到一个包含着更新过的值的初始数据包，详见<a href="#7.2_Negotiating_Connection_IDs">第7.2章</a>。令牌字段的值被拷贝至所有后续初始数据包，详见<a href="#8.1.2_Address_Validation_Using_Retry_Packets">第8.1.2章</a>。</p>
<p>除了要更新目标连接ID和令牌字段外，客户端后续发出的初始数据包与首个初始数据包受到同样的限制。客户端<em><strong>必须</strong></em>使用和首个初始数据包中相同的加密握手消息。对于包含了不同加密握手消息的数据包，服务器<em><strong>可以</strong></em>将其视作为一种连接错误，或丢弃它。注意，包含令牌字段会减少数据包中加密握手消息的可用空间，这可能导致客户端需要发送多个初始数据包。</p>
<p>客户端<em><strong>可以</strong></em>在接收到重试数据包后尝试0-RTT，方法是向服务器提供的连接ID发送0-RTT数据包。</p>
<p>客户端<em><strong>必须不</strong></em>在处理完重试数据包后重置任何数据包号空间中的数据包号。尤其是，0-RTT数据包包含着的机密信息很有可能在接收到重试数据包时被重新传输。由于是在回复一个重试数据包，用于保护这些新0-RTT数据包的密钥不会改变。然而，这些数据包中发送的数据可能和之前发送的不一样。用相同的数据包号发送这些新数据包可能使这些数据包的数据包保护失效，因为相同的密钥和随机数可能被用于保护不同内容。服务器如果检测到客户端重置了数据包号。它<em><strong>可以</strong></em>中止这次连接。</p>
<p>在客户端和服务器间被交换的初始数据包和重试数据包中的那些连接ID会被拷贝到传输参数中并且被验证，详见<a href="#7.3_Authenticating_Connection_IDs">第7.3章</a>。</p>
</div>
</section>
<section class="page" id="17.3_Short_Header_Packets">
<h2>
<a href="#17.3_Short_Header_Packets">17.3 短包头数据包</a>
</h2>
<div class="content">
<p>本QUIC版本定义了1种使用短数据包包头的数据包类型。</p>
</div>
</section>
<section class="page" id="17.3.1_1-RTT_Packet">
<h3>
<a href="#17.3.1_1-RTT_Packet">17.3.1 1-RTT数据包</a>
</h3>
<div class="content">
<p>1-RTT数据包使用短数据包包头。它在协商出版本和1-RTT密钥之后被使用。</p>
<div class="block ref" id="Figure_19_1-RTT_Packet">
<pre tabindex="0"><code>1-RTT数据包 {
  包头形式 (1) = 0,
  固定比特位 (1) = 1,
  自旋比特位 (1),
  保留比特位 (2),
  密钥阶段 (1),
  数据包号长度 (2),
  目标连接ID (0..160),
  数据包号 (8..32),
  数据包载荷 (8..),
}
</code></pre><p><a href="#Figure_19_1-RTT_Packet">图19：1-RTT数据包</a></p>
</div>
<p>1-RTT数据包包含以下字段：</p>
<dl>
<dt>包头形式（Header Form）：</dt>
<dd>
<p>对于短包头，字节0的最高有效位（<code>0x80</code>）被设置为<code>0</code>。</p>
</dd>
<dt>固定比特位（Fixed Bit）：</dt>
<dd>
<p>字节0中的下一个比特位（<code>0x40</code>）被设置为<code>1</code>。此比特位为<code>0</code>的数据包表示它不是当前版本的合法数据包且<em><strong>必须</strong></em>被丢弃。此比特位为<code>1</code>允许QUIC与其他协议共存，详见《<a href="https://www.rfc-editor.org/info/rfc7983">RFC7983</a>》。</p>
</dd>
<dt>自旋比特位（Spin Bit）：</dt>
<dd>
<p>字节0的第三高有效比特位（<code>0x20</code>）是延迟自旋比特位，按<a href="#17.4_Latency_Spin_Bit">第17.4章</a>中描述的那样去设置。</p>
</dd>
<dt>保留比特位（Reserved Bits）：</dt>
<dd>
<p>字节0中的后两个比特位（掩码为<code>0x18</code>的那两个）被保留使用。这些比特位被头部保护所保护，详见《<a href="../RFC9001_Chinese_Simplified">QUIC-TLS</a>》的<a href="../RFC9001_Chinese_Simplified/#5.4_Header_Protection">第5.4章</a>。在进行保护前，这两个比特位的值<em><strong>必须</strong></em>被设置为0。若在移除数据包保护和头部保护之后发现这些位被设置为非零值，则接收到该数据包的终端<em><strong>必须</strong></em>将该情况视作一个类型为<code>PROTOCOL_VIOLATION</code>的连接错误。仅在移除头部保护后就丢弃这样的数据包会使终端暴露于攻击之下，详见《<a href="../RFC9001_Chinese_Simplified">QUIC-TLS</a>》的<a href="../RFC9001_Chinese_Simplified/#9.5_Header_Protection_Timing_Side_Channels">第9.5章</a>。</p>
</dd>
<dt>密钥阶段（Key Phase）：</dt>
<dd>
<p>字节0中的下一个比特位（<code>0x04</code>）表明了密钥阶段，它允许数据包的接收方辨别用于保护数据包的数据包保护密钥。有关细节见《<a href="/RFC9001_Chinese_Simplified">QUIC-TLS</a>》。这个比特位被头部保护所保护，详见《<a href="../RFC9001_Chinese_Simplified">QUIC-TLS</a>》的<a href="../RFC9001_Chinese_Simplified/#5.4_Header_Protection">第5.4章</a>。</p>
</dd>
<dt>数据包号长度（Packet Number Length）：</dt>
<dd>
<p>在包含数据包号字段的数据包类型中，字节0最低的两个有效位（掩码为<code>0x03</code>的那两个）包含数据包号字段的长度。该长度被编码为一个2位无符号整型值，这个值比数据包号字段的字节长度小<code>1</code>。也就是说，数据包号字段的长度等于这个字段的值加<code>1</code>。这些比特位被头部保护所保护，详见《<a href="../RFC9001_Chinese_Simplified">QUIC-TLS</a>》的<a href="../RFC9001_Chinese_Simplified/#5.4_Header_Protection">第5.4章</a>。</p>
</dd>
<dt>目标连接ID（Destination Connection ID）：</dt>
<dd>
<p>目标连接ID是一个由此数据包意图的接收方选择的一个连接ID，详见<a href="#5.1_Connection_ID">第5.1章</a>。</p>
</dd>
<dt>数据包号（Packet Number）：</dt>
<dd>
<p>这个字段的长度是1至4字节。数据包号被头部保护所保护，详见《<a href="../RFC9001_Chinese_Simplified">QUIC-TLS</a>》的<a href="../RFC9001_Chinese_Simplified/#5.4_Header_Protection">第5.4章</a>。数据包号字段的长度被编码进字节0的数据包号长度字段。有关细节见<a href="#17.1_Packet_Number_Encoding_and_Decoding">第17.1章</a>。</p>
</dd>
<dt>数据包载荷（Packet Payload）：</dt>
<dd>
<p>1-RTT数据包总是包含着受1-RTT保护的载荷。</p>
</dd>
</dl>
<p>一个短包头数据包的包头形式比特位和目标连接ID字段是版本无关的。其余字段是由选择的QUIC版本特定的。有关怎样解释不同QUIC版本的数据包的细节，见《<a href="../RFC8999_Chinese_Simplified">QUIC不变量</a>》。</p>
</div>
</section>
<section class="page" id="17.4_Latency_Spin_Bit">
<h2>
<a href="#17.4_Latency_Spin_Bit">17.4 延迟自旋比特位</a>
</h2>
<div class="content">
<p>为1-RTT数据包（<a href="#17.3.1_1-RTT_Packet">第17.3.1章</a>）定义的延迟自旋比特位允许网络路径上的各个观察点在整个连接期间进行被动的延迟监测。</p>
<p>自旋比特位仅在1-RTT数据包中出现，因为若要测量一条连接的初始RTT，可以通过观察握手过程来实现。因此，自旋比特位在版本协商和连接建立完成后才可用。《<a href="https://tools.ietf.org/html/draft-ietf-quic-manageability-11">QUIC可管理性</a>》中进一步讨论了延迟自旋比特位在链路上的测量和使用。</p>
<p>在本QUIC版本中，自旋比特位是一个<em><strong>可选</strong></em>特性。如下文所述，不支持此特性的终端<em><strong>必须</strong></em>禁用它。</p>
<p>每个终端对一条连接是否启用自旋比特位做单方面的决定。各个实现<em><strong>必须</strong></em>允许客户端和服务器的管理员能够禁用自旋比特位，要么全局禁用要么基于单条连接禁用。即使自旋比特位没有被管理员禁用，终端也<em><strong>必须</strong></em>在每16条网络路径中随机地选择至少一条，或每16个连接ID中选择一个，然后在使用这些选出的路径或连接ID时禁用自旋比特位，这是为了确保在网络上能经常观察到禁用自旋比特位的QUIC连接。当每个终端独立地禁用自旋比特位时，能确保自旋比特位信号量在大约八分之一的网络路径中是关闭的。</p>
<p>当自旋比特位被禁用时，终端<em><strong>可以</strong></em>将自旋比特位设置为任意值，且<em><strong>必须</strong></em>忽略任何传入值。<em><strong>推荐</strong></em>终端将自旋比特位设置为随机值，要么为每个数据包独立选择，要么为每个连接ID独立选择。</p>
<p>如果自旋比特位在当前连接中是启用的，终端就要为每条网络路径维护一个自旋值，并且当1-RTT数据包要在某条网络路径上发送时，将数据包头部中的自旋比特位设置为当前存储的自旋值。每个终端还要记录在每条路径上的对端所看到的最大数据包号。</p>
<p>当服务器在某条网络路径上接收到一个1-RTT数据包且它增大了服务器所记录的客户端看到的最大数据包号，服务器就将那条路径上的自旋值设置为接收到的那个数据包中的自旋值。</p>
<p>当客户端在某条网络路径上接收到一个1-RTT数据包且它增大了客户端所记录的服务器看到的最大数据包号，客户端就将那条路径上的自旋值设置为接收到的那个数据包中的自旋值的相反值。</p>
<p>当在一条网络路径上改变所使用的连接ID时，终端将那条网络路径上的自旋值重置为<code>0</code>。</p>
</div>
</section>
<section class="page" id="18_Transport_Parameter_Encoding">
<h1>
<a href="#18_Transport_Parameter_Encoding">18. 传输参数编码</a>
</h1>
<div class="content">
<p>在《<a href="/RFC9001_Chinese_Simplified">QUIC-TLS</a>》定义的<code>quic_transport_parameters</code>其<code>extension_data</code>字段包含QUIC传输参数。它们被编码为一个传输参数序列，如<a href="#Figure_20_Sequence_of_Transport_Parameters">图20</a>所示：</p>
<div class="block ref" id="Figure_20_Sequence_of_Transport_Parameters">
<pre tabindex="0"><code>传输参数序列 {
  传输参数 (..) ...,
}
</code></pre><p><a href="#Figure_20_Sequence_of_Transport_Parameters">图20：传输参数序列</a></p>
</div>
<p>每个传输参数被编码为一个形如<code>(标识符,长度,值)</code>的元组，如<a href="#Figure_21_Transport_Parameter_Encoding">图21</a>所示：</p>
<div class="block ref" id="Figure_21_Transport_Parameter_Encoding">
<pre tabindex="0"><code>传输参数 {
  传输参数ID (i),
  传输参数长度 (i),
  传输参数值 (..),
}
</code></pre><p><a href="#Figure_21_Transport_Parameter_Encoding">图21：传输参数编码</a></p>
</div>
<p><code>传输参数长度</code>字段包含<code>传输参数值</code>的字节长度。</p>
<p>QUIC编码传输参数为一个字节序列，并包含于加密握手中。</p>
</div>
</section>
<section class="page" id="18.1_Reserved_Transport_Parameters">
<h2>
<a href="#18.1_Reserved_Transport_Parameters">18.1 保留传输参数</a>
</h2>
<div class="content">
<p>标识符为<code>31 * N + 27</code>——其中<code>N</code>为整数——的传输参数保留用于执行未知传输参数。这些传输参数没有语义，可以携带任意值。</p>
</div>
</section>
<section class="page" id="18.2_Transport_Parameter_Definitions">
<h2>
<a href="#18.2_Transport_Parameter_Definitions">18.2 传输参数定义</a>
</h2>
<div class="content">
<p>本章描述本文定义的传输参数的细节。</p>
<p>这里列出的许多传输参数都是整型值。那些整型的传输参数使用变长整数编码，详见<a href="#16_Variable-Length_Integer_Encoding">第16章</a>。除非有额外说明，否则传输参数在不设置时的默认值是0。</p>
<p>各个传输参数具体定义如下：</p>
<dl>
<dt>原始目标连接ID<code>original_destination_connection_id</code> (<code>0x00</code>)：</dt>
<dd>
<p>这个参数是由客户端发出的第一个初始包的目标连接ID字段的值，详见<a href="#16_Variable-Length_Integer_Encoding">第16章</a>。该传输参数只会由服务端发出。</p>
</dd>
<dt>最大空闲超时时间<code>max_idle_timeout</code> (<code>0x01</code>)：</dt>
<dd>
<p>最大空闲超时是一个编码为整型的值，单位毫秒，详见<a href="#10.1_Idle_Timeout">第10.1章</a>。当双端均忽略此传输参数或设置其值为0时，空闲超时将被禁用。</p>
</dd>
<dt>无状态重置令牌<code>stateless_reset_token</code> (<code>0x02</code>)：</dt>
<dd>
<p>无状态重置令牌用于验证无状态重置，详见<a href="#10.3_Stateless_Reset">第10.3章</a>。这个传输参数是一个16字节的序列。客户端<em><strong>必须不</strong></em>能发送这个参数，但是服务端<em><strong>可以</strong></em>发送。没有发送此参数的服务端不能对握手期间协商的连接ID使用无状态重置。</p>
</dd>
<dt>最大UDP载荷<code>max_udp_payload_size</code> (<code>0x03</code>)：</dt>
<dd>
<p>最大UDP载荷参数是一个整型值，用于终端限制愿意接收的UDP载荷的大小。UDP报文的载荷如果大于这个限制将不太可能被服务端处理。</p>
</dd>
<dd>
<p>该参数默认值是最大UDP载荷65527。该值不能小于1200。</p>
</dd>
<dd>
<p>这个限制是对报文大小的一个与通道MTU一样的附加约束，但其是终端的属性而非通道的属性，详见<a href="#14_Datagram_Size">第14章</a>。应该认为这是终端用于保存传入数据包的空间。</p>
</dd>
<dt>初始最大数据量<code>initial_max_data</code> (<code>0x04</code>)：</dt>
<dd>
<p>初始最大数据量参数是一个包含连接可发送初始最大数据量的整型值。等效于连接在完成握手后立即发送一个<code>最大数据帧</code>（<code>MAX_DATA</code>，详见<a href="#19.9_MAX_DATA_Frames">第19.9章</a>）。</p>
</dd>
<dt>初始本地最大双向流数据量<code>initial_max_stream_data_bidi_local</code> (<code>0x05</code>)：</dt>
<dd>
<p>本参数是一个整型值，用于指定本地初始化的双向流的初始流量控制限制。这个限制适用于由发送传输参数端打开的新创建双向流。在客户端传输参数中，其适用于流标识符最低两个有效位设置为<code>0x00</code>的流；在服务端，其适用于流标识符最低两个有效位设置为<code>0x01</code>的流。</p>
</dd>
<dt>初始远端最大双向流数据量<code>initial_max_stream_data_bidi_remote</code> (<code>0x06</code>):</dt>
<dd>
<p>本参数是一个整型值，用于指定对端初始化的双向流的初始流量控制限制。这个限制适用于由接收传输参数端打开的新创建双向流。在客户端传输参数中，其适用于流标识符最低两个有效位设置为<code>0x01</code>的流；在服务端，其适用于流标识符最低两个有效位设置为<code>0x00</code>的流。</p>
</dd>
<dt>初始最大单向流数据量<code>initial_max_stream_data_uni</code> (<code>0x07</code>):</dt>
<dd>
<p>本参数是一个整型值，用于指定单向流的初始流量控制限制。这个限制适用于接收传输参数端打开的新创建单向流。在客户端传输参数中，其适用于流标识符最低两个有效位设置为<code>0x03</code>的流；在服务端，其适用于流标识符最低两个有效位设置为<code>0x02</code>的流。</p>
</dd>
<dt>初始最大双向流数量<code>initial_max_streams_bidi</code> (<code>0x08</code>):</dt>
<dd>
<p>初始最大双向流数量参数是一个整型值，包含接收该传输参数的终端允许初始化的最大双向流数量。如果这个参数未设置或置为0，则对端不能开启双向流直到发完<code>最大流帧</code>。设置该参数等效于发送一个相关流类型的数值一致的<code>最大流帧</code>（<a href="#19.11_MAX_STREAMS_Frames">第19.11章</a>）。</p>
</dd>
<dt>初始最大单向流数量<code>initial_max_streams_uni</code> (<code>0x09</code>):</dt>
<dd>
<p>初始最大单向流数量参数是一个整型值，包含接收该传输参数的终端允许初始化的最大单向流数量。如果该参数未设置或设置为0，则对端不能开启单向流直到发完<code>最大流帧</code>。设置该参数等效于发送一个相关流类型的数值一致的<code>最大流帧</code>（<a href="#19.11_MAX_STREAMS_Frames">第19.11章</a>）。</p>
</dd>
<dt>ACK延迟指数<code>ack_delay_exponent</code> (<code>0x0a</code>):</dt>
<dd>
<p>确认延迟指数是一个整型值，用于指定一个指数解码<code>ACK帧</code>的“ACK延迟”字段（<a href="#19.2_PING_Frames">第19.2章</a>）。如果该值未设置，则置一个默认值3（表示8的乘数）。大于20的值非法。</p>
</dd>
<dt>最大ACK延迟<code>max_ack_delay</code> (<code>0x0b</code>):</dt>
<dd>
<p>最大确认延迟是一个整型值，表示终端会延迟发送确认包的最大毫秒数。该值<em><strong>应该</strong></em>包括警报触发时接收者的预期延迟。例如，如果接收者设置了一个5ms超时的定时器，且警报通常会延迟1ms，那么它应该发送一个值为6ms的<code>max_ack_delay</code>参数。如果该值未设置，则会设置默认值25ms。该值为214及以上非法。</p>
</dd>
<dt>禁止活跃迁移<code>disable_active_migration</code> (<code>0x0c</code>):</dt>
<dd>
<p>禁止活动迁移传输参数是在终端握手阶段所使用的地址不支持活跃连接迁移（<a href="#9_Connection_Migration">第9章</a>）时加入的。收到该传输参数的终端<em><strong>必须不</strong></em>使用一个新的本地地址发往对端在握手阶段使用的地址。该传输参数不能在<code>preferred_address</code>已经在客户端生效后阻止连接迁移。该参数是一个非零值。</p>
</dd>
<dt>首选地址<code>preferred_address</code> (<code>0x0d</code>):</dt>
<dd>
<p>服务端首选地址用于在握手最后变更服务端地址，如<a href="#9.6_Server's_Preferred_Address">第9.6章</a>所述。该传输参数只由服务端发送。服务端<em><strong>可以</strong></em>选择只发送一个地址族中的一个首选地址，另一个地址族则发送全零地址及端口（<code>0.0.0.0:0</code>或<code>[::]:0</code>）。IP地址以网络字节序编码。</p>
<p><code>preferred_address</code>传输参数包含一个IPv4和一个IPv6的地址和端口。4字节IPv4地址字段后接相关的2字节IPv4端口字段。接下来紧随一个16字节IPv6地址字段和一个2字节IPv6端口字段。在地址和端口组合之后的是连接ID长度字段，描述接下来的连接ID的长度。最后是一个与连接ID相关的16字节无状态重置令牌字段。本传输参数格式如下述<a href="#Figure_22_Preferred_Address_Format">图22</a>所示。</p>
<p>连接ID字段及无状态重置令牌字段包含一个可选的序列号为1的连接ID，详见<a href="#5.1.1_Issuing_Connection_IDs">第5.1.1章</a>。将这些值与首选地址一起发送，可以确保当客户端开始迁移到首选地址时，至少有一个未使用的活动连接ID。</p>
<p>首选地址的连接ID和无状态重置令牌字段在语法和语义上与<code>新连接ID帧</code>相应字段相同（详见<a href="#19.15_NEW_CONNECTION_ID_Frames">第19.15章</a>）。服务端若选择了一个零长度的连接ID，则<em><strong>必须不</strong></em>提供首选地址。同理，服务端<em><strong>必须不</strong></em>在首选地址传输参数里包含零长度连接ID。客户端<em><strong>必须</strong></em>必须将违反这些要求的情况视为一个<code>TRANSPORT_PARAMETER_ERROR</code>类型的连接错误。</p>
</dd>
</dl>
<div class="block ref" id="Figure_22_Preferred_Address_Format">
<pre tabindex="0"><code>首选地址 {
  IPv4地址 (32),
  IPv4端口 (16),
  IPv6地址 (128),
  IPv6端口 (16),
  连接ID长度 (8),
  连接ID (..),
  无状态重置令牌 (128),
}
</code></pre><p><a href="#Figure_22_Preferred_Address_Format">图22：首选地址格式</a></p>
</div>
<dl>
<dt>活跃连接ID上限<code>active_connection_id_limit</code> (<code>0x0e</code>):</dt>
<dd>
<p>这是一个整型值，用于指定终端愿意存储的来自对端的最大连接ID数量。该值包括握手阶段收到的连接ID，包括从<code>preferred_address</code>参数及<code>新连接ID帧</code>里收到的。该值<em><strong>必须</strong></em>大于等于2。终端收到小于2的值<em><strong>必须</strong></em>以错误类型<code>TRANSPORT_PARAMETER_ERROR</code>关闭连接。如果没有设置该传输参数，则默认值为2。如果终端指定一个零长度连接ID，则其永远不会发送<code>新连接ID帧</code>，且会忽略从对端发来的<code>active_connection_id_limit</code>参数值。</p>
</dd>
<dt>初始源连接ID<code>initial_source_connection_id</code> (<code>0x0f</code>):</dt>
<dd>
<p>这是终端给相应连接发送的首个初始包的源连接ID字段包含的值，详见<a href="#7.3_Authenticating_Connection_IDs">第7.3章</a>。</p>
</dd>
<dt>重试源连接ID<code>retry_source_connection_id</code> (<code>0x10</code>):</dt>
<dd>
<p>这是服务端包含于一个重试包的源连接ID字段的值，详见<a href="#7.3_Authenticating_Connection_IDs">第7.3章</a>。该传输参数仅由服务端发出。</p>
</dd>
</dl>
<p>如果存在，用于设置初始化每条流的流量控制上限的传输参数（<code>initial_max_stream_data_bidi_local</code>、<code>initial_max_stream_data_bidi_remote</code>及<code>initial_max_stream_data_uni</code>）等效于在每条流开启后立即给它发送相应流类型的<em>最大流数据帧</em>（详见<a href="#19.10_MAX_STREAM_DATA_Frames">第19.10章</a>）。如果相应传输参数没有设置，则其对应流类型的流其初始流量控制上限就是0。</p>
<p>客户端<em><strong>必须不</strong></em>包含任何只有服务端可以发送的传输参数：<code>original_destination_connection_id</code>、<code>preferred_address</code>、<code>retry_source_connection_id</code>或<code>stateless_reset_token</code>。服务端<em><strong>必须</strong></em>将收到任何此类传输参数的情况视为<code>TRANSPORT_PARAMETER_ERROR</code>类型连接错误。</p>
</div>
</section>
<section class="page" id="19_Frame_Types_and_Formats">
<h1>
<a href="#19_Frame_Types_and_Formats">19. 帧类型与格式</a>
</h1>
<div class="content">
<p>正如<a href="#12.4_Frames_and_Frame_Types">第12.4章</a>所述，数据包包含一个或多个帧。本章描述QUIC帧类型的格式和语义。</p>
</div>
</section>
<section class="page" id="19.1_PADDING_Frames">
<h2>
<a href="#19.1_PADDING_Frames">19.1 填充帧</a>
</h2>
<div class="content">
<p><strong>填充帧</strong>（PADDING frame，类型<code>0x00</code>）无语义值。<strong>填充帧</strong>可以用于提高数据包大小。填充可以用于填充初始包以达到被要求的最小包大小，或对受保护数据包进行流量分析提供保护。</p>
<p><strong>填充帧</strong>的格式如<a href="#Figure_23_PADDING_Frame_Format">图23</a>所示，可见<strong>填充帧</strong>没有内容。也就是说，<strong>填充帧</strong>由标识该帧类型的单个字节构成。</p>
<div class="block ref" id="Figure_23_PADDING_Frame_Format">
<pre tabindex="0"><code>填充帧 {
  类型 (i) = 0x00,
}
</code></pre><p><a href="#Figure_23_PADDING_Frame_Format">图23：填充帧格式</a></p>
</div>
</div>
</section>
<section class="page" id="19.2_PING_Frames">
<h2>
<a href="#19.2_PING_Frames">19.2 Ping帧</a>
</h2>
<div class="content">
<p>终端可以使用<strong>Ping帧</strong>（类型为<code>0x01</code>）验证其对端是否仍然活跃，或检查到对端的可达性。</p>
<p><strong>Ping帧</strong>格式如<a href="#Figure_24_PING_Frame_Format">图24</a>所示，可见<strong>Ping帧</strong>无内容。</p>
<div class="block ref" id="Figure_24_PING_Frame_Format">
<pre tabindex="0"><code>Ping帧 {
  类型 (i) = 0x01,
}
</code></pre><p><a href="#Figure_24_PING_Frame_Format">图24：Ping帧格式</a></p>
</div>
</div>
</section>
<section class="page" id="19.3_ACK_Frames">
<h2>
<a href="#19.3_ACK_Frames">19.3 ACK帧</a>
</h2>
<div class="content">
<p>接收方发送<strong>ACK帧</strong>（类型为<code>0x02</code>或<code>0x03</code>）通知发送方其发出的数据包已经收到并处理完成了。<strong>ACK帧</strong>包含一个或多个ACK块（ACK Range）。ACK块标识被确认的数据包。如果帧类型为<code>0x03</code>，<strong>ACK帧</strong>也会包含到目前为止在该连接上收到的带有相关ECN标记的QUIC数据包的累计值。QUIC实现<em><strong>必须</strong></em>准确处理这两种类型，并且，如果其对发送数据包采用了ECN，其<em><strong>应该</strong></em>使用ECN块中的信息管理其拥塞状态。</p>
<p>QUIC的确认是不可撤销的。数据包一旦被确认，其就会维持在被确认状态，即使其没有出现在后续的<strong>ACK帧</strong>中。这一点不同于TCP选择性确认（SACK）违约（《<a href="https://www.rfc-editor.org/info/rfc2018">RFC2018</a>》）。</p>
<p>属于不同数据包号空间的数据包可以使用相同的数值标识。数据包的一个确认需要同时标明数据包号和数据包号空间。这是通过让每个<strong>ACK帧</strong>只确认其所在数据包的相同数据包号空间内的数据包实现的。</p>
<p>不能确认版本协商和重试包，因为它们不包含数据包号。这些数据包与其依靠<strong>ACK帧</strong>，不如通过后续客户端发送的初始包隐式确认。</p>
<p><strong>ACK帧</strong>格式如<a href="#Figure_25_ACK_Frame_Format">图25</a>所示。</p>
<div class="block ref" id="Figure_25_ACK_Frame_Format">
<pre tabindex="0"><code>ACK帧 {
  类型 (i) = 0x02..0x03,
  最大确认数 (i),
  ACK延迟 (i),
  ACK块计数 (i),
  首个ACK块 (i),
  ACK块 (..) ...,
  [ECN计数 (..)],
}
</code></pre><p><a href="#Figure_25_ACK_Frame_Format">图25：ACK帧格式</a></p>
</div>
<p><strong>ACk帧</strong>包含下述字段：</p>
<dl>
<dt>最大确认数（Largest Acknowledged）：</dt>
<dd>
<p>一个可变长度整型，表示对端确认的最大数据包号；这通常是对端在生成<strong>ACK帧</strong>前收到的最大数据包号。不同于QUIC长包头或短包头里的数据包号，<strong>ACK帧</strong>内的包号没有截断。</p>
</dd>
<dt>ACK延迟（ACK Delay）：</dt>
<dd>
<p>一个可变长度整型，编码ACK延迟，单位微秒，详见<a href="#13.2.5_Measuring_and_Reporting_Host_Delay">第13.2.5章</a>。其通过将字段中的值乘以2的<code>ack_delay_exponent</code>次方来解码的，其中<code>ack_delay_exponent</code>传输参数值是由<strong>ACK帧</strong>发送方发出的，详见<a href="#18.2_Transport_Parameter_Definitions">第18.2章</a>。相比于简单地用整型表示延迟，这种编码在相同字节数内支持更大范围的值，代价是分辨率较低。</p>
</dd>
<dt>ACK块计数（ACK Range Count）：</dt>
<dd>
<p>一个可变长度整型，表示<strong>ACK帧</strong>中ACK块字段的数目。</p>
</dd>
<dt>首个ACK块（First ACK Range）：</dt>
<dd>
<p>一个可变长度整型，表示在最大确认数之前正在被确认的连续的数据包的数量。也就是说，块内最小被确认的数据包的包号可以通过最大确认数减去首个ACK块值得到。</p>
</dd>
<dt>ACK块：</dt>
<dd>
<p>包含额外的数据包区段，这些数据包可以是未被确认的（空档），也可以是已被确认的（ACK块），详见<a href="#19.3.1_ACK_Ranges">第19.3.1章</a>。</p>
</dd>
<dt>ECN计数：</dt>
<dd>
<p>三个ECN统计，详见<a href="#19.3.2_ECN_Counts">第19.3.2章</a>。</p>
</dd>
</dl>
</div>
</section>
<section class="page" id="19.3.1_ACK_Ranges">
<h3>
<a href="#19.3.1_ACK_Ranges">19.3.1 ACK块</a>
</h3>
<div class="content">
<p>每个ACK块由交替的空档和ACK块长度值构成，按包号降序排列。ACK块可以重复。空档和ACK块长度值的数量由ACK块计数字段决定，每个ACK块中的一个值（空档或ACK块长度）对应ACK块计数字段的每个值。</p>
<p>ACK块的结构如<a href="#Figure_26_ACK_Ranges">图26</a>所示。</p>
<div class="block ref" id="Figure_26_ACK_Ranges">
<pre tabindex="0"><code>ACK块 {
  空档 (i),
  ACK块长度 (i),
}
</code></pre><p><a href="#Figure_26_ACK_Ranges">图26：ACK块</a></p>
</div>
<p>构成ACK块的字段是：</p>
<dl>
<dt>空档（Gap）：</dt>
<dd>
<p>一个可变长度整型值，表示比前述ACK块中的最小数据包号小一的数据包之前连续未被确认数据包的数目。</p>
</dd>
<dt>ACK块长度（ACK Range Length）：</dt>
<dd>
<p>一个可变长度整型值，表示先前空档确定的最大数据包号之前连续被确认数据包的数目。</p>
</dd>
</dl>
<p>空档和ACK块长度值使用一个相对整型编码以提高效率。即使每个编码结果是正值，但也会被减去，因此每个ACK块表示的都是包号逐渐递减的数据包。</p>
<p>每个ACK块确认一段包号连续的数据包，通过ACK块内包号最大的被确认数据包之前的包数指定确认范围。值为0表示只有包号最大的数据包被确认。更大的ACK块值表示更大的确认范围，与此同时该块内最小数据包号则更小。换言之，给定ACK块最大数据包号，则最小数据包号通过下述公式计算：</p>
<pre tabindex="0"><code>最小数据包号 = 最大数据包号 - ACK块值
</code></pre><p>一个ACK块确认最小数据包号到最大数据包号之间的全部数据包，包含两端。</p>
<p>一个ACK块的最大数据包号通过累积减去先前的所有ACK块长度和空档确定。</p>
<p>每个空档表示一段未被确认的数据包。空档内未被确认的数据包数目比空档字段中的编码值多1。</p>
<p>空档字段值使用以下公式为后续ACK块生成最大的数据包号值：</p>
<pre tabindex="0"><code>最大数据包号 = 先前最小数据包号 - 空档值 - 2
</code></pre><p>如果任何有关计算得到的数据包号是负数，则终端<em><strong>必须</strong></em>产生一个<code>FRAME_ENCODING_ERROR</code>类型的连接错误。</p>
</div>
</section>
<section class="page" id="19.3.2_ECN_Counts">
<h3>
<a href="#19.3.2_ECN_Counts">19.3.2 ECN计数</a>
</h3>
<div class="content">
<p><strong>ACK帧</strong>使用类型值的最小有效位（也就是类型<code>0x03</code>）表示ECN反馈，并通告收到在IP头部中带有与ECT(0)、ECT(1)或ECN-CE有关的ECN码点（codepoint）的QUIC数据包。ECN计数只由类型为<code>0x03</code>的<strong>ACK帧</strong>携带。</p>
<p><strong>ACK帧</strong>中ECN计数如<a href="#Figure_27_ECN_Count_Format">图27</a>所示。</p>
<div class="block ref" id="Figure_27_ECN_Count_Format">
<pre tabindex="0"><code>ECN计数 {
  ECT0计数 (i),
  ECT1计数 (i),
  ECN-CE计数 (i),
}
</code></pre><p><a href="#Figure_27_ECN_Count_Format">图27：ECN帧格式</a></p>
</div>
<p>ECN计数各个字段分别是：</p>
<dl>
<dt>ECT0计数：</dt>
<dd>
<p>一个可变长度整型值，表示收到的<strong>ACK帧</strong>所在数据包号空间里且携带ECT(0)码点的数据包总数。</p>
</dd>
<dt>ECT1计数：</dt>
<dd>
<p>一个可变长度整型值，表示收到的<strong>ACK帧</strong>所在数据包号空间里且携带ECT(1)码点的数据包总数。</p>
</dd>
<dt>ECN-CE计数：</dt>
<dd>
<p>一个可变长度整型值，表示收到的<strong>ACK帧</strong>所在数据包号空间里且携带ECN-CE码点的数据包总数。</p>
</dd>
</dl>
<p>每个数据包号空间单独维护各自的ECN计数。</p>
</div>
</section>
<section class="page" id="19.4_RESET_STREAM_Frames">
<h2>
<a href="#19.4_RESET_STREAM_Frames">19.4 重置帧</a>
</h2>
<div class="content">
<p>终端使用<strong>重置帧</strong>（RESET_STREAM frame，类型为<code>0x04</code>）立即关闭流的发送部分。</p>
<p>发送完<strong>重置帧</strong>后，终端停止在相应的流上传输或重传<strong>流帧</strong>。<strong>重置帧</strong>的接收方可以忽略任何已经在该流上收到的数据。</p>
<p>终端收到一条只用于发送的流的<strong>重置</strong>帧时<em><strong>必须</strong></em>以<code>STREAM_STATE_ERROR</code>类型错误关闭连接。</p>
<p><strong>重置帧</strong>格式如<a href="#Figure_28_RESET_STREAM_Frame_Format">图28</a>所示。</p>
<div class="block ref" id="Figure_28_RESET_STREAM_Frame_Format">
<pre tabindex="0"><code>重置帧 {
  类型 (i) = 0x04,
  流ID (i),
  应用层协议错误码 (i),
  最终大小 (i),
}
</code></pre><p><a href="#Figure_28_RESET_STREAM_Frame_Format">图28：重置帧格式</a></p>
</div>
<p><strong>重置帧</strong>包含下述字段：</p>
<dl>
<dt>流ID：</dt>
<dd>
<p>一个可变长度整型，编码需要关闭的流的流ID。</p>
</dd>
<dt>应用层协议错误码（Application Protocol Error Code）：</dt>
<dd>
<p>一个可变长度整型值，包含表明为何关闭该流的应用层协议错误码（详见<a href="#20.2_Application_Protocol_Error_Codes">第20.2章</a>）。</p>
</dd>
<dt>最终大小（Final Size）：</dt>
<dd>
<p>一个可变长度整型值，表示<strong>重置帧</strong>发送方的流最终大小，单位字节，详见<a href="#4.5_Stream_Final_Size">第4.5章</a>。</p>
</dd>
</dl>
</div>
</section>
<section class="page" id="19.5_STOP_SENDING_Frames">
<h2>
<a href="#19.5_STOP_SENDING_Frames">19.5 停止发送帧</a>
</h2>
<div class="content">
<p>终端使用<strong>停止发送帧</strong>（STOP_SENDING frame，类型是<code>0x05</code>）告知对方收到每个应用层请求时传入的数据将被丢弃。<strong>停止发送帧</strong>要求对端停止在某条流上传输数据。</p>
<p>一个<strong>停止发送帧</strong>可以在流的“接收”和“数据量确认”状态发送，详见<a href="#3.2_Receiving_Stream_States">第3.2章</a>。收到一条由本地初始化但是却尚未被创建的流的<strong>停止发送帧</strong><em><strong>必须</strong></em>视为一个<code>STREAM_STATE_ERROR</code>类型的连接错误。终端收到只用于接收的流的<strong>停止发送帧</strong><em><strong>必须</strong></em>以<code>STREAM_STATE_ERROR</code>类型的错误关闭连接。</p>
<p><strong>停止发送帧</strong>格式如<a href="#Figure_29_STOP_SENDING_Frame_Format">图29</a>所示。</p>
<div class="block ref" id="Figure_29_STOP_SENDING_Frame_Format">
<pre tabindex="0"><code>停止发送帧 {
  类型 (i) = 0x05,
  流ID (i),
  应用层协议错误码 (i),
}
</code></pre><p><a href="#Figure_29_STOP_SENDING_Frame_Format">图29：停止发送帧格式</a></p>
</div>
<p><strong>停止发送帧</strong>包含如下字段：</p>
<dl>
<dt>流ID：</dt>
<dd>
<p>一个可变长度整型值，携带需要忽略其数据的流的流ID。</p>
</dd>
<dt>应用层协议错误码（Application Protocol Error Code）：</dt>
<dd>
<p>一个可变长度整型值，包含应用层指定的发送者忽略该流数据的原因，详见<a href="#20.2_Application_Protocol_Error_Codes">第20.2章</a>。</p>
</dd>
</dl>
</div>
</section>
<section class="page" id="19.6_CRYPTO_Frames">
<h2>
<a href="#19.6_CRYPTO_Frames">19.6 加密帧</a>
</h2>
<div class="content">
<p><strong>加密帧</strong>（CRYPTO frame，类型是<code>0x06</code>）用于传输加密握手信息。其可以被除0-RTT包以外的其他类型包发送。<strong>加密帧</strong>为加密协议提供了一个有序的字节流。<strong>加密帧</strong>除了不携带流标识符（流ID）、不进行流控，以及不携带可选偏移量、可选长度及流结束标记外，它们在功能上与<strong>流帧</strong>完全相同。</p>
<p><strong>加密帧</strong>格式如<a href="#Figure_30_CRYPTO_Frame_Format">图30</a>所示。</p>
<div class="block ref" id="Figure_30_CRYPTO_Frame_Format">
<pre tabindex="0"><code>加密帧 {
  类型 (i) = 0x06,
  偏移 (i),
  长度 (i),
  加密数据 (i),
}
</code></pre><p><a href="#Figure_30_CRYPTO_Frame_Format">图30：加密帧格式</a></p>
</div>
<p><strong>加密帧</strong>包含下述字段：</p>
<dl>
<dt>偏移（Offset）：</dt>
<dd>
<p>一个可变长度整型值，表示<strong>加密帧</strong>中加密数据在数据流中的字节偏移量。</p>
</dd>
<dt>长度：</dt>
<dd>
<p>一个可变长度整型值，表示<strong>加密帧</strong>的加密数据字段携带数据长度。</p>
</dd>
<dt>加密数据（Crypto Data）：</dt>
<dd>
<p>加密信息数据。</p>
</dd>
</dl>
<p>每个加密级别都有一条单独的加密握手数据流，每条流都从偏移量0开始。也就是说每个加密级别都被视为一条单独的加密数据流。</p>
<p>这样的数据流其最大偏移量——偏移量与数据长度之和——不能超过<code>2<sup>26</sup>-1</code>。收到一个超过此上限的的帧<em><strong>必须</strong></em>视为一个<code>FRAME_ENCODING_ERROR</code>类型或<code>CRYPTO_BUFFER_EXCEEDED</code>类型的连接错误。</p>
<p>不同于<strong>流帧</strong>有着流ID用以区分数据属于哪条流，<strong>加密帧</strong>为每个加密级别携带单条流的数据。数据流没有一个明确的结束点，所以<strong>加密帧</strong>没有FIN位。</p>
</div>
</section>
<section class="page" id="19.7_NEW_TOKEN_Frames">
<h2>
<a href="#19.7_NEW_TOKEN_Frames">19.7 新令牌帧</a>
</h2>
<div class="content">
<p>服务端发送<strong>新令牌帧</strong>（NEW_TOKEN  frame，类型是<code>0x07</code>）给客户端提供一张令牌，以便客户端在一条后续流的初始包包头中携带该令牌发送过来。</p>
<p><strong>新令牌帧</strong>格式如<a href="#Figure_31_NEW_TOKEN_Frame_Format">图31</a>所示。</p>
<div class="block ref" id="Figure_31_NEW_TOKEN_Frame_Format">
<pre tabindex="0"><code>新令牌帧 {
  类型 (i) = 0x07,
  令牌长度 (i),
  令牌 (i),
}
</code></pre><p><a href="#Figure_31_NEW_TOKEN_Frame_Format">图30：新令牌帧格式</a></p>
</div>
<p><strong>新令牌帧</strong>包含如下字段：</p>
<dl>
<dt>令牌长度（Token Length）：</dt>
<dd>
<p>一个可变长度整型值，表示令牌的字节长度。</p>
</dd>
<dt>令牌：</dt>
<dd>
<p>一个不透明blob，客户端可以在后续的初始包中使用。令牌<em><strong>必须不</strong></em>为空。客户端<em><strong>必须</strong></em>将收到带空令牌字段的<strong>新令牌帧</strong>的情况视为一个<code>FRAME_ENCODING_ERROR</code>类型的连接错误。</p>
</dd>
</dl>
<p>如果包含这类帧的数据包被误认为丢失了，那么客户端可能收到多个携带相同令牌值的<strong>新令牌帧</strong>。客户端负责丢弃重复的令牌，这些令牌可能用于连接重试，详见<a href="#8.1.3_Address_Validation_for_Future_Connections">第8.1.3章</a>。</p>
<p>客户端<em><strong>必须不</strong></em>能发送<strong>新令牌帧</strong>。服务端<em><strong>必须</strong></em>将收到<strong>新令牌帧</strong>视为一个<code>PROTOCOL_VIOLATION</code>类型连接错误。</p>
</div>
</section>
<section class="page" id="19.8_STREAM_Frames">
<h2>
<a href="#19.8_STREAM_Frames">19.8 流帧</a>
</h2>
<div class="content">
<p><strong>流帧</strong>明确地创建一条流并携带流数据。<strong>流帧</strong>的类型字段格式形如<code>0b00001XXX</code>（即从<code>0x08</code>到<code>0x0f</code>之间的值）。帧类型的三个低比特位标示帧的如下字段：</p>
<ul>
<li>帧类型中的<code>OFF</code>位（<code>0x04</code>）用于标识帧的偏移字段。
当置为1，则表示偏移字段存在。
当置为0，则偏移字段不存在，且流数据的偏移量从0另开（也就是说，该帧携带这条流的起始字节，或该流的终点且不携带任何数据）。</li>
<li>帧类型的<code>LEN</code>位（<code>0x02</code>）用于标识帧的长度字段。
当置为0，则表示长度字段不存在，且流数据字段延续到数据包的末尾。
当置为1，则表示长度字段存在。</li>
<li>帧类型的<code>FIN</code>位（<code>0x01</code>）标志流的结束。
流的最终数据量等于偏移量与该帧的长度之和。</li>
</ul>
<p>如果收到属于一条由本地初始化却尚未创建的流或一条只用于发送的流的<strong>流帧</strong>，则终端<em><strong>必须</strong></em>以<code>STREAM_STATE_ERROR</code>类型错误关闭连接。</p>
<p><strong>流帧</strong>格式如<a href="#Figure_32_STREAM_Frame_Format">图32</a>所示。</p>
<div class="block ref" id="Figure_32_STREAM_Frame_Format">
<pre tabindex="0"><code>流帧 {
  类型 (i) = 0x08..0x0f,
  流ID (i),
  [偏移 (i)],
  [长度 (i)],
  流数据 (..),
}
</code></pre><p><a href="#Figure_32_STREAM_Frame_Format">图32：流帧格式</a></p>
</div>
<p><strong>流帧</strong>包含如下字段：</p>
<dl>
<dt>流ID：</dt>
<dd>
<p>一个可变长度整型值，表示流的流ID，详见<a href="#2.1_Stream_Types_and_Identifiers">第2.1章</a>。</p>
</dd>
<dt>偏移（Offset）：</dt>
<dd>
<p>一个可变长度整型值，表示<strong>流帧</strong>中的流数据在整条流中的字节偏移量。这个字段在<code>OFF</code>位置为1时存在。当偏移字段不存在时，偏移量为0。</p>
</dd>
<dt>长度：</dt>
<dd>
<p>一个可变长度整型值，表示<strong>流帧</strong>中的流数据字段的长度。该字段在<code>LEN</code>位置为1时存在。当<code>LEN</code>位置为0，则流数据字段会囊括数据包的所有剩余字节。</p>
</dd>
<dt>流数据（Stream Data）：</dt>
<dd>
<p>指定流中需要传递的字节。</p>
</dd>
</dl>
<p>当流数据字段长度为0，流帧的偏移量就是下一个将要发送的字节的偏移量。</p>
<p>流的首字节的偏移量是0。流传输的最大偏移量——帧的偏移值与数据长度之和——不能超过<code>2<sup>62</sup>-1</code>，因为无法为这样的数据量分配流量控制额度。收到一个超过该限制的帧的情况<em><strong>必须</strong></em>视为一个<code>FRAME_ENCODING_ERROR</code>类型或<code>FLOW_CONTROL_ERROR</code>类型的连接错误。</p>
</div>
</section>
<section class="page" id="19.9_MAX_DATA_Frames">
<h2>
<a href="#19.9_MAX_DATA_Frames">19.9 最大数据量帧</a>
</h2>
<div class="content">
<p><strong>最大数据量帧</strong>（MAX_DATA frame，类型是<code>0x10</code>）用于流量控制，告知对端可以在整个连接上发送的最大数据量。</p>
<p><strong>最大数据量帧</strong>格式如<a href="#Figure_33_MAX_DATA_Frame_Format">图33</a>所示。</p>
<div class="block ref" id="Figure_33_MAX_DATA_Frame_Format">
<pre tabindex="0"><code>最大数据量帧 {
  类型 (i) = 0x10,
  最大数据量 (i),
}
</code></pre><p><a href="#Figure_33_MAX_DATA_Frame_Format">图32：最大数据量帧格式</a></p>
</div>
<p><strong>最大数据量帧</strong>包含下述字段：</p>
<dl>
<dt>最大数据量（Maximum Data）：</dt>
<dd>
<p>一个可变长度整型值，表示可以在整个连接上发送的最大数据量，单位字节。</p>
</dd>
</dl>
<p>流帧上发送的所有数据的总和趋近该限制。所有流的最终数据量之和——包括处于关闭状态的流——<em><strong>必须不</strong></em>可超过接收方指定的这个值。如果终端收到的数据量超过了它发出的最大数据量值，其<em><strong>必须</strong></em>以<code>FLOW_CONTROL_ERROR</code>类型错误关闭流。这包括违背早期数据记录的限制，详见<a href="#7.4.1_Values_of_Transport_Parameters_for_0_RTT">第7.4.1章</a>。</p>
</div>
</section>
<section class="page" id="19.10_MAX_STREAM_DATA_Frames">
<h2>
<a href="#19.10_MAX_STREAM_DATA_Frames">19.10 最大流数据量帧</a>
</h2>
<div class="content">
<p><strong>最大流数据量帧</strong>（MAX_STREAM_DATA frame，类型是<code>0x11</code>）用于流量控制中通知对端一条流上可以发送的最大数据量。</p>
<p><strong>最大流数据量帧</strong>可以在流的“接收”状态发送，详见<a href="#3.2_Receiving_Stream_States">第3.2章</a>。收到一条由本地初始化却尚未创建的流的<strong>最大流数据量帧</strong>的情况<em><strong>必须</strong></em>视为一个<code>STREAM_STATE_ERROR</code>类型连接错误。收到只用于发送的流的<strong>最大流数据量帧</strong>的终端<em><strong>必须</strong></em>以<code>STREAM_STATE_ERROR</code>类型错误关闭连接。</p>
<p><strong>最大流数据量帧</strong>格式如<a href="#Figure_34_MAX_STREAM_DATA_Frame_Format">图34</a>所示。</p>
<div class="block ref" id="Figure_34_MAX_STREAM_DATA_Frame_Format">
<pre tabindex="0"><code>最大流数据量帧 {
  类型 (i) = 0x11,
  流ID (i),
  最大流数据量 (i),
}
</code></pre><p><a href="#Figure_34_MAX_STREAM_DATA_Frame_Format">图34：最大流数据量帧格式</a></p>
</div>
<p><strong>最大流数据量帧</strong>包含如下字段：</p>
<dl>
<dt>流ID：</dt>
<dd>
<p>被作用的流的流ID，以可变长度整数值编码。</p>
</dd>
<dt>最大流数据量（Maximum Stream Data）：</dt>
<dd>
<p>一个可变长度整型值，表示可以在标识流上发送的最大数据量，单位字节。</p>
</dd>
</dl>
<p>当累计数据量趋近该限制，终端统计在流上发送或接收的数据的最大接收偏移量。丢失或乱序可能意味着一条流的最大接收数据偏移量可能会大于该流上收到的总数据量。收到<strong>流帧</strong>可能不会提升最大接收偏移量。</p>
<p>流上发送的数据<em><strong>必须不</strong></em>可以超过接收方发出的最大流数据量值的最大值。如果终端收到比其给相关流发出的最大流数据量的最大值更多的数据量，终端<em><strong>必须</strong></em>以<code>FLOW_CONTROL_ERROR</code>类型错误关闭连接。这包括违背早期数据记录的限制，详见<a href="#7.4.1_Values_of_Transport_Parameters_for_0_RTT">第7.4.1章</a>。</p>
</div>
</section>
<section class="page" id="19.11_MAX_STREAMS_Frames">
<h2>
<a href="#19.11_MAX_STREAMS_Frames">19.11 最大流帧</a>
</h2>
<div class="content">
<p><strong>最大流帧</strong>（MAX_STREAMS frame，类型是<code>0x12</code>或<code>0x13</code>）用于告知对端允许打开给定类型的流的累积数量。类型<code>0x12</code>的<strong>最大流帧</strong>用于双向流，类型<code>0x13</code>的则用于单向流。</p>
<p><strong>最大流帧</strong>格式如<a href="#Figure_35_MAX_STREAMS_Frame_Format">图35</a>所示。</p>
<div class="block ref" id="Figure_35_MAX_STREAMS_Frame_Format">
<pre tabindex="0"><code>最大流帧 {
  类型 (i) = 0x12..0x13,
  最大流数 (i),
}
</code></pre><p><a href="#Figure_35_MAX_STREAMS_Frame_Format">图35：最大流帧格式</a></p>
</div>
<p><strong>最大流帧</strong>包含下述字段：</p>
<dl>
<dt>最大流数：</dt>
<dd>
<p>在连接的生命周期内可以打开的相应类型流的累积总数。该值不能超过<code>2<sup>60</sup></code>，因为不能编码大于<code>2<sup>60</sup>-1</code>的流ID。收到允许开启高于该限制数量流的<strong>最大流帧</strong>的情况<em><strong>必须</strong></em>视为一个<code>FRAME_ENCODING_ERROR</code>类型的连接错误。</p>
</dd>
</dl>
<p>丢失或乱序可能导致终端收到一个<strong>最大流帧</strong>，其限制低于之前收到的<strong>最大流帧</strong>。<em><strong>必须</strong></em>忽略不能提高流数量限制的<strong>最大流帧</strong>。</p>
<p>终端<em><strong>必须不</strong></em>打开超过其对端设置的当前流限制所允许的更多的流。例如，服务端收到限制单向流数量为3，则其可以打开流3、7和11，但是不能打开流15。如果对端打开超过其被允许的流，那么终端<em><strong>必须</strong></em>以<code>STREAM_LIMIT_ERROR</code>类型错误关闭连接。这包括违背早期数据记录的限制，详见<a href="#7.4.1_Values_of_Transport_Parameters_for_0_RTT">第7.4.1章</a>。</p>
<p>注意这些帧（以及有关传输参数）并未描述可以并发打开的流的数量。该限制包括已经关闭的流和打开的流。</p>
</div>
</section>
<section class="page" id="19.12_DATA_BLOCKED_Frames">
<h2>
<a href="#19.12_DATA_BLOCKED_Frames">19.12 数据阻塞帧</a>
</h2>
<div class="content">
<p>发送方<em><strong>应该</strong></em>在其希望发送数据却因连接级流量控制而无法发送时，发送<strong>数据阻塞帧</strong>（DATA_BLOCKED frame，类型是<code>0x14</code>），详见<a href="#4_Flow_Control">第4章</a>。<strong>数据阻塞帧</strong>可以用于流量控制算法的调控输入。</p>
<p><strong>数据阻塞帧</strong>格式如<a href="#Figure_36_DATA_BLOCKED_Frame_Format">图36</a>所示。</p>
<div class="block ref" id="Figure_36_DATA_BLOCKED_Frame_Format">
<pre tabindex="0"><code>数据阻塞帧 {
  类型 (i) = 0x14,
  最大数据量 (i),
}
</code></pre><p><a href="#Figure_36_DATA_BLOCKED_Frame_Format">图36：数据阻塞帧格式</a></p>
</div>
<p><strong>数据阻塞帧</strong>包含下述字段：</p>
<dl>
<dt>最大数据量：</dt>
<dd>
<p>一个可变长度整型值，表示连接阻塞时的连接级限制。</p>
</dd>
</dl>
</div>
</section>
<section class="page" id="19.13_STREAM_DATA_BLOCKED_Frames">
<h2>
<a href="#19.13_STREAM_DATA_BLOCKED_Frames">19.13 流数据阻塞帧</a>
</h2>
<div class="content">
<p>发送方<em><strong>应该</strong></em>在其希望发送数据却因流级流量控制而无法发送时，发送<strong>流数据阻塞帧</strong>（STREAM_DATA_BLOCKED frame，类型是<code>0x15</code>）。该传输参数类似于<strong>数据阻塞帧</strong>，详见<a href="#19.12_DATA_BLOCKED_Frames">第19.12章</a>。</p>
<p>收到一条只用于发送的流的<strong>流数据阻塞帧</strong>时，终端<em><strong>必须</strong></em>以<code>STREAM_STATE_ERROR</code>类型错误关闭连接。</p>
<p><strong>流数据阻塞帧</strong>格式如<a href="#Figure_37_STREAM_DATA_BLOCKED_Frame_Format">图37</a>所示。</p>
<div class="block ref" id="Figure_37_STREAM_DATA_BLOCKED_Frame_Format">
<pre tabindex="0"><code>流数据阻塞帧 {
  类型 (i) = 0x15,
  最大流数据量 (i),
}
</code></pre><p><a href="#Figure_37_STREAM_DATA_BLOCKED_Frame_Format">图37：流数据阻塞帧格式</a></p>
</div>
<p><strong>流数据阻塞帧</strong>包含如下字段：</p>
<dl>
<dt>流ID：</dt>
<dd>
<p>一个可变长度整型值，表示被流量控制阻塞的流。</p>
</dd>
<dt>最大流数据量：</dt>
<dd>
<p>一个可变长度整型值，表示阻塞发生时流的偏移量。</p>
</dd>
</dl>
</div>
</section>
<section class="page" id="19.14_STREAMS_BLOCKED_Frames">
<h2>
<a href="#19.14_STREAMS_BLOCKED_Frames">19.14 流阻塞帧</a>
</h2>
<div class="content">
<p>发送方<em><strong>应该</strong></em>在其希望打开一条流但是被对端设置的最大流上限（详见<a href="#19.11_MAX_STREAMS_Frames">第19.11章</a>）所限制时，发送<strong>流阻塞帧</strong>（STREAM_BLOCKED frame，类型是<code>0x16</code>或<code>0x17</code>）。类型为<code>0x16</code>的<strong>流阻塞帧</strong>用于表示双向流达到上限，而类型<code>0x17</code>则表示单向流达到上限。</p>
<p><strong>流阻塞帧</strong>不会打开流，而是告知对端需要打开一条流，但是当前的流数上限阻止了这条流的创建。</p>
<p><strong>流阻塞帧</strong>格式如<a href="#Figure_38_STREAM_BLOCKED_Frame_Format">图38</a>所示。</p>
<div class="block ref" id="Figure_38_STREAM_BLOCKED_Frame_Format">
<pre tabindex="0"><code>流阻塞帧 {
  类型 (i) = 0x16..0x17,
  最大流数 (i),
}
</code></pre><p><a href="#Figure_38_STREAM_BLOCKED_Frame_Format">图38：流阻塞帧格式</a></p>
</div>
<p><strong>流阻塞帧</strong>包含如下字段：</p>
<dl>
<dt>最大流数：</dt>
<dd>
<p>一个可变长度整型值，表示该帧发送时允许创建的最大流数量。该值不能超过<code>2<sup>60</sup></code>，因为不能编码超过<code>2<sup>62-1</sup></code>的流ID。收到编码值超过这个限制的<strong>流阻塞帧</strong>的情况<em><strong>必须</strong></em>被视为一个<code>STREAM_LIMIT_ERROR</code>或<code>FRAME_ENCODING_ERROR</code>类型的连接错误。</p>
</dd>
</dl>
</div>
</section>
<section class="page" id="19.15_NEW_CONNECTION_ID_Frames">
<h2>
<a href="#19.15_NEW_CONNECTION_ID_Frames">19.15 新连接ID帧</a>
</h2>
<div class="content">
<p>终端发送<strong>新连接ID帧</strong>（NEW_CONNECTION_ID frame，类型为<code>0x18</code>）给对端提供可选连接ID，其可以用于连接迁移时中断连接性，详见<a href="#9.5_Privacy_Implications_of_Connection_Migration">第9.5章</a>。</p>
<p><strong>新连接ID帧</strong>格式如<a href="#Figure_39_NEW_CONNECTION_ID_Frame_Format">图39</a>所示。</p>
<div class="block ref" id="Figure_39_NEW_CONNECTION_ID_Frame_Format">
<pre tabindex="0"><code>新连接ID帧 {
  类型 (i) = 0x18,
  序列号 (i),
  停用前 (i),
  长度 (i),
  连接ID (8..160),
  无状态重置令牌 (128),
}
</code></pre><p><a href="#Figure_39_NEW_CONNECTION_ID_Frame_Format">图39：新连接ID帧格式</a></p>
</div>
<p><strong>新连接ID帧</strong>包含如下字段：</p>
<dl>
<dt>序列号：</dt>
<dd>
<p>序列号由发送方分配给连接ID，编码为可变长度整型值，详见<a href="#5.1.1_Issuing_Connection_IDs">第5.1.1章</a>。</p>
</dd>
<dt>停用前（Retire Prior To）：</dt>
<dd>
<p>一个可变长度整型值，表示被停用的连接ID（们），详见<a href="#5.1.2_Consuming_and_Retiring_Connection_IDs">第5.1.2章</a>。</p>
</dd>
<dt>长度（Length）：</dt>
<dd>
<p>一个8位无符号整型值，包含连接ID的长度。小于1或大于20的长度值均是无效的，且<em><strong>必须</strong></em>视其为一个<code>FRAME_ENCODING_ERROR</code>类型连接错误。</p>
</dd>
<dt>连接ID：</dt>
<dd>
<p>一个指定长度的连接ID。</p>
</dd>
<dt>无状态重置令牌（Stateless Reset Token）：</dt>
<dd>
<p>一个128位值，在对关联的连接ID进行无状态重置时使用，详见<a href="#10.3_Stateless_Reset">第10.3章</a>。</p>
</dd>
</dl>
<p>如果终端当前需要对端使用0长度的目标连接ID，那么其<em><strong>必须不</strong></em>能发送该帧。将连接ID长度改为0长度或从0长度改为非0长度都会使得难以辨别连接ID值何时发生了改变。终端发送0长度目标连接ID的数据包时，<em><strong>必须</strong></em>将收到<strong>新连接ID帧</strong>的情况视为一个<code>PROTOCOL_VIOLATION</code>类型连接错误。</p>
<p>传输错误、超时和重传可能导致相同的<strong>新连接ID帧</strong>被重复接收。重复接收相同的该类帧的情况<em><strong>必须不</strong></em>能被当作连接错误处理。接收方可以根据<strong>新连接ID帧</strong>提供的序列号处理重复收到相同<strong>新连接ID帧</strong>的情况。</p>
<p>如果终端收到一个<strong>新连接ID帧</strong>重复了之前发布的连接ID，却有着不同的无状态重置令牌或不同的序列号字段值或该序列号用于其他不同的连接ID，终端<em><strong>可以</strong></em>将之视为一个<code>PROTOCOL_VIOLATION</code>类型连接错误。</p>
<p>“停用前”字段适用于在连接设置期间创建的连接ID以及<code>preferred_address</code>传输参数，详见<a href="#5.1.2_Consuming_and_Retiring_Connection_IDs">第5.1.2章</a>。“停用前”字段值<em><strong>必须</strong></em>小于或等于“序列号”字段值。收到“停用前”字段值大于序列号字段值<em><strong>必须</strong></em>视为一个<code>FRAME_ENCODING_ERROR</code>类型连接错误。</p>
<p>一旦发送方指定了一个“停用前”字段值，在后续<strong>新连接ID帧</strong>中发送的较小值就不再发挥作用了。接收方<em><strong>必须</strong></em>忽略任何没有提高最大“停用前”值的“停用前”字段。</p>
<p>收到序列号小于已收到<strong>新连接ID帧</strong>的“停用前”字段值的<strong>新连接ID帧</strong>的终端<em><strong>必须</strong></em>发送一个相应的停用新收到连接ID的<strong>停用连接ID帧</strong>，除非其已经对该序列号发过这个帧了。</p>
</div>
</section>
<section class="page" id="19.16_RETIRE_CONNECTION_ID_Frames">
<h2>
<a href="#19.16_RETIRE_CONNECTION_ID_Frames">19.16 停用连接ID帧</a>
</h2>
<div class="content">
<p>终端发送<strong>停用连接ID帧</strong>（RETIRE_CONNECTION_ID frame，类型是<code>0x19</code>）来表明其将不再使用对端发布的某个连接ID。这包含握手期间提供的连接ID。发送一个<strong>停用连接ID帧</strong>也作为一个请求令对端发送额外的连接ID以备后续使用，详见<a href="#5.1_Connection_ID">第5.1章</a>。新连接ID可以通过<strong>新连接ID帧</strong>发往对端。</p>
<p>停用一个连接ID会令该连接ID关联的无状态重置令牌失效。</p>
<p><strong>停用连接ID帧</strong>格式如<a href="#Figure_40_RETIRE_CONNECTION_ID_Frame_Format">图40</a>所示。</p>
<div class="block ref" id="Figure_40_RETIRE_CONNECTION_ID_Frame_Format">
<pre tabindex="0"><code>停用连接ID帧 {
  类型 (i) = 0x19,
  序列号 (i),
}
</code></pre><p><a href="#Figure_40_RETIRE_CONNECTION_ID_Frame_Format">图40：停用连接ID帧格式</a></p>
</div>
<p><strong>停用连接ID帧</strong>包含如下字段：</p>
<dl>
<dt>序列号：</dt>
<dd>
<p>被停用的连接ID的序列号，详见<a href="#5.1.2_Consuming_and_Retiring_Connection_IDs">第5.1.2章</a>。</p>
</dd>
</dl>
<p>收到包含大于任何先前发往对端的序列号的<strong>停用连接ID帧</strong>的情况<em><strong>必须</strong></em>视为一个<code>PROTOCOL_VIOLATION</code>类型连接错误。</p>
<p><strong>停用连接ID帧</strong>指定的序列号<em><strong>必须不</strong></em>能指向包含该帧的数据包的目标连接ID。对端<em><strong>可以</strong></em>将这种情况视为一个<code>PROTOCOL_VIOLATION</code>类型连接错误。</p>
<p>如果对端提供过一个零长度连接ID，终端不能发生这类帧。提供零长度连接ID的终端<em><strong>必须</strong></em>将收到<strong>停用连接ID帧</strong>视为一个<code>PROTOCOL_VIOLATION</code>类型连接错误。</p>
</div>
</section>
<section class="page" id="19.17_PATH_CHALLENGE_Frames">
<h2>
<a href="#19.17_PATH_CHALLENGE_Frames">19.17 通道挑战帧</a>
</h2>
<div class="content">
<p>终端可以使用<strong>通道挑战帧</strong>（PATH_CHALLENGE frame，类型是<code>0x1a</code>）检查到对端的可达性以及进行连接迁移过程中的通道验证。</p>
<p><strong>通道挑战帧</strong>格式如<a href="#Figure_41_PATH_CHALLENGE_Frame_Format">图41</a>所示。</p>
<div class="block ref" id="Figure_41_PATH_CHALLENGE_Frame_Format">
<pre tabindex="0"><code>通道挑战帧 {
  类型 (i) = 0x1a,
  数据 (64),
}
</code></pre><p><a href="#Figure_41_PATH_CHALLENGE_Frame_Format">图41：通道挑战帧格式</a></p>
</div>
<p><strong>通道挑战帧</strong>包含如下字段：</p>
<dl>
<dt>数据：</dt>
<dd>
<p>8字节字段包含一段任意数据。</p>
</dd>
</dl>
<p>包含64位任意数据的<strong>通道挑战帧</strong>确保接收数据包比猜测值的正确性更简单。</p>
<p>接收方收到该帧后<em><strong>必须</strong></em>生成一个包含同样数据字段内容的<strong>回复通道帧</strong>（详见<a href="#19.18_PATH_RESPONSE_Frames">第19.18章</a>）。</p>
</div>
</section>
<section class="page" id="19.18_PATH_RESPONSE_Frames">
<h2>
<a href="#19.18_PATH_RESPONSE_Frames">19.18 回复通道帧</a>
</h2>
<div class="content">
<p><strong>回复通道帧</strong>（PATH_RESPONSE frame，类型为<code>0x1b</code>）作为<strong>通道挑战帧</strong>的响应发送。</p>
<p><strong>回复通道帧</strong>格式如<a href="#Figure_42_PATH_RESPONSE_Frame_Format">图42</a>所示。<strong>回复通道帧</strong>格式与<strong>通道挑战帧</strong>一致，详见<a href="#19.17_PATH_CHALLENGE_Frames">第19.17章</a>。</p>
<div class="block ref" id="Figure_42_PATH_RESPONSE_Frame_Format">
<pre tabindex="0"><code>回复通道帧 {
  类型 (i) = 0x1a,
  数据 (64),
}
</code></pre><p><a href="#Figure_42_PATH_RESPONSE_Frame_Format">图42：回复通道帧格式</a></p>
</div>
<p>如果<strong>回复通道帧</strong>的内容与先前发送的<strong>通道挑战帧</strong>内容不匹配，终端<em><strong>可以</strong></em>生成一个<code>PROTOCOL_VIOLATION</code>类型连接错误。</p>
</div>
</section>
<section class="page" id="19.19_CONNECTION_CLOSE_Frames">
<h2>
<a href="#19.19_CONNECTION_CLOSE_Frames">19.19 连接关闭帧</a>
</h2>
<div class="content">
<p>终端发送<strong>连接关闭帧</strong>（CONNECTION_CLOSE frame，类型是<code>0x1c</code>或<code>0x1d</code>）通知对端连接正在关闭中。<code>0x1c</code>类型的<strong>连接关闭帧</strong>用于QUIC层发送错误信号，或没有错误（携带<code>NO_ERROR</code>码）。<code>0x1d</code>类型的<strong>连接关闭帧</strong>用于使用QUIC的应用程序发送错误信号。</p>
<p>如果有打开的流尚未被显式关闭，当连接关闭时它们将被隐式关闭。</p>
<p><strong>连接关闭帧</strong>格式如<a href="#Figure_43_CONNECTION_CLOSE_Frame_Format">图43</a>所示。</p>
<div class="block ref" id="Figure_43_CONNECTION_CLOSE_Frame_Format">
<pre tabindex="0"><code>连接关闭帧 {
  类型 (i) = 0x1c..0x1d,
  错误码 (i),
  [帧类型 (i)],
  原因语句长度 (i),
  原因语句 (..),
}
</code></pre><p><a href="#Figure_43_CONNECTION_CLOSE_Frame_Format">图43：连接关闭帧格式</a></p>
</div>
<p><strong>连接关闭帧</strong>包含如下字段：</p>
<dl>
<dt>错误码：</dt>
<dd>
<p>一个可变长度整型值，表示关闭该连接的原因。<code>0x1c</code>类型<strong>连接关闭帧</strong>使用<a href="#20.1_Transport_Error_Codes">第20.1章</a>定义的错误码；<code>0x1d</code>类型<strong>连接关闭帧</strong>使用<a href="#20.2_Application_Protocol_Error_Codes">第20.2章</a>定义的错误码。</p>
</dd>
<dt>帧类型：</dt>
<dd>
<p>一个可变长度整型值，编码触发该错误的帧类型。值为0（相当于<strong>填充帧</strong>）用于未知帧类型。应用层型<strong>连接关闭帧</strong>（类型<code>0x1d</code>）不包含此字段。</p>
</dd>
<dt>原因语句长度（Reason Phrase Length）：</dt>
<dd>
<p>一个可变长度整型值，指定原因语句的字节长度。由于<strong>连接关闭帧</strong>不能被拆分到多个数据包，因此任何对数据包大小作出的限制也会相应得限制原因语句的可用空间。</p>
</dd>
<dt>原因语句（Reason Phrase）：</dt>
<dd>
<p>关闭相关的附加诊断信息。如果发送方选择不在错误码之外给出更多细节，该字段可以是零长度。该字段<em><strong>应该</strong></em>是UTF-8编码字符串<sup><a href="#RFC3629">RFC3629</a></sup>，即使该帧没有携带如语言标签之类的信息，这些信息有助于帮助创建文本之外的其他实体理解。</p>
</dd>
</dl>
<p><strong>连接关闭帧</strong>（<code>0x1d</code>类型）的应用指定变量只可以通过0-RTT或1-RTT包发送，详见<a href="#12.5_Frames_and_Number_Spaces">第12.5章</a>。当应用层意图在握手阶段放弃一条连接时，终端可以通过初始包或握手包发送一个错误码为<code>APPLICATION_ERROR</code>的<strong>连接关闭帧</strong>（类型<code>0x1c</code>）。</p>
</div>
</section>
<section class="page" id="19.20_HANDSHAKE_DONE_Frames">
<h2>
<a href="#19.20_HANDSHAKE_DONE_Frames">19.20 握手完成帧</a>
</h2>
<div class="content">
<p>服务端使用<strong>握手完成帧</strong>（HANDSHAKE_DONE frame，类型<code>0x1e</code>）向客户端发送确认握手的信号。</p>
<p><strong>握手完成帧</strong>格式如<a href="#Figure_44_HANDSHAKE_DONE_Frame_Format">图44</a>所示，可见该类帧没有内容。</p>
<div class="block ref" id="Figure_44_HANDSHAKE_DONE_Frame_Format">
<pre tabindex="0"><code>握手完成帧 {
  类型 (i) = 0x1e,
}
</code></pre><p><a href="#Figure_44_HANDSHAKE_DONE_Frame_Format">图44：握手完成帧格式</a></p>
</div>
<p><strong>握手完成帧</strong>只可以由服务端发送。服务端<em><strong>必须不</strong></em>能在完成握手前发送<strong>握手完成帧</strong>。服务的<em><strong>必须</strong></em>必须将收到<strong>握手完成帧</strong>视为一个<code>PROTOCOL_VIOLATION</code>类型连接错误。</p>
</div>
</section>
<section class="page" id="19.21_Extension_Frames">
<h2>
<a href="#19.21_Extension_Frames">19.21 扩展帧</a>
</h2>
<div class="content">
<p>QUIC帧不使用自描述编码。终端因而需要理解所有帧的语法才能成功处理数据包。这使帧的编码得以高效，但是也意味着终端不能发送一个对端不知道类型的帧。</p>
<p>意图使用新类型帧的QUIC扩展<em><strong>必须</strong></em>事先确保对端能够理解该帧。终端可以使用传输参数表示其愿意接收的扩展帧类型。一个传输参数可以表示支持一个或多个扩展帧类型。</p>
<p>修改或替换核心协议功能（包括帧类型）的扩展将难以与其他修改相同功能的扩展兼容，除非明确定义了组合的行为方式。这种扩展<em><strong>应该</strong></em>定义如何与先前定义的修改了相同协议组件的扩展进行互动。</p>
<p>扩展帧<em><strong>必须</strong></em>是受拥塞控制的，且<em><strong>必须</strong></em>触发<strong>ACK帧</strong>发送。替换或补充ACK帧的扩展帧除外。扩展帧不包含在流量控制中，除非在扩展中有指定。</p>
<p>IANA注册表用于管理帧类型的分配，详见<a href="#22.2_QUIC_Versions_Registry">第22.2章</a>。</p>
</div>
</section>
<section class="page" id="20_Error_Codes">
<h1>
<a href="#20_Error_Codes">20. 错误码</a>
</h1>
<div class="content">
<p>QUIC传输层错误码和应用层错误码都是62位无符号整型。</p>
</div>
</section>
<section class="page" id="20.1_Transport_Error_Codes">
<h1>
<a href="#20.1_Transport_Error_Codes">20.1. 传输层错误码</a>
</h1>
<div class="content">
<p>本章列出可能在<code>0x1c</code>类型<strong>连接关闭帧</strong>中使用的QUIC错误码的定义。这些错误可能在整个连接期间发生。</p>
<dl>
<dt>NO_ERROR (<code>0x00</code>，无错误):</dt>
<dd>
<p>终端在<strong>连接关闭帧</strong>中携带该错误码以通知连接在没有发生任何错误之下关闭。</p>
</dd>
</dl>
<p>INTERNAL_ERROR (<code>0x01</code>，内部错误):</p>
<p>：  终端遇到内部错误而不能继续维持连接。</p>
<dl>
<dt>CONNECTION_REFUSED (<code>0x02</code>，连接拒绝):</dt>
<dd>
<p>服务端拒绝接收新连接。</p>
</dd>
<dt>FLOW_CONTROL_ERROR (<code>0x03</code>，流量控制错误):</dt>
<dd>
<p>终端收到的数据量多于其被推荐的数据量上限，详见<a href="#4_Flow_Control">第4章</a>。</p>
</dd>
<dt>STREAM_LIMIT_ERROR (<code>0x04</code>，流限制错误):</dt>
<dd>
<p>终端收到一个流标识对应帧超过了该相关类型的流被推荐的流上限。</p>
</dd>
<dt>STREAM_STATE_ERROR (<code>0x05</code>，流状态错误):</dt>
<dd>
<p>终端收到流的一个帧，但是当前所处状态不允许接收该类帧，详见<a href="#3_Stream_States">第3章</a>。</p>
</dd>
<dt>FINAL_SIZE_ERROR (<code>0x06</code>，最终大小错误):</dt>
<dd>
<p>1、终端收到包含超过先前确立的最终大小数据量数据的<strong>流帧</strong>；2、终端收到包含一个最终大小的<strong>流帧</strong>或<strong>流重置帧</strong>，该最终大小小于该流已经收到数据的大小；3、或终端收到包含的最终大小与已经确立的最终大小不一致的<strong>流帧</strong>或<strong>流重置帧</strong>。</p>
</dd>
<dt>FRAME_ENCODING_ERROR (<code>0x07</code>，帧编码错误):</dt>
<dd>
<p>终端收到一个错误格式的帧——例如，一个未知类型的帧，或包含过多确认范围以至于超出数据包剩余空间所能承载的<strong>ACK帧</strong>。</p>
</dd>
<dt>TRANSPORT_PARAMETER_ERROR (<code>0x08</code>，传输参数错误):</dt>
<dd>
<p>终端收到的传输参数存在格式错误、包含无效值、省略了强制要求传输的、传输了禁止传输的，或存在其他错误。</p>
</dd>
<dt>CONNECTION_ID_LIMIT_ERROR (<code>0x09</code>，连接ID限制错误):</dt>
<dd>
<p>对端提供的连接ID数量超出了<code>active_connection_id_limit</code>的限制。</p>
</dd>
<dt>PROTOCOL_VIOLATION (<code>0x0a</code>，协议违背):</dt>
<dd>
<p>终端检测到未被更具体的错误码覆盖的违背协议错误。</p>
</dd>
<dt>INVALID_TOKEN (<code>0x0b</code>，无效令牌):</dt>
<dd>
<p>服务端收到客户端包含无效令牌字段的初始包。</p>
</dd>
<dt>APPLICATION_ERROR (<code>0x0c</code>，应用错误):</dt>
<dd>
<p>应用程序或应用层协议导致连接关闭。</p>
</dd>
<dt>CRYPTO_BUFFER_EXCEEDED (<code>0x0d</code>，加密缓存溢出):</dt>
<dd>
<p>终端在<strong>加密帧</strong>收到的数据量超出其缓存容量。</p>
</dd>
<dt>KEY_UPDATE_ERROR (<code>0x0e</code>，密钥更新错误):</dt>
<dd>
<p>终端在执行密钥更新中检测到错误，详见《<a href="../RFC9001_Chinese_Simplified">QUIC-TLS</a>》<a href="../RFC9001_Chinese_Simplified/#6_Key_Update">第6章</a>。</p>
</dd>
<dt>AEAD_LIMIT_REACHED (<code>0x0f</code>，触及AEAD上限):</dt>
<dd>
<p>终端已经触及给定连接所用AEAD算法的保密性或完整性上限。</p>
</dd>
<dt>NO_VIABLE_PATH (<code>0x10</code>，无可行通道):</dt>
<dd>
<p>终端已经确认网络通道不能支持QUIC。终端不太可能收到携带该错误码的<strong>连接关闭帧</strong>，除非通道不支持足够大的MTU。</p>
</dd>
<dt>CRYPTO_ERROR (<code>0x0100</code>-<code>0x01ff</code>，加密错误):</dt>
<dd>
<p>加密握手失败。为所使用的加密握手专用的错误码保留256个值的范围。使用TLS进行加密握手时可能出现的错误码详见《<a href="../RFC9001_Chinese_Simplified">QUIC-TLS</a>》<a href="../RFC9001_Chinese_Simplified/#4.8_TLS_Errors">第4.8章</a>。</p>
</dd>
</dl>
</div>
</section>
<section class="page" id="20.2_Application_Protocol_Error_Codes">
<h1>
<a href="#20.2_Application_Protocol_Error_Codes">20.2 应用协议错误码</a>
</h1>
<div class="content">
<p>应用程序错误码留给应用协议管理。应用协议错误码用于<strong>重置帧</strong>（<a href="#19.4_RESET_STREAM_Frames">第19.4章</a>）、<strong>停止发送帧</strong>（<a href="#19.5_STOP_SENDING_Frames">第19.5章</a>），以及<code>0x1d</code>类型的<strong>连接关闭帧</strong>（<a href="#19.19_CONNECTION_CLOSE_Frames">第19.19章</a>）。</p>
</div>
</section>
<section class="page" id="21_Security_Considerations">
<h1>
<a href="#21_Security_Considerations">21. 关于安全性的考量</a>
</h1>
<div class="content">
<p>QUIC的目标是提供一条安全的传输层连接。<a href="#21.1_Overview_of_Security_Properties">第21.1章</a>给出了关于这种安全性的概述；后续章节讨论了有关安全性的限制和警告，其中描述了已知的攻击手段和对抗措施。</p>
</div>
</section>
<section class="page" id="21.1_Overview_of_Security_Properties">
<h2>
<a href="#21.1_Overview_of_Security_Properties">21.1. 安全性概述</a>
</h2>
<div class="content">
<p>完整的对于QUIC安全性的分析超出了本文档的范畴。本节对QUIC应有的安全性给出了一份非正规的描述，用它来辅助QUIC实现方对协议进行分析。</p>
<p>QUIC使用了在《<a href="https://www.rfc-editor.org/info/rfc3552">SEC-CONS</a>》中描述的威胁模型假设，并针对此模型中的多种攻击方式提供了保护手段。</p>
<p>为此，我们将攻击分类为被动攻击和主动攻击。被动的攻击者具有从网络中读取数据包的能力，而主动的攻击者还具有向网络写入数据包的能力。然而，被动攻击中的攻击者可以具有引发路由变化的能力或对传递数据包的路径作出其他修改的能力。</p>
<p>攻击者还被归类为在路径上的攻击者或不在路径上的攻击者。在路径上的攻击者可以读取或修改它所观察到的任意数据包，还可以移除任意数据包从而使得数据包无法到达它的目的地，而不在路径上的攻击者能观察数据包但无法阻止原始数据包抵达它的目的地。此外，这两种类型的攻击者都能发送任意数据包。这样的定义与《<a href="https://www.rfc-editor.org/info/rfc3552">SEC-CONS</a>》的<a href="https://www.rfc-editor.org/rfc/rfc3552.html#section-3.5">第3.5章</a>中的不同，区别是不在路径上的攻击者可以观察到数据包。</p>
<p>握手的安全性、受保护数据包的安全性和连接迁移的安全性会被分别考量。</p>
</div>
</section>
<section class="page" id="21.1.1_Handshake">
<h3>
<a href="#21.1.1_Handshake">21.1.1. 握手</a>
</h3>
<div class="content">
<p>QUIC握手中包含着TLS 1.3握手，所以会继承在《<a href="https://www.rfc-editor.org/info/rfc8446">TLS13</a>》的<a href="https://www.rfc-editor.org/rfc/rfc8446.html#appendix-E.1">附录E.1</a>中描述的加密安全性。QUIC的安全性有相当一部分依靠TLS握手来提供。任何针对TLS握手的攻击都会影响到QUIC。</p>
<p>对于在会话密钥的机密性和唯一性上或在认证对端身份时让步的TLS握手的攻击会影响到QUIC所提供的依赖这些密钥的安全性保证。比如，连接迁移（详见<a href="#9_Connection_Migration">第9章</a>）为了避免跨网络路径的可关联性，依赖着在使用TLS握手的密钥协商过程和QUIC数据包保护过程中的可信度保护。</p>
<p>针对TLS握手的完整性进行的攻击可能使得攻击者能够影响应用协议或QUIC版本的选择。</p>
<p>在TLS提供的安全性之外，QUIC握手也提供了一些防御手段来对抗针对握手的拒绝服务攻击。</p>
</div>
</section>
<section class="page" id="21.1.1.1_Anti-Amplification">
<h4>
<a href="#21.1.1.1_Anti-Amplification">21.1.1.1. 抗放大</a>
</h4>
<div class="content">
<p>地址验证（详见<a href="#8_Address_Validation">第8章</a>）被用于验证声称位于某个地址的实体是否有在那个地址接收数据包的能力。对于一些地址，攻击者能够观察到发向这些地址的数据包，而地址验证能限制针对这些地址的放大攻击。</p>
<p>在完成地址验证前，终端在能够发送的数据量上会受到限制。终端向未经验证的地址发送的数据量不能超过从那个地址接收到的数据量的三倍。</p>
<blockquote>
<p>注意：抗放大限制仅适用于终端对接收自未经验证地址的数据包进行响应的情况。抗放大限制不适用于客户端建立新连接或发起连接迁移的情况。</p>
</blockquote>
</div>
</section>
<section class="page" id="21.1.1.2_Server-Side_DoS">
<h4>
<a href="#21.1.1.2_Server-Side_DoS">21.1.1.2. 针对服务器的拒绝服务</a>
</h4>
<div class="content">
<p>服务器为完整的握手过程计算首轮数据可能需要耗费大量资源，其中需要涉及签名和密钥交换的计算。为了抵御针对计算资源的拒绝服务攻击，重试数据包提供了一种低成本的令牌交换机制，使得服务器能够以单轮数据包往返的代价，在进行大量计算前先验证客户端的IP地址。在成功完成握手后，服务器可以向客户端签发新令牌，这使得下次建立连接时不需要引入上述代价。</p>
</div>
</section>
<section class="page" id="21.1.1.3_On-Path_Handshake_Termination">
<h4>
<a href="#21.1.1.3_On-Path_Handshake_Termination">21.1.1.3. 在路径上的握手终止</a>
</h4>
<div class="content">
<p>在路径上的或不在路径上的攻击者都可以通过替换或竞速初始数据包的方式强制握手失败。一旦合法的初始数据包完成交换，后续的握手数据包就会受到握手密钥的保护，于是在路径上的攻击者就不能再强制握手失败，除非它丢弃掉数据包从而使得终端放弃尝试连接。</p>
<p>在路径上的攻击者还可以替换任意一侧的数据包中的地址，从而使得客户端或服务器得知虚假的远程地址。这样的攻击无法与NAT进行的转换相区分。</p>
</div>
</section>
<section class="page" id="21.1.1.4_Parameter_Negotiation">
<h4>
<a href="#21.1.1.4_Parameter_Negotiation">21.1.1.4. 参数协商</a>
</h4>
<div class="content">
<p>整个握手都受到加密保护，其中初始数据包被由QUIC版本指定的密钥加密，握手数据包和后续数据包被衍生自TLS密钥交换的密钥加密。此外，参数协商会被包含在TLS的记录单（<code>transcript</code>）中，因此它与普通的TLS协商提供相同的完整性保证。攻击者可以观测客户端的传输参数（只要它知道那个由QUIC版本指定的盐），但是却不能观测到服务器的传输参数，因此无法影响到参数协商。</p>
<p>连接ID不会被加密，但是会在所有数据包中受到完整性保护。</p>
<p>本QUIC版本中不包含版本协商机制；互不兼容的版本的实现之间无法建立连接。</p>
</div>
</section>
<section class="page" id="21.1.2_Protected_Packets">
<h3>
<a href="#21.1.2_Protected_Packets">21.1.2. 受保护的数据包</a>
</h3>
<div class="content">
<p>数据包保护（详见<a href="#12.1_Protected_Packets">第12.1章</a>）将认证加密应用到除版本协商数据包外的所有数据包上，不过出于使用了由QUIC版本指定的密钥材料的缘故，初始数据包和重试数据包仅受到有限的保护；有关细节详见《<a href="/RFC9001_Chinese_Simplified">QUIC-TLS</a>》。本节考量了针对受保护数据包的被动与主动攻击。</p>
<p>在路径上和不在路径上的攻击者都能发起被动攻击，在这种攻击中，攻击者将观察到的数据包保存起来，将之用于将来的针对数据包保护的离线攻击；这对任何网络中任何数据包的任何观察者都是成立的。</p>
<p>没有观察连接中数据包的能力就注入数据包的攻击者不太可能会成功，因为数据包保护确保了合法的数据包只能由拥有在握手期间建立的密钥材料的终端才能创建出来；详见<a href="#7_Cryptographic_and_Transport_Handshake">第7章</a>和<a href="#21.1.1_Handshake">第21.1.1章</a>。类似地，任何观察数据包并尝试往这些数据包中插入新数据或修改原有数据的主动攻击者应该都无法创建出能被接收方认定为合法的数据包，除非它操作的是初始数据包。</p>
<p>伪造攻击，也就是由主动攻击者改写由它转发或被它注入的数据包中未经保护的部分，例如源地址或目标地址，只有在攻击者能够将数据包转发到原始终端上时才会生效。数据包保护确保了数据包载荷只能被完成了握手的终端所处理，并且非法的数据包会被终端忽略。</p>
<p>攻击者还能修改数据包与UDP数据报间的边界，使得多个数据包被合并至单个数据报中，或将经合并的数据包拆分至多个数据报中。除了需要扩充的包含初始数据包的数据报外，对数据包在数据报中的排列方式的修改对于连接没有实际效果，不过它可以改变一些性能上的特征。</p>
</div>
</section>
<section class="page" id="21.1.3_Connection_Migration">
<h3>
<a href="#21.1.3_Connection_Migration">21.1.3. 连接迁移</a>
</h3>
<div class="content">
<p>连接迁移（详见<a href="#9_Connection_Migration">第9章</a>）为终端提供了在数条路径的IP地址与端口间转移的能力，在同一时间终端只能在一条路径上发送和接收非探测帧。路径验证（详见<a href="#8.2_Path_Validation">第8.2章</a>）能证实对端有意愿且有能力接收在某条路径上发送的数据包。通过限制发送至假地址的数据包数量，这有助于减少地址伪造的影响。</p>
<p>本节描述了在受到不同类型的拒绝服务攻击的情况下，连接迁移应该具有的安全性。</p>
</div>
</section>
<section class="page" id="21.1.3.1_On-Path_Active_Attacks">
<h4>
<a href="#21.1.3.1_On-Path_Active_Attacks">21.1.3.1. 在路径上的主动攻击</a>
</h4>
<div class="content">
<p>能够令观察到的数据包抵达不了它原本目的地的攻击者被认为是在路径上的攻击者。当客户端和服务器间存在攻击者时，终端为了在给定路径上建立连接，发送的数据包不得不经过此攻击者。</p>
<p>在路径上的攻击者可以做到：</p>
<ul>
<li>
<p>检视数据包</p>
</li>
<li>
<p>修改IP数据包和UDP数据包头部</p>
</li>
<li>
<p>注入新数据包</p>
</li>
<li>
<p>使数据包延误</p>
</li>
<li>
<p>对数据包重新排序</p>
</li>
<li>
<p>丢弃数据包</p>
</li>
<li>
<p>拆分与合并数据报和数据包</p>
</li>
</ul>
<p>在路径上的攻击者不能做到：</p>
<ul>
<li>既修改数据包中经认证的部分又使得接收方接收该数据包。</li>
</ul>
<p>在路径上的攻击者有修改它观察到的数据包的机会；然而，对于数据包中经认证部分的任何修改都会使得它被接收方认定为非法而遭到丢弃，因为数据包载荷是经过认证与加密的。</p>
<p>QUIC旨在将在路径上的攻击者的能力限制至：</p>
<ol>
<li>
<p>在路径上的攻击者可以阻止将一条路径用于建立连接，如果终端找不到一条不包含攻击者的路径，连接就会失败。这可以通过丢弃所有数据包、修改数据包以使得它们无法通过解密或其他方式来做到。</p>
</li>
<li>
<p>在路径上的攻击者可以通过使新路径上的地址验证失败的方式，阻止连接迁移到一条依旧包含攻击者的路径上。</p>
</li>
<li>
<p>在路径上的攻击者不能阻止客户端迁移到一条不包含攻击者的路径上。</p>
</li>
<li>
<p>在路径上的攻击者可以通过使数据包延误或丢弃数据包的方式，降低连接的吞吐量。</p>
</li>
<li>
<p>在路径上的攻击者不能令终端接受一个被它修改过经认证部分的数据包。</p>
</li>
</ol>
</div>
</section>
<section class="page" id="21.1.3.2_Off-Path_Active_Attacks">
<h4>
<a href="#21.1.3.2_Off-Path_Active_Attacks">21.1.3.2. 不在路径上的主动攻击</a>
</h4>
<div class="content">
<p>不在路径上的攻击者并不直接位于客户端与服务器间的路径上，但是拥有获得客户端与服务器间发送的部分或全部数据包的能力。它还能够将那些数据包的副本发送给任一终端。</p>
<p>不在路径上的攻击者可以做到：</p>
<ul>
<li>
<p>检视数据包</p>
</li>
<li>
<p>注入新数据包</p>
</li>
<li>
<p>对注入的数据包重新排序</p>
</li>
</ul>
<p>不在路径上的攻击者不能做到：</p>
<ul>
<li>
<p>修改由终端发送的数据包</p>
</li>
<li>
<p>使数据包延误</p>
</li>
<li>
<p>丢弃数据包</p>
</li>
<li>
<p>对原始数据包重新排序</p>
</li>
</ul>
<p>不在路径上的攻击者可以为它观察到的数据包创建修改过的副本，并将这些副本注入网络中，副本的源地址和目标地址可以是伪造的。</p>
<p>在本讨论中，我们假定不在路径上的攻击者具有将修改后的数据包副本注入到网络中的能力，并且这个数据包会比它观察的那个原始数据包更早抵达目标终端。换句话说，攻击者具有持续“赢下”与原始数据包间的竞速的能力，并使得原始数据包被接收方忽略。</p>
<p>我们还假设了攻击者具有影响NAT状态所需的资源。尤其是，攻击者有能力使某终端丢失它的NAT绑定，然后取代它，使用与终端先前所使用的相同的端口来吞吐流量。</p>
<p>QUIC旨在将不在路径上的攻击者的能力限制至：</p>
<ol>
<li>
<p>不在路径上的攻击者可以竞速数据包并尝试成为在“受限”路径上的攻击者。</p>
</li>
<li>
<p>不在路径上的攻击者可以通过转发数据包并将源地址改为自己的地址的方式，使自己的地址通过验证，前提是它可以在客户端和服务器间提供更优秀的连接质量。</p>
</li>
<li>
<p>不在路径上的攻击者不能在握手完成后引发连接关闭。</p>
</li>
<li>
<p>不在路径上的攻击者不能在无法观察新路径的条件下使得连接迁移到这条路径上。</p>
</li>
<li>
<p>不在路径上的攻击者可以在迁移到新路径的期间成为一个在受限路径上的攻击者，而它在新路径上仍是一个不在路径上的攻击者。</p>
</li>
<li>
<p>不在路径上的攻击者可以通过影响与客户端共享的NAT状态的方式成为一个在受限路径上的攻击者，以便从客户端曾使用过的IP地址和端口向服务器发送数据包。</p>
</li>
</ol>
</div>
</section>
<section class="page" id="21.1.3.3_Limited_On-Path_Active_Attacks">
<h4>
<a href="#21.1.3.3_Limited_On-Path_Active_Attacks">21.1.3.3. 在受限路径上的主动攻击</a>
</h4>
<div class="content">
<p>在受限路径上的攻击者指的是一个通过在服务器和客户端间复制并转发原始数据包的方式提供更优秀路由质量的不在路径上的攻击者，这会使得那些数据包比原始数据包要更早抵达，从而令原始数据包被目标终端丢弃。</p>
<p>在受限路径上的攻击者与在路径上的攻击者的不同之处在于它并不在终端间的原始路径上，因此由终端发送的原始数据包仍然在前往它们目的地的途中。这意味着只要没有将数据包副本更快地路由到目的地，就无法阻止原始数据包抵达目的地。</p>
<p>在受限路径上的攻击者可以做到：</p>
<ul>
<li>
<p>检视数据包</p>
</li>
<li>
<p>注入新数据包</p>
</li>
<li>
<p>修改未经加密的数据包头部</p>
</li>
<li>
<p>对数据包重新排序</p>
</li>
</ul>
<p>在受限路径上的攻击者不能做到：</p>
<ul>
<li>
<p>使数据包延误，从而令它们比在原始路径上发送的数据包更晚抵达</p>
</li>
<li>
<p>丢弃数据包</p>
</li>
<li>
<p>修改数据包中经认证和加密的部分，并使得接收方接受该数据包</p>
</li>
</ul>
<p>在受限路径上的攻击者只能够使数据包副本延误至原始数据包抵达为止，这意味着它不能提供比原始路径的延迟表现要差的路由质量。就算在受限路径上的攻击者将数据包副本丢弃，原始数据包仍然会抵达目标终端。</p>
<p>QUIC旨在将在受限路径上的攻击者的能力限制至：</p>
<ul>
<li>
<p>在受限路径上的攻击者不能在握手完成后引发连接关闭。</p>
</li>
<li>
<p>在受限路径上的攻击者不能在客户端首先恢复活动的条件下引发空闲连接的关闭。</p>
</li>
<li>
<p>在受限路径上的攻击者可以在服务器首先恢复活动的条件下使得空闲连接被认定为丢失。</p>
</li>
</ul>
<p>注意，出于完全相同的原因，这些保证与任何NAT所提供的保证是一致的。</p>
</div>
</section>
<section class="page" id="21.2_Handshake_Denial_of_Service">
<h2>
<a href="#21.2_Handshake_Denial_of_Service">21.2. 针对握手的拒绝服务攻击</a>
</h2>
<div class="content">
<p>作为一种经加密和认证的传输层协议，QUIC针对拒绝服务提供了诸多保护措施。一旦加密握手完成，QUIC终端就会丢弃绝大多数未经认证的数据包，极大地限制了攻击者介入已建立的连接的能力。</p>
<p>在连接被建立后，QUIC终端可以接受一些未经认证的ICMP数据包（详见<a href="#14.2.1_Handling_of_ICMP_Messages_by_PMTUD">第14.2.1章</a>），但是对这些数据包的使用是极度受限的。终端可以接受的另一种数据包是无状态重置（详见<a href="#10.3_Stateless_Reset">第10.3章</a>），它依赖于在令牌被使用前保持令牌的机密性。</p>
<p>在创建连接期间，QUIC提供的保护仅针对不在路径上的攻击。所有的QUIC数据包都包含着能表明终端接收到了来自对端的前序数据包的依据。</p>
<p>在握手期间无法更改地址，所以终端可以丢弃另一条网络路径上接收到的数据包。</p>
<p>在握手期间，源连接ID字段和目标连接ID字段是抵御不在路径上的攻击的主要手段；详见<a href="#8.1_Address_Validation_during_Connection_Establishment">第8.1章</a>。这些字段必须与对端填写的对应字段匹配。除了初始数据包和无状态重置外，终端只接受包含着与终端之前选择的值匹配的目标连接ID字段的数据包。这是为版本协商数据包提供的唯一保护。</p>
<p>初始数据包中的目标连接ID字段是由客户端选择的不可预测的值，它起着额外的作用。传递加密握手消息的数据包会受到密钥的保护，该密钥衍生自此连接ID和由QUIC版本指定的盐。这使得终端在加密握手完成后始终使用一致的计算过程来认证接收到的数据包。未能通过认证的数据包会被丢弃。以这种方式保护数据包能提供一种强有力的保证，保证数据包的发送方接收到了初始数据包并且能够理解它。</p>
<p>这些保护在面对有能力在连接建立前就接收到QUIC数据包的攻击者时并不一定有效。这样的攻击者可能发送出会被QUIC终端接受的数据包。本QUIC版本尝试检测出此类攻击，但是终端应该令连接的建立过程直接失败，而不是试图从中恢复。在握手期间检测出篡改行为的责任主要在于加密握手协议（详见《<a href="https://www.rfc-editor.org/info/rfc9001">QUIC-TLS</a>》）。</p>
<p>允许终端使用其他手段来检测出握手被介入的情况并尝试从中恢复。非法数据包可以被其他手段识别出来并被丢弃，不过在本文档中没有推荐什么特别的方法。</p>
</div>
</section>
<section class="page" id="21.3_Amplification_Attack">
<h2>
<a href="#21.3_Amplification_Attack">21.3. 放大攻击</a>
</h2>
<div class="content">
<p>攻击者也许有能力在从服务器接收到地址验证令牌（详见<a href="#8_Address_Validation">第8章</a>）后释放掉它用于接收令牌的IP地址。一段时间后，攻击者可以伪造出相同的地址，并向服务器发起0-RTT连接，但这时该地址指向的会是另一个（受害者）终端。攻击者于是有机会令服务器向受害者发送多达一整个初始拥塞窗口的数据。</p>
<p>服务器<em><strong>应该</strong></em>通过限制地址验证令牌的使用范围与有效期限的方式抵御此类攻击；详见<a href="#8.1.3_Address_Validation_for_Future_Connections">第8.1.3章</a>。</p>
</div>
</section>
<section class="page" id="21.4_Optimistic_ACK_Attack">
<h2>
<a href="#21.4_Optimistic_ACK_Attack">21.4. 针对乐观ACK的攻击</a>
</h2>
<div class="content">
<p>会对尚未接收到的数据包进行确认的终端可能使得拥塞控制器允许以超过网络所支持的速率进行发送。要检测此行为，终端<em><strong>可以</strong></em>在发送数据包时跳过某些数据包号。终端在检测到对端的此类行为后可以立即用类型为<code>PROTOCOL_VIOLATION</code>（协议违背）的连接错误来关闭连接；详见<a href="#10.2_Immediate_Close">第10.2章</a>。</p>
</div>
</section>
<section class="page" id="21.5_Request_Forgery_Attacks">
<h2>
<a href="#21.5_Request_Forgery_Attacks">21.5. 请求伪造攻击</a>
</h2>
<div class="content">
<p>在请求伪造攻击中，终端使得对端向受害者发起一次由终端控制的请求。请求伪造攻击旨在使得攻击者能够操作对端所具有的功能，而一般情况下攻击者无法访问到这些功能。对于一份网络协议来说，正因为对端在网络中所处的特殊位置，请求伪造攻击经常被用于利用在受害者与对端间非公开的鉴权认证。</p>
<p>要使请求伪造生效，攻击者需要具有影响对端所发送的数据包以及这些数据包的目的地的能力。如果攻击者可以使用它所控制的载荷来针对某个易受攻击的服务进行攻击，那么该服务就可能进行一些看上去是由攻击者的对端发起实际却是由攻击者控制的操作。</p>
<p>举例来说，互联网上的跨站请求伪造（详见《<a href="https://doi.org/10.1145/1455770.1455782">CSRF</a>》）漏洞会使得客户端发起携带着认证Cookie（详见《<a href="https://www.rfc-editor.org/info/rfc6265">COOKIE</a>》）的请求，使得某个网站能够访问到本应只有另一个网站才能访问的信息和操作。</p>
<p>由于QUIC运行在UDP之上，主要关心的攻击形式是攻击者能够操纵其对端将UDP数据报发向的地址并且能够控制数据包载荷中的部分原始内容。由于QUIC终端发送的许多数据都是受保护的，所以这种攻击包含着对密文的控制。如果攻击者能够使得对端向某个会基于数据报内容进行相应操作的主机发送UDP数据报，那么攻击就会成功。</p>
<p>本节讨论了可能使用QUIC来进行伪造请求攻击的各种方式。</p>
<p>本节还讨论了QUIC终端可以实现但是效果有限的对抗措施。这些抵御方式可以被某个QUIC实现或部署方式单方面实施，而不需要请求伪造攻击的潜在目标采取行动。然而，如果基于UDP的服务没有恰当地对请求进行鉴权认证，那么单靠这些对抗措施会是不够充分的。</p>
<p>因为在<a href="#21.5.4_Request_Forgery_with_Spoofed_Migration">第21.5.4章</a>中描述的迁移攻击相当强力并且针对它没有适当的对抗措施，所以QUIC实现应该假定攻击者可以利用它们来生成任意UDP载荷并将其发送至任意目标。QUIC服务器<em><strong>不应该</strong></em>被部署到没有启用传入流量过滤（详见《<a href="https://www.rfc-editor.org/info/bcp38">BCP38</a>》）和存在安全性未经充分加固的UDP终端的网络中。</p>
<p>虽然通常不太可能确保客户端没有和易受攻击的终端处在一起，但是本QUIC版本并不允许服务器发起迁移，从而阻止了对客户端发起虚假迁移攻击。任何将来的允许服务器迁移的扩展<em><strong>必须</strong></em>为伪造攻击定义对抗措施。</p>
</div>
</section>
<section class="page" id="21.5.1_Control_Options_for_Endpoints">
<h3>
<a href="#21.5.1_Control_Options_for_Endpoints">21.5.1. 控制终端的途径</a>
</h3>
<div class="content">
<p>QUIC给了攻击者一些影响或操纵其对端的UDP数据报发送目标的机会：</p>
<ul>
<li>
<p>初始的连接建立（详见<a href="#7_Cryptographic_and_Transport_Handshake">第7章</a>），此时服务器拥有操纵客户端的数据包发送目标的能力——例如，通过填写DNS记录的方式；</p>
</li>
<li>
<p>首选地址（详见<a href="#9.6_Server's_Preferred_Address">第9.6章</a>），此时服务器拥有操纵客户端的数据包发送目标的能力；</p>
</li>
<li>
<p>虚假的连接迁移（详见<a href="#9.3.1_Peer_Address_Spoofing">第9.3.1章</a>），此时客户端具有使用伪造的源地址来操纵服务器后续数据报的发送目标的能力；以及</p>
</li>
<li>
<p>伪造的数据包，这能令服务器发送版本协商数据包（详见<a href="#21.5.5_Request_Forgery_with_Version_Negotiation">第21.5.5章</a>）。</p>
</li>
</ul>
<p>在任一情况下，攻击者都能令其对端向某个受害者发送数据报，无论受害者能不能理解QUIC。也就是说，这些数据包会在对端进行地址验证前就被发送出去；详见<a href="#8_Address_Validation">第8章</a>。</p>
<p>在数据包经加密的部分之外，QUIC给予了终端一些可选项，用于控制其对端发送的UDP数据报的内容。目标连接ID字段提供了针对对端发送的数据包中位置靠前的字节的直接控制；详见<a href="#5.1_Connection_ID">第5.1章</a>。初始数据包中的令牌字段提供了针对初始数据包中其他字节的控制；详见<a href="#17.2.2_Initial_Packet">第17.2.2章</a>。</p>
<p>在本QUIC版本中没有任何方法来阻止针对数据包中经加密的部分的间接控制。假定终端能够控制对端所发送的帧内容是很有必要的，尤其是那些传递应用数据的帧，例如<strong>流帧</strong>。尽管它在一定程度上依赖于应用协议的细节部分，但是在多数协议的使用场景中都有可能出现某种程度的控制能力。只要攻击者能访问到数据包保护密钥，它们就有能力预测对端会如何加密后续数据包。于是，要成功控制数据报内容，只需要攻击者有能力预测数据包号和数据包中的帧大概会出现的位置。</p>
<p>本节假定了我们无法限制攻击者对数据报内容的控制。在后续章节中，抵御手段的重点在于限制数据报会在进行地址验证前就被发送出去的情况，以防止它们被用于进行请求伪造。</p>
</div>
</section>
<section class="page" id="21.5.2_Request_Forgery_with_Client_Initial_Packets">
<h3>
<a href="#21.5.2_Request_Forgery_with_Client_Initial_Packets">21.5.2. 使用客户端初始数据包的请求伪造</a>
</h3>
<div class="content">
<p>假扮成服务器的攻击者可以自由宣称自己所在的IP地址和端口，所以发送自客户端的初始数据包被假定为可以用于此类攻击。在握手中隐含着的地址验证确保了——在建立新连接时——客户端不会向一个不理解QUIC或不愿意接受QUIC连接的目标发送其他类型的数据包。</p>
<p>初始数据包保护（详见《<a href="../RFC9001_Chinese_Simplified">QUIC-TLS</a>》的<a href="../RFC9001_Chinese_Simplified/#5.2_Initial_Secrets">第5.2章</a>）使得服务器难以操纵由客户端发送的初始数据包内容。客户端会选择一个不可预测的目标连接ID，确保了服务器无法操纵客户端初始数据包中任何经加密的部分。</p>
<p>然而，令牌字段是开放给服务器去控制的，并且它确实允许服务器利用客户端来进行请求伪造攻击。使用由<strong>新令牌帧</strong>（详见<a href="#8.1.3_Address_Validation_for_Future_Connections">第8.1.3章</a>）提供的令牌成为了在连接建立期间进行请求伪造的唯一途径。</p>
<p>不过，客户端并没有一定要使用<strong>新令牌帧</strong>的义务。只需要客户端在服务器的地址与发送<strong>新令牌帧</strong>时的不同的情况下发送空的令牌字段，依赖于令牌字段的请求伪造攻击就可以被避免。</p>
<p>客户端可以在服务器地址变化时避免使用<strong>新令牌帧</strong>。然而，不使用令牌字段会对性能产生不利影响。服务器可能依赖于<strong>新令牌帧</strong>以在发送数据时超过三倍限制；详见<a href="#8.1_Address_Validation_during_Connection_Establishment">第8.1章</a>。尤其是，这会影响客户端使用0-RTT来从服务器请求数据的情况。</p>
<p>重试数据包为服务器提供了改变令牌字段的一种途径。在发送了重试数据包后，服务器还可以控制客户端后续初始数据包中的目标连接ID字段。这还有可能实现对初始数据包中经加密的内容的间接控制。然而，有关重试数据包的通信验证了服务器的地址，于是阻止了将后续初始数据包用于请求伪造。</p>
</div>
</section>
<section class="page" id="21.5.3_Request_Forgery_with_Preferred_Addresses">
<h3>
<a href="#21.5.3_Request_Forgery_with_Preferred_Addresses">21.5.3. 使用首选地址的请求伪造</a>
</h3>
<div class="content">
<p>服务器可以指定首选地址，客户端在确认完握手之后就会发起迁移；详见<a href="#9.6_Server's_Preferred_Address">第9.6章</a>。客户端发向首选地址的数据包中的目标连接ID字段可以被用于请求伪造。</p>
<p>客户端<em><strong>必须不</strong></em>在验证某首选地址前就向它发送非探测帧；详见<a href="#8_Address_Validation">第8章</a>。这极大地减少了服务器能够操纵数据报中经加密的部分的途径数量。</p>
<p>本文档没有提供额外的与使用首选地址有关的和能够由终端实现的对抗措施。在<a href="#21.5.6_Generic_Request_Forgery_Countermeasures">第21.5.6章</a>中描述的通用措施可以被用作更进一步的抵御手段。</p>
</div>
</section>
<section class="page" id="21.5.4_Request_Forgery_with_Spoofed_Migration">
<h3>
<a href="#21.5.4_Request_Forgery_with_Spoofed_Migration">21.5.4. 使用虚假迁移的请求伪造</a>
</h3>
<div class="content">
<p>客户端能够在连接迁移中使用伪造的源地址，使得服务器向该地址发送数据报。</p>
<p>服务器后续向这个假地址发送的任何数据包中的目标连接ID字段都能被用于请求伪造。客户端可能还有影响密文的能力。</p>
<p>在进行地址验证前只会向该地址发送探测数据包（详见<a href="#9.1_Probing_a_New_Path">第9.1章</a>）的服务器让攻击者对数据报中经加密的部分仅持有有限的控制。然而，尤其是对NAT重绑定来说，这会对性能产生不利影响。如果服务器发送了携带着应用数据的帧，那么攻击者就可能控制数据报中的绝大多数内容。</p>
<p>除了在<a href="#21.5.6_Generic_Request_Forgery_Countermeasures">第21.5.6章</a>中描述的通用措施外，本文档没有提供终端能够实现的专门的对抗措施。然而，在网络层面的针对地址伪造的对抗措施——尤其是传入流量过滤（详见<a href="https://www.rfc-editor.org/info/bcp38">BCP38</a>）——对于使用伪造地址且源自外部网络的攻击是极其有效的。</p>
</div>
</section>
<section class="page" id="21.5.5_Request_Forgery_with_Version_Negotiation">
<h3>
<a href="#21.5.5_Request_Forgery_with_Version_Negotiation">21.5.5. 使用版本协商的请求伪造</a>
</h3>
<div class="content">
<p>有能力在数据包中使用虚假源地址的客户端能够令服务器向该地址发送版本协商数据包（详见<a href="#17.2.1_Version_Negotiation_Packet">第17.2.1章</a>）。</p>
<p>在未知版本的数据包中对于连接ID字段长度限制的缺失提高了客户端能够在产生的数据报中控制的数据量。该数据包的首个字节不在客户端控制之下，并且后四个字节均为零，但是客户端可以控制从第五个字节开始的至多512个字节。</p>
<p>针对此类攻击，没有提供专门的对抗措施，不过通用的保护手段（详见<a href="#21.5.6_Generic_Request_Forgery_Countermeasures">第21.5.6章</a>）是适用的。在这种情况下，传入流量过滤（详见《<a href="https://www.rfc-editor.org/info/bcp38">BCP38</a>》）也是有效的。</p>
</div>
</section>
<section class="page" id="21.5.6_Generic_Request_Forgery_Countermeasures">
<h3>
<a href="#21.5.6_Generic_Request_Forgery_Countermeasures">21.5.6. 针对请求伪造的通用对抗措施</a>
</h3>
<div class="content">
<p>针对请求伪造攻击的最有效防御方法就是修改易受攻击的服务，让它使用强有力的鉴权认证。然而，这一点并不总是在QUIC部署的控制之下。本节概述了QUIC终端可以单方面采取的一些其他措施。这些额外措施都应该酌情使用，因为根据情况的不同，它们可能干涉或阻止QUIC的正常工作。</p>
<p>通过回环接口提供的服务通常缺乏恰当的鉴权认证。终端<em><strong>可以</strong></em>阻止指向回环地址的连接尝试或迁移。当指向的服务曾在另一个接口上开放过，或者指向的回环地址是由位于非回环地址的服务提供的，那么终端<em><strong>不应该</strong></em>批准指向这个回环地址的连接或迁移。依赖于这些能力的终端可以提供一个可以禁用这些保护的选项。</p>
<p>类似地，终端可以将从全球唯一地址、唯一本地地址（详见《<a href="https://www.rfc-editor.org/info/rfc4193">RFC4193</a>》）或非私有地址变更到链路本地地址（详见《<a href="https://www.rfc-editor.org/info/rfc4291">RFC4291</a>》）或处于私有使用范围的地址（详见《<a href="https://www.rfc-editor.org/info/rfc1918">RFC1918</a>》）的情况视作潜在的对请求伪造的企图。终端可以完全拒绝使用以上地址，但是要承担干涉QUIC合法用途的巨大风险。终端<em><strong>不应该</strong></em>拒绝使用某个地址，除非它对于网络的先验知识告诉它向某范围内的未经验证的地址发送数据报是不安全的。</p>
<p>终端<em><strong>可以</strong></em>选择以不使用来自初始数据包中<strong>新令牌帧</strong>的值的方式或只有在完成地址验证后才在数据包中发送探测帧的方式来减少请求伪造的风险。注意，这不能阻止攻击者将目标连接ID用于攻击中。</p>
<p>终端不需要专门持有容易成为请求伪造攻击目标的服务器的位置信息。然而，经过一段时间后，识别出某些常常成为攻击目标的UDP端口或被用于进行攻击的数据报中的特定模式是有可能的。终端<em><strong>可以</strong></em>选择避免向那些端口发送数据报或不在验证目标地址前发送符合这种模式的数据包。终端<em><strong>可以</strong></em>撤销符合已知可能产生问题的模式的连接ID而不使用它们。</p>
<p>注意： 修改终端来应用以上保护措施比起部署基于网络的保护措施要更高效，因为终端在向经验证的地址发送数据时不需要进行额外的处理。</p>
</div>
</section>
<section class="page" id="21.6_Slowloris_Attacks">
<h2>
<a href="#21.6_Slowloris_Attacks">21.6. 慢速连接攻击</a>
</h2>
<div class="content">
<p>通常被称为慢速连接攻击（详见《<a href="https://web.archive.org/web/20150315054838/http://ha.ckers.org/slowloris/">SLOWLORIS</a>》）的攻击方式会尝试打开许多与目标终端的连接并且尽可能长地维持它们。这类攻击可以通过进行最低限度的活动以避免连接因无活动而被关闭的方式攻击某个QUIC终端。其中可能还包含发送少量数据，逐渐打开流量控制窗口从而控制发送者的速率，以及制造能模拟高丢包率的<strong>ACK帧</strong>。</p>
<p>QUIC部署<em><strong>应该</strong></em>针对慢速连接攻击提供抵御手段，例如扩大服务器允许的最大客户端数量、限制单个IP地址能够创建的连接数量、向连接所允许的最低传输速率施加限制，以及限制终端能够保持连接的时长。</p>
</div>
</section>
<section class="page" id="21.7_Stream_Fragmentation_and_Reassembly_Attacks">
<h2>
<a href="#21.7_Stream_Fragmentation_and_Reassembly_Attacks">21.7. 流分段与重组攻击</a>
</h2>
<div class="content">
<p>恶意的攻击者可能有意不发送一部分流数据，使得接收者为那些未发送的数据预留资源。这会造成接收方出现极高的缓存占用并且/或者创建出巨大且低效的数据结构。</p>
<p>恶意的接收者可能有意不确认包含流数据的数据包，为的是强制发送方持续存储未确认的流数据以便重传。</p>
<p>当流量控制窗口与可用内存相关时，针对接收方的攻击就能被抵御。然而，一些接收方会过度占用内存，并且在合计的时候宣告会超过实际可用内存的流量控制偏移值。这种透支策略在终端运行状态良好时能够提高性能，但是会在遭受流分段攻击时使得终端变得脆弱。</p>
<p>QUIC实现<em><strong>应该</strong></em>针对流分段攻击提供抵御手段。其中可以包含避免透支内存、限制持续维护的数据结构的尺寸、延迟组装<strong>流帧</strong>、实现基于数据重组缺口时长的启发式方法，以及以上措施的各种组合。</p>
</div>
</section>
<section class="page" id="21.8_Stream_Commitment_Attack">
<h2>
<a href="#21.8_Stream_Commitment_Attack">21.8. 流占用攻击</a>
</h2>
<div class="content">
<p>恶意的终端可以打开大量的流并耗尽终端的状态。恶意的终端可以在大量连接上重复此过程，就像TCP中的SYN泛洪攻击那样。</p>
<p>通常情况下，客户端会按顺序打开流，就像<a href="#2.1_Stream_Types_and_Identifiers">第2.1章</a>中解释的那样。然而，当短时间内发起多个流时，丢包或乱序会使得打开流的<strong>流帧</strong>被乱序地接收到。在接收到较高编号的流ID时，接收者需要打开同类型的所有低编号流；详见<a href="#3.2_Receiving_Stream_States">第3.2章</a>。因此，在一条新连接上，打开了编号为<code>4000000</code>的流就会打开一百万零一条由客户端发起的双向流。</p>
<p>活跃流的数量是由传输参数<code>initial_max_streams_bidi</code>（初始最大双向流数量）和<code>initial_max_streams_uni</code>（初始最大单向流数量）限制的，并会随着接收到的<strong>最大流帧</strong>而被更新，如<a href="#4.6_Controlling_Concurrency">第4.6章</a>所述。只要审慎地选择，这些限制就能抵御流占用攻击会产生的效果。然而，将限制设置得过低则会在应用希望打开大量流时影响性能。</p>
</div>
</section>
<section class="page" id="21.9_Peer_Denial_of_Service">
<h2>
<a href="#21.9_Peer_Denial_of_Service">21.9. 来自对端的拒绝服务攻击</a>
</h2>
<div class="content">
<p>QUIC和TLS中的一些帧和消息在某些情况下具有合理用途，但也可以被滥用，使得终端花费大量计算资源却对连接的状态产生不了肉眼可见的影响。</p>
<p>消息还能被用于以简短快捷的方式更改和回退状态数据，例如向流量控制的限制值发送较小的增量更改。</p>
<p>如果计算上的代价比起带宽上的消耗或对状态的影响要大得多，那么这可能使得恶意的对端能够耗尽终端计算资源。</p>
<p>尽管所有消息都有其合理用途，但是QUIC实现<em><strong>应该</strong></em>监视处理过程中在计算上的消耗并且将任何投入巨大却产出低下的数据包处理过程视作潜在的攻击。终端<em><strong>可以</strong></em>用连接错误或数据包的丢弃来响应这种情况。</p>
</div>
</section>
<section class="page" id="21.10_Explicit_Congestion_Notification_Attacks">
<h2>
<a href="#21.10_Explicit_Congestion_Notification_Attacks">21.10. 显式拥塞通知攻击</a>
</h2>
<div class="content">
<p>在路径上的攻击者可以操纵IP头部中ECN字段的值来影响发送方的速率。在《<a href="https://www.rfc-editor.org/info/rfc3168">RFC3168</a>》中更详细地讨论了操纵方式及其效果。</p>
<p>在受限路径上的攻击者可以拷贝并发送修改过ECN字段的数据包，从而影响发送方的速率。如果重复的数据包会被接收方丢弃，那么攻击者就要使数据包副本与原始数据包竞速，才能使攻击成功。因此，除非IP数据包中至少有一个QUIC数据包被成功处理，否则QUIC终端会忽略IP数据包中的ECN字段；详见<a href="#13.4_Explicit_Congestion_Notification">第13.4章</a>。</p>
</div>
</section>
<section class="page" id="21.11_Stateless_Reset_Oracle">
<h2>
<a href="#21.11_Stateless_Reset_Oracle">21.11. 无状态重置泄密</a>
</h2>
<div class="content">
<p>无状态重置会创建一种潜在的拒绝服务攻击，它与TCP重置注入很相似。这种攻击的成功需要攻击者对于连接ID为特定值的连接，具有触发其无状态重置令牌的生成的能力。能够触发终端生成该令牌的攻击者就能重置具有该连接ID的活跃连接。</p>
<p>如果数据包会被路由至共享同一静态密钥的其他实例上——例如，通过改变IP地址或端口——那么攻击者就能令服务器发送无状态重置。要抵御这种形式的拒绝服务攻击，共享用于无状态重置的同一密钥的终端（详见<a href="#10.3.2_Calculating_a_Stateless_Reset_Token">第10.3.2章</a>）<em><strong>必须</strong></em>被妥善安排，从而使具有给定连接ID的数据包总是抵达具有连接状态的那个实例，除非该连接不再处于活跃状态。</p>
<p>更一般地，如果具有相同连接ID的连接在使用相同静态密钥的其他终端上可能处于活跃状态，那么服务器就<em><strong>必须不</strong></em>创建无状态重置。</p>
<p>在服务器集群使用动态负载均衡的情况中，可能出现对负载均衡器配置进行了更改而活跃的实例仍维护着连接状态的现象。即使某个实例维护着连接状态，路由和作为结果的无状态重置的变化会使得连接被终止。如果数据包没有机会被路由到正确的实例上，那么比起等待连接超时，最好发送无状态重置。然而，该做法只有在攻击者无法影响到路由的情况下才能被使用。</p>
</div>
</section>
<section class="page" id="21.12_Version_Downgrade">
<h2>
<a href="#21.12_Version_Downgrade">21.12. 版本降级</a>
</h2>
<div class="content">
<p>本文档定义了QUIC的版本协商包（详见<a href="#6_Version_Negotiation">第6章</a>），它能被用于协商在两个终端间使用的QUIC版本。然而，本文档没有规定在本版本与后续版本之间如何进行协商。尤其是，版本协商数据包中并不包含任何能阻止版本降级攻击的机制。将来的使用版本协商数据包的QUIC版本<em><strong>必须</strong></em>定义一种针对版本降级攻击的健壮的防御机制。</p>
</div>
</section>
<section class="page" id="21.13_Targeted_Attacks_by_Routing">
<h2>
<a href="#21.13_Targeted_Attacks_by_Routing">21.13. 通过路由的定向攻击</a>
</h2>
<div class="content">
<p>QUIC部署应该限制攻击者将新连接定向至特定服务器实例的能力。理想情况下，路由决策应该与客户端的相关值无关，包括地址。一旦选定了某个实例，就能决定连接ID，以便将来的数据包都被路由至同一实例。</p>
</div>
</section>
<section class="page" id="21.14_Traffic_Analysis">
<h2>
<a href="#21.14_Traffic_Analysis">21.14. 流量分析</a>
</h2>
<div class="content">
<p>QUIC数据包的长度会透露出有关这些数据包内容长度的信息。<strong>填充帧</strong>给予了终端混淆数据包内容长度的能力；详见<a href="#19.1_PADDING_Frames">第19.1章</a>。</p>
<p>对流量分析的防御是充满挑战的，并且是很多积极研究的主题。长度不是唯一会泄露信息的途径。终端还可能通过其他侧信道泄露敏感信息，例如数据包的计时侧信道。</p>
</div>
</section>
<section class="page" id="22_IANA_Considerations">
<h1>
<a href="#22_IANA_Considerations">22. 关于IANA的考量</a>
</h1>
<div class="content">
<p>本文档为QUIC中码点的管理建立了一些注册表。这些注册表遵循在<a href="#22.1_Registration_Policies_for_QUIC_Registries">第22.1章</a>中描述的一组通用规范。</p>
</div>
</section>
<section class="page" id="22.1_Registration_Policies_for_QUIC_Registries">
<h2>
<a href="#22.1_Registration_Policies_for_QUIC_Registries">22.1. QUIC注册表中注册项的规范</a>
</h2>
<div class="content">
<p>所有QUIC注册表都允许码点以临时或永久的形式注册。本节记述了对这些注册表的通用规范。</p>
</div>
</section>
<section class="page" id="22.1.1_Provisional_Registrations">
<h3>
<a href="#22.1.1_Provisional_Registrations">22.1.1. 临时注册项</a>
</h3>
<div class="content">
<p>码点的临时注册项是为了支持私有用途和QUIC的实验性扩展。临时注册项中只需要包含码点值和联系方式。然而，临时注册项可以被释放或重新指定为另一用途。</p>
<p>临时注册项需要经过专家评审（<code>Expert Review</code>），就像《<a href="https://www.rfc-editor.org/info/rfc8126">RFC8126</a>》的<a href="https://www.rfc-editor.org/rfc/rfc8126.html#section-4.5">第4.5章</a>中定义的那样。建议被指派的专家或专家组仅对那些在不在剩余码点空间中的申请，或者对可用码点空间中首个未分配值的申请（详见<a href="#22.1.2_Selecting_Codepoints">第22.1.2章</a>）做出拒绝。</p>
<p>临时注册项中将包含日期字段，它表明了该注册项的最后更新时间。对任何临时注册项的日期进行更新的申请不需要经过专家（组）的评审。</p>
<p>为了支持临时注册项，所有QUIC注册表都包含以下字段：</p>
<dl>
<dt>值：</dt>
<dd>
<p>分配的码点。</p>
</dd>
<dt>状态：</dt>
<dd>
<p>“永久”或“临时”。</p>
</dd>
<dt>规范：</dt>
<dd>
<p>指向一份公开可用的针对此值的规范的引用。</p>
</dd>
<dt>日期：</dt>
<dd>
<p>最后一次更新此注册项的日期。</p>
</dd>
<dt>更改责任人：</dt>
<dd>
<p>对此注册项的定义负责的实体。</p>
</dd>
<dt>联系方式：</dt>
<dd>
<p>注册者的联系方式。</p>
</dd>
<dt>备注：</dt>
<dd>
<p>关于此注册项的补充性备注。</p>
</dd>
</dl>
<p>临时注册项中<em><strong>可以</strong></em>省略规范和备注字段，以及任何对永久注册项来说必需的额外字段。日期字段在申请注册时不是必需的，因为它会在创建或更新注册项时被设置上去。</p>
</div>
</section>
<section class="page" id="22.1.2_Selecting_Codepoints">
<h3>
<a href="#22.1.2_Selecting_Codepoints">22.1.2. 挑选码点</a>
</h3>
<div class="content">
<p>对来自QUIC注册表中的码点的申请<em><strong>应该</strong></em>使用一个随机选择的码点，并且避开已分配的码点和选定空间中的首个未分配码点。<em><strong>可以</strong></em>使用一个连续的范围来申请复数码点。这使得不同实现将相差过大的语义赋给同一码点的风险能够降至最低。</p>
<p>首个未分配码点是保留码点，对它的分配遵循着标准行为（<code>Standards Action</code>）流程；详见《<a href="https://www.rfc-editor.org/info/rfc8126">RFC8126</a>》的<a href="https://www.rfc-editor.org/rfc/rfc8126.html#section-4.9">第4.9章</a>。早期码点分配过程（详见《<a href="https://www.rfc-editor.org/info/rfc7120">EARLY-ASSIGN</a>》）适用于这些值。</p>
<p>对于以可变长度整型编码（详见<a href="#16_Variable-Length_Integer_Encoding">第16章</a>）的码点，例如帧类型，<em><strong>应该</strong></em>使用被编码至四字节或八字节（也就是大于等于<code>214</code>的值）的码点，除非它对编码结果的长度有特殊要求。</p>
<p>在QUIC注册表中注册码点的应用<em><strong>可以</strong></em>申请一个码点并作为注册的一部分。如果这个码点未被分配并且符合注册流程的各项要求，那么IANA<em><strong>必须</strong></em>分配所选码点。</p>
</div>
</section>
<section class="page" id="22.1.3_Reclaiming_Provisional_Codepoints">
<h3>
<a href="#22.1.3_Reclaiming_Provisional_Codepoints">22.1.3. 释放临时码点</a>
</h3>
<div class="content">
<p>可以申请从注册表中移除一条未使用的临时注册项从而腾出注册表中的空间，也可以申请移除注册表的一块区域（例如从<code>64</code>至<code>16383</code>的范围，它们是使用了可变长度整型编码的码点）。该申请<em><strong>应该</strong></em>只从具有最早记录日期的码点开始进行，并且一年内曾被更新过的注册项<em><strong>不应该</strong></em>被释放。</p>
<p>对于移除码点的申请<em><strong>必须</strong></em>得到所指派的专家组的评审。专家组<em><strong>必须</strong></em>尝试判断该码点是否仍在使用中。专家组应该联系注册项中列出的联系方式，和尽可能多的协议实现方，从而判断该码点是否仍有使用场景。专家组还应该拥有至少四周的时间用于做出答复。</p>
<p>如果上文中查找使用场景的结果是认定该码点仍在使用，或出现了更新此注册项的申请，那么<em><strong>必须不</strong></em>释放该码点。取而代之的是，注册表项的日期会被更新。可以为此注册项新增一条备注，记录在此过程中了解到的相关信息。</p>
<p>如果没有找到该码点的使用场景，并且没有出现更新此注册项的申请，那么该码点<em><strong>可以</strong></em>被移除出注册表。</p>
<p>这种评审与商讨的过程还适用于将临时注册项变更为永久注册项的申请，只不过目标不是判断有没有该码点的使用场景，而是判断此注册项是否准确地表达了它在某一部署场景中的用途。</p>
</div>
</section>
<section class="page" id="22.1.4_Permanent_Registrations">
<h3>
<a href="#22.1.4_Permanent_Registrations">22.1.4. 永久注册项</a>
</h3>
<div class="content">
<p>QUIC注册表中的永久注册项遵循的是强制规范（<code>Specification Required</code>）流程（详见《<a href="https://www.rfc-editor.org/info/rfc8126">RFC8126</a>》的<a href="https://www.rfc-editor.org/rfc/rfc8126.html#section-4.6">第4.6章</a>），除非有特别规定。被指派的专家或专家组验证规范文件是否存在并且具备可访问性。鼓励专家组倾向于批准注册申请，除非申请自身带有辱骂、轻蔑或者其他有害性质（不仅仅是在美学上令人不快或在结构上令人怀疑）。在创建注册项时<em><strong>可以</strong></em>对永久注册项指定额外限制。</p>
<p>注册项的创建<em><strong>可以</strong></em>指定一定范围的码点，使它们受到另一种注册流程的管理。例如，注册表“QUIC帧类型”（详见<a href="#22.4_QUIC_Frame_Types_Registry">第22.4章</a>）中从<code>0</code>至<code>63</code>的码点受到更严格流程的控制。</p>
<p>对永久注册项的任何更严格的要求都不会影响相关码点上的临时注册项。例如，可以为帧类型<code>61</code>申请临时注册项。</p>
<p>所有由标准化出版物创建的注册项<em><strong>必须</strong></em>是永久的。</p>
<p>本文档中的所有注册项均被指定为永久状态，更改责任人为IETF，联系方式为QUIC工作组（quic@ietf.org）。</p>
</div>
</section>
<section class="page" id="22.2_QUIC_Versions_Registry">
<h2>
<a href="#22.2_QUIC_Versions_Registry">22.2. QUIC版本注册表</a>
</h2>
<div class="content">
<p>IANA在“QUIC”条目下新增了“QUIC版本”注册表。</p>
<p>“QUIC版本”注册表管理着一段32位长的空间；详见<a href="#15_Versions">第15章</a>。该注册表遵循着来自<a href="#22.1_Registration_Policies_for_QUIC_Registries">第22.1章</a>的注册流程。该注册表中的永久注册项被指定为使用强制规范流程（详见《<a href="https://www.rfc-editor.org/info/rfc8126">RFC8126</a>》的<a href="https://www.rfc-editor.org/rfc/rfc8126.html#section-4.6">第4.6章</a>）。</p>
<p>QUIC协议的码点<code>0x00000001</code>被指定为本文档中定义的协议，并具有永久状态。码点<code>0x00000000</code>的使用被永久保留；该码点的备注表明了此版本被预留为版本协商。</p>
<p>遵循模式<code>0x?a?a?a?a</code>的所有码点的使用都被保留，它们<em><strong>必须不</strong></em>被IANA指定，并且<em><strong>必须不</strong></em>被列出在已指定的值中。</p>
</div>
</section>
<section class="page" id="22.3_QUIC_Transport_Parameters_Registry">
<h2>
<a href="#22.3_QUIC_Transport_Parameters_Registry">22.3. QUIC传输参数注册表</a>
</h2>
<div class="content">
<p>IANA在“QUIC”条目下新增了“QUIC传输参数”注册表。</p>
<p>“QUIC传输参数”注册表管理着一段62位长的空间。该注册表遵循着来自<a href="#22.1_Registration_Policies_for_QUIC_Registries">第22.1章</a>的注册流程。该注册表中的永久注册项被指定为使用强制规范流程（详见《<a href="https://www.rfc-editor.org/info/rfc8126">RFC8126</a>》的<a href="https://www.rfc-editor.org/rfc/rfc8126.html#section-4.6">第4.6章</a>），但是从<code>0x00</code>至<code>0x3f</code>间（十六进制，包含两端）的值除外，这些值会以标准行为或IESG批准的方式指定，有关定义详见《<a href="https://www.rfc-editor.org/info/rfc8126">RFC8126</a>》的<a href="https://www.rfc-editor.org/rfc/rfc8126.html#section-4.9">第4.9章</a>和<a href="https://www.rfc-editor.org/rfc/rfc8126.html#section-4.10">第4.10章</a>。</p>
<p>除了在<a href="#22.1.1_Provisional_Registrations">第22.1.1章</a>中列出的字段外，该注册表中的永久注册项还<em><strong>必须</strong></em>包含以下字段：</p>
<dl>
<dt>参数名称：</dt>
<dd>
<p>该参数简短的帮助记忆的名称。</p>
</dd>
</dl>
<p>该注册表的初始内容如<a href="#Table_6_Initial_QUIC_Transport_Parameters_Registry_Entries">表6</a>所示。</p>
<div class="block ref" id="Table_6_Initial_QUIC_Transport_Parameters_Registry_Entries">
<table>
<thead>
<tr>
<th style="text-align:left">值</th>
<th style="text-align:left">参数名称</th>
<th style="text-align:left">规范</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">0x00</td>
<td style="text-align:left">original_destination_connection_id</td>
<td style="text-align:left"><a href="#18.2_Transport_Parameter_Definitions">第18.2章</a></td>
</tr>
<tr>
<td style="text-align:left">0x01</td>
<td style="text-align:left">max_idle_timeout</td>
<td style="text-align:left"><a href="#18.2_Transport_Parameter_Definitions">第18.2章</a></td>
</tr>
<tr>
<td style="text-align:left">0x02</td>
<td style="text-align:left">stateless_reset_token</td>
<td style="text-align:left"><a href="#18.2_Transport_Parameter_Definitions">第18.2章</a></td>
</tr>
<tr>
<td style="text-align:left">0x03</td>
<td style="text-align:left">max_udp_payload_size</td>
<td style="text-align:left"><a href="#18.2_Transport_Parameter_Definitions">第18.2章</a></td>
</tr>
<tr>
<td style="text-align:left">0x04</td>
<td style="text-align:left">initial_max_data</td>
<td style="text-align:left"><a href="#18.2_Transport_Parameter_Definitions">第18.2章</a></td>
</tr>
<tr>
<td style="text-align:left">0x05</td>
<td style="text-align:left">initial_max_stream_data_bidi_local</td>
<td style="text-align:left"><a href="#18.2_Transport_Parameter_Definitions">第18.2章</a></td>
</tr>
<tr>
<td style="text-align:left">0x06</td>
<td style="text-align:left">initial_max_stream_data_bidi_remote</td>
<td style="text-align:left"><a href="#18.2_Transport_Parameter_Definitions">第18.2章</a></td>
</tr>
<tr>
<td style="text-align:left">0x07</td>
<td style="text-align:left">initial_max_stream_data_uni</td>
<td style="text-align:left"><a href="#18.2_Transport_Parameter_Definitions">第18.2章</a></td>
</tr>
<tr>
<td style="text-align:left">0x08</td>
<td style="text-align:left">initial_max_streams_bidi</td>
<td style="text-align:left"><a href="#18.2_Transport_Parameter_Definitions">第18.2章</a></td>
</tr>
<tr>
<td style="text-align:left">0x09</td>
<td style="text-align:left">initial_max_streams_uni</td>
<td style="text-align:left"><a href="#18.2_Transport_Parameter_Definitions">第18.2章</a></td>
</tr>
<tr>
<td style="text-align:left">0x0a</td>
<td style="text-align:left">ack_delay_exponent</td>
<td style="text-align:left"><a href="#18.2_Transport_Parameter_Definitions">第18.2章</a></td>
</tr>
<tr>
<td style="text-align:left">0x0b</td>
<td style="text-align:left">max_ack_delay</td>
<td style="text-align:left"><a href="#18.2_Transport_Parameter_Definitions">第18.2章</a></td>
</tr>
<tr>
<td style="text-align:left">0x0c</td>
<td style="text-align:left">disable_active_migration</td>
<td style="text-align:left"><a href="#18.2_Transport_Parameter_Definitions">第18.2章</a></td>
</tr>
<tr>
<td style="text-align:left">0x0d</td>
<td style="text-align:left">preferred_address</td>
<td style="text-align:left"><a href="#18.2_Transport_Parameter_Definitions">第18.2章</a></td>
</tr>
<tr>
<td style="text-align:left">0x0e</td>
<td style="text-align:left">active_connection_id_limit</td>
<td style="text-align:left"><a href="#18.2_Transport_Parameter_Definitions">第18.2章</a></td>
</tr>
<tr>
<td style="text-align:left">0x0f</td>
<td style="text-align:left">initial_source_connection_id</td>
<td style="text-align:left"><a href="#18.2_Transport_Parameter_Definitions">第18.2章</a></td>
</tr>
<tr>
<td style="text-align:left">0x10</td>
<td style="text-align:left">retry_source_connection_id</td>
<td style="text-align:left"><a href="#18.2_Transport_Parameter_Definitions">第18.2章</a></td>
</tr>
</tbody>
</table>
<p><a href="#Table_6_Initial_QUIC_Transport_Parameters_Registry_Entries">表6：QUIC传输参数注册表的初始项</a></p>
</div>
<p>对于非负整数<code>N</code>，所有满足形式<code>31 * N + 27</code>的值（也就是<code>27</code>、<code>58</code>、<code>89</code>……）的使用都被保留；它们<em><strong>必须不</strong></em>被IANA指定，并且<em><strong>必须不</strong></em>被列出在已指定的值中。</p>
</div>
</section>
<section class="page" id="22.4_QUIC_Frame_Types_Registry">
<h2>
<a href="#22.4_QUIC_Frame_Types_Registry">22.4. QUIC帧类型注册表</a>
</h2>
<div class="content">
<p>IANA在“QUIC”条目下新增了“QUIC帧类型”注册表。</p>
<p>“QUIC帧类型”注册表管理着一段62位长的空间。该注册表遵循着来自<a href="#22.1_Registration_Policies_for_QUIC_Registries">第22.1章</a>的注册流程。该注册表中的永久注册项被指定为使用强制规范流程（详见《<a href="https://www.rfc-editor.org/info/rfc8126">RFC8126</a>》的<a href="https://www.rfc-editor.org/rfc/rfc8126.html#section-4.6">第4.6章</a>），但是从<code>0x00</code>至<code>0x3f</code>间（十六进制，包含两端）的值除外，这些值会以标准行为或IESG批准的方式指定，有关定义详见《<a href="https://www.rfc-editor.org/info/rfc8126">RFC8126</a>》的<a href="https://www.rfc-editor.org/rfc/rfc8126.html#section-4.9">第4.9章</a>和<a href="https://www.rfc-editor.org/rfc/rfc8126.html#section-4.10">第4.10章</a>。</p>
<p>除了在<a href="#22.1.1_Provisional_Registrations">第22.1.1章</a>中列出的字段外，该注册表中的永久注册项还<em><strong>必须</strong></em>包含以下字段：</p>
<dl>
<dt>帧类型名称：</dt>
<dd>
<p>该参数简短的帮助记忆的名称。</p>
</dd>
</dl>
<p>除了在<a href="#22.1_Registration_Policies_for_QUIC_Registries">第22.1章</a>中给出的建议外，新的永久注册项的规范<em><strong>应该</strong></em>提供一份描述，描述终端可以用于判断是否能够发送该类型的帧的方法。对绝大多数注册项来说，还应该同时注册相关的传输参数；详见<a href="#22.3_QUIC_Transport_Parameters_Registry">第22.3章</a>。永久注册项的规范还需要描述该类型的帧中所有字段的格式及其语义。</p>
<p>该注册表的初始内容被罗列在<a href="#Table_3_Frame_Types">表3</a>中。注意，实际的注册表中并不包含<a href="#Table_3_Frame_Types">表3</a>中的“数据包类型”一栏和“特殊规则”一栏。</p>
</div>
</section>
<section class="page" id="22.5_QUIC_Transport_Error_Codes_Registry">
<h2>
<a href="#22.5_QUIC_Transport_Error_Codes_Registry">22.5. QUIC传输层错误码注册表</a>
</h2>
<div class="content">
<p>IANA在“QUIC”条目下新增了“QUIC传输层错误码”注册表。</p>
<p>“QUIC传输层错误码”注册表管理着一段62位长的空间。该空间被拆分为三段由不同注册流程管理的空间。该注册表遵循着来自<a href="#22.1_Registration_Policies_for_QUIC_Registries">第22.1章</a>的注册流程。该注册表中的永久注册项被指定为使用强制规范流程（详见《<a href="https://www.rfc-editor.org/info/rfc8126">RFC8126</a>》的<a href="https://www.rfc-editor.org/rfc/rfc8126.html#section-4.6">第4.6章</a>），但是从<code>0x00</code>至<code>0x3f</code>间（十六进制，包含两端）的值除外，这些值会以标准行为或IESG批准的方式指定，有关定义详见《<a href="https://www.rfc-editor.org/info/rfc8126">RFC8126</a>》的<a href="https://www.rfc-editor.org/rfc/rfc8126.html#section-4.9">第4.9章</a>和<a href="https://www.rfc-editor.org/rfc/rfc8126.html#section-4.10">第4.10章</a>。</p>
<p>除了在<a href="#22.1.1_Provisional_Registrations">第22.1.1章</a>中列出的字段外，该注册表中的永久注册项还<em><strong>必须</strong></em>包含以下字段：</p>
<dl>
<dt>代码：</dt>
<dd>
<p>该参数简短的帮助记忆的名称。</p>
</dd>
<dt>描述：</dt>
<dd>
<p>对该错误码语义的简要描述，当提供了指向规范文件的引用时，此内容<em><strong>可以</strong></em>是一份概述。</p>
</dd>
</dl>
<p>该注册表的初始内容如<a href="#Table_7_Initial_QUIC_Transport_Error_Codes_Registry_Entries">表7</a>所示。</p>
<div class="block ref" id="Table_7_Initial_QUIC_Transport_Error_Codes_Registry_Entries">
<table>
<thead>
<tr>
<th style="text-align:left">值</th>
<th style="text-align:left">代码</th>
<th style="text-align:left">描述</th>
<th style="text-align:left">规范</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">0x00</td>
<td style="text-align:left">NO_ERROR</td>
<td style="text-align:left">无错误</td>
<td style="text-align:left"><a href="#20_Error_Codes">第20章</a></td>
</tr>
<tr>
<td style="text-align:left">0x01</td>
<td style="text-align:left">INTERNAL_ERROR</td>
<td style="text-align:left">实现中的错误</td>
<td style="text-align:left"><a href="#20_Error_Codes">第20章</a></td>
</tr>
<tr>
<td style="text-align:left">0x02</td>
<td style="text-align:left">CONNECTION_REFUSED</td>
<td style="text-align:left">服务器拒绝了连接</td>
<td style="text-align:left"><a href="#20_Error_Codes">第20章</a></td>
</tr>
<tr>
<td style="text-align:left">0x03</td>
<td style="text-align:left">FLOW_CONTROL_ERROR</td>
<td style="text-align:left">流量控制错误</td>
<td style="text-align:left"><a href="#20_Error_Codes">第20章</a></td>
</tr>
<tr>
<td style="text-align:left">0x04</td>
<td style="text-align:left">STREAM_LIMIT_ERROR</td>
<td style="text-align:left">打开了过多流</td>
<td style="text-align:left"><a href="#20_Error_Codes">第20章</a></td>
</tr>
<tr>
<td style="text-align:left">0x05</td>
<td style="text-align:left">STREAM_STATE_ERROR</td>
<td style="text-align:left">接收到了在当前流状态下非法的帧</td>
<td style="text-align:left"><a href="#20_Error_Codes">第20章</a></td>
</tr>
<tr>
<td style="text-align:left">0x06</td>
<td style="text-align:left">FINAL_SIZE_ERROR</td>
<td style="text-align:left">最终尺寸发生了变化</td>
<td style="text-align:left"><a href="#20_Error_Codes">第20章</a></td>
</tr>
<tr>
<td style="text-align:left">0x07</td>
<td style="text-align:left">FRAME_ENCODING_ERROR</td>
<td style="text-align:left">帧编码错误</td>
<td style="text-align:left"><a href="#20_Error_Codes">第20章</a></td>
</tr>
<tr>
<td style="text-align:left">0x08</td>
<td style="text-align:left">TRANSPORT_PARAMETER_ERROR</td>
<td style="text-align:left">传输参数中出现错误</td>
<td style="text-align:left"><a href="#20_Error_Codes">第20章</a></td>
</tr>
<tr>
<td style="text-align:left">0x09</td>
<td style="text-align:left">CONNECTION_ID_LIMIT_ERROR</td>
<td style="text-align:left">接收到了过多的连接ID</td>
<td style="text-align:left"><a href="#20_Error_Codes">第20章</a></td>
</tr>
<tr>
<td style="text-align:left">0x0a</td>
<td style="text-align:left">PROTOCOL_VIOLATION</td>
<td style="text-align:left">通用的协议违背错误</td>
<td style="text-align:left"><a href="#20_Error_Codes">第20章</a></td>
</tr>
<tr>
<td style="text-align:left">0x0b</td>
<td style="text-align:left">INVALID_TOKEN</td>
<td style="text-align:left">接收到了非法的令牌</td>
<td style="text-align:left"><a href="#20_Error_Codes">第20章</a></td>
</tr>
<tr>
<td style="text-align:left">0x0c</td>
<td style="text-align:left">APPLICATION_ERROR</td>
<td style="text-align:left">应用错误</td>
<td style="text-align:left"><a href="#20_Error_Codes">第20章</a></td>
</tr>
<tr>
<td style="text-align:left">0x0d</td>
<td style="text-align:left">CRYPTO_BUFFER_EXCEEDED</td>
<td style="text-align:left">加密数据缓存溢出</td>
<td style="text-align:left"><a href="#20_Error_Codes">第20章</a></td>
</tr>
<tr>
<td style="text-align:left">0x0e</td>
<td style="text-align:left">KEY_UPDATE_ERROR</td>
<td style="text-align:left">对数据包保护密钥的非法更新</td>
<td style="text-align:left"><a href="#20_Error_Codes">第20章</a></td>
</tr>
<tr>
<td style="text-align:left">0x0f</td>
<td style="text-align:left">AEAD_LIMIT_REACHED</td>
<td style="text-align:left">对数据包保护密钥的超量使用</td>
<td style="text-align:left"><a href="#20_Error_Codes">第20章</a></td>
</tr>
<tr>
<td style="text-align:left">0x10</td>
<td style="text-align:left">NO_VIABLE_PATH</td>
<td style="text-align:left">无可用网络路径</td>
<td style="text-align:left"><a href="#20_Error_Codes">第20章</a></td>
</tr>
<tr>
<td style="text-align:left">0x0100-<br>0x01ff</br></td>
<td style="text-align:left">CRYPTO_ERROR</td>
<td style="text-align:left">TLS警告码</td>
<td style="text-align:left"><a href="#20_Error_Codes">第20章</a></td>
</tr>
</tbody>
</table>
<p><a href="#Table_7_Initial_QUIC_Transport_Error_Codes_Registry_Entries">表7：QUIC传输错误码注册表的初始项</a></p>
</div>
</div>
</section>
<section class="page" id="23_References">
<h1>
<a href="#23_References">23. 参考文献</a>
</h1>
<div class="content">
</div>
</section>
<section class="page" id="23.1_Normative_References">
<h2>
<a href="#23.1_Normative_References">23.1. 规范性参考文献</a>
</h2>
<div class="content">
<div class="out_ref" id="BCP38">
<p><a href="#BCP38"><strong>[BCP38]</strong></a> </p>
<p>“Network Ingress Filtering: Defeating Denial of Service Attacks which employ IP Source Address Spoofing”, BCP 38, RFC 2827, May 2000. <a href="https://www.rfc-editor.org/info/bcp38">https://www.rfc-editor.org/info/bcp38</a></p>
</div>
<div class="out_ref" id="DPLPMTUD">
<p><a href="#DPLPMTUD"><strong>[DPLPMTUD]</strong></a> </p>
<p>“Packetization Layer Path MTU Discovery for Datagram Transports”, RFC 8899, DOI 10.17487/RFC8899, September 2020, <a href="https://www.rfc-editor.org/info/rfc8899">https://www.rfc-editor.org/info/rfc8899</a>.</p>
</div>
<div class="out_ref" id="EARLY-ASSIGN">
<p><a href="#EARLY-ASSIGN"><strong>[EARLY-ASSIGN]</strong></a> </p>
<p>“Early IANA Allocation of Standards Track Code Points”, BCP 100, RFC 7120, DOI 10.17487/RFC7120, January 2014, <a href="https://www.rfc-editor.org/info/rfc7120">https://www.rfc-editor.org/info/rfc7120</a>.</p>
</div>
<div class="out_ref" id="IPv4">
<p><a href="#IPv4"><strong>[IPv4]</strong></a> </p>
<p>“Internet Protocol”, STD 5, RFC 791, DOI 10.17487/RFC0791, September 1981, <a href="https://www.rfc-editor.org/info/rfc791">https://www.rfc-editor.org/info/rfc791</a>.</p>
</div>
<div class="out_ref" id="QUIC-INVARIANTS">
<p><a href="#QUIC-INVARIANTS"><strong>[QUIC-INVARIANTS]</strong></a> </p>
<p>“Version-Independent Properties of QUIC”, RFC 8999, DOI 10.17487/RFC8999, May 2021, <a href="https://www.rfc-editor.org/info/rfc8999">https://www.rfc-editor.org/info/rfc8999</a>.</p>
</div>
<div class="out_ref" id="QUIC-RECOVERY">
<p><a href="#QUIC-RECOVERY"><strong>[QUIC-RECOVERY]</strong></a> </p>
<p>“QUIC Loss Detection and Congestion Control”, RFC 9002, DOI 10.17487/RFC9002, May 2021, <a href="https://www.rfc-editor.org/info/rfc9002">https://www.rfc-editor.org/info/rfc9002</a>.</p>
</div>
<div class="out_ref" id="QUIC-TLS">
<p><a href="#QUIC-TLS"><strong>[QUIC-TLS]</strong></a> </p>
<p>“Using TLS to Secure QUIC”, RFC 9001, DOI 10.17487/RFC9001, May 2021, <a href="https://www.rfc-editor.org/info/rfc9001">https://www.rfc-editor.org/info/rfc9001</a>.</p>
</div>
<div class="out_ref" id="RFC1191">
<p><a href="#RFC1191"><strong>[RFC1191]</strong></a> </p>
<p>Mogul, J. and S. Deering, “Path MTU discovery”, RFC 1191, DOI 10.17487/RFC1191, November 1990, <a href="https://www.rfc-editor.org/info/rfc1191">https://www.rfc-editor.org/info/rfc1191</a>.</p>
</div>
<div class="out_ref" id="RFC2119">
<p><a href="#RFC2119"><strong>[RFC2119]</strong></a> RFC文档中用于指出要求级别的关键字</p>
<p>Bradner, S., “Key words for use in RFCs to Indicate Requirement Levels”, BCP 14, RFC 2119, DOI 10.17487/RFC2119, March 1997, <a href="https://www.rfc-editor.org/info/rfc2119">https://www.rfc-editor.org/info/rfc2119</a>.</p>
</div>
<div class="out_ref" id="RFC3168">
<p><a href="#RFC3168"><strong>[RFC3168]</strong></a> </p>
<p>Ramakrishnan, K., Floyd, S., and D. Black, “The Addition of Explicit Congestion Notification (ECN) to IP”, RFC 3168, DOI 10.17487/RFC3168, September 2001, <a href="https://www.rfc-editor.org/info/rfc3168">https://www.rfc-editor.org/info/rfc3168</a>.</p>
</div>
<div class="out_ref" id="RFC3629">
<p><a href="#RFC3629"><strong>[RFC3629]</strong></a> </p>
<p>Yergeau, F., “UTF-8, a transformation format of ISO 10646”, STD 63, RFC 3629, DOI 10.17487/RFC3629, November 2003, <a href="https://www.rfc-editor.org/info/rfc3629">https://www.rfc-editor.org/info/rfc3629</a>.</p>
</div>
<div class="out_ref" id="RFC6437">
<p><a href="#RFC6437"><strong>[RFC6437]</strong></a> </p>
<p>Amante, S., Carpenter, B., Jiang, S., and J. Rajahalme, “IPv6 Flow Label Specification”, RFC 6437, DOI 10.17487/RFC6437, November 2011, <a href="https://www.rfc-editor.org/info/rfc6437">https://www.rfc-editor.org/info/rfc6437</a>.</p>
</div>
<div class="out_ref" id="RFC8085">
<p><a href="#RFC8085"><strong>[RFC8085]</strong></a> </p>
<p>Eggert, L., Fairhurst, G., and G. Shepherd, “UDP Usage Guidelines”, BCP 145, RFC 8085, DOI 10.17487/RFC8085, March 2017, <a href="https://www.rfc-editor.org/info/rfc8085">https://www.rfc-editor.org/info/rfc8085</a>.</p>
</div>
<div class="out_ref" id="RFC8126">
<p><a href="#RFC8126"><strong>[RFC8126]</strong></a> </p>
<p>Cotton, M., Leiba, B., and T. Narten, “Guidelines for Writing an IANA Considerations Section in RFCs”, BCP 26, RFC 8126, DOI 10.17487/RFC8126, June 2017, <a href="https://www.rfc-editor.org/info/rfc8126">https://www.rfc-editor.org/info/rfc8126</a>.</p>
</div>
<div class="out_ref" id="RFC8174">
<p><a href="#RFC8174"><strong>[RFC8174]</strong></a> RFC2119中关键字大写与小写的歧义</p>
<p>Leiba, B., “Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words”, BCP 14, RFC 8174, DOI 10.17487/RFC8174, May 2017, <a href="https://www.rfc-editor.org/info/rfc8174">https://www.rfc-editor.org/info/rfc8174</a>.</p>
</div>
<div class="out_ref" id="RFC8201">
<p><a href="#RFC8201"><strong>[RFC8201]</strong></a> </p>
<p>McCann, J., Deering, S., Mogul, J., and R. Hinden, Ed., “Path MTU Discovery for IP version 6”, STD 87, RFC 8201, DOI 10.17487/RFC8201, July 2017, <a href="https://www.rfc-editor.org/info/rfc8201">https://www.rfc-editor.org/info/rfc8201</a>.</p>
</div>
<div class="out_ref" id="RFC8311">
<p><a href="#RFC8311"><strong>[RFC8311]</strong></a> </p>
<p>Black, D., “Relaxing Restrictions on Explicit Congestion Notification (ECN) Experimentation”, RFC 8311, DOI 10.17487/RFC8311, January 2018, <a href="https://www.rfc-editor.org/info/rfc8311">https://www.rfc-editor.org/info/rfc8311</a>.</p>
</div>
<div class="out_ref" id="TLS13">
<p><a href="#TLS13"><strong>[TLS13]</strong></a> </p>
<p>Rescorla, E., “The Transport Layer Security (TLS) Protocol Version 1.3”, RFC 8446, DOI 10.17487/RFC8446, August 2018, <a href="https://www.rfc-editor.org/info/rfc8446">https://www.rfc-editor.org/info/rfc8446</a>.</p>
</div>
<div class="out_ref" id="UDP">
<p><a href="#UDP"><strong>[UDP]</strong></a> </p>
<p>Postel, J., “User Datagram Protocol”, STD 6, RFC 768, DOI 10.17487/RFC0768, August 1980, <a href="https://www.rfc-editor.org/info/rfc768">https://www.rfc-editor.org/info/rfc768</a>.</p>
</div>
</div>
</section>
<section class="page" id="23.2_Informative_References">
<h2>
<a href="#23.2_Informative_References">23.2. 资料性参考文献</a>
</h2>
<div class="content">
<div class="out_ref" id="AEAD">
<p><a href="#AEAD"><strong>[AEAD]</strong></a> </p>
<p>McGrew, D., “An Interface and Algorithms for Authenticated Encryption”, RFC 5116, DOI 10.17487/RFC5116, January 2008, <a href="https://www.rfc-editor.org/info/rfc5116">https://www.rfc-editor.org/info/rfc5116</a>.</p>
</div>
<div class="out_ref" id="ALPN">
<p><a href="#ALPN"><strong>[ALPN]</strong></a> </p>
<p>Friedl, S., Popov, A., Langley, A., and E. Stephan, “Transport Layer Security (TLS) Application-Layer Protocol Negotiation Extension”, RFC 7301, DOI 10.17487/RFC7301, July 2014, <a href="https://www.rfc-editor.org/info/rfc7301">https://www.rfc-editor.org/info/rfc7301</a>.</p>
</div>
<div class="out_ref" id="ALTSVC">
<p><a href="#ALTSVC"><strong>[ALTSVC]</strong></a> </p>
<p>Nottingham, M., McManus, P., and J. Reschke, “HTTP Alternative Services”, RFC 7838, DOI 10.17487/RFC7838, April 2016, <a href="https://www.rfc-editor.org/info/rfc7838">https://www.rfc-editor.org/info/rfc7838</a>.</p>
</div>
<div class="out_ref" id="COOKIE">
<p><a href="#COOKIE"><strong>[COOKIE]</strong></a> </p>
<p>Barth, A., “HTTP State Management Mechanism”, RFC 6265, DOI 10.17487/RFC6265, April 2011, <a href="https://www.rfc-editor.org/info/rfc6265">https://www.rfc-editor.org/info/rfc6265</a>.</p>
</div>
<div class="out_ref" id="CSRF">
<p><a href="#CSRF"><strong>[CSRF]</strong></a> </p>
<p>Barth, A., Jackson, C., and J. Mitchell, “Robust defenses for cross-site request forgery”, Proceedings of the 15th ACM conference on Computer and communications security - CCS ‘08, DOI 10.1145/1455770.1455782, 2008, <a href="https://doi.org/10.1145/1455770.1455782">https://doi.org/10.1145/1455770.1455782</a>.</p>
</div>
<div class="out_ref" id="EARLY-DESIGN">
<p><a href="#EARLY-DESIGN"><strong>[EARLY-DESIGN]</strong></a> </p>
<p>Roskind, J., “QUIC: Multiplexed Stream Transport Over UDP”, 2 December 2013, <a href="https://docs.google.com/document/d/1RNHkx_VvKWyWg6Lr8SZ-saqsQx7rFV-ev2jRFUoVD34/edit?usp=sharing">https://docs.google.com/document/d/1RNHkx_VvKWyWg6Lr8SZ-saqsQx7rFV-ev2jRFUoVD34/edit?usp=sharing</a>.</p>
</div>
<div class="out_ref" id="GATEWAY">
<p><a href="#GATEWAY"><strong>[GATEWAY]</strong></a> </p>
<p>Hätönen, S., Nyrhinen, A., Eggert, L., Strowes, S., Sarolahti, P., and M. Kojo, “An experimental study of home gateway characteristics”, Proceedings of the 10th ACM SIGCOMM conference on Internet measurement - IMC ‘10, DOI 10.1145/1879141.1879174, November 2010, <a href="https://doi.org/10.1145/1879141.1879174">https://doi.org/10.1145/1879141.1879174</a>.</p>
</div>
<div class="out_ref" id="HTTP2">
<p><a href="#HTTP2"><strong>[HTTP2]</strong></a> </p>
<p>Belshe, M., Peon, R., and M. Thomson, Ed., “Hypertext Transfer Protocol Version 2 (HTTP/2)”, RFC 7540, DOI 10.17487/RFC7540, May 2015, <a href="https://www.rfc-editor.org/info/rfc7540">https://www.rfc-editor.org/info/rfc7540</a>.</p>
</div>
<div class="out_ref" id="IPv6">
<p><a href="#IPv6"><strong>[IPv6]</strong></a> </p>
<p>Deering, S. and R. Hinden, “Internet Protocol, Version 6 (IPv6) Specification”, STD 86, RFC 8200, DOI 10.17487/RFC8200, July 2017, <a href="https://www.rfc-editor.org/info/rfc8200">https://www.rfc-editor.org/info/rfc8200</a>.</p>
</div>
<div class="out_ref" id="QUIC-MANAGEABILITY">
<p><a href="#QUIC-MANAGEABILITY"><strong>[QUIC-MANAGEABILITY]</strong></a> </p>
<p>Kuehlewind, M. and B. Trammell, “Manageability of the QUIC Transport Protocol”, Work in Progress, Internet-Draft, draft-ietf-quic-manageability-11, 21 April 2021, <a href="https://tools.ietf.org/html/draft-ietf-quic-manageability-11">https://tools.ietf.org/html/draft-ietf-quic-manageability-11</a>.</p>
</div>
<div class="out_ref" id="RANDOM">
<p><a href="#RANDOM"><strong>[RANDOM]</strong></a> </p>
<p>Eastlake 3rd, D., Schiller, J., and S. Crocker, “Randomness Requirements for Security”, BCP 106, RFC 4086, DOI 10.17487/RFC4086, June 2005, <a href="https://www.rfc-editor.org/info/rfc4086">https://www.rfc-editor.org/info/rfc4086</a>.</p>
</div>
<div class="out_ref" id="RFC1812">
<p><a href="#RFC1812"><strong>[RFC1812]</strong></a> </p>
<p>Baker, F., Ed., “Requirements for IP Version 4 Routers”, RFC 1812, DOI 10.17487/RFC1812, June 1995, <a href="https://www.rfc-editor.org/info/rfc1812">https://www.rfc-editor.org/info/rfc1812</a>.</p>
</div>
<div class="out_ref" id="RFC1918">
<p><a href="#RFC1918"><strong>[RFC1918]</strong></a> </p>
<p>Rekhter, Y., Moskowitz, B., Karrenberg, D., de Groot, G. J., and E. Lear, “Address Allocation for Private Internets”, BCP 5, RFC 1918, DOI 10.17487/RFC1918, February 1996, <a href="https://www.rfc-editor.org/info/rfc1918">https://www.rfc-editor.org/info/rfc1918</a>.</p>
</div>
<div class="out_ref" id="RFC2018">
<p><a href="#RFC2018"><strong>[RFC2018]</strong></a> </p>
<p>Mathis, M., Mahdavi, J., Floyd, S., and A. Romanow, “TCP Selective Acknowledgment Options”, RFC 2018, DOI 10.17487/RFC2018, October 1996, <a href="https://www.rfc-editor.org/info/rfc2018">https://www.rfc-editor.org/info/rfc2018</a>.</p>
</div>
<div class="out_ref" id="RFC2104">
<p><a href="#RFC2104"><strong>[RFC2104]</strong></a> </p>
<p>Krawczyk, H., Bellare, M., and R. Canetti, “HMAC: Keyed-Hashing for Message Authentication”, RFC 2104, DOI 10.17487/RFC2104, February 1997, <a href="https://www.rfc-editor.org/info/rfc2104">https://www.rfc-editor.org/info/rfc2104</a>.</p>
</div>
<div class="out_ref" id="RFC3449">
<p><a href="#RFC3449"><strong>[RFC3449]</strong></a> </p>
<p>Balakrishnan, H., Padmanabhan, V., Fairhurst, G., and M. Sooriyabandara, “TCP Performance Implications of Network Path Asymmetry”, BCP 69, RFC 3449, DOI 10.17487/RFC3449, December 2002, <a href="https://www.rfc-editor.org/info/rfc3449">https://www.rfc-editor.org/info/rfc3449</a>.</p>
</div>
<div class="out_ref" id="RFC4193">
<p><a href="#RFC4193"><strong>[RFC4193]</strong></a> </p>
<p>Hinden, R. and B. Haberman, “Unique Local IPv6 Unicast Addresses”, RFC 4193, DOI 10.17487/RFC4193, October 2005, <a href="https://www.rfc-editor.org/info/rfc4193">https://www.rfc-editor.org/info/rfc4193</a>.</p>
</div>
<div class="out_ref" id="RFC4291">
<p><a href="#RFC4291"><strong>[RFC4291]</strong></a> </p>
<p>Hinden, R. and S. Deering, “IP Version 6 Addressing Architecture”, RFC 4291, DOI 10.17487/RFC4291, February 2006, <a href="https://www.rfc-editor.org/info/rfc4291">https://www.rfc-editor.org/info/rfc4291</a>.</p>
</div>
<div class="out_ref" id="RFC4443">
<p><a href="#RFC4443"><strong>[RFC4443]</strong></a> </p>
<p>Conta, A., Deering, S., and M. Gupta, Ed., “Internet Control Message Protocol (ICMPv6) for the Internet Protocol Version 6 (IPv6) Specification”, STD 89, RFC 4443, DOI 10.17487/RFC4443, March 2006, <a href="https://www.rfc-editor.org/info/rfc4443">https://www.rfc-editor.org/info/rfc4443</a>.</p>
</div>
<div class="out_ref" id="RFC4787">
<p><a href="#RFC4787"><strong>[RFC4787]</strong></a> </p>
<p>Audet, F., Ed. and C. Jennings, “Network Address Translation (NAT) Behavioral Requirements for Unicast UDP”, BCP 127, RFC 4787, DOI 10.17487/RFC4787, January 2007, <a href="https://www.rfc-editor.org/info/rfc4787">https://www.rfc-editor.org/info/rfc4787</a>.</p>
</div>
<div class="out_ref" id="RFC5681">
<p><a href="#RFC5681"><strong>[RFC5681]</strong></a> </p>
<p>Allman, M., Paxson, V., and E. Blanton, “TCP Congestion Control”, RFC 5681, DOI 10.17487/RFC5681, September 2009, <a href="https://www.rfc-editor.org/info/rfc5681">https://www.rfc-editor.org/info/rfc5681</a>.</p>
</div>
<div class="out_ref" id="RFC5869">
<p><a href="#RFC5869"><strong>[RFC5869]</strong></a> </p>
<p>Krawczyk, H. and P. Eronen, “HMAC-based Extract-and-Expand Key Derivation Function (HKDF)”, RFC 5869, DOI 10.17487/RFC5869, May 2010, <a href="https://www.rfc-editor.org/info/rfc5869">https://www.rfc-editor.org/info/rfc5869</a>.</p>
</div>
<div class="out_ref" id="RFC7983">
<p><a href="#RFC7983"><strong>[RFC7983]</strong></a> </p>
<p>Petit-Huguenin, M. and G. Salgueiro, “Multiplexing Scheme Updates for Secure Real-time Transport Protocol (SRTP) Extension for Datagram Transport Layer Security (DTLS)”, RFC 7983, DOI 10.17487/RFC7983, September 2016, <a href="https://www.rfc-editor.org/info/rfc7983">https://www.rfc-editor.org/info/rfc7983</a>.</p>
</div>
<div class="out_ref" id="RFC8087">
<p><a href="#RFC8087"><strong>[RFC8087]</strong></a> </p>
<p>Fairhurst, G. and M. Welzl, “The Benefits of Using Explicit Congestion Notification (ECN)”, RFC 8087, DOI 10.17487/RFC8087, March 2017, <a href="https://www.rfc-editor.org/info/rfc8087">https://www.rfc-editor.org/info/rfc8087</a>.</p>
</div>
<div class="out_ref" id="RFC8981">
<p><a href="#RFC8981"><strong>[RFC8981]</strong></a> </p>
<p>Gont, F., Krishnan, S., Narten, T., and R. Draves, “Temporary Address Extensions for Stateless Address Autoconfiguration in IPv6”, RFC 8981, DOI 10.17487/RFC8981, February 2021, <a href="https://www.rfc-editor.org/info/rfc8981">https://www.rfc-editor.org/info/rfc8981</a>.</p>
</div>
<div class="out_ref" id="SEC-CONS">
<p><a href="#SEC-CONS"><strong>[SEC-CONS]</strong></a> </p>
<p>Rescorla, E. and B. Korver, “Guidelines for Writing RFC Text on Security Considerations”, BCP 72, RFC 3552, DOI 10.17487/RFC3552, July 2003, <a href="https://www.rfc-editor.org/info/rfc3552">https://www.rfc-editor.org/info/rfc3552</a>.</p>
</div>
<div class="out_ref" id="SLOWLORIS">
<p><a href="#SLOWLORIS"><strong>[SLOWLORIS]</strong></a> </p>
<p>“RSnake” Hansen, R., “Welcome to Slowloris - the low bandwidth, yet greedy and poisonous HTTP client!”, June 2009, <a href="https://web.archive.org/web/20150315054838/http://ha.ckers.org/slowloris/">https://web.archive.org/web/20150315054838/http://ha.ckers.org/slowloris/</a>.</p>
</div>
</div>
</section>
<section class="page" id="Appendix_A_Pseudocode">
<h1>
<a href="#Appendix_A_Pseudocode">附录A. 伪代码</a>
</h1>
<div class="content">
<p>本章的伪代码描述了一些算法样例。这些算法有意写得准确且清晰，没有为了性能而优化。</p>
<p>本章中的伪代码片段以代码组件的形式受到权利保护；详见版权声明。</p>
</div>
</section>
<section class="page" id="A.1_Sample_Variable-Length_Integer_Decoding">
<h2>
<a href="#A.1_Sample_Variable-Length_Integer_Decoding">A.1. 可变长度整型解码样例</a>
</h2>
<div class="content">
<p><a href="#Figure_45_Sample_Variable_Length_Integer_Decoding_Algorithm">图45</a>中的伪代码展示了如何从字节流中读取可变长度整型值。<code>ReadVarint</code>函数接收单个参数——一个字节序列，它将以网络字节序被读取。</p>
<div class="block ref" id="Figure_45_Sample_Variable_Length_Integer_Decoding_Algorithm">
<pre tabindex="0"><code>ReadVarint(data):
  // 可变长度整型值的长度被编码在首个字节的前两个比特位中。
  v = data.next_byte()
  prefix = v &gt;&gt; 6
  length = 1 &lt;&lt; prefix

  // 一旦长度已知，就移除这些比特位，并读取剩余字节。
  v = v &amp; 0x3f
  repeat length-1 times:
    v = (v &lt;&lt; 8) + data.next_byte()
  return v
</code></pre><p><a href="#Figure_45_Sample_Variable_Length_Integer_Decoding_Algorithm">图45：可变长度整型解码算法样例</a></p>
</div>
<p>举例来说，八字节序列<code>0xc2197c5eff14e88c</code>会被解码为十进制值<code>151,288,809,941,952,652</code>；四字节序列<code>0x9d7f3e7d </code>会被解码为<code>494,878,333</code>；双字节序列<code>0x7bbd </code>会被解码为<code>15,293</code>；而单字节<code>0x25</code>会被解码为<code>37</code>（和解码双字节序列<code>0x4025</code>的结果一致）。</p>
</div>
</section>
<section class="page" id="A.2_Sample_Packet_Number_Encoding_Algorithm">
<h2>
<a href="#A.2_Sample_Packet_Number_Encoding_Algorithm">A.2. 数据包号编码算法样例</a>
</h2>
<div class="content">
<p><a href="#Figure_46_Sample_Packet_Number_Encoding_Algorithm">图46</a>中的伪代码展示了QUIC实现怎样选择合适长度的数据包号编码。</p>
<p><code>EncodePacketNumber</code>函数接收两个参数：</p>
<ul>
<li>
<p><code>full_pn</code>是正在发送的数据包的完整数据包号。</p>
</li>
<li>
<p><code>largest_acked</code>是当前数据包号空间中已被对端确认的最大数据包号，如果有的话。</p>
</li>
</ul>
<div class="block ref" id="Figure_46_Sample_Packet_Number_Encoding_Algorithm">
<pre tabindex="0"><code>EncodePacketNumber(full_pn, largest_acked):

  // 比特位的数量必须至少比连续未被确认的数据包号的数量（包括此数据包本身）的
  // 以`2`为底的对数值大`1`
  if largest_acked is None:
    num_unacked = full_pn + 1
  else:
    num_unacked = full_pn - largest_acked

  min_bits = log(num_unacked, 2) + 1
  num_bytes = ceil(min_bits / 8)

  // 将整型值编码，并截断为仅剩最低`num_bytes`个字节
  return encode(full_pn, num_bytes)
</code></pre><p><a href="#Figure_46_Sample_Packet_Number_Encoding_Algorithm">图46：数据包号编码算法样例</a></p>
</div>
<p>举例来说，如果终端接收到了对于数据包<code>0xabe8b3</code>的确认，并且正在发送数据包号为<code>0xac5c02</code>的数据包，那么就存在着<code>29,519</code>（<code>0x734f</code>）个未确认的数据包号。为了能够至少表示这个数量的两倍大小（<code>59,038</code>个，或者说<code>0xe69e</code>个数据包），就需要16个比特位。</p>
<p>在相同的状态下，发送数据包号为<code>0xace8fe</code>的数据包会使用长度为24比特位的编码方式，因为至少需要18个比特位才能表示缺口数量的两倍（<code>131,222</code>个，或者说<code>0x020096</code>个数据包）。</p>
</div>
</section>
<section class="page" id="A.3_Sample_Packet_Number_Decoding_Algorithm">
<h2>
<a href="#A.3_Sample_Packet_Number_Decoding_Algorithm">A.3. 数据包号解码算法样例</a>
</h2>
<div class="content">
<p><a href="#Figure_47_Sample_Packet_Number_Decoding_Algorithm">图47</a>中的伪代码包含了在移除头部保护后解码数据包号的算法样例。</p>
<p><code>DecodePacketNumber</code>函数接收三个参数：</p>
<ul>
<li>
<p><code>largest_pn</code>是当前数据包号空间中已成功处理的最大数据包号</p>
</li>
<li>
<p><code>truncated_pn</code>是数据包号字段的值</p>
</li>
<li>
<p><code>pn_nbits</code>是数据包号字段中比特位的数量（<code>8</code>、<code>16</code>、<code>24</code>或<code>32</code>）。</p>
</li>
</ul>
<div class="block ref" id="Figure_47_Sample_Packet_Number_Decoding_Algorithm">
<pre tabindex="0"><code>DecodePacketNumber(largest_pn, truncated_pn, pn_nbits):
  expected_pn  = largest_pn + 1
  pn_win       = 1 &lt;&lt; pn_nbits
  pn_hwin      = pn_win / 2
  pn_mask      = pn_win - 1
  // 传入数据包号应该大于`expected_pn - pn_hwin`且小于等于
  // `expected_pn + pn_hwin`
  //
  // 这意味着我们不能简单地去掉`expected_pn`中末尾的比特位再加上`truncated_pn`
  // 因为那样会产生一个超过窗口范围的值。
  //
  // 接下来的代码计算了一个候选值，并确保它处于数据包号窗口范围中。
  // 注意用于防止数值过大和数值过小的额外检查。
  candidate_pn = (expected_pn &amp; ~pn_mask) | truncated_pn
  if candidate_pn &lt;= expected_pn - pn_hwin and
    candidate_pn &lt; (1 &lt;&lt; 62) - pn_win:
    return candidate_pn + pn_win
  if candidate_pn &gt; expected_pn + pn_hwin and
    candidate_pn &gt;= pn_win:
    return candidate_pn - pn_win
  return candidate_pn
</code></pre><p><a href="#Figure_47_Sample_Packet_Number_Decoding_Algorithm">图47：数据包号解码算法样例</a></p>
</div>
<p>举例来说，如果已成功认证数据包的数据包号中，最大值为<code>0xa82f30ea</code>，那么值为<code>0x9b32</code>的16比特长的数据包号字段会被解码为<code>0xa82f9b32</code>。</p>
</div>
</section>
<section class="page" id="A.4_Sample_ECN_Validation_Algorithm">
<h2>
<a href="#A.4_Sample_ECN_Validation_Algorithm">A.4. ECN验证算法样例</a>
</h2>
<div class="content">
<p>每次终端开始在新的网络路径上发送时，它都要判断该路径是否支持ECN；详见<a href="#13.4_Explicit_Congestion_Notification">第13.4章</a>。如果该路径支持ECN，那么就要将ECN利用起来。终端还可以每隔一段时间重新判断一次被认为不支持ECN的路径。</p>
<p>本节描述了一种用于测试新路径的方法。本算法的意图是展示如何测试一条路径是否支持ECN。终端可以用其他方法实现。</p>
<p>受测试的路径会被指定一种ECN状态，它会是“测试中”、“未知”、“失败”和“支持”中的一种。在状态为“测试中”或“支持”的路径上，终端发送的数据包会带有<code>ECT</code>标记——默认是<code>ECT(0)</code>；否则，终端发送的数据包上不带标记。</p>
<p>要启动对一条路径的测试，其ECN状态会被置为“测试中”，并且当前的ECN计数被记录为基准值。</p>
<p>测试期间会持续发送数个数据包，或者持续一段指定的时间，这由终端决定。此处的目标不是要限制测试的时长，而是确保发送了足够多经标记的数据包以使得接收到的ECN计数能够清晰地表明该路径会怎样对待经标记的数据包。<a href="#13.4.2_ECN_Validation">第13.4.2章</a>建议将此时长限制为发送10个数据包的耗时或PTO的三倍大小。</p>
<p>在测试期结束时，该路径的ECN状态会转为“未知”。对<strong>ACK帧</strong>中ECN计数的成功验证会使得该路径的状态从“未知”转为“支持”，除非没有经标记的数据包得到确认。</p>
<p>一旦对ECN计数的验证失败，那么相关路径的ECN状态就会转为“失败”。终端还可以在经标记的数据包全部被认定为丢包或全部被标记上<code>ECN-CE</code>时将ECN状态置为“失败”。</p>
<p>按照本算法，能够确保在正确支持ECN的路径上ECN几乎不会被禁用。任何错误地修改了标记的路径都会使得ECN被禁用。对于那些经标记数据包被路径丢弃的罕见情况，短暂的测试期能够限制被丢弃数据包的数量。</p>
</div>
</section>
<section class="page" id="Contributors">
<h1>
<a href="#Contributors">贡献者</a>
</h1>
<div class="content">
<p>本协议背后的原始设计和基本原理很大程度上来自Jim Roskind的工作（详见《<a href="https://docs.google.com/document/d/1RNHkx_VvKWyWg6Lr8SZ-saqsQx7rFV-ev2jRFUoVD34/edit?usp=sharing">EARLY-DESIGN</a>》）。</p>
<p>IETF QUIC工作组接收到了来自许多人员的大量支持。以下人员对本文档做出了重要贡献：</p>
<ul>
<li>
<p>Alessandro Ghedini</p>
</li>
<li>
<p>Alyssa Wilk</p>
</li>
<li>
<p>Antoine Delignat-Lavaud</p>
</li>
<li>
<p>Brian Trammell</p>
</li>
<li>
<p>Christian Huitema</p>
</li>
<li>
<p>Colin Perkins</p>
</li>
<li>
<p>David Schinazi</p>
</li>
<li>
<p>Dmitri Tikhonov</p>
</li>
<li>
<p>Eric Kinnear</p>
</li>
<li>
<p>Eric Rescorla</p>
</li>
<li>
<p>Gorry Fairhurst</p>
</li>
<li>
<p>Ian Swett</p>
</li>
<li>
<p>Igor Lubashev</p>
</li>
<li>
<p>奥 一穂 (Kazuho Oku)</p>
</li>
<li>
<p>Lars Eggert</p>
</li>
<li>
<p>Lucas Pardue</p>
</li>
<li>
<p>Magnus Westerlund</p>
</li>
<li>
<p>Marten Seemann</p>
</li>
<li>
<p>Martin Duke</p>
</li>
<li>
<p>Mike Bishop</p>
</li>
<li>
<p>Mikkel Fahnøe Jørgensen</p>
</li>
<li>
<p>Mirja Kühlewind</p>
</li>
<li>
<p>Nick Banks</p>
</li>
<li>
<p>Nick Harper</p>
</li>
<li>
<p>Patrick McManus</p>
</li>
<li>
<p>Roberto Peon</p>
</li>
<li>
<p>Ryan Hamilton</p>
</li>
<li>
<p>Subodh Iyengar</p>
</li>
<li>
<p>Tatsuhiro Tsujikawa</p>
</li>
<li>
<p>Ted Hardie</p>
</li>
<li>
<p>Tom Jones</p>
</li>
<li>
<p>Victor Vasiliev</p>
</li>
</ul>
</div>
</section>
<section class="page" id="Authors_Addresses">
<h1>
<a href="#Authors_Addresses">联系作者</a>
</h1>
<div class="content">
<h5 id="jana-iyengar-编辑">Jana Iyengar (编辑)</h5>
<p>Fastly</p>
<p>Email: <a href="mailto:jri.ietf@gmail.com">jri.ietf@gmail.com</a></p>
<h5 id="martin-thomson-编辑">Martin Thomson (编辑)</h5>
<p>Mozilla</p>
<p>Email: <a href="mailto:mt@lowentropy.net">mt@lowentropy.net</a></p>
<h2 id="译">译</h2>
<ul>
<li>
<p><a href="https://github.com/YunzheZJU">Yunzhe</a></p>
<ul>
<li>Email: <a href="mailto:yunzhe@zju.edu.cn">yunzhe@zju.edu.cn</a></li>
</ul>
</li>
<li>
<p><a href="https://github.com/fangqiuhang">方秋航</a></p>
<ul>
<li>Email: <a href="mailto:fangqiuhang@163.com">fangqiuhang@163.com</a></li>
</ul>
</li>
</ul>
</div>
</section>
</div>
</body>
</html>
