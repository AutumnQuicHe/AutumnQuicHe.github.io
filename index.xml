<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Autumn Navigation</title>
    <link>/</link>
    <description>Recent content on Autumn Navigation</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>cn</language><atom:link href="/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>前言</title>
      <link>/RFC8999_Chinese_Translation/Foreword/forword/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC8999_Chinese_Translation/Foreword/forword/</guid>
      <description>本文是关于QUIC传输层协议基础属性的网络规范文档译文，尚未完成翻译，欢迎指正。</description>
    </item>
    
    <item>
      <title>前言</title>
      <link>/RFC9000_Chinese_Translation/Foreword/forword/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9000_Chinese_Translation/Foreword/forword/</guid>
      <description>本文是QUIC传输层协议的网络规范文档译文，尚未完成翻译，欢迎指正。</description>
    </item>
    
    <item>
      <title>前言</title>
      <link>/RFC9001_Chinese_Translation/Foreword/forword/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9001_Chinese_Translation/Foreword/forword/</guid>
      <description>本文是QUIC使用TLS进行加密通信的网络规范文档译文，尚未完成翻译，欢迎指正。</description>
    </item>
    
    <item>
      <title>前言</title>
      <link>/RFC9002_Chinese_Translation/Foreword/forword/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9002_Chinese_Translation/Foreword/forword/</guid>
      <description>本文是关于QUIC丢包检测与恢复的网络规范文档译文，尚未完成翻译，欢迎指正。</description>
    </item>
    
    <item>
      <title>前言</title>
      <link>/RFC9114_Chinese_Simplified/Foreword/forword/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9114_Chinese_Simplified/Foreword/forword/</guid>
      <description>本文是关于HTTP/3的网络规范文档译文，尚未完成翻译，欢迎指正。</description>
    </item>
    
    <item>
      <title>前言</title>
      <link>/RFC9204_Chinese_Simplified/Foreword/forword/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9204_Chinese_Simplified/Foreword/forword/</guid>
      <description>本文是关于QPACK的网络规范文档译文，尚未完成翻译，欢迎指正。</description>
    </item>
    
    <item>
      <title>前言</title>
      <link>/RFC9221_Chinese_Simplified/Foreword/forword/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9221_Chinese_Simplified/Foreword/forword/</guid>
      <description>本文是关于QUIC进行不可靠数据报文传输的网络规范文档译文，尚未完成翻译，欢迎指正。</description>
    </item>
    
    <item>
      <title>前言</title>
      <link>/RFC9250_Chinese_Simplified/Foreword/forword/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9250_Chinese_Simplified/Foreword/forword/</guid>
      <description>本文是关于DNS如何使用QUIC的网络规范文档译文，尚未完成翻译，欢迎指正。</description>
    </item>
    
    <item>
      <title>摘要</title>
      <link>/RFC8999_Chinese_Translation/Foreword/abstract/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC8999_Chinese_Translation/Foreword/abstract/</guid>
      <description>本文定义了在所有版本的QUIC传输协议间均通用的属性。</description>
    </item>
    
    <item>
      <title>摘要</title>
      <link>/RFC9000_Chinese_Translation/Foreword/abstract/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9000_Chinese_Translation/Foreword/abstract/</guid>
      <description>本文定义了QUIC传输协议的核心。QUIC是能支持应用程序进行有流量控制的多流结构化通信机制，支持低延迟连接建立和网络迁移。QUIC自带机密、完整的安全措施，能广泛支持各种各样的部署。有关文档描述了QUIC如何将TLS的密钥协商、丢包检测及众多拥塞控制算法整合。</description>
    </item>
    
    <item>
      <title>摘要</title>
      <link>/RFC9001_Chinese_Translation/Foreword/abstract/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9001_Chinese_Translation/Foreword/abstract/</guid>
      <description>本文描述如何使用传输层安全协议（TLS）加密QUIC。</description>
    </item>
    
    <item>
      <title>摘要</title>
      <link>/RFC9002_Chinese_Translation/Foreword/abstract/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9002_Chinese_Translation/Foreword/abstract/</guid>
      <description>本文描述了QUIC丢包检测与拥塞控制机制的设计。</description>
    </item>
    
    <item>
      <title>摘要</title>
      <link>/RFC9114_Chinese_Simplified/Foreword/abstract/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9114_Chinese_Simplified/Foreword/abstract/</guid>
      <description>QUIC传输协议有着诸多HTTP的传输层所渴求的特性，例如流的多路复用、每条流独立的流量控制以及低延迟连接建立。 本文描述一种HTTP语义在QUIC上的映射。 本文也会指出包含在QUIC中的HTTP/2特性，并描述如何将HTTP/2扩展移植到HTTP/3。</description>
    </item>
    
    <item>
      <title>摘要</title>
      <link>/RFC9204_Chinese_Simplified/Foreword/abstract/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9204_Chinese_Simplified/Foreword/abstract/</guid>
      <description>本规范定义了QPACK：一种高效表示用于HTTP/3的HTTP字段的压缩格式。 这是一个HPACK的变种，旨在降低队头阻塞。</description>
    </item>
    
    <item>
      <title>摘要</title>
      <link>/RFC9221_Chinese_Simplified/Foreword/abstract/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9221_Chinese_Simplified/Foreword/abstract/</guid>
      <description>本文定义了QUIC传输协议的一个扩展，用以支持在一条QUIC连接上发送和接收不可靠数据报文。</description>
    </item>
    
    <item>
      <title>摘要</title>
      <link>/RFC9250_Chinese_Simplified/Foreword/abstract/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9250_Chinese_Simplified/Foreword/abstract/</guid>
      <description>This document describes the use of QUIC to provide transport confidentiality for DNS. The encryption provided by QUIC has similar properties to those provided by TLS, while QUIC transport eliminates the head-of-line blocking issues inherent with TCP and provides more efficient packet-loss recovery than UDP. DNS over QUIC (DoQ) has privacy properties similar to DNS over TLS (DoT) specified in RFC 7858, and latency characteristics similar to classic DNS over UDP.</description>
    </item>
    
    <item>
      <title>备忘状态</title>
      <link>/RFC8999_Chinese_Translation/Foreword/status_of_this_memo/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC8999_Chinese_Translation/Foreword/status_of_this_memo/</guid>
      <description>本文是互联网标准追踪文档。
本文产自互联网工程任务组（IETF），已接受公开审查，并由互联网互联网工程指导委员会（IESG）批准出版。更多互联网标准相关信息详见RFC 7841第2章。
关于本文当前状态、勘误及反馈方式等相关信息请移步https://www.rfc-editor.org/info/rfc8999。</description>
    </item>
    
    <item>
      <title>备忘状态</title>
      <link>/RFC9000_Chinese_Translation/Foreword/status_of_this_memo/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9000_Chinese_Translation/Foreword/status_of_this_memo/</guid>
      <description>本文是互联网标准追踪文档。
本文产自互联网工程任务组（IETF），已接受公开审查，并由互联网互联网工程指导委员会（IESG）批准出版。更多互联网标准相关信息详见RFC 7841第2章。
关于本文当前状态、勘误及反馈方式等相关信息请移步https://www.rfc-editor.org/info/rfc9000。</description>
    </item>
    
    <item>
      <title>备忘状态</title>
      <link>/RFC9001_Chinese_Translation/Foreword/status_of_this_memo/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9001_Chinese_Translation/Foreword/status_of_this_memo/</guid>
      <description>本文是互联网标准追踪文档。
本文产自互联网工程任务组（IETF），已接受公开审查，并由互联网互联网工程指导委员会（IESG）批准出版。更多互联网标准相关信息详见RFC 7841第2章。
关于本文当前状态、勘误及反馈方式等相关信息请移步https://www.rfc-editor.org/info/rfc9001。</description>
    </item>
    
    <item>
      <title>备忘状态</title>
      <link>/RFC9002_Chinese_Translation/Foreword/status_of_this_memo/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9002_Chinese_Translation/Foreword/status_of_this_memo/</guid>
      <description>本文是互联网标准追踪文档。
本文产自互联网工程任务组（IETF），已接受公开审查，并由互联网互联网工程指导委员会（IESG）批准出版。更多互联网标准相关信息详见RFC 7841第2章。
关于本文当前状态、勘误及反馈方式等相关信息请移步https://www.rfc-editor.org/info/rfc9002。</description>
    </item>
    
    <item>
      <title>备忘状态</title>
      <link>/RFC9114_Chinese_Simplified/Foreword/status_of_this_memo/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9114_Chinese_Simplified/Foreword/status_of_this_memo/</guid>
      <description>本文是互联网标准追踪文档。
本文产自互联网工程任务组（IETF），已接受公开审查，并由互联网互联网工程指导委员会（IESG）批准出版。更多互联网标准相关信息详见RFC 7841第2章。
关于本文当前状态、勘误及反馈方式等相关信息请移步https://www.rfc-editor.org/info/rfc9114。</description>
    </item>
    
    <item>
      <title>备忘状态</title>
      <link>/RFC9204_Chinese_Simplified/Foreword/status_of_this_memo/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9204_Chinese_Simplified/Foreword/status_of_this_memo/</guid>
      <description>本文是互联网标准追踪文档。
本文产自互联网工程任务组（IETF），已接受公开审查，并由互联网互联网工程指导委员会（IESG）批准出版。更多互联网标准相关信息详见RFC 7841第2章。
关于本文当前状态、勘误及反馈方式等相关信息请移步https://www.rfc-editor.org/info/rfc9204。</description>
    </item>
    
    <item>
      <title>备忘状态</title>
      <link>/RFC9221_Chinese_Simplified/Foreword/status_of_this_memo/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9221_Chinese_Simplified/Foreword/status_of_this_memo/</guid>
      <description>本文是互联网标准追踪文档。
本文产自互联网工程任务组（IETF），已接受公开审查，并由互联网互联网工程指导委员会（IESG）批准出版。更多互联网标准相关信息详见RFC 7841第2章。
关于本文当前状态、勘误及反馈方式等相关信息请移步https://www.rfc-editor.org/info/rfc9221。</description>
    </item>
    
    <item>
      <title>备忘状态</title>
      <link>/RFC9250_Chinese_Simplified/Foreword/status_of_this_memo/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9250_Chinese_Simplified/Foreword/status_of_this_memo/</guid>
      <description>本文是互联网标准追踪文档。
本文产自互联网工程任务组（IETF），已接受公开审查，并由互联网互联网工程指导委员会（IESG）批准出版。更多互联网标准相关信息详见RFC 7841第2章。
关于本文当前状态、勘误及反馈方式等相关信息请移步https://www.rfc-editor.org/info/rfc9250。</description>
    </item>
    
    <item>
      <title>版权声明</title>
      <link>/RFC8999_Chinese_Translation/Foreword/copyright_notice/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC8999_Chinese_Translation/Foreword/copyright_notice/</guid>
      <description>版权所有（c）2021 IETF信托及确认为文档作者的个人。保留所有权利。
本文遵守BCP 78及在本文发布之日起生效的IETF信托涉及IETF文档的法律条文（https://trustee.ietf.org/license-info）。请仔细阅读相关条文，因为其描述了你对本文所有的权利及限制。从本文中摘录的代码组件必须包含信托法律条文第4.e章的简版BSD License文件，并且不附带任何该文件所描述的保证。</description>
    </item>
    
    <item>
      <title>版权声明</title>
      <link>/RFC9000_Chinese_Translation/Foreword/copyright_notice/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9000_Chinese_Translation/Foreword/copyright_notice/</guid>
      <description>版权所有（c）2021 IETF信托及确认为文档作者的个人。保留所有权利。
本文遵守BCP 78及在本文发布之日起生效的IETF信托涉及IETF文档的法律条文（https://trustee.ietf.org/license-info）。请仔细阅读相关条文，因为其描述了你对本文所有的权利及限制。从本文中摘录的代码组件必须包含信托法律条文第4.e章的简版BSD License文件，并且不附带任何该文件所描述的保证。</description>
    </item>
    
    <item>
      <title>版权声明</title>
      <link>/RFC9001_Chinese_Translation/Foreword/copyright_notice/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9001_Chinese_Translation/Foreword/copyright_notice/</guid>
      <description>版权所有（c）2021 IETF信托及确认为文档作者的个人。保留所有权利。
本文遵守BCP 78及在本文发布之日起生效的IETF信托涉及IETF文档的法律条文（https://trustee.ietf.org/license-info）。请仔细阅读相关条文，因为其描述了你对本文所有的权利及限制。从本文中摘录的代码组件必须包含信托法律条文第4.e章的简版BSD License文件，并且不附带任何该文件所描述的保证。</description>
    </item>
    
    <item>
      <title>版权声明</title>
      <link>/RFC9002_Chinese_Translation/Foreword/copyright_notice/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9002_Chinese_Translation/Foreword/copyright_notice/</guid>
      <description>版权所有（c）2021 IETF信托及确认为文档作者的个人。保留所有权利。
本文遵守BCP 78及在本文发布之日起生效的IETF信托涉及IETF文档的法律条文（https://trustee.ietf.org/license-info）。请仔细阅读相关条文，因为其描述了你对本文所有的权利及限制。从本文中摘录的代码组件必须包含信托法律条文第4.e章的简版BSD License文件，并且不附带任何该文件所描述的保证。</description>
    </item>
    
    <item>
      <title>版权声明</title>
      <link>/RFC9114_Chinese_Simplified/Foreword/copyright_notice/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9114_Chinese_Simplified/Foreword/copyright_notice/</guid>
      <description>版权所有（c）2022 IETF信托及确认为文档作者的个人。保留所有权利。
本文遵守BCP 78及在本文发布之日起生效的IETF信托涉及IETF文档的法律条文（https://trustee.ietf.org/license-info）。请仔细阅读相关条文，因为其描述了你对本文所有的权利及限制。从本文中摘录的代码组件必须包含信托法律条文第4.e章的简版BSD License文件，并且不附带任何该文件所描述的保证。</description>
    </item>
    
    <item>
      <title>版权声明</title>
      <link>/RFC9204_Chinese_Simplified/Foreword/copyright_notice/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9204_Chinese_Simplified/Foreword/copyright_notice/</guid>
      <description>版权所有（c）2022 IETF信托及确认为文档作者的个人。保留所有权利。
本文遵守BCP 78及在本文发布之日起生效的IETF信托涉及IETF文档的法律条文（https://trustee.ietf.org/license-info）。请仔细阅读相关条文，因为其描述了你对本文所有的权利及限制。从本文中摘录的代码组件必须包含信托法律条文第4.e章的简版BSD License文件，并且不附带任何该文件所描述的保证。</description>
    </item>
    
    <item>
      <title>版权声明</title>
      <link>/RFC9221_Chinese_Simplified/Foreword/copyright_notice/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9221_Chinese_Simplified/Foreword/copyright_notice/</guid>
      <description>版权所有（c）2022 IETF信托及确认为文档作者的个人。保留所有权利。
本文遵守BCP 78及在本文发布之日起生效的IETF信托涉及IETF文档的法律条文（https://trustee.ietf.org/license-info）。请仔细阅读相关条文，因为其描述了你对本文所有的权利及限制。从本文中摘录的代码组件必须包含信托法律条文第4.e章的简版BSD License文件，并且不附带任何该文件所描述的保证。</description>
    </item>
    
    <item>
      <title>版权声明</title>
      <link>/RFC9250_Chinese_Simplified/Foreword/copyright_notice/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9250_Chinese_Simplified/Foreword/copyright_notice/</guid>
      <description>版权所有（c）2022 IETF信托及确认为文档作者的个人。保留所有权利。
本文遵守BCP 78及在本文发布之日起生效的IETF信托涉及IETF文档的法律条文（https://trustee.ietf.org/license-info）。请仔细阅读相关条文，因为其描述了你对本文所有的权利及限制。从本文中摘录的代码组件必须包含信托法律条文第4.e章的简版BSD License文件，并且不附带任何该文件所描述的保证。</description>
    </item>
    
    <item>
      <title>1.1. 文档结构</title>
      <link>/RFC9000_Chinese_Translation/Overview/1.1_document_structure/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9000_Chinese_Translation/Overview/1.1_document_structure/</guid>
      <description>本文描述了QUIC协议的核心部分，文章组织如下：
  第1章流是QUIC支持的基本服务抽象层。
 第2章描述流相关的核心概念， 第3章提供一个流状态的参考模型， 第4章概述流量控制的过程。    连接是QUIC终端交流的上下文。
 第5章描述连接相关的核心概念， 第6章描述版本协商 第7章详细描述连接建立的过程， 第8章描述地址验证及危险的拒绝服务迁移攻击， 第9章描述终端如何将一个连接迁移到新的网络通道上， 第10章列举关闭一个已打开连接的各个方式，以及 第11章给流与连接错误处理提供指导。    数据包和帧是QUIC交流的基本单元。
 第12章描述数据包与帧相关的概念， 第13章定义数据传输、重传和确认的模型，以及 第14章描述指定携带QUIC数据包的数据报大小的规则。    最后，QUIC协议要素的编码细节描述在：
 第15章版本， 第16章整型编码， 第17章数据包头部， 第18章传输参数， 第19章帧，以及 第20章错误。    相关文档《QUIC恢复》描述QUIC的数据丢失检测及拥塞控制，《QUIC TLS》描述TLS及其他加密机制的使用。
本文定义了QUIC版本1，支持《QUIC不变量》所定义的不变量。
若引用QUIC版本1，请引用本文（你还是引用《》吧）。若引用QUIC支持的独立版本的某个子集，请引用《QUIC不变量原文》。</description>
    </item>
    
    <item>
      <title>QUIC相关翻译说明</title>
      <link>/Translation_Norms/For_RFCs/QUIC_related/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/Translation_Norms/For_RFCs/QUIC_related/</guid>
      <description>1. 帧类型翻译展示 ACK、STREAM、NEW_CONNECTION_ID等帧类型如果直接使用原文实为不妥，并不直观。然而，其又以大写形式表现，固所以需要进行特别处理。
本文决定暂时采用将其加粗展示的方式进行区分。
2. 帧字段翻译展示 如下是重置帧的定义：
RESET_STREAM Frame { Type (i) = 0x04, Stream ID (i), Application Protocol Error Code (i), Final Size (i), } 其中Type、Stream ID等均是帧字段。 用“”将字段括起来。
2. 错误类型翻译展示 形如CONNECTION_ID_LIMIT_ERROR的错误类型也比较麻烦，因其可能细碎地提前引用。因此，需要将其特别考虑。 在其正式介绍前，如果首次出现在一个大章节中，则该大写字段以括号（）附上中文翻译。同章节后续再出现则不再附上翻译。
3. 传输参数翻译展示 传输参数（transport parameters）展示方式同第2点。</description>
    </item>
    
    <item>
      <title>1.2. 术语及定义</title>
      <link>/RFC9000_Chinese_Translation/Overview/1.2_terms_and_definitions/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9000_Chinese_Translation/Overview/1.2_terms_and_definitions/</guid>
      <description>本文中的关键字“必须（MUST）”、“必须不（MUST NOT）”、“需要（REQUIRED）”、“强烈要求（SHALL）”、“强烈要求不（SHALL NOT）”、“应该（SHOULD）”、“不应该（SHOULD NOT）”、“推荐（RECOMMENDED）”、“不推荐（NOT RECOMMENDED）”、“可以（MAY）”，以及“可选（OPTIONAL）”应理解为BCP 14 《RFC2119》《RFC8174》所描述的，当且仅当它们像本段一样以斜体加粗方式出现的时候。
本文常用术语列述如下：
QUIC：本文描述的传输协议。QUIC是名称，不是首字母缩写。
终端（Endpoint）：一个能够以创建、接收及处理QUIC数据包参与QUIC连接的实体。QUIC终端有两种类型：客户端（client）及服务端（server）。
客户端：初始化QUIC连接的终端。
服务端：接收QUIC连接的终端。
QUIC数据包：QUIC的一个可以封装进UDP报文中的完整处理单元。单个UDP报文可以封装进一个或多个QUIC数据包。
ACK触发包：一个包含除确认帧（ACK）、填充帧（PADDING）及连接关闭帧（CONNECTION_CLOSE）外的帧的QUIC数据包。接收方收到这类包会发确认，详见第13.2.1章。
帧：一个结构化的协议信息单元。帧有多种类型，不同类型的帧携带不同类型的信息。帧由QUIC数据包承载。
地址：当使用不受限制，由IP版本、IP地址及UDP端口号构成的元组表示网络通道的一端。
连接ID：终端用来标识一条QUIC连接的标识符。每个终端选择一个或多个连接ID，从而在对端发送给本端的QUIC包中包含这些连接ID。该值对对端是不透明的。
流：QUIC连接上一个单向或双向的有序字节通道。一个QUIC连接可以同时承载多条流。
应用：一个使用QUIC发送及接收数据的实体。
本文使用术语“QUIC数据包”、“UDP报文”及“IP数据包”表示相应协议的传输单元。换言之，一个或多个QUIC包被封装到一个UDP报文里，最终封装到一个IP数据包中。</description>
    </item>
    
    <item>
      <title>1.3. 标准规范</title>
      <link>/RFC9000_Chinese_Translation/Overview/1.3_notational_conventions/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9000_Chinese_Translation/Overview/1.3_notational_conventions/</guid>
      <description>本文数据包及帧的图解使用一种定制格式，目的是总结而不是定义协议元素。文中定义了完整的语义及详细的结构。
复杂的字段被命名后，由紧随命名的一个以一对花括号括起来的字段列表描述，列表中的字段以逗号分隔。
单个字段包括长度信息、带正号的定值、可选值或本字段的副本。单个字段使用下述标准规范，且所有长度都以比特为单位：
x (A): 表示x是A比特长度
x (i): 表示x是一个使用第16章描述的变量长度编码的整型值
x (A..B): 表示x的长度可以是从A到B的所有值，省略A表示最小零位，并且省略B表示没有设置上限。这种格式的值总是以字符边界结束。
x (L) = C: 表示x有一个定值C，且x的长度为L，L可以用上述任何长度格式
x (L) = C..D: 表示x的值介于C到D之间，包括边界值C和D，L表示长度，同上
[x (L)]: 表示x是一个可选的值，长度为L
x (L) ...: 表示x重复0次或以上次数，且每个实例长度为L
本文使用网络字节序（也就是大端）值。字段每个字节的各个比特从高位到低位排列。
约定单个字段通过使用复合字段的名称引用复合字段。</description>
    </item>
    
    <item>
      <title>2.1. TLS概述</title>
      <link>/RFC9001_Chinese_Translation/Notational_Conventions/2.1_TLS_Overview/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9001_Chinese_Translation/Notational_Conventions/2.1_TLS_Overview/</guid>
      <description>TLS为两个终端提供一种经由不受信任的中间人（例如，互联网）建立通信的方法。TLS认证对端的身份并且为终端间交换的信息提供可信度和完整性保护。
TLS在协议内部有着不同的层，它的结构如图1所示。
 TODO：图1
  图1：TLS的层
 每条内容层消息（例如握手、警告和应用数据）都是由记录层将其作为一系列具有类型的TLS记录来传递的。每条记录受到单独的加密保护，然后经由一种可靠的传输方式（通常是TCP）被发送出去，可靠是指它提供了有序且受保证的交付。
在两个终端（客户端和服务器）间会进行TLS认证密钥的交换。交换由客户端发起，服务器则负责响应。如果密钥交换顺利完成，那么客户端和服务器将就一个秘密值达成一致。TLS既支持预共享密钥（PSK），也支持基于有限域或椭圆曲线的迪菲-赫尔曼金密钥交换（(EC)DHE）。预共享密钥是早期数据（0-RTT）的基础；后者在(EC)DHE密钥被销毁时提供前向安全（Forward Secrecy）。还可以组合使用这两种模式，以在使用PSK认证时提供前向安全。
只要完成了TLS握手，客户端就能了解到并验证服务器的身份，而服务器能够可选地去了解和验证客户端的身份。TLS支持使用X.509（详见《RFC5280》）证书来认证服务器和客户端。当使用PSK密钥交换时（在恢复过程中会用到），有关PSK的知识也能帮助验证对端的身份。
TLS密钥交换能抵御攻击者的篡改，并且由它生成的共享秘密值不受任一终端的控制。
TLS提供两种QUIC感兴趣的基本握手模式：
  完整的1-RTT握手，这种情况下客户端可以在单次数据往返后发送应用数据，而服务器可以在接收到来自客户端的首条握手消息后立即作出响应。
  0-RTT握手，这种情况下客户端使用有关服务器的已知信息来立即发送应用数据。这些应用数据可以被攻击者重放，所以0-RTT不适合用来传递被重放后可能引发意外的副作用的指令。
  图2展示的是简化后的发送0-RTT应用数据的TLS握手过程。
 TODO：图2
  图2：使用0-RTT的TLS握手
 图2省略了QUIC不会使用到的EndOfEarlyData（早期数据结束）消息；详见第8.3章。类似地，QUIC也不会使用ChangeCipherSpec（更改加密设置）消息和KeyUpdate（密钥更新）消息。在TLS 1.3中ChangeCipherSpec是冗余的；详见第8.4章。QUIC有自己的密钥更新机制；详见第6章。
多种加密级别被用于保护数据：
  初始密钥
  早期数据（0-RTT）密钥
  握手密钥
  应用数据（1-RTT）密钥
  应用数据只能出现在早期数据和应用数据这两种密级中。握手消息和警告消息可以出现在任一密级。
如果客户端和服务器之间曾进行过通信，那么可以使用0-RTT握手。进行1-RTT握手时，客户端只有在收到所有来自服务器的握手消息后才能发送受保护的应用数据。</description>
    </item>
    
    <item>
      <title>2.1. 流类型及标识符</title>
      <link>/RFC9000_Chinese_Translation/Streams/2.1_Stream_Types_and_Identifiers/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9000_Chinese_Translation/Streams/2.1_Stream_Types_and_Identifiers/</guid>
      <description>流可以是单向或双向的。单向流往一个方向传输数据：从流发起端向对端发送；双向流允许双端向对端发送数据。
在连接中，流以一个数字值标识，称为流ID。一个流ID是一个62比特的整数（0-262-1），且与同连接中其他流的流ID严格区分。流ID编码为一个可变长度整型，详见第16章。一个QUIC终端必须不能在同一个连接的不同流上重复使用同一个数值作为流ID。
流ID的最小有效位（0x01）标识流的发起者。 客户端发起的流的ID是偶数（该位被置为0），服务端发起的流的ID是奇数（该位被置为1）。
流ID的次小有效位（0x02）标识流是双向流（该位被置为0）抑或单向流（该位被置为1）。
也就是说，流ID的最小两个有效位用来标识一条流是总共四种流类型中的哪一种，总结在如下表格1中：
   位 流类型     0x00 客户端创建的双向流   0x01 服务端创建的双向流   0x02 客户端创建的单向流   0x03 服务端创建的单向流    表格1：流类型
 每种流类型的流空间从其最小值开始（依次从0x00到0x03）；每种流的每个流ID根据创建顺序依次线性递增。 如果不按顺序地使用了一个流ID，将导致相同流类型的所有具有更小的流ID的流都被开启。</description>
    </item>
    
    <item>
      <title>2.2. 数据发送与接收</title>
      <link>/RFC9000_Chinese_Translation/Streams/2.2_Sending_and_Receiving_Data/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9000_Chinese_Translation/Streams/2.2_Sending_and_Receiving_Data/</guid>
      <description>流帧（第19.8章）封装应用层发送的数据。 终端使用流帧的流ID及偏移字段整理数据。
终端必须将流数据以一个有序字节流传递给应用层。 传递一个有序字节流需要终端缓存任何接收到的乱序数据，直到到达了建议的流量控制限制的上限。
QUIC对于传递流的无序数据并没有做额外的打算。 然而，实现上 可以选择支持传递无序数据给应用层接收。
终端可以从一条流的同一个偏移位置多次接收数据。 如果数据已经被接收过了，就会直接被丢弃。 处在任何偏移位置的数据如果被重复发送，其必须不能更改。 终端可以将在流的同一偏移处收到不同数据的情况视为PROTOCOL_VIOLATION类型（违反协议）的连接错误。
流是一个抽象的有序字节流，QUIC不感知除此以外的任何结构。 流帧的边界在数据被传输、丢包后重传以及被传递给应用层接收者后，不会继续保留。
终端必须不能在对端设置的流量控制限制之外发送任何数据。流量控制详见第4章。</description>
    </item>
    
    <item>
      <title>2.3. 流优先级</title>
      <link>/RFC9000_Chinese_Translation/Streams/2.3_Stream_Prioritization/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9000_Chinese_Translation/Streams/2.3_Stream_Prioritization/</guid>
      <description>如果资源以正确的优先级分配给多条流，那么流的多路复用可以对应用性能产生显著影响。
QUIC并不支持交换优先级信息，相反，其依赖从应用层接收的优先级信息。
QUIC在实现上应该提供某种方法使得应用层能够因此确定各条流的相对优先级。 一种实现是使用应用层提供的信息决定分配多少资源来激活流。</description>
    </item>
    
    <item>
      <title>2.4. 流操作</title>
      <link>/RFC9000_Chinese_Translation/Streams/2.4._Operations_on_Streams/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9000_Chinese_Translation/Streams/2.4._Operations_on_Streams/</guid>
      <description>本文没有定义QUIC API，而是定义了一系列流操作相关的函数可以用于应用层协议的构建。 应用层协议可以假定QUIC有关实现提供了本章描述的操作对应的接口。 为一个特定应用层协议设计实现的QUIC协议可能仅仅提供该协议需要的这些操作。
在流的发送部分，应用层协议可以：
 写数据，只有当流量控制给数据写出留足空间（第4.1章）才能成功写出； 结束流（清理并关闭），发送一个设置FIN位为1的流帧（第19.8章）； 重置流（中止并关闭），当流未处在终止状态时发送一个RESET_STREAM帧（第19.4章）。  在流的接收部分，应用层协议可以：
 读数据，以及 中止读取流数据并请求关闭流，该操作可能需要发送STOP_SENDING帧（第19.5章）。  应用层协议也可以请求在流状态改变的时候收到通知信息，包括当对端开启或重置流、对端中止流数据读取、有新数据可以读取、以及数据可以写出或因流控不能写出。</description>
    </item>
    
    <item>
      <title>3.1. 流发送状态</title>
      <link>/RFC9000_Chinese_Translation/Stream_States/3.1_Sending_Stream_States/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9000_Chinese_Translation/Stream_States/3.1_Sending_Stream_States/</guid>
      <description>图2展示了通过流向对端发送发送数据的状态。
 图2：流数据发送部分状态
 终端发起的流的发送部分（客户端发起的流类型是0和2，1和3则是由服务端发起的）由应用层打开。 用于发送的流数据可能被缓存起来。
发送首个流帧（STREAM）或流阻塞帧（STREAM_DATA_BLOCKED）使流的发送部分进入“发送”状态。 QUIC实现可以选择延迟分配流ID直到其发送首个流帧并进入“发送”状态，这样可以实现更好的流优先级。
由对端发起的双向流的发送部分（服务端发起的流类型是0，客户端发起的是1）在接收部分创建时就已处于“就绪”状态，并从此状态开始。
在“发送”状态，终端通过流帧传输——必要时重传——流数据。 终端遵从其对端设置的流量控制限制，同时持续接收与处理最大流数据帧（MAX_STREAM_DATA）。 当发送过程被流的流量控制限制（第4.1章）所阻塞时，处在“发送”状态的终端会生成流阻塞帧。
在应用层表示所有应用数据及一个带FIN置位的流帧都发送完成后，流的发送部分进入“发送完成”状态。 从这个状态开始，终端只会做必要的数据重传。 在对端收到最终流下标前，都有可能收到最大流数据帧。 处于此状态的终端可以忽略任何其收到的最大流数据帧，这样是安全的。
当所有流数据都被成功确认后，发送部分进入“接收完成”状态，这是一个最终状态。
处在“就绪”、“发送”及“发送完成”状态中的任何一个状态时，应用层都可以提出取消发送流数据。 相应地，终端也可能从其对端收到一个停止发送帧（STOP_SENDING）。 不论哪种情况，终端都会发送流重置帧（RESET_STREAM），随后流进入“重置发送”状态。
终端可以发送一个流重置帧作为流的首个帧，这会导致该流的发送部分开启然后立即转到“重置发送”状态。
一旦一个包含流重置帧的数据包被确认，流的发送部分即进入“重置接收”状态，这也是一个最终状态。</description>
    </item>
    
    <item>
      <title>3.2. 接收流状态</title>
      <link>/RFC9000_Chinese_Translation/Stream_States/3.2_Receiving_Stream_States/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9000_Chinese_Translation/Stream_States/3.2_Receiving_Stream_States/</guid>
      <description>图3展示了通过流从对端接收数据的状态。 流的接收部分只会反映对端流发送部分的一些状态。 流的接收部分不能追踪发送部分那些不可见的状态，例如“就绪”状态。 相反，流的接收部分追踪向应用层传递的数据，其中一些数据对发送端不可见。
 图3：流数据接收部分状态
 由对端发起的流（客户端发起的流类型是1和3，服务端发起的是0和2）的接收部分在收到该流的第一个流帧、流阻塞帧或流重置帧时创建。 对于由对端创建的双向流，发送部分收到最大流数据帧或停止发送帧时也会创建该流的接收部分。 流的接收部分的初始状态是“接受”状态。
由本端发起的双向流（客户端发起的流类型是0，服务端发起的是1），当其发送部分进入“就绪”状态时，其接收部分进入“接收”状态。
终端在收到最大流数据帧或停止发送帧后打开一条双向流。 接收到一条未开启的流的最大流数据帧意味着对端已经开启了该流，并开始支持流量控制额度。 而接收到一条未开启流的停止发送帧意味着对端不会再从该流接收数据。 无论这两种帧的哪一种都可能先于流帧或流阻塞帧到达本端，原因是包丢失或乱序。
在一条流创建前，所有数值小于该流ID的同类型流都必须被创建。 这样能确保双端流的创建次序保持一致。
在“接收”状态，终端接收流帧和流阻塞帧。 传入数据将被缓存，并可以按照正确顺序重组以便递给应用层。 随着应用层不断消耗数据，缓冲区重新空出来，终端发送最大流数据帧告知对端可以发送更多数据。
当收到一个带FIN置位的流帧时，数据的最终大小确定下来，详见第4.5章。 流的接收部分随后转到“数据量确认”状态。 在此状态，终端不再需要发送最大流数据帧，只需要接收重传数据即可。
一旦收完了一条流的所有数据，流的接收部分转入“接收完成”状态。 这可能发生在收到导致转入“数据量确认”状态的同一个流帧后。 在所有数据都收完后，可以丢弃该流的任何流帧或流阻塞帧。
秋航注：意思是说，在收到流帧后，接收方可能转入“接收量确认”状态；紧接着，状态再次流转到“接收完成”状态。 中间这句原译为：
 在接收到导致状态转换到“接收量确认”的流帧后，可能同时导致转入“接收完成”状态。
  “接收完成”状态会一直持续直到数据全部传递到应用层。 一旦流数据传递完成，即转到“读取完成”状态，这是一个最终状态。
如果在“接收”或“数据量确认”状态收到一个流重置帧，将导致流转到“重置接收”状态。 这可能打断流数据传递到应用层。
流重置帧也有可能在所有流数据都收完后才收到（即在“接收完成”阶段）。 同样地，也可能在收完流重置帧后收到了剩下的流数据（即在“重置接收”状态）。 在QUIC的具体实现上，可以自由选择如何处理这两种情况。
发送流重置帧意味着终端不能保证流数据的传输。 然而，并没有要求在收到流重置帧后不传输流数据。 QUIC实现可以打断流数据的传输，丢弃任何没有被消耗的数据，并通知对端收到了流重置帧。 如果流数据完成了接收并被缓存起来以供应用层读取，此时收到流重置帧信号，则该信号可能被抑制或扣留。 如果流重置帧被抑制，流的接收部分仍然维持在“接收完成”状态。
一旦应用层收到流被重置的信号，流的接收部分转到“重置读取”阶段，这是一个最终状态。</description>
    </item>
    
    <item>
      <title>3.3. 许可帧</title>
      <link>/RFC9000_Chinese_Translation/Stream_States/3.3_Permitted_Frame_Types/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9000_Chinese_Translation/Stream_States/3.3_Permitted_Frame_Types/</guid>
      <description>流的发送端发送的帧只有三种能同时影响发送端和接收端状态：流帧（第19.8章）、流阻塞帧（第19.13章），以及流重置帧（第19.4章）。
发送端必须不在最终状态（“接收完成”或“重置接收”）发送任何这些帧。当流处在“重置发送”或任何最终状态时——也就是说，在发送完一个流重置帧后，发送端必须不发送流帧或流阻塞帧。接收端可以在任何状态接收这三种帧，原因在于被延迟的包可能携带这些帧。
流的接收端发送最大流数据帧（第19.19章）及停止发送帧（第19.5章）。
接收端只可以在“接收”状态发送最大流数据帧。接收端可以在任何尚未收到过流重置帧的状态——也就是除“重置接收”、“重置读取”之外的状态，发送一个停止发送帧。然而，在“接收完成”状态发送停止发送帧意义不大，因为所有流数据都已经收到了。由于可能存在数据包延迟，因此发送端可以在任何状态接收这两种帧。</description>
    </item>
    
    <item>
      <title>3.4. 双向流状态</title>
      <link>/RFC9000_Chinese_Translation/Stream_States/3.4_Bidirectional_Stream_States/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9000_Chinese_Translation/Stream_States/3.4_Bidirectional_Stream_States/</guid>
      <description>双向流同时包括接收部分和发送部分。 QUIC的实现可以将双向流的状态表示成发送及接收流状态的组合状态。 在最简单的模型里，当发送和接收部分均处在非最终状态时，表示流处于“打开”状态；当两者均处于最终状态时，表示流处于“关闭”状态。
表格2展示了一个更复杂的双向流状态映射，粗略对应HTTP/2（HTTP2）中定义的流状态。 这表明流的发送或接收部分多个状态映射到同一个组合状态。 注意这仅仅是一个可能的映射，这种映射需要数据全部被确认后才能转入“关闭”或“半关闭”状态。
   发送部分 接收部分 组合状态     无流、就绪 无流、接收① 空闲   就绪、发送、发送完成 接收、数据量确认 打开   就绪、发送、发送完成 接收完成、读取完成 半关闭（对端）   就绪、发送、发送完成 重置接收、重置读取 半关闭（对端）   接收完成 接收、数据量确认 半关闭（本端）   重置发送、重置接收 接收、数据量确认 半关闭（本端）   重置发送、重置接收 接收完成、读取完成 关闭   重置发送、重置接收 重置接收、重置读取 关闭   接收完成 接收完成、读取完成 关闭   接收完成 重置接收、重置读取 关闭    表2：流状态到HTTP/2间可能的映射方式
  注意（①）：如果一条流尚未被创建或其接收部分处于“接收”状态而尚未收到任何帧，则流处于“空闲”状态。</description>
    </item>
    
    <item>
      <title>3.5. 请求状态转换</title>
      <link>/RFC9000_Chinese_Translation/Stream_States/3.5_Solicited_State_Transitions/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9000_Chinese_Translation/Stream_States/3.5_Solicited_State_Transitions/</guid>
      <description>如果应用层不再需要流接收到的数据，应用层可以中止流的读取，并指定一个应用层错误码。
如果流处在“接收”或“数据量确认”状态，传输层应该发送一个停止发送帧通知对端及时在反方向关闭流。 这通常表明接收方应用层不再读取流接收到的数据，但这并不意味着传入的数据一定会被忽略。
在发送完停止发送帧后收到的流帧仍然会被连接及流级别的流量控制统计，即使这些帧可能在接收时即被丢弃。
停止发送帧请求接收端发送一个流重置帧。 如果流处在“就绪”或“发送”状态，收到停止发送帧的一端必须发送一个流重置帧。 如果流处在“发送完成”状态，终端可以推迟发送流重置帧直到含有未发完数据的数据包被确认或明确的被丢弃。 如果任何未发完数据得到明确被丢弃了，终端应该发送一个流重置帧而非重传数据。
终端应该从停止发送帧复制错误码到要发出的流重置帧，但是其可以使用任何应用层错误码。 发送停止发送帧的终端可以忽略任何随后被流接收到的流重置帧里的错误码。
停止发送帧应该只能在流尚未被对端重置前发送出去。 停止发送帧主要在流的“接收”或“数据量确认”状态使用。
如果包含前一个停止发送帧的数据包丢失了，终端应当发送另一个停止发送帧。 然而，一旦流收到了所有流数据或一个流重置帧——也就是说流处在“接收”或“数据量确认”之外的状态——发送停止发送帧就不再必要了。
如果双向流的一端想要将流的两个方向同时关闭，那么其可以通过发送一个流重置帧关闭一个方向，并发送一个停止发送帧促使相反方向也迅速得到关闭。</description>
    </item>
    
    <item>
      <title>4.1. 数据流量控制</title>
      <link>/RFC9000_Chinese_Translation/Flow_Control/4.1_Data_Flow_Control/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9000_Chinese_Translation/Flow_Control/4.1_Data_Flow_Control/</guid>
      <description>QUIC使用一个基于限制的流量控制模型，接收者给出其准备在给定流或整个连接上准备接收的总字节数的上限。 这使得QUIC中存在两层数据流量控制：
 流的流量控制：通过限制每条流可以发送的数据量，防止单条流耗尽一条连接的全部接收缓冲区； 连接流量控制：通过限制所有流经由流帧可以发送的数据量，防止发送方超过连接接收方的缓冲区容量。  发送方发送数据必须不能超过上述任何一个限制。
接收方在握手过程中（第7.4章）通过传输参数为所有流设置初始的流接收缓存区上限。随后，接收方发送最大流数据帧（第19.10章）或最大数据帧（第19.9章）以告知对方提高流接收缓存区上限。
接收方可以通过发送一个含相关流ID的最大流数据帧告知对方提高流接收缓存区上限。 最大流数据帧表示流的最大绝对字节偏移量。 接收方可以根据当前流消耗数据的偏移量确定后续发出的流量控制的偏移量。
接收方可以通过发送一个最大数据帧告知对方提高连接的接收缓存区上限，亦即所有流绝对字节偏移量之和的上限。 接收方维护一个在所有流上累计接收数据的总字节数，用以检查是否超过了连接或流流量控制上限。 接收方可以基于在所有流上消耗数据总字节数确定后续发出的最大数据偏移量。
接收方发布连接或流的流量控制上限若低于之前的上限，这不是错误，只是这个更低的上限不会生效而已。
如果发送方违反了推荐的连接或流的流量控制上限，接收方必须以FLOW_CONTROL_ERROR类型错误关闭连接，更多错误处理相关细节详见第11章。
发送方必须忽略任何不会提高流量控制上限的最大流数据帧或最大数据帧。
如果发送方发送数据达到了流量控制上限，其将不能再发送新数据，且应认为其被阻塞住了。 发送方应该发送一个流数据阻塞帧或数据阻塞帧来告知接收方其有数据要写出但是被流量控制所阻塞。 如果发送方被阻塞的时间超过空等超时时间（第10.1章），接收方可以关闭连接，即便发送方有可传输的数据。 为了保持连接不被关闭，在没有可引发ACK的数据包处于传输中时，被流量控制限制所阻塞的发送方应该定期发送一个流数据阻塞帧或数据阻塞帧。</description>
    </item>
    
    <item>
      <title>4.1.1. 握手完成</title>
      <link>/RFC9001_Chinese_Translation/Carrying_TLS_Messages/Interface_to_TLS/4.1.1_Handshake_Complete/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9001_Chinese_Translation/Carrying_TLS_Messages/Interface_to_TLS/4.1.1_Handshake_Complete/</guid>
      <description>在本文档中，当TLS栈报告握手已完成时，就可以认定此次TLS握手完成。这一事件会在TLS栈发送了自己的Finished（已结束）消息并且验证了对端的Finished消息时发生。验证对端的Finished消息使得终端能够确信之前的握手消息没有受到篡改。注意，两侧的终端不是同时认定握手完成的。所以，任何基于握手完成这一时机的要求，该时机都是由终端在具体问题中的角色决定的。</description>
    </item>
    
    <item>
      <title>4.1.2. 握手已确认</title>
      <link>/RFC9001_Chinese_Translation/Carrying_TLS_Messages/Interface_to_TLS/4.1.2_Handshake_Confirmed/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9001_Chinese_Translation/Carrying_TLS_Messages/Interface_to_TLS/4.1.2_Handshake_Confirmed/</guid>
      <description>在本文档中，在握手完成的同时，服务器一侧的TLS握手就可以被认定为已确认。一旦握手完成，服务器必须立即发送握手完成帧。而在客户端一侧，只有接收到握手完成帧后才能认定握手为已确认。
除此之外，客户端可以在接收到对于某个1-RTT数据包的确认时将握手认定为已确认。这可以通过记录使用1-RTT密钥发送的最小数据包号，并将它与接收到的1-RTTACK帧的最大确认数字段作比较，来实现：一旦后者大于等于前者，即可确认握手。</description>
    </item>
    
    <item>
      <title>4.1.3. 发送和接收握手消息</title>
      <link>/RFC9001_Chinese_Translation/Carrying_TLS_Messages/Interface_to_TLS/4.1.3_Sending_and_Receiving_Handshake_Messages/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9001_Chinese_Translation/Carrying_TLS_Messages/Interface_to_TLS/4.1.3_Sending_and_Receiving_Handshake_Messages/</guid>
      <description>为了进行握手，TLS需要发送和接收握手消息的能力。对于这个接口，有两个基本函数：QUIC从其中一个函数获取握手消息，向另一个函数提供组成握手消息的字节数据。
在启动握手前，QUIC向TLS提供它想传递的传输参数（详见第8.2章）。
QUIC客户端以向TLS获取握手的字节数据的方式启动TLS。客户端在发送首个数据包前获取握手的字节数据。QUIC服务器则以向TLS提供客户端的握手字节数据的方式启动TLS。
任一终端的TLS栈都始终记录着当前的发送密级和接收密级。TLS密级决定了QUIC数据包类型和用于保护数据的密钥。
每个密级都关联着各自的一份字节序列，这些字节内容会由加密帧可靠地发送给对端。当TLS提供了将要发送的握手字节时，这些字节会被追加到当前密级的握手字节内容后面。该密级决定着最终发送加密帧时所用的数据包类型；详见表1。
四个密级分别为初始数据包、0-RTT数据包、握手数据包和1-RTT数据包生成密钥。其中只有三个密级能被用来传递加密帧，不在其中的是0-RTT这个密级。这四个密级对应着三个数据包号空间：受初始密钥和握手密钥加密的数据包分别使用各自的空间；0-RTT数据包和1-RTT数据包使用应用数据数据包号空间。
QUIC使用未受保护的TLS握手记录的内容作为加密帧的内容。QUIC不使用TLS的记录保护。QUIC将加密帧组装进具有QUIC数据包保护的QUIC数据包。
QUIC加密帧仅传递TLS握手消息。TLS警告被转换为QUIC连接关闭帧的错误码；详见第4.8章。TLS应用数据和其他内容类型不能由QUIC以任何密级传递；不应该从TLS栈接收到它们，否则这是一种错误。
当终端从网络接收到了一个包含加密帧的QUIC数据包时，它应该这样处理：
  如果数据包使用了当前的TLS接收密级，那么数据会被正常地按顺序置入输入流。和流帧一样，要使用偏移值来在数据序列中找到正确的置入位置。如果完成该过程后出现了新的可用数据，那么新数据会被有序地交付给TLS。
  如果数据包来自之前使用过的密级，那么它包含的数据必须不扩展那个密级的数据流末尾。QUIC实现必须将任何违反这项要求的情况视作类型为PROTOCOL_VIOLATION（协议违反）的连接错误。
  如果数据包来自新的密级，那么它会被保存起来，用于将来给TLS处理。一旦TLS改用此密级接收数据，暂存着的数据就可以被交给TLS。当TLS为更高的密级提供密钥时，如果还有来自之前的密级但是还未被TLS处理的数据，那么必须将该情况视作类型为PROTOCOL_VIOLATION的连接错误。
  每次将新数据交给TLS时，都会向TLS获取新的握手字节。如果TLS接收到的握手消息不完整或它没有数据需要发送，那么它可能不会提供任何字节数据。
加密帧的内容可能会被TLS增量处理，或被缓存起来直到有完整的可用消息。TLS负责缓存按序到达的握手字节数据。QUIC负责缓存未按序到达或属于尚未可用的密级的握手字节。QUIC不会为加密帧提供任何流量控制的方法；详见《QUIC传输》的第7.5章。
一旦TLS握手完成，这一事件就会随着TLS要发送的最后的握手字节一起被告知给QUIC。在这个阶段，握手期间对端宣告的传输参数会被验证；详见第8.2章。
一旦握手完成，TLS就变得被动起来。TLS仍然可以从对端接收数据并作出响应，但它没有必要发送更多数据，除非被应用或QUIC专门提出要发送数据的请求。发送数据的可能原因之一是服务器可能想要向客户端新增或更新会话票据。
当握手完成后，QUIC只需要向TLS提供以加密帧的形式到达的数据。和握手期间的行为一样，处理完接收到的数据后QUIC会向TLS获取新数据。</description>
    </item>
    
    <item>
      <title>4.1.4. 改变密级</title>
      <link>/RFC9001_Chinese_Translation/Carrying_TLS_Messages/Interface_to_TLS/4.1.4_Encryption_Level_Changes/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9001_Chinese_Translation/Carrying_TLS_Messages/Interface_to_TLS/4.1.4_Encryption_Level_Changes/</guid>
      <description>当某个密级的密钥对TLS可用时，TLS会告知QUIC那个密级的读取密钥或写入密钥已经变为可用了。
新密钥变为可用这一事件一定是因向TLS提供输入而引发的。TLS只有在（被客户端）初始化后或接收到新握手数据时才会提供新密钥。
然而，TLS实现可能会异步地进行某些处理过程。尤其是，验证证书的过程可能会花不少时间。当等待TLS处理时，如果终端接收到了需要用尚未可用的密钥来处理的数据包，那么终端应该将它们缓存起来。一旦TLS提供了密钥，这些数据包就能够得到处理。终端应该继续响应此时可以处理的数据包。
在处理完输入后，TLS可能生成出握手字节、新密级的密钥或两者兼具。
当新密级可用时，TLS会向QUIC提供以下三份内容：
  一个秘密值
  一个带有关联数据的认证加密（AEAD）函数
  一个密钥衍生函数（KDF）
  这些值源自TLS协商出的那些值，以及被QUIC用于生成数据包与头部保护密钥的那些值；详见第5章和第5.4章。
如果要使用0-RTT，那么0-RTT会在客户端发送了TLS的ClientHello消息或服务器接收到这条消息后就绪。在第一次向QUIC提供握手字节后，TLS栈可能会发送有关0-RTT密钥发生变化的信号。在服务器接收到包含ClientHello消息的握手字节后，TLS服务器可以发送有关0-RTT密钥变为可用的信号。
尽管TLS在某一时刻只会使用一个密级，QUIC却可以同时使用不止一个密级。举例来说，终端在发送完Finished消息后（使用的是处于握手密级的加密帧），它可以发送流帧（使用的是1-RTT加密）。如果Finished消息在传输过程中被丢失了，那么终端会用握手密级重传丢失的消息。数据包乱序或丢包的存在意味着QUIC可能需要同时处理处于不同密级的数据包。在握手期间，这意味着有可能需要处理位于比TLS正在使用的密级更高或更低的密级的数据包。
特别是，服务器上的QUIC实现需要有能力同时读取位于握手密级和位于0-RTT密级的数据包。客户端可能使0-RTT数据与受握手密钥保护的ACK帧交错传输，而服务器得处理这些确认才能检测出丢包的握手数据包。
QUIC还需要访问对TLS实现来说并不可用的密钥。例如，客户端可能需要在准备好发送握手密级的加密帧前确认握手数据包。因此TLS可能需要在出于自己使用的目的而生成密钥前就向QUIC提供这些密钥。</description>
    </item>
    
    <item>
      <title>4.1.5. TLS接口概述</title>
      <link>/RFC9001_Chinese_Translation/Carrying_TLS_Messages/Interface_to_TLS/4.1.5_TLS_Interface_Summary/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9001_Chinese_Translation/Carrying_TLS_Messages/Interface_to_TLS/4.1.5_TLS_Interface_Summary/</guid>
      <description>图5概述了客户端和服务器上的QUIC和TLS的通信过程。实线箭头表示传递握手数据的数据包，虚线箭头表示可以发送应用数据的地方。每个箭头都具有一个标签，标示着此传输使用的密级。
 TODO：图5
  图5：QUIC和TLS间交互的概述
 从图5中可以看出，来自单次“航班”的多个数据包中的消息会被单独处理，这表示不同的传入消息触发调用了不同的行为。图中展示了多次“获取握手”的调用，它们在不同密级上获取握手消息。在处理完传入数据包后，会请求新的握手消息。
图5展示的是简单握手通信时的一种可能的结构。准确的过程会基于终端的实现架构和数据包抵达的顺序而变化。QUIC实现可以执行与图中不同的操作或不按图中的顺序执行操作。</description>
    </item>
    
    <item>
      <title>4.2. TLS版本</title>
      <link>/RFC9001_Chinese_Translation/Carrying_TLS_Messages/4.2_TLS_Version/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9001_Chinese_Translation/Carrying_TLS_Messages/4.2_TLS_Version/</guid>
      <description>本文档描述了如何与QUIC一起使用TLS 1.3（详见《TLS13》）。
在实际操作时，TLS握手会协商出一个要使用的TLS版本。在两侧终端都支持的情况下，它们最终可能协商出一个比1.3还要高的TLS版本。这是可以接受的，因为QUIC使用的TLS 1.3特性都会在更高版本中得到支持。
客户端必须不提供低于1.3的TLS版本。未恰当配置的TLS实现可能想要协商TLS 1.2或别的低版本TLS。如果协商了低于1.3的TLS版本，那么终端必须终止连接。</description>
    </item>
    
    <item>
      <title>4.2. 提高流量控制限制</title>
      <link>/RFC9000_Chinese_Translation/Flow_Control/4.2_Increasing_Flow_Control_Limits/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9000_Chinese_Translation/Flow_Control/4.2_Increasing_Flow_Control_Limits/</guid>
      <description>QUIC实现决定什么时候以什么额度通过最大流数据帧及最大数据帧提高流量控制限制，但是本章提出了一些注意事项。
为了避免阻塞发送方，接收方可以在一个往返时间（RTT）内多次发送一个最大流数据帧或最大数据帧，或者尽可能早地发送，从而为帧的丢失及随后的恢复留出时间。
控制帧也会引入连接开销。 也就是说频繁发送最大流数据帧及最大数据帧做极其微小的调整是不可取的。 另一方面，如果更新不够频繁，每次更新时就要对接收方上限做更大幅度的提升以防发送方被阻塞，使得接收方耗费需要更多资源。 因此，确定决定接收方推荐上限需要权衡资源耗费与连接开销。
接收方可以使用一个常见于TCP实现的基于往返时间及接收数据应用层消耗速率的自动调谐机制来调整推荐接收上限的频率和增量。 作为优化，终端只有在有其他帧要发送时才可以发送流量控制相关帧，以确保流量控制不会导致额外的数据包发送。
被阻塞发送方不一定发送流阻塞帧或数据阻塞帧。 因此，接收方必须不能在发送最大流数据帧及最大数据帧前等待接收流阻塞帧或数据阻塞帧，否则可能导致发送方在连接的其余部分被阻塞。 即使发送方发送了这些帧，等待它们也会导致发送方至少被阻塞一个完整的往返周期。
当终端在阻塞期间收到可发送数据额度时，它可能会回复大量数据，造成短暂的拥塞，详见《QUIC快速恢复》第7.7章有关终端如何避免这类拥塞的讨论。
秋航注：这里将credit翻译为额度、增量等，指的是最大流数据帧及最大数据帧所带来的接收方新流量控制上限相对之前的提升量，这个提升量是发送方后续可发送新数据的空间。
 </description>
    </item>
    
    <item>
      <title>4.3. ClientHello的尺寸</title>
      <link>/RFC9001_Chinese_Translation/Carrying_TLS_Messages/4.3_ClientHello_Size/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9001_Chinese_Translation/Carrying_TLS_Messages/4.3_ClientHello_Size/</guid>
      <description>来自客户端的首个初始数据包包含着客户端首个加密握手消息的所有部分或起始部分，对TLS来说这个消息就是ClientHello（客户端问候）。服务器可能需要解析完完整的ClientHello（例如，为了访问服务器名称认证（SNI）和应用层协议协商（ALPN）等扩展）后才能决定要不要接受这个新传入的QUIC连接。如果ClientHello被拆分为多个初始数据包，那么这么做的服务器就需要缓存接收到的数据分段，这会在客户端地址尚未被验证时消耗过多资源。为了避免这一情况，服务器可以使用重试特性（详见《QUIC传输》的第8.1章）以仅缓存来自具有经验证地址的客户端的ClientHello消息。
QUIC数据包和分帧过程会向ClientHello消息添加至少36字节的开销。如果客户端选择了长于零字节的源连接ID字段，那么这个开销还会增加。这个开销还不包含令牌字段和长于8字节的目标连接ID字段，当服务器发送重试数据包时会需要它们。
一个典型的TLSClientHello可以被轻松地放进1200字节的数据包中。然而，除了由QUIC引入的开销之外，还有其他因素会使得ClientHello的尺寸超过这一限制。较大的会话票据、多个或较大的密钥共享值和较长的受支持的加密方法、签名算法、版本、QUIC传输参数或其他可协商参数与扩展的列表都可能使得这条消息变大。
对服务器而言，除了连接ID和令牌外，TLS会话票据的尺寸也可能会影响客户端能否高效地进行连接。尽可能减小这些值的尺寸可以提高客户端使用它们并且仍能将整个ClientHello消息放进首个初始数据包的可能性。
TLS实现不需要确保ClientHello的尺寸足够大来满足QUIC对于传递初始数据包的数据报的要求；详见《QUIC传输》的第14.1章。QUIC实现会使用填充帧或数据包合并的方法来确保数据报足够大。</description>
    </item>
    
    <item>
      <title>4.3. 流量控制性能</title>
      <link>/RFC9000_Chinese_Translation/Flow_Control/4.3_Flow_Control_Performance/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9000_Chinese_Translation/Flow_Control/4.3_Flow_Control_Performance/</guid>
      <description>如果终端不能确保其对端始终在该连接上有大于对端带宽时延积的流量控制额度，其接收吞吐量将被流量控制限制。
包丢失会导致接收缓冲区出现空隙，从而阻碍应用层消耗数据并释放接收缓冲空间。
及时发送流量控制上限更新能提高性能。 发送只包含流量控制更新的数据包会增加网络负载，对性能产生不利影响。 将流量控制更新与其他帧一起发出，例如如ACK帧，可以降低此类更新带来的消耗。</description>
    </item>
    
    <item>
      <title>4.4. 处理流取消</title>
      <link>/RFC9000_Chinese_Translation/Flow_Control/4.4_Handling_Stream_Cancellation/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9000_Chinese_Translation/Flow_Control/4.4_Handling_Stream_Cancellation/</guid>
      <description>终端之间最终必须在每条流消耗的流量控制额度上达成一致，从而能够计算出连接级流量控制的字节数。
收到流重置帧后，终端就会关闭相应流的状态，并忽略后续从该流上收到的数据。
流重置帧会立即中止流的一个方向。 对于一条双向流，流重置帧不会影响另一个方向的数据流。 双端必须给一条流尚未关闭的方向维持流量控制状态直到该方向转入终止状态。
秋航注：“中止”与“终止”的区别在于“中止”强调突然地、异常地结束一个过程，而“终止”没有这种强调意味。可以认为，“终止”包含流程的正常结束和异常“中止”两种情况。
 </description>
    </item>
    
    <item>
      <title>4.4. 对端验证</title>
      <link>/RFC9001_Chinese_Translation/Carrying_TLS_Messages/4.4_Peer_Authentication/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9001_Chinese_Translation/Carrying_TLS_Messages/4.4_Peer_Authentication/</guid>
      <description>有关验证的要求是视正在使用的应用协议而定的。TLS提供了验证服务器的手段，并且允许服务器请求进行客户端验证。
客户端必须验证服务器的身份。这通常包含两部分验证过程，一是验证证书中包含着服务器的身份，二是验证证书是由可信任的实体签发的（有关样例详见《RFC2818》）。
 注意：当服务器提供用于验证的证书时，证书链的尺寸可能消耗大量字节。控制证书链的尺寸对于QUIC的性能是十分关键的，因为服务器在验证客户端地址前可发送的字节数不能超过接收到字节数的3倍；详见《QUIC传输》的第8.1章。证书链的尺寸是可以被控制的，为此可以限制名称或扩展的数量；使用以较短的公钥表示方法，如ECDSA，表示的密钥；或使用证书压缩（详见《COMPRESS》）。
 服务器可以在握手期间请求进行客户端验证。如果客户端在被请求验证后不能够提供证明，那么服务器可以拒绝这条连接。对于客户端验证的要求会基于应用协议和部署方法的不同而不同。
服务器必须不使用握手后客户端验证（详见《TLS13》的第4.6.2章），因为QUIC提供的多路复用机制使得客户端不能将证书请求与触发它的应用层事件关联起来（详见《HTTP2-TLS13》）。更准确地说，在握手完成后服务器必须不发送TLS的CertificateRequest（证书请求）消息，并且客户端必须将接收到这种消息的情况视作类型为PROTOCOL_VIOLATION的连接错误。</description>
    </item>
    
    <item>
      <title>4.5. 会话恢复</title>
      <link>/RFC9001_Chinese_Translation/Carrying_TLS_Messages/4.5_Session_Resumption/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9001_Chinese_Translation/Carrying_TLS_Messages/4.5_Session_Resumption/</guid>
      <description>QUIC可以使用TLS 1.3的会话恢复特性。这可以在握手完成后通过使用加密帧传递NewSessionTicket（新会话票据）消息的方式来做到。会话恢复可以被用于提供0-RTT，无论0-RTT是否被禁用。
使用会话恢复的终端可能需要在恢复会话时记录有关当前连接的一些信息。TLS会要求某些信息得到持续保留；详见《TLS13》的第4.6.1章。在恢复连接时，QUIC本身不依赖于任何被持续保留的状态，除非还使用了0-RTT；详见《QUIC传输》的第7.4.1章和第4.6.1章。应用协议可以依赖在被恢复的连接间持续保留的状态。
客户端可以将任何恢复会话所需的状态与会话票据一起存储起来。服务器可以使用会话票据来协助保存状态。
会话恢复使得服务器将原始连接上的活动与被恢复的连接关联起来，这可能涉及到客户端的隐私问题。客户端可以选择禁用恢复机制来避免建立这种关联。客户端不应该重用票据，因为这使得除服务器外的实体能够将不同连接关联起来；详见《TLS13》的附录C.4。</description>
    </item>
    
    <item>
      <title>4.5. 流的最终数据量</title>
      <link>/RFC9000_Chinese_Translation/Flow_Control/4.5_Stream_Final_Size/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9000_Chinese_Translation/Flow_Control/4.5_Stream_Final_Size/</guid>
      <description>流的最终数据量是流消耗的流量控制额度的总量。 假设流的每个连续的字节只被发送一次，那么其最终数据量就是发出的总字节数。 更一般地来说，这比流上发送的最大偏移的字节高1，若无字节发送则为0。
不管流是如何终止的，发送方始终试图将流的最终数据量可靠地发送给接收方。 最终数据量是 带有FIN置位的流帧的Offset（下标）和Length（长度）字段值的总和，注意这些字段可能是隐式的。 或者，流重置帧的Final Size字段也可以携带最终数据量值。 这保证了双端发送方在该流上消耗的流量控制额度上达成一致。
终端在流的接收部分转入“数据量确认”或“重置接收”状态（第3章）后将得知最终数据量。 接收方必须根据流的最终数据量在其连接层流量控制上统计该流发送的字节数。
终端必须不能在大于或等于最终数据量的流上发送数据。
一旦流的最终数据量得到确认，就不能再更改。 如果收到流重置帧或流帧表示要修改流的最终数据量，终端应该回复一个FINAL_SIZE_ERROR类型的错误，更多细节详见第11章有关错误处理部分。 接收方应该将收到达到或超过最终数据量数据的情况视为FINAL_SIZE_ERROR类型的错误，即使是在关闭后收到的。 并不强制要求生成这些错误，因为终端若要做到这一点往往意味着终端需要给已关闭流维持一个最终数据量状态，也就意味着需要增加一个重要的状态确认。</description>
    </item>
    
    <item>
      <title>4.6. 并发控制</title>
      <link>/RFC9000_Chinese_Translation/Flow_Control/4.6_Controlling_Concurrency/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9000_Chinese_Translation/Flow_Control/4.6_Controlling_Concurrency/</guid>
      <description>终端限制对端累计可以开启的流的数量。 只有流ID小于(max_streams * 4 + first_stream_id_of_type)的流可以被开启，详见表1。 初始限制由传输参数设置，详见第18.2章。 随后的限制由最大流帧推出，详见第19.11。 针对单向及双向流由单独的限制。
如果经由max_streams传输参数或最大流帧收到的值大于260，这将使得最大流ID不能表示为变长整数，详见第16章。 如果收到了这两者的其中一个，必须立即关闭连接： 如果这个值是通过传输参数收到的，就以TRANSPORT_PARAMETER_ERROR错误关闭连接；如果是通过帧收到的，就以FRAME_ENCODING_ERROR错误关闭连接，详见第10.2章。
终端必须不能触达对端设置的流数量限制。 终端收到一个有个触达其设置的流数量上限的流ID的帧的情况必须视为STREAM_LIMIT_ERROR类型的连接错误，更多有关错误梳理的细节详见第11章。
一旦接收方通过最大流帧推荐了一个流数量上限，再推荐一个更小的上限将不再生效。 必须忽略不会提高流数量上限的最大流帧。
正如流及连接层流量控制，本文让实现者来决定通过最大流帧发布的流数量上限的时间及数值。 QUIC实现可以选择在流关闭时提高流数量上限，从而保持对端可以使用的流的数量大体对等。
终端因对端设置的流数量上限而不能再开启新流时，应该发送一个流阻塞帧（第19.14章）。 可以认为这个信号主要用于调试。 终端必须不能在告知额外额度前等待这个信号，因为这样做的话意味着对端会被阻塞至少一个往返周期，且若对端选择不发流阻塞帧时则等待可能会是无限期的。</description>
    </item>
    
    <item>
      <title>4.6.1. 启用0-RTT</title>
      <link>/RFC9001_Chinese_Translation/Carrying_TLS_Messages/0-RTT/4.6.1_Enabling_0-RTT/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9001_Chinese_Translation/Carrying_TLS_Messages/0-RTT/4.6.1_Enabling_0-RTT/</guid>
      <description>TLS在NewSessionTicket消息中定义的early_data（早期数据）扩展是为了（在max_early_data_size（最大早期数据尺寸）参数中）传达服务器愿意接受的TLS 0-RTT的数据量。QUIC并不使用TLS的早期数据。QUIC使用0-RTT数据包来传递早期数据。于是，max_early_data_size参数被重新定义，当它的值为0xffffffff时，意味着服务器愿意接受QUIC 0-RTT数据。想要表明服务器并不接受0-RTT数据，就要从NewSessionTicket中省略early_data扩展。客户端能够在QUIC 0-RTT中发送的数据量是由服务器提供的initial_max_data（初始最大数据量）传输参数控制的。
若max_early_data_size字段的值并非0xffffffff，则服务器必须不发送early_data扩展。如果客户端收到的NewSessionTicket中包含early_data扩展但是max_early_data_size是其他值，那么客户端必须将此情况视作类型为PROTOCOL_VIOLATION的连接错误。
想要发送0-RTT数据包的客户端在后续握手的ClientHello消息中使用early_data扩展；详见《TLS13》的第4.2章。然后它就能在0-RTT数据包中发送应用数据。
如果服务器曾发送过新令牌帧，那么尝试0-RTT的客户端可能还会提供一个地址验证令牌；详见《QUIC传输》的第8.1章。</description>
    </item>
    
    <item>
      <title>4.6.2. 接受与拒绝0-RTT</title>
      <link>/RFC9001_Chinese_Translation/Carrying_TLS_Messages/0-RTT/4.6.2_Accepting_and_Rejecting_0-RTT/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9001_Chinese_Translation/Carrying_TLS_Messages/0-RTT/4.6.2_Accepting_and_Rejecting_0-RTT/</guid>
      <description>服务器通过在加密扩展（EncryptedExtensions）中发送early_data扩展的方式接受0-RTT；详见《TLS13》的第4.2.10章。随后服务器处理并确认它接收到的0-RTT数据包。
服务器通过发送不带early_data扩展的加密扩展（EncryptedExtensions）的方式拒绝0-RTT。如果服务器发送了TLS的HelloRetryRequest（问候重试请求），就意味着它拒绝了0-RTT。如果拒绝了0-RTT，那么服务器必须不处理任何0-RTT数据包，即使它有能力这么做。如果0-RTT被拒绝，那么客户端应该在有能力的情况下将收到一个对于0-RTT数据包的确认的情况视作类型为PROTOCOL_VIOLATION的连接错误。
当0-RTT被拒绝时，客户端假设的所有关于连接的特性都可能是不正确的。这包括应用协议、传输参数和任何应用配置的选择。因此客户端必须重置所有流的状态，包括与这些流相关的应用状态。
如果客户端接收到重试数据包或版本协商数据包，那么它可以再次尝试0-RTT。这些数据包并不标志着0-RTT被拒绝。</description>
    </item>
    
    <item>
      <title>4.6.3. 验证0-RTT配置</title>
      <link>/RFC9001_Chinese_Translation/Carrying_TLS_Messages/0-RTT/4.6.3_Validating_0-RTT_Configuration/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9001_Chinese_Translation/Carrying_TLS_Messages/0-RTT/4.6.3_Validating_0-RTT_Configuration/</guid>
      <description>当服务器接收到了具有early_data扩展的ClientHello，它就必须决定是要接受还是拒绝来自客户端的0-RTT数据。TLS栈会参与这个决定（例如，检查ClientHello中是否包含那组恢复出来的加密套件；详见《TLS13》的第4.2.10章）。即使TLS栈没有拒绝0-RTT数据的理由，QUIC栈或使用QUIC的应用协议也可以拒绝0-RTT数据，因为与被恢复的会话关联的传输或应用配置与服务器的当前配置可能不一致。
为了关联0-RTT会话票据，QUIC需要额外的传输状态。一种常见的实现方法是使用无状态的会话票据并将这些状态存储在会话票据中。使用QUIC的应用协议可能对于关联和存储状态有着类似的要求。被关联的状态会被用于决定是否拒绝0-RTT。举例来说，HTTP/3设置（详见《QUIC-HTTP》）会决定怎样解释来自客户端的0-RTT数据。其他使用QUIC的应用协议为了决定接受还是拒绝0-RTT数据，可能有着不同的要求。</description>
    </item>
    
    <item>
      <title>4.7. HelloRetryRequest</title>
      <link>/RFC9001_Chinese_Translation/Carrying_TLS_Messages/4.7_HelloRetryRequest/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9001_Chinese_Translation/Carrying_TLS_Messages/4.7_HelloRetryRequest/</guid>
      <description>可以使用HelloRetryRequest消息（详见《TLS13》的第4.1.4章）来请求客户端提供密钥共享值等新信息，或验证客户端的一些特征。在QUIC看来，HelloRetryRequest与其他使用初始数据包传递的加密握手消息没有差别。尽管理论上可以使用这项特性来进行地址验证，但是QUIC实现应该改用重试特性来做地址验证；详见《QUIC传输》的第8.1章。</description>
    </item>
    
    <item>
      <title>4.8. TLS错误</title>
      <link>/RFC9001_Chinese_Translation/Carrying_TLS_Messages/4.8_TLS_Errors/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9001_Chinese_Translation/Carrying_TLS_Messages/4.8_TLS_Errors/</guid>
      <description>如果TLS遇到了错误，那么它会按照《TLS13》的第6章中定义的那样创建一个合适的警告。
TLS警告会被转换为QUIC的连接错误。为了使创建出的QUIC错误码落在为CRYPTO_ERROR（加密错误）保留的范围内，警告描述的值需要与0x0100相加；详见《QUIC传输》的第20.1章。相加的结果使用QUIC的类型为0x1c的连接关闭帧来发送。
QUIC仅仅有能力传达级别为“致命”的警告。在TLS 1.3中，“警告”级别的唯一用处是发送连接关闭的信号；详见《TLS13》的第6.1章。由于QUIC提供了关闭连接的替代机制，并且TLS连接只会在遇到错误时才被关闭，QUIC终端必须将所有来自TLS的警告都视作为“致命”级别。
QUIC允许使用通用的错误码来代替专门的错误码；详见《QUIC传输》的第11章。对TLS警告来说，这就表示允许将任何警告都替换为通用的警告，比如handshake_failure（握手失败，在QUIC中的错误码为0x0128）。终端可以使用通用的错误码来避免暴露加密信息。</description>
    </item>
    
    <item>
      <title>4.9.1. 弃用初始密钥</title>
      <link>/RFC9001_Chinese_Translation/Carrying_TLS_Messages/4.9_Discarding_Unused_Keys/4.9.1_Discarding_Initial_Keys/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9001_Chinese_Translation/Carrying_TLS_Messages/4.9_Discarding_Unused_Keys/4.9.1_Discarding_Initial_Keys/</guid>
      <description>受初始秘密值（详见第5.2章）保护的数据包是不受认证的，这意味着攻击者可以伪造数据包来干扰连接。为了限制这种攻击造成的影响，初始数据包保护密钥相比其他密钥会被更激进地弃用。
开始使用握手数据包就意味着不再需要交换初始数据包，因为只有在接收到所有初始数据包中的加密帧后才能创建握手密钥。因此，客户端必须在首次发送握手数据包时弃用握手密钥，同时服务器必须在首次成功处理握手数据包时弃用初始密钥。在此之后，终端必须不发送初始数据包。
这会丢弃初始密级的丢包恢复状态并且忽略所有未得到处理的初始数据包。</description>
    </item>
    
    <item>
      <title>4.9.2. 弃用握手密钥</title>
      <link>/RFC9001_Chinese_Translation/Carrying_TLS_Messages/4.9_Discarding_Unused_Keys/4.9.2_Discarding_Handshake_Keys/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9001_Chinese_Translation/Carrying_TLS_Messages/4.9_Discarding_Unused_Keys/4.9.2_Discarding_Handshake_Keys/</guid>
      <description>当TLS的握手已确认（详见第4.1.2章）时，终端必须弃用它的握手密钥。</description>
    </item>
    
    <item>
      <title>4.9.3. 弃用0-RTT密钥</title>
      <link>/RFC9001_Chinese_Translation/Carrying_TLS_Messages/4.9_Discarding_Unused_Keys/4.9.3_Discarding_0-RTT_Keys/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9001_Chinese_Translation/Carrying_TLS_Messages/4.9_Discarding_Unused_Keys/4.9.3_Discarding_0-RTT_Keys/</guid>
      <description>0-RTT数据包和1-RTT数据包共享同一个数据包号空间，并且客户端在发送了1-RTT数据包后就不会再发送0-RTT数据包（详见第5.6章）。
因此，客户端应该在建立了1-RTT密钥后立即弃用0-RTT密钥，因为在那之后它们不再有任何用处。
除此之外，服务器应该在接收到1-RTT数据包后立即弃用0-RTT密钥。然而，由于数据包乱序的存在，0-RTT数据包可能晚于1-RTT数据包到达。服务器应该暂时保留0-RTT密钥以能够解密乱序数据包而不需要等对端用1-RTT密钥重传其中的数据。在接收到1-RTT数据包后，服务器必须在一段较短的时间内弃用0-RTT密钥；推荐的时长是探测包超时时间（PTO，详见《QUIC恢复》）的三倍大小。如果服务器判断它已经接收到了所有0-RTT数据包，那么它可以提早弃用0-RTT密钥，这可以通过追踪缺失的数据包号来做到。</description>
    </item>
    
    <item>
      <title>5.1 长包头</title>
      <link>/RFC8999_Chinese_Translation/QUIC_Packets/5.1_Long_Header/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC8999_Chinese_Translation/QUIC_Packets/5.1_Long_Header/</guid>
      <description>图2是QUIC长包头的格式。
长包头 { 包头格式 (1) = 1, 版本特定相关位 (7), 版本 (32), 目标连接ID长度 (8), 目标连接ID (0..2040), 源连接ID长度 (8), 源连接ID (0..2040), 版本特定相关数据 (..), } 图2：QUIC长包头
 QUIC长包头数据包其首字节最高比特位设置为1，其余比特位则视具体版本而定。
随后的四个字节包含一个32位版本字段，关于版本详见第5.4章。
接下来的一个字节包含紧随其后的目标连接ID字段的长度，且该长度值以字节计数，并被编码为一个8位无符号整数。目标连接ID字段紧随目标连接ID长度字段，其长度在0到255字节之间。连接ID详见第5.3章。
接下来的一个字节包含紧随其后的源连接ID字段的长度，且该长度值以字节计数，并被编码为一个8位无符号整数。源连接ID字段紧随源连接ID长度字段，其长度在0-255字节之间。
数据包接下来剩余字段包含与QUIC版本特定相关的内容。</description>
    </item>
    
    <item>
      <title>5.1. 数据包保护密钥</title>
      <link>/RFC9001_Chinese_Translation/Packet_Protection/5.1_Packet_Protection_Keys/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9001_Chinese_Translation/Packet_Protection/5.1_Packet_Protection_Keys/</guid>
      <description>QUIC衍生数据包保护密钥的方法与TLS衍生记录保护密钥的方法是一致的。
每个密级在不同发送数据的方向上分别有各自的秘密值用来保护数据包。这些秘密值是由TLS衍生的（详见《TLS13》的第7.1章），并且会被QUIC用在除了初始密级外的所有其他密级上。用于初始密级的秘密值是基于客户端的初始目标连接ID计算出来的，详见第5.2章。
用于数据包保护的密钥是通过对TLS秘密值使用TLS提供的KDF（密钥衍生函数）的方式计算出来的。对于TLS 1.3，使用的KDF是在《TLS13》的第7.1章中介绍的HKDF-Expand-Label函数，协商出的加密套件中的哈希函数也会被用到。在QUIC中所有使用HKDF-Expand-Label的地方都使用零长度的Context参数。
注意，标签（label参数）是以ASCII（详见《ASCII》）字节的形式编码的字符串，其中不包含引号或任何末尾NUL字节。
为了和QUIC一起使用，其他版本的TLS必须提供类似的函数。
为了生成AEAD密钥，KDF的输入是当前密级的秘密值和值为quic key的标签；衍生初始化向量（Initialization Vector，IV）时，使用的标签值为quic iv；详见第5.3章。头部保护密钥使用的是值为quic hp的标签；详见第5.4章。使用以上标签能够区分QUIC和TLS的密钥；详见第9.6章。
quic key和quic hp都被用来生成密钥，所以与这些标签一道交给HKDF-Expand-Label函数的Length字段的值是由AEAD或头部保护算法的密钥长度决定的。和quic iv一起使用的Length字段的值是AEAD随机数的最小长度，但不能小于8字节；详见《AEAD》。
总是使用来自TLS 1.3的HKDF-Expand-Label函数作为用于初始秘密值的KDF；详见第5.2章。</description>
    </item>
    
    <item>
      <title>5.1.1 发布连接ID</title>
      <link>/RFC9000_Chinese_Translation/Connections/Connection_IDs/5.1.1_Issuing_Connection_IDs/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9000_Chinese_Translation/Connections/Connection_IDs/5.1.1_Issuing_Connection_IDs/</guid>
      <description>当新连接ID帧或撤销连接ID帧指向同一个值时，每个连接ID都有一个相关联的序列号用于协助检测。一个终端发出的初始连接ID是通过握手阶段（第17.2章）的长包头的源连接ID字段发送的。初始连接ID的序列号是0。如果发送了传输参数preferred_address（推荐地址），发出的连接ID的序列号就是1。
额外的连接ID通过新连接ID帧（第19.5章）传输给对方。新发出的连接ID的序列号必须递增1。客户端给其发出的第一个目标连接ID字段的连接ID及重试包的连接ID不会分配序列号。
当一个终端发出一个连接ID，其必须在连接存活期间或在对端通过撤销连接ID帧（第19.16章）取消连接前接收携带该连接ID的数据包。 连接ID被发出且没有被取消，即是活跃的；任何活跃的连接ID在连接任何时间、对其任何类型的数据包都可以有效使用。这包括被服务端通过推荐地址传输参数发出的连接ID。
终端应该确保其对端有足够数量可用且未使用的连接ID。 终端使用active_connection_id_limit（活跃连接ID限制）传输参数指定它们想要维持的活跃连接ID的数目。 一个终端必须不能提供超过对端限制数目的连接ID。 如果新连接ID帧也要求终止任何多余的连接ID，终端可以通过在“撤销前”字段包含一个足够大的值来发送临时超过对端限制数量的连接ID。
终端可以根据新连接ID帧的“撤销前”字段内容添加一些活跃连接ID并终止其他连接ID。 在处理完一个新连接ID帧，添加及撤销一些活跃连接ID后，如果活跃连接ID数量仍然超过active_connection_id_limit传输参数建议的值，终端必须以CONNECTION_ID_LIMIT_ERROR（连接ID限制）错误关闭连接。
当对端撤销一个连接ID后，终端应该提供一个新的连接ID。 如果终端提供的连接ID数目小于对端active_connection_id_limit值，则其可以在收到一个包含之前撤销的连接ID的数据包时提供一个新的连接ID。 终端可以限制为每条连接发布的连接ID总数来避免连接ID耗尽的风险，见第10.3.2章。 终端也可以限制连接ID的发布以降低其维护的通道层面的状态量，例如通道验证状态，因为对端可能有多少连接ID就用多少通道与其交互。
启动连接迁移且需要非零长度连接ID的终端应该确保其连接ID池对端可得，从而使对端能在连接迁移时用新的连接ID，因为如果连接ID池耗尽，对端将无法回复。
在握手阶段选择零长度连接ID的终端不能发布新的连接ID。通过任何通道发往一个这样的终端的所有包使用零长度目标连接ID字段。</description>
    </item>
    
    <item>
      <title>5.1.2 消耗及撤销连接ID</title>
      <link>/RFC9000_Chinese_Translation/Connections/Connection_IDs/5.1.2_Consuming_and_Retiring_Connection_IDs/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9000_Chinese_Translation/Connections/Connection_IDs/5.1.2_Consuming_and_Retiring_Connection_IDs/</guid>
      <description>终端可以在连接期间任何时候将其与对端交互的连接ID更改为另一个可用的连接ID。 在对端进行迁移连接时，终端会消耗连接ID，更多详见第9.5章。
终端维护一个接收自对端的连接ID集合，其中每个ID均可用于发送数据包。当终端想要停止使用一个连接ID，其可以发送一个撤销连接ID帧给对端。 发送一个撤销连接ID帧意味着将不会再次使用该连接ID，同时请求对端通过新连接ID帧换一个新的连接ID。
如第9.5章所述，终端限制使用一个连接ID从一个单一本地地址向一个单一目标地址发送数据包。当使用连接ID的本地或目标地址不再活跃的时候，终端应该撤销这些连接ID。
在特定场合，终端可能需要停止接收先前发布的连接ID。 这种终端会通过发送带有值已增加的“撤销前”字段的新连接ID帧使对端停用这些连接ID。 终端应该继续接收先前发布的连接ID直到它们被对端撤销。如果终端不能再处理指定的连接ID，其可以关闭连接。
一旦收到一个值增加的“撤销前”字段，对端必须停止使用相关连接ID，并在添加新提供的连接ID到活跃连接ID集合之前，通过撤销连接ID帧停用这些连接ID。 这么安排使得终端能够替换全部活跃连接ID，而不会出现对端没有可用连接ID的情况，也不会使活跃连接ID数超过对端传输参数active_connection_id_limit设下的限制，详见第18.2章。 无法停止使用连接ID可能导致连接错误，因为发布端可能不能在当前连接上继续使用这些连接ID。
如果撤销连接ID帧尚未被确认，那么终端应该限制本地已撤销连接ID的数量。 终端应该允许发送中及可追踪的撤销连接ID帧数量至少是传输参数active_connection_id_limit值的两倍。 终端必须不在没有撤销一个连接ID前忘记它，尽管其可以选择将仍然使用达到该限制而需要被撤销的连接ID的情况视为一个CONNECTION_ID_LIMIT_ERROR类型的连接错误。
在收到撤销由先前的“撤销前”字段指定的全部连接ID的撤销连接ID帧前，终端不应该发布更新“撤销前”字段。</description>
    </item>
    
    <item>
      <title>5.2 短包头</title>
      <link>/RFC8999_Chinese_Translation/QUIC_Packets/5.2_Short_Header/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC8999_Chinese_Translation/QUIC_Packets/5.2_Short_Header/</guid>
      <description>图3是QUIC短包头的格式。
短包头 { 包头格式 (1) = 0, 版本特定相关位 (7), 目标连接ID (..), 版本特定相关数据 (..), } 图3：QUIC短包头
 短包头QUIC数据包的首字节的最高位设置为0。
短包头数据包紧随首字节之后是一个目标连接ID。 短包头不会包含目标连接ID长度、源连接ID长度、源连接ID或版本字段。 目标连接ID的长度不会编码在短包头数据包里，也不会受限于这个特性。
数据包接下来剩余字段有与版本特定相关的语义。</description>
    </item>
    
    <item>
      <title>5.2. 初始秘密值</title>
      <link>/RFC9001_Chinese_Translation/Packet_Protection/5.2_Initial_Secrets/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9001_Chinese_Translation/Packet_Protection/5.2_Initial_Secrets/</guid>
      <description>数据包保护的过程适用于初始数据包，但是要使用的秘密值是从客户端首个初始数据包的目标连接ID字段衍生来的。
这个秘密值是通过对值为0x38762cf7f55934b34d179ae6a4c80cadccbb7f0a的盐和值为目标连接ID的输入密钥材料（IKM）应用HKDF-Extract（详见《HKDF》的第2.2章）来决定的。这能生成一个起中间作用的伪随机密钥（PRK），它被用来衍生出两个分别用于发送和接收的秘密值。
客户端用于构造初始数据包的秘密值是通过将该PRK和值为client in的标签输入至来自TLS（详见《TLS13》）的HKDF-Expand-Label函数来生成的，这会产生一个32字节长的秘密值。服务器以同样的形式并使用值为server in的标签来构造数据包。衍生初始秘密值和密钥时，HKDF使用的哈希函数是SHA-256（详见SHA）。
该过程的伪代码如下：
initial_salt = 0x38762cf7f55934b34d179ae6a4c80cadccbb7f0a initial_secret = HKDF-Extract(initial_salt, client_dst_connection_id) client_initial_secret = HKDF-Expand-Label(initial_secret, &amp;quot;client in&amp;quot;, &amp;quot;&amp;quot;, Hash.length) server_initial_secret = HKDF-Expand-Label(initial_secret, &amp;quot;server in&amp;quot;, &amp;quot;&amp;quot;, Hash.length) 
 HKDF-Expand-Label使用的连接ID是客户端发送的初始数据包里的目标连接ID。它会是一个随机选择的值，除非客户端是在收到重试数据包后才创建的初始数据包，那么这时的目标连接ID是由服务器选择的。
将来版本的QUIC应该使用一个新的盐值，从而确保每个QUIC版本的密钥互不相同。这会使得仅能识别一种QUIC版本的中间设备无法读取或修改将来版本的数据包的内容。
对于初始数据包，必须使用在TLS 1.3中定义的HKDF-Expand-Label函数，即便可使用的TLS版本中并不包含TLS 1.3。
当服务器发送重试数据包以使用由服务器选择的连接ID时，用于构建后续初始数据包的秘密值会发生变化。在客户端为了响应来自服务器的初始数据包而更改目标连接ID时，这些秘密值不会发生变化。
 注意：目标连接ID字段的长度可以是不超过20字节的任意值，包括零长度，零长度的情况会在服务器发送具有零长度的源连接ID字段的重试数据包时出现。在启动重试流程后，初始密钥就不能使得客户端确信服务器接收到了它的数据包，所以客户端必须依靠包含重试数据包的通信才能验证服务器地址；详见《QUIC传输》的第8.1章。
 附录A中展示了作为样例的初始数据包。</description>
    </item>
    
    <item>
      <title>5.2.1 客户端数据包处理</title>
      <link>/RFC9000_Chinese_Translation/Connections/Matching_Packets_to_Connections/5.2.1_Client_Packet_Handling/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9000_Chinese_Translation/Connections/Matching_Packets_to_Connections/5.2.1_Client_Packet_Handling/</guid>
      <description>发往客户端的有效数据包往往包含一个与客户端选择的值匹配的目标连接ID。 选择接收零长度连接ID的客户端可以使用本地地址和端口识别一个连接。 不能与已存在连接匹配的数据包——基于目标连接ID或目标连接ID为零长度时基于本地IP地址和端口——将被丢弃。
由于数据包乱序或丢失，客户端可能收到使用尚未算出的密钥加密的数据包。客户端可以丢弃这些包，也可以缓存起来以备后续数据包使其可以计算出密钥。
如果客户端收到一个包使用了与初始化阶段选择不同的QUIC版本，其必须丢弃该包。</description>
    </item>
    
    <item>
      <title>5.2.2 服务端数据包处理</title>
      <link>/RFC9000_Chinese_Translation/Connections/Matching_Packets_to_Connections/5.2.2_Server_Packet_Handling/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9000_Chinese_Translation/Connections/Matching_Packets_to_Connections/5.2.2_Server_Packet_Handling/</guid>
      <description>如果服务端收到一个来自不支持版本的数据包而其又足够初始化某个支持版本的新连接，服务端应该发送一个版本协商包，详见第6.1章。 服务端可以限制其回复的版本协商包的数量。 服务端必须丢弃属于不支持版本的小包。
一个不支持版本的第一个包可以对任何与具体版本有关的字段使用不同语义和编码。 尤其是不同的版本可能使用不同的数据包保护密钥。 不支持一个特定版本的服务端不太可能解密数据包的有效负载或正确解释其内容。 当数据报文足够长时，服务端应该回复一个版本协商包。
有一个支持版本或没有版本字段的数据包通过连接ID或——对于零长度连接ID的数据包——本地地址和端口与一个连接匹配，这些包在该连接上处理；否则，服务端继续做如下处理。
如果数据包是完全符合规范的初始化包，则服务端继续进行握手（第7章）。 服务端会指派为客户端选择的版本。
如果服务端拒绝接收一个新连接，它应该发送一个带连接关闭帧的初始化包给客户端，其中连接关闭帧的错误码设置为CONNECTION_REFUSED（连接拒绝）。
如果数据包是一个0-RTT包，服务端可以进行有限数量的缓存，因为后续预期会收到初始化包。 由于客户端不可能先于收到服务端回复发送握手包，所以服务端应该忽略任何这样的包。
服务端必须丢弃任何其他场合收到的数据包。</description>
    </item>
    
    <item>
      <title>5.2.3 关于简单负载均衡</title>
      <link>/RFC9000_Chinese_Translation/Connections/Matching_Packets_to_Connections/5.2.3_Considerations_for_Simple_Load_Balancers/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9000_Chinese_Translation/Connections/Matching_Packets_to_Connections/5.2.3_Considerations_for_Simple_Load_Balancers/</guid>
      <description>服务端部署可以仅仅使用源与目的IP地址和端口在服务器之间进行负载均衡。 改变客户端IP地址或端口可能导致数据包被转发到错误的服务器上。 这种服务端部署可以从如下方法中选择一个用于在客户端地址变换时维持连接。
 服务端可以使用带外机制，根据连接ID将数据包转发到正确的服务器； 如果服务器可以使用固定的IP地址或端口，且不同于客户端初始建联时访问的那个，它们可以使用传输参数preferred_address（推荐地址）请求客户端迁移到那个固定的地址上。 注意客户端可以选择不使用推荐地址。  服务端的一台服务器如果不支持在客户端改变地址时维持连接，其应该通过传输参数disable_active_migration（关闭活动迁移）告知对端当前不支持连接迁移。 在客户端预先拿到preferred_address参数后，传输参数disable_active_migration将不能阻止客户端进行连接迁移。
应用本简单形式负载均衡进行部署后，服务端必须避免创建无状态重置指示，详见第21.11章。</description>
    </item>
    
    <item>
      <title>5.3 连接ID</title>
      <link>/RFC8999_Chinese_Translation/QUIC_Packets/5.3_Connection_ID/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC8999_Chinese_Translation/QUIC_Packets/5.3_Connection_ID/</guid>
      <description>连接ID是一个任意长度的不透明字段。
连接ID的主要功能是确保底层协议（UDP、IP及更底层的协议栈）发生地址变更时不会导致一个QUIC连接的数据包被传输到错误的QUIC终端上。 连接ID由终端及支持的中间设备用以确保每个数据包能够被调度到相应终端的正确实体上。 对于终端而言，连接ID用于标识数据包对应的QUIC连接。
连接ID由每个终端根据版本特定的方式选择，而同一个QUIC连接的数据包可能使用不同的连接ID。</description>
    </item>
    
    <item>
      <title>5.3 连接操作</title>
      <link>/RFC9000_Chinese_Translation/Connections/5.3_Operations_on_Connections/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9000_Chinese_Translation/Connections/5.3_Operations_on_Connections/</guid>
      <description>本文没有定义QUIC的API，而是定义了一系列有关QUIC连接的函数，用于应用层协议进行依赖。 应用层协议可以假设一个QUIC的实现提供了一个包括本章所述操作的接口。 针对一个特定应用层协议而设计的实现可能只提供该协议用到的那些操作。
当实现用户端时，应用层协议可以：
 创建一个连接，开始进行第7章描述的交互过程； 如果支持，启用早期数据功能； 当早期数据被服务端接受或拒绝时，收到通知。  当实现服务端时，应用层协议可以：
 监听传入的连接，准备进行第7章描述的交互过程； 如果支持早期数据，在发送给客户端的TLS恢复ticket中嵌入应用层控制数据； 如果支持早期数据，从接收自客户端的恢复ticket中恢复应用层控制数据，并根据该信息接受或拒绝早期数据。  当同时实现客户端及服务端时，应用层协议可以：
 如传输参数（第7.4章）所述，为每种类型允许的流的配置最小的初始数量； 通过设置流级别及连接级别的流量控制限制，限制接收缓存区资源分配； 识别握手已经成功结束抑或仍在进行中； 保持连接不被默认关闭，即通过PING帧（第19.2章）或其他请求使得传输层在空闲超时（第10.1章）前发送额外的帧；以及 立即关闭连接（第10.2章）。  </description>
    </item>
    
    <item>
      <title>5.3. AEAD的使用</title>
      <link>/RFC9001_Chinese_Translation/Packet_Protection/5.3_AEAD_Usage/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9001_Chinese_Translation/Packet_Protection/5.3_AEAD_Usage/</guid>
      <description>QUIC数据包保护所用的带有关联数据的认证加密（AEAD）函数（详见《AEAD》）是在对TLS连接进行协商时产生的。例如，如果TLS要使用TLS_AES_128_GCM_SHA256这一组加密套件，那么就要使用AEAD_AES_128_GCM函数。
QUIC可以使用在《TLS13》中定义的任意一组加密套件，但是TLS_AES_128_CCM_8_SHA256除外。除非QUIC为某组加密套件定义了头部保护方案，否则必须不对此套件进行协商。本文档为《TLS13》中定义的除TLS_AES_128_CCM_8_SHA256外的所有加密套件都定义了头部保护方案。这些加密套件都具有16字节的认证标签并且会生成比输入要长16字节的输出。
对于一个提供了不受终端支持的加密套件的ClientHello（客户端问候），终端必须不拒绝它，否则将来的QUIC版本将无法部署新加密套件。此要求同样适用于TLS_AES_128_CCM_8_SHA256。
当构建数据包时，AEAD函数会在进行头部保护前被应用；详见第5.4章。未经保护的数据包头部是关联数据（A）的一部分。在处理数据包时，终端首先移除头部保护。
数据包的密钥和IV的计算方法如第5.1章所述。随机数，N，是通过组合数据包保护的IV和数据包号的方式来构造的。以网络字节序重建的62位QUIC数据包号会以在左侧补零的方式被扩充至IV的长度。扩充后的数据包号与IV的按位异或结果就是AEAD的随机数。
AEAD的关联数据，A，就是QUIC头部的内容，无论短包头还是长包头都是从首个字节开始，结束于且包含未受保护的数据包号。
AEAD的输入明文，P，就是QUIC数据包的载荷，如《QUIC传输》中所述。
AEAD的输出密文，C，会代替P被传输至对端。
一些AEAD函数对于在相同密钥和IV下能够加密的数据包数量有限制；详见第6.6章。这个限制值可能会低于数据包号的数量限制。在超出当前使用的AEAD所设的任何限制前，终端必须发起密钥更新（详见第6章）。</description>
    </item>
    
    <item>
      <title>5.4 版本</title>
      <link>/RFC8999_Chinese_Translation/QUIC_Packets/5.4_Version/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC8999_Chinese_Translation/QUIC_Packets/5.4_Version/</guid>
      <description>版本字段包含一个4字节标识符。该值可供终端用以标识一个QUIC版本。值为0x00000000的版本字段保留给版本协商使用，详见第6章，而任何其余值均可能有效。
本文描述的属性适用于所有版本的QUIC。不符合本文所述属性的协议不是QUIC协议。后续文档可以给某个特定QUIC版本或一系列QUIC版本增加其他的属性。</description>
    </item>
    
    <item>
      <title>5.4.1. 应用头部保护的过程</title>
      <link>/RFC9001_Chinese_Translation/Packet_Protection/5.4_Header_Protection/5.4.1_Header_Protection_Application/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9001_Chinese_Translation/Packet_Protection/5.4_Header_Protection/5.4.1_Header_Protection_Application/</guid>
      <description>头部保护会在数据包保护之后被应用（详见第5.3章）。数据包的密文会被采样并被用作某个加密算法的输入。使用的算法取决于协商出的AEAD。
该算法的输出是一个5字节的掩码，这个掩码会以按位异或的方式被应用到受保护的头部字段。数据包首个字节的几个最低有效位会被掩码首个字节的对应最低有效位掩饰起来，同时数据包号会被剩余字节掩饰起来。掩码中未使用的字节不会被使用，这种情况可能在遇到较短的数据包号编码结果时发生。
图6展示了应用头部保护的样例算法。移除头部保护的过程只在决定数据包号长度（pn_length）这一步的顺序上与此有所不同（这里使用^来表示按位异或运算）。
mask = header_protection(hp_key, sample) pn_length = (packet[0] &amp;amp; 0x03) + 1 if (packet[0] &amp;amp; 0x80) == 0x80: # 长包头: 掩饰4个比特位 packet[0] ^= mask[0] &amp;amp; 0x0f else: # 短包头: 掩饰5个比特位 packet[0] ^= mask[0] &amp;amp; 0x1f # pn_offset 是数据包号字段的起始位置 packet[pn_offset:pn_offset+pn_length] ^= mask[1:1+pn_length] 图6：头部保护的伪代码
 每一组加密套件都有专门的头部保护函数的定义；详见第5.4.3章和第5.4.4章。
图7展示了一个长包头数据包（初始数据包）和一个短包头数据包（1-RTT数据包）的样例。从图7中可以看出每种头部中被头部保护覆盖到的字段和受保护的数据包载荷中被采样的部分。
初始数据包 { 包头形式 (1) = 1, 固定比特位 (1) = 1, 长数据包类型 (2) = 0, 保留比特位 (2), # 受保护 数据包号长度 (2), # 受保护 版本 (32), 目标连接ID长度 (8), 目标连接ID (0.</description>
    </item>
    
    <item>
      <title>5.4.2. 头部保护的采样</title>
      <link>/RFC9001_Chinese_Translation/Packet_Protection/5.4_Header_Protection/5.4.2_Header_Protection_Sample/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9001_Chinese_Translation/Packet_Protection/5.4_Header_Protection/5.4.2_Header_Protection_Sample/</guid>
      <description>头部保护算法会用到头部保护密钥和来自数据包载荷字段的密文样本。
采样的字节数总是相同的，但是需要存在一种使得不知道数据包号字段的长度的接收方也有能力移除保护的方法。密文的样本采取自数据包号字段的起始位置向后偏移4个字节的位置。也就是说，在为头部保护采样数据包密文时，数据包号字段被假设为具有4个字节的长度（数据包号经编码后其长度的最大的可能值）。
终端必须丢弃过短以至于无法提供完整样本的数据包。
为了确保存在足够数据用于采样，数据包会被扩充从而使得经编码的数据包号与受保护载荷的长度之和至少要比头部保护所需样本的长度要大4个字节。《TLS13》中定义的加密套件——除TLS_AES_128_CCM_8_SHA256外，因为本文档没有为它定义头部保护方案——都具有16字节的扩充量和16字节的头部保护样本长度要求。这意味着如果数据包号被编码至单个字节中，那么在未经保护的载荷中需要有至少3个字节长的帧，或者在被编码至双字节中时需要有至少2个字节的帧。
可以使用以下伪代码来决定采样的密文：
# pn_offset 是数据包号字段的起始位置 sample_offset = pn_offset + 4 sample = packet[sample_offset..sample_offset+sample_length] 
 可以这样计算短包头数据包的数据包号偏移：
pn_offset = 1 + len(connection_id) 
 而长包头数据包的数据包号偏移可以这样计算：
pn_offset = 7 + len(destination_connection_id) + len(source_connection_id) + len(payload_length) if packet_type == Initial: pn_offset += len(token_length) + len(token) 
 举个例子，如果某个短包头数据包具有8字节的连接ID并且受到AEAD_AES_128_GCM的保护，那么样本就是从字节13至字节28（包含两端，且索引的起始值为0）。
单个UDP数据报中可以包含数个QUIC数据包。每个数据包都会被单独处理。</description>
    </item>
    
    <item>
      <title>5.4.3. 基于AES的头部保护</title>
      <link>/RFC9001_Chinese_Translation/Packet_Protection/5.4_Header_Protection/5.4.3_AES-Based_Header_Protection/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9001_Chinese_Translation/Packet_Protection/5.4_Header_Protection/5.4.3_AES-Based_Header_Protection/</guid>
      <description>本节为AEAD_AES_128_GCM、AEAD_AES_128_CCM和AEAD_AES_256_GCM定义了数据包保护算法。AEAD_AES_128_GCM和AEAD_AES_128_CCM使用的是电子密码本（ECB）模式，128位的AES。AEAD_AES_256_GCM使用的是ECB模式，256位的AES。AES的定义详见《AES》。
该算法从数据包中采样16字节长的密文。这份样本会被用作AES-ECB的输入。用伪代码的方式将头部保护函数定义为：
header_protection(hp_key, sample): mask = AES-ECB(hp_key, sample) 
 </description>
    </item>
    
    <item>
      <title>5.4.4. 基于ChaCha20的头部保护</title>
      <link>/RFC9001_Chinese_Translation/Packet_Protection/5.4_Header_Protection/5.4.4_ChaCha20-Based_Header_Protection/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9001_Chinese_Translation/Packet_Protection/5.4_Header_Protection/5.4.4_ChaCha20-Based_Header_Protection/</guid>
      <description>若要使用AEAD_CHACHA20_POLY1305，进行头部保护时就要使用原始的ChaCha20函数，它被定义于《CHACHA》的第2.4章。它会使用一个256位的密钥和采样自数据包保护的输出的16个字节样本。
密文样本的前4个字节被用作块计数器。如果ChaCha20的实现要求计数器的输入是一个32位的整数而不是字节序列，那么这时就要将字节序列解释为一个小端编码的值。
剩余的12个字节被用作随机数。如果ChaCha20的实现要求随机数的输入是三个32位整数组成的数组而不是字节序列，那么这时就要将随机数的字节解释为一串小端编码的32位整数。
通过使用ChaCha20来保护5个值为0的字节，可以得到加密掩码。用伪代码的方式将头部保护函数定义为：
header_protection(hp_key, sample): counter = sample[0..3] nonce = sample[4..15] mask = ChaCha20(hp_key, counter, nonce, {0,0,0,0,0}) 
 </description>
    </item>
    
    <item>
      <title>5.5. 接收受保护的数据包</title>
      <link>/RFC9001_Chinese_Translation/Packet_Protection/5.5_Receiving_Protected_Packets/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9001_Chinese_Translation/Packet_Protection/5.5_Receiving_Protected_Packets/</guid>
      <description>一旦终端成功地接收到了具有某个数据包号的数据包，那么对于相同数据包号空间中具有更高数据包号的所有数据包，如果终端无法使用相同的密钥或，如果存在密钥更新，后续的数据包保护密钥来移除它们的保护，那么它必须丢弃这些具有更高数据包号的数据包；详见第6章。类似地，看上去应该触发密钥更新却无法被成功地移除保护的数据包必须被丢弃。
无法移除数据包保护并不意味着受到了攻击或对端处出现了违背协议的错误。因为在数据包被严重延误时，QUIC使用的截断数据包号的编码方式有可能造成数据包号被错误地解码。</description>
    </item>
    
    <item>
      <title>5.6. 0-RTT密钥的使用</title>
      <link>/RFC9001_Chinese_Translation/Packet_Protection/5.6_Use_of_0-RTT_Keys/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9001_Chinese_Translation/Packet_Protection/5.6_Use_of_0-RTT_Keys/</guid>
      <description>如果可以使用0-RTT密钥（详见第4.6.1章），那么在缺乏针对重放攻击的保护措施的情况下就必须限制它们的使用以避免针对QUIC协议的重放攻击。
在《QUIC传输》定义的各种帧中，流帧、重置流帧、停止发送帧和连接关闭帧在与0-RTT一起使用时可能是不安全的，因为它们携带着应用数据。在0-RTT中接收到的应用数据会使得客户端处的应用重复处理相同数据，而不是只处理一次。客户端如果重复处理了经重放的应用数据，那么有可能产生意外的副作用。因此客户端必须不将0-RTT用于应用数据，除非正在运行的应用有意要求这么做。
使用QUIC的应用协议必须提供一份文件并在其中定义允许使用0-RTT的范围；否则，0-RTT只能被用于传递没有携带应用数据的QUIC帧。例如，HTTP对应的这份内容被描述于《HTTP-REPLAY》中，并且被使用在HTTP/3里；详见《QUIC-HTTP》的第10.9章。
尽管重放数据包可能会引发额外的连接尝试，但是处理经重放的却未携带应用数据的帧的影响仅限于改变相关连接的状态。使用经重放的数据包无法使得TLS握手成功完成。
在TLS握手完成前，客户端可以对它发送的数据施加额外的限制。
否则，客户端将0-RTT密钥与1-RTT密钥等同对待，只不过它不能用0-RTT密钥发送特定类型的帧；详见《QUIC传输》的第12.5章。
如果客户端接收到了能够表明服务器已经接受0-RTT数据的信号，那么它可以继续发送0-RTT数据，直到它接收到了服务器的所有握手消息。如果客户端接收到了能够表明0-RTT数据被拒绝的信号，那么它应该停止发送0-RTT数据。
服务器必须不使用0-RTT密钥来保护数据包；它使用1-RTT密钥来保护对于0-RTT数据包的确认。客户端必须不尝试解密它接收到的0-RTT数据包，而是必须丢弃它们。
一旦客户端已经建立了1-RTT密钥，那么它必须不再发送0-RTT数据包。
 注意： 0-RTT数据可能在被服务器接收到时就得到确认，但是包含对于0-RTT数据的确认的数据包可能无法被客户端移除数据包保护，直到TLS握手完成。移除数据包保护所必需的1-RTT密钥只有在客户端接收到服务器所有的握手消息后才能被衍生出来。
 </description>
    </item>
    
    <item>
      <title>5.7. 接收乱序的受保护数据包</title>
      <link>/RFC9001_Chinese_Translation/Packet_Protection/5.7_Receiving_Out-of-Order_Protected_Packets/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9001_Chinese_Translation/Packet_Protection/5.7_Receiving_Out-of-Order_Protected_Packets/</guid>
      <description>因为有乱序和丢包的情况存在，受保护的数据包可能在终端接收到最后的TLS握手消息前就被接收到了。这时客户端还无法解密来自服务器的1-RTT数据包，或服务器还无法解密来自客户端的1-RTT数据包。任一终端必须不在握手完成前解密来自对端的1-RTT数据包。
即使服务器在接收到来自客户端的首条握手消息后就能建立1-RTT密钥，但它还不能确信此时客户端的状态：
  客户端还未经验证，除非服务器愿意接受预共享密钥并且已经验证过了客户端的预共享密钥绑定；详见《TLS13》的第4.2.11章。
  客户端还未表现出活动的迹象，除非服务器已经用重试数据包或其他手段验证了客户端的地址；详见《QUIC传输》的第8.1章。
  服务器准备对之响应的任何0-RTT数据都有可能是由重放攻击制造的。
  因此，服务器在握手完成前对1-RTT密钥的使用目的受限为数据的发送。服务器在TLS握手完成前必须不处理传入的受1-RTT密钥保护的数据包。因为发送确认就表明数据包中的所有帧都已经被处理了，所以服务器在TLS握手完成前不能发送对1-RTT数据包的确认。已接收到的受1-RTT密钥保护的数据包可以被存储起来，在将来握手完成时再解密和使用它们。
 注意：TLS的实现可能会在握手完成前就提供所有1-RTT秘密值。在握手完成前，QUIC的实现即使获得了1-RTT读取密钥，也不能使用这些密钥。
 服务器必须等待客户端的Finished（已结束）消息的这项要求意味着服务器依赖于那条消息被成功交付到服务器。客户端可以避免这种依赖暗含的队头阻塞问题，方法是将它的1-RTT数据包和一个包含着携带Finished消息的加密帧的握手数据包合并，直到其中一个握手数据包被确认。这使得服务器可以立即处理那些数据包。
服务器可能在接收到TLS的ClientHello前就接收到受0-RTT密钥保护的数据包。服务器可以保留这些数据包，并期待能接收到ClientHello以将它们解密。
客户端通常会在握手完成的同时得到1-RTT密钥。即使它拥有1-RTT的秘密值，客户端也必须不在TLS握手完成前处理传入的受1-RTT密钥保护的数据包。</description>
    </item>
    
    <item>
      <title>5.8. 重试数据包的完整性</title>
      <link>/RFC9001_Chinese_Translation/Packet_Protection/5.8_Retry_Packet_Integrity/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9001_Chinese_Translation/Packet_Protection/5.8_Retry_Packet_Integrity/</guid>
      <description>重试数据包（详见《QUIC传输》的第17.2.5章）携带着重试完整性标签，该标签具有两项属性：它使得被网络意外破坏的数据包可以被丢弃，同时只有观测到初始数据包的实体才能发送合法的重试数据包。
重试完整性标签是一个长度为128位的字段，它是将以下参数作为AEAD_AES_128_GCM（详见《AEAD》）的输入而计算出的结果。
  密钥，K，是一个长度为128位的固定值0xbe0c690b9f66575a1d766b54e368c84e。
  随机数，N，是一个长度为96位的固定值0x461599d35d632bf2239825bb。
  明文，P，为空。
  关联数据，A，是重试伪数据包的内容，如图8所示。
  密钥和随机数的值是通过对值为0xd9c9943e6101fd200021506bcc02814c73030f25c79d71ce876eca876e6fca8e的秘密值和值分别为quic key与quic iv的标签调用HKDF-Expand-Label而衍生出来的（详见第5.1章）。
重试伪数据包 { 原始目标连接ID长度 (8), 原始目标连接ID (0..160), 包头形式 (1) = 1, 固定比特位 (1) = 1, 长数据包类型 (2) = 3, 未使用 (4), 版本 (32), 目标连接ID长度 (8), 目标连接ID (0..160), 源连接ID长度 (8), 源连接ID (0..160), 重试令牌 (..), } 图8：重试伪数据包
 重试伪数据包不会被实际发送。它是通过对被实际发送的重试数据包移除重试完整性标签，再追加以下两个字段的方式来构建出来的：
 原始目标连接ID长度（ODCID Length）：  原始目标连接ID长度字段中包含了跟在它后方的原始目标连接ID字段以字节为单位的长度，它被编码为一个8位无符号整型值。
 原始目标连接ID（Original Destination Connection ID）：  原始目标连接ID包含了这个重试数据包正在响应的初始数据包中目标连接ID字段的值。这个字段的长度在原始目标连接ID长度字段中给出。这个字段的存在确保了合法的重试数据包只能由观测到初始数据包的实体构造出来。
  </description>
    </item>
    
    <item>
      <title>6.1 发送版本协商包</title>
      <link>/RFC9000_Chinese_Translation/Version_Negotiation/6.1_Sending_Version_Negotiation-Packets/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9000_Chinese_Translation/Version_Negotiation/6.1_Sending_Version_Negotiation-Packets/</guid>
      <description>如果客户端选择的版本服务端不接受，服务端会响应一个版本协商包，详见第17.2.1章。 版本协商包包含一个服务端支持的版本的列表。 终端必须不能给一个版本协商包回应一个版本协商包。
这个系统允许服务端处理不支持的数据包而不保持状态。 即使作为响应发出的初始包或版本协商包都可能丢失，客户端也会发新的包直到收到回复或放弃建连尝试。
服务端可以限制其发送版本协商包的数量。 例如，能识别0-RTT包的服务端可能会选择不发送版本协商包来响应0-RTT包，而是期望最终能收到初始包。</description>
    </item>
    
    <item>
      <title>6.1. 发起密钥更新</title>
      <link>/RFC9001_Chinese_Translation/Key_Update/6.1_Initiating_a_Key_Update/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9001_Chinese_Translation/Key_Update/6.1_Initiating_a_Key_Update/</guid>
      <description>终端为数据包保护维护着相互独立的读取秘密值和写入秘密值。终端通过更新数据包的写入秘密值并用它去保护新数据包的方式来发起密钥更新。终端如《TLS13》的第7.2章中所展示的那样，从已有的写入秘密值创建新的写入秘密值。这会用到由TLS提供的KDF函数和值为quic ku的标签。该秘密值会如第5.1章中所述的那样，创建出相应的密钥和IV。而头部保护密钥不会被更新。
举个例子，在使用TLS 1.3时，为了更新写入密钥，要这样使用HKDF-Expand-Label：
secret_&amp;lt;n+1&amp;gt; = HKDF-Expand-Label(secret_&amp;lt;n&amp;gt;, &amp;quot;quic ku&amp;quot;, &amp;quot;&amp;quot;, Hash.length) 
 终端会切换密钥阶段比特位的状态，并将更新后的密钥和IV用于保护后续数据包。
在握手已确认（详见第4.1.2章）前，终端必须不发起密钥更新。在终端接收到对于受当前密钥阶段的密钥保护的数据包的确认前，它必须不发起后续的密钥更新。这确保了再一次发起密钥更新前，当前密钥在两侧终端处均为可用状态。要做到这一点，可以追踪用各个密钥阶段的密钥发送的最小数据包号，以及在1-RTT空间中的最大已确认数据包号：一旦后者大于等于前者，就可以再发起一次密钥更新。
 注意：非1-RTT数据包的密钥从不会被更新；它们的密钥一定是从TLS握手状态中衍生出来的。
 发起密钥更新的终端还会更新用于接收数据包的密钥。这些密钥会在更新后被用于处理对端发送的数据包。
在成功移除了使用新密钥发送的数据包的保护前，终端必须保留旧密钥。在成功移除了使用新密钥发送的数据包的保护后，终端应该将旧密钥保留一段时间。过早地弃用旧密钥会导致延误的数据包被丢弃。丢弃数据包的行为会被对端当作数据包遭遇了丢包，反而会影响性能。</description>
    </item>
    
    <item>
      <title>6.2 处理版本协商包</title>
      <link>/RFC9000_Chinese_Translation/Version_Negotiation/6.2_Handling_Version_Negotiation_Packets/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9000_Chinese_Translation/Version_Negotiation/6.2_Handling_Version_Negotiation_Packets/</guid>
      <description>设计版本协商包的目的是为了让QUIC能够给未来定义的功能协商QUIC版本用于连接。 未来标准追踪规范可能改变支持多版本QUIC对于收到的用于回复给试图使用这个版本建立连接的版本协商包进行应对的实现方式。
仅仅支持这个版本的客户端如果收到一个版本协商包，其必须放弃当前建联尝试，除非是下述两种例外： 如果已经收到且成功处理任何其他类型的包，客户端必须忽略任何版本协商包； 客户端必须忽略包含其选择的QUIC版本的版本协商包。
如何执行版本协商留作由未来标准追踪规范定义的未来工作。 特别是，未来工作将确保在抵御版本降级攻击时具有健壮性，详见第21.12章。</description>
    </item>
    
    <item>
      <title>6.2. 响应密钥更新</title>
      <link>/RFC9001_Chinese_Translation/Key_Update/6.2_Responding_to_a_Key_Update/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9001_Chinese_Translation/Key_Update/6.2_Responding_to_a_Key_Update/</guid>
      <description>在接收到对于受当前密钥阶段的密钥保护的数据包的确认后，对端就可以发起密钥更新。终端在处理到一个密钥阶段的值与它曾发出的最后一个数据包中的值不同的数据包时，会将该情况视作为密钥更新。为了处理这个数据包，终端要使用下一阶段中的数据包保护密钥和IV。有关创建这些密钥时的考量，详见第6.3章。
如果某个数据包可以使用下一阶段中的密钥和IV来处理，就说明对端发起了密钥更新。作为响应，终端必须将它的发送密钥更新到相应的密钥阶段，如第6.1章所述。在发送对于使用了更新后的密钥来接收的数据包的确认前，必须更新发送密钥。通过用受更新后的密钥保护的数据包来确认触发密钥更新的数据包的方式，终端发送出密钥更新完成的信号。
终端可以根据自己平时的数据包发送习惯，推迟发送数据包或确认：没有必要为了响应密钥更新而立即创建新数据包。终端发送的下一个数据包会用上更新后的密钥。下一个包含确认的数据包会使得密钥更新完成。如果终端检测到了第二次密钥更新，但它这时还没有使用更新后的密钥发送包含对于触发前一次密钥更新的数据包的响应的数据包，那么这就表明对端没有等待确认就更新了密钥两次。终端可以将这样的连续密钥更新行为视作类型为KEY_UPDATE_ERROR（密钥更新错误）的连接错误。
如果终端接收到的确认来自受旧密钥保护的数据包，但确认是对于受新密钥保护的数据包的，那么它可以将这种情况视作类型为KEY_UPDATE_ERROR的连接错误。这表明对端已经接收到并且确认了发起密钥更新的数据包，但是在响应时没有更新密钥。</description>
    </item>
    
    <item>
      <title>6.3 使用保留版本</title>
      <link>/RFC9000_Chinese_Translation/Version_Negotiation/6.3_Using_Reserved_Versions/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9000_Chinese_Translation/Version_Negotiation/6.3_Using_Reserved_Versions/</guid>
      <description>对于将来使用新版本QUIC的服务端，客户端需要正确处理不支持的版本。 一些版本号（如0x?a?a?a?a，见第15章）保留作包含版本号的字段。
终端可以添加保留版本到任意未知或不支持版本中会被忽略的字段，用以测试对端是否正确地忽略了该值。 例如，终端可以发版本协商包中包含一个保留版本，详见第17.2.1章)。 终端可以发送一个保留版本的数据包来测试对端是否会正确丢弃该包。</description>
    </item>
    
    <item>
      <title>6.3. 对创建接收密钥的计时</title>
      <link>/RFC9001_Chinese_Translation/Key_Update/6.3_Timing_of_Receive_Key_Generation/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9001_Chinese_Translation/Key_Update/6.3_Timing_of_Receive_Key_Generation/</guid>
      <description>终端在响应密钥更新时必须不产生在计时侧信道上可能表明密钥阶段比特位的有效性（详见第9.5章）的信号。当未批准进行密钥更新时，终端可以假装进行密钥更新，并使用随机化的数据包保护密钥来代替因更新而被弃用的密钥。使用随机化的密钥确保了移除数据包保护的尝试不会造成计时结果的变化，且具有无效的密钥阶段比特位的数据包会被正确地拒绝。
在接收数据包时，创建新的数据包保护密钥的过程可能透露出这期间进行了密钥更新。终端可以将创建新密钥作为数据包处理的一部分，但是这会产生计时上的信号，这个信号会被攻击者用于学习密钥更新的发生时机，从而泄露密钥阶段比特位的值。
通常，当前阶段中的和下一阶段中的数据包保护密钥应该都是对终端可用的。在密钥更新完成后不超过PTO的短暂时间里，终端可以延迟下一组接收用的数据包保护密钥的建立。这使得终端只需要维护两组接收密钥；详见第6.5章。
下一组数据包保护密钥一旦生成就应该被持续保留，哪怕接收到的数据包后来被丢弃了。看上去包含密钥更新的数据包很容易伪造，尽管密钥更新的过程不需要大量计算资源，但是攻击者还是可以触发它来进行拒绝服务攻击。
因此，终端必须有能力维护两组用于接收数据包的数据包保护密钥：当前阶段中的和下一阶段中的。维护除此之外的先前的密钥可能会提升性能，但是这是不必要的。</description>
    </item>
    
    <item>
      <title>6.4. 使用更新后的密钥来发送</title>
      <link>/RFC9001_Chinese_Translation/Key_Update/6.4_Sending_with_Updated_Keys/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9001_Chinese_Translation/Key_Update/6.4_Sending_with_Updated_Keys/</guid>
      <description>终端绝不会发送受旧密钥保护的数据包。只有当前阶段的密钥会被用到。切换到新密钥后，用于保护数据包的旧密钥可以被立即弃用。
用于保护具有更大数据包号的数据包的密钥必须与用于保护更小数据包号数据包的密钥一致，或比后者更新。如果终端用旧密钥移除了保护，但具有更小数据包号的数据包是受新密钥保护的，那么它必须将这种情况视作类型为KEY_UPDATE_ERROR的连接错误。</description>
    </item>
    
    <item>
      <title>6.5. 使用不同的密钥来接收</title>
      <link>/RFC9001_Chinese_Translation/Key_Update/6.5_Receiving_with_Different_Keys/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9001_Chinese_Translation/Key_Update/6.5_Receiving_with_Different_Keys/</guid>
      <description>在密钥更新期间，可能会接收到受旧密钥保护的数据包，它们因为被网络延误而刚刚抵达。保留旧的数据包保护密钥使得这些数据包能够被成功处理。
由于受来自下一阶段的密钥保护的数据包会与受来自上一阶段的密钥保护的数据包使用相同的密钥阶段，要想处理受旧密钥保护的数据包，就有必要区分这两种数据包。这可以通过使用数据包号来做到。如果重建出来的数据包号比当前密钥阶段的任一数据包号要小，那么这些数据包就要使用上一阶段的数据包保护密钥；如果重建出来的数据包号比当前密钥阶段的任一数据包号要大，那么这些数据包就要使用下一阶段的数据包保护密钥。
为了确保在上一阶段、当前阶段和下一阶段的数据包保护密钥间选择的过程不会在计时侧信道上泄露最终用于移除数据包保护的是哪一组密钥，必须谨慎操作。有关更多信息，详见第9.5章。
作为替代方案，终端可以仅维护两组数据包保护密钥，只需在经过对网络重排序来说充足的时间后将上一阶段的密钥替换为下一阶段的密钥。在这种情况下，只需要密钥阶段比特位就足以选择密钥。
在将下一阶段的接收密钥提升为当前阶段后，终端可以在建立再下一组数据包保护密钥前等待一段约为一个探测包超时（PTO；详见《QUIC恢复》）的时间。这组被推迟建立的新密钥可以在经过这段等待时间后才替换上一阶段的旧密钥。只不过有一个缺点，即PTO是一个主观的测量结果——也就是说，对端对于RTT的预估可能不同——这段等待时间既应该足够长以使得所有乱序数据包哪怕被确认了也都会被对端认定为丢包，又应该足够短以使得对端可以发起后续的密钥更新。
在对端保留旧密钥期间，对端可能无法解密发起密钥更新的数据包，终端需要允许这种情况的存在。在接收到能够表明先前的密钥更新已经被接收到的确认后，终端在发起密钥更新前应该等待一段时长为PTO三倍大小的时间。若没有留足时间，可能导致数据包被丢弃。
在接收到受新密钥保护的数据包后，终端保留旧的读取密钥的时长应该不超过PTO的三倍。在这段等待时间之后，旧的读取密钥和它们对应的秘密值应该被弃用。</description>
    </item>
    
    <item>
      <title>6.6. AEAD的用量上限</title>
      <link>/RFC9001_Chinese_Translation/Key_Update/6.6_Limits_on_AEAD_Usage/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9001_Chinese_Translation/Key_Update/6.6_Limits_on_AEAD_Usage/</guid>
      <description>本文档为AEAD设置了用量上限以确保在使用QUIC时哪怕过量使用AEAD也不会在通信的可信度和完整性上给予攻击者过多的优势。
TLS 1.3中定义的用量上限是为了抵御针对可信度的攻击，只有遵从这些限制，使用AEAD的保护才是有效的。认证加密中的完整性保护也依赖于对伪造数据包的尝试次数进行限制。TLS是以一遇到未通过认证校验的记录就关闭连接的方式做到这一点的。相比之下，QUIC会忽略无法通过认证的所有数据包，允许多次尝试伪造数据包。
QUIC为AEAD的可信度上限和完整性上限分别进行计数。在可信度方面，限制某个密钥可以加密的数据包数量。在完整性方面，限制某个连接中可以解密的数据包数量。下文是有关为各种AEAD算法施加限制的细节。
终端必须为每一组密钥单独计算加密数据包的数量。如果同一密钥的加密数据包总数超过了所选AEAD的可信度上限，那么终端必须停止使用这组密钥。在发送的受保护数据包数量超过所选AEAD允许的可信度上限前，终端必须发起密钥更新。如果无法进行密钥更新或触及了完整性上限，那么终端必须停止使用当前连接，并且以仅仅发送无状态重置的方式响应接收到的数据包。推荐终端在进入无法进行密钥更新的状态前立即用类型为AEAD_LIMIT_REACHED（触及AEAD上限）的连接错误来关闭连接。
对于AEAD_AES_128_GCM和AEAD_AES_256_GCM，可信度上限为223个加密数据包；详见附录B.1。对于AEAD_CHACHA20_POLY1305，其可信度上限要比可能的数据包数量（262）还大，因此不用考虑。对于AEAD_AES_128_CCM，可信度上限是221.5个加密数据包；详见附录B.2。
除了要为发送的数据包计数外，终端必须为在一条连接的存活期间内接收到但未通过认证的数据包计数。如果在某条连接中接收到但未通过认证的数据包总数，无论受什么密钥保护，超过了所选AEAD的完整性上限，那么终端必须立即用类型为AEAD_LIMIT_REACHED的连接错误来关闭连接，并且不再处理更多数据包。
对于AEAD_AES_128_GCM和AEAD_AES_256_GCM，完整性上限为252个非法数据包；详见附录B.1。对于AEAD_CHACHA20_POLY1305，完整性上限为236个非法数据包；详见《AEBounds》。对于AEAD_AES_128_CCM，完整性上限为221.5个非法数据包；详见附录B.2。应用这些限制能够降低攻击者成功伪造数据包的可能性；详见《AEBounds》、《ROBUST》和《GCM-MU》。
限制数据包尺寸的终端可以使用更高的可信度上限和完整性上限；有关细节详见附录B。
将来的分析与规范可以放松对于某AEAD的可信度上限或完整性上限。
可以被用于QUIC的任一TLS加密套件必须定义相关AEAD函数在可信度和完整性方面的用量上限。也就是说，这些限制必须准确指出允许被认证的数据包数量和允许未通过认证的数据包数量。提供一份分析如何计算该值的参考文献——并指出所有在此分析中使用到的假设——使得限制值能够变化以适应不同的使用条件。</description>
    </item>
    
    <item>
      <title>6.7. 密钥更新的错误码</title>
      <link>/RFC9001_Chinese_Translation/Key_Update/6.7_Key_Update_Error_Code/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9001_Chinese_Translation/Key_Update/6.7_Key_Update_Error_Code/</guid>
      <description>错误码KEY_UPDATE_ERROR（0x0e）被用于发送与密钥更新相关的错误的信号。</description>
    </item>
    
    <item>
      <title>7.1. 握手流程示例</title>
      <link>/RFC9000_Chinese_Translation/Cryptographic_and_Transport_Handshake/7.1_Example_Handshake_Flows/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9000_Chinese_Translation/Cryptographic_and_Transport_Handshake/7.1_Example_Handshake_Flows/</guid>
      <description>关于TLS如何与QUIC整合的更多细节详见《QUIC TLS》，但在此举出一些范例。 用以支持客户端地址验证的这种交换的一个扩展详见第8.1.2章。
一旦完成任何地址验证交换，加密握手将用于协商密钥。 加密握手由初始包（第17.2.2章）和握手包（第17.2.4章）携带。
图5展示了1-RTT握手过程的概况。 每行展示一个QUIC数据包，首先展示其包类型和包号，紧接着展示这类包通常包含的帧。 例如首包通常是初始包，包号是0，且包含一个携带ClientHello内容的加密帧。
多个QUIC包——甚至包类型各不相同——可以合并成一个UDP报文，详见第12.2章。 因此，这次握手可能由仅仅4个或更少的UDP报文组成（受限于协议固有的诸如拥塞控制和反放大机制）。 例如，服务端的首个报文包含初始包、握手包及包含“0.5-RTT数据”的1-RTT包。
TODO：图5
图6是一个0-RTT握手连接的示例，并且其中一个数据包携带0-RTT数据。 注意，如12.3章所述，服务端在1-RTT包中对0-RTT数据进行确认，并且客户端发送的1-RTT包处于同一个包号空间。
TODO：图6</description>
    </item>
    
    <item>
      <title>7.2. 协商连接ID</title>
      <link>/RFC9000_Chinese_Translation/Cryptographic_and_Transport_Handshake/7.2_Negotiating_Connection_IDs/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9000_Chinese_Translation/Cryptographic_and_Transport_Handshake/7.2_Negotiating_Connection_IDs/</guid>
      <description>连接ID用于确保数据包稳定路由，详见第5.1章。 长包头包含两个连接ID：目标连接ID由接收方指定并用于提供稳定路由；源连接ID供对端设置为目标连接ID。
在握手期间，带有长包头（详见第17.2章）的数据包用于设置双端所使用的连接ID。 每端的源连接ID会作为发往该端的数据包的目标连接ID。 在处理完首个初始数据包后，每端将后续发送数据包的目标连接ID字段值设置为其接收的源连接ID字段值。
当客户端发送初始包之前未从服务端收到过初始数据包或重试数据包，则生成不可预测值填充发送的初始包的目标连接ID字段。 目标连接ID的长度必须至少8字节。 客户端在一条连接上必须使用同一个目标连接ID，直到收到服务端发来的数据包为止。
客户端发送的首个初始数据包的目标连接ID字段用于确定初始数据包的包保护密钥。 这些密钥在收到重试数据包后变更，详见QUIC TLS第5.2章。
客户端选择一个值填充源连接ID字段，并设置源连接ID长度字段以标识其长度。
客户端发送的首个0-RTT数据包使用其发送的首个初始数据包一致的源连接ID和目标连接ID。
在首次收到从服务端发来的初始数据包或重试数据包后，客户端将服务的提供的源连接ID作为后续发送数据包的目标连接ID，包括任何0-RTT包。 这意味着客户端可能需要在连接建立阶段将目标连接ID字段的值变更两次： 一次是响应服务端发来的重试数据包，一次是响应服务端发来的初始数据包。 一旦客户端收到一个从服务端发来的有效的初始数据包，则其必须丢弃在该连接上后续接收到的任何带有不同源连接ID值的数据包。
客户端必须在收到首个初始数据包或首个重试数据包后，更改其后续发送数据包时的目标连接ID值。 服务端必须基于收到的首个初始数据包设置发送数据包的目标连接ID。 任何针对目标连接ID的后续改动，只允许通过新连接ID帧携带的值进行； 如果后续的初始数据包包含不同的源连接ID，则必须将该包丢弃。 这避免了对多个具有不同源连接ID的初始数据包进行无状态处理可能导致的不可预测的结果。
终端发出的目标连接ID可以在一条连接的生命周期内变更，尤其是在响应连接迁移（第9章），详见第5.1.1章。</description>
    </item>
    
    <item>
      <title>7.3. 验证连接ID</title>
      <link>/RFC9000_Chinese_Translation/Cryptographic_and_Transport_Handshake/7.3_Authenticating_Connection_IDs/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9000_Chinese_Translation/Cryptographic_and_Transport_Handshake/7.3_Authenticating_Connection_IDs/</guid>
      <description>终端在握手期间的连接ID做出的选择，通过包括传输参数的所有的值验证，详见第7.4章。 这确保所有用于握手的连接ID也同时通过加密握手得到认证了。
终端将其发出的首个初始数据包的源连接ID字段值包含在initial_source_connection_id传输参数中，详见第18.2章。 服务端将其接收到的首个初始数据包中的目标连接ID值包含在original_destination_connection_id传输参数中；如果服务端发送了一个重试数据包，则其对应的是发送该包之前收到的首个初始数据包。 如果发送重试数据包，服务端也会将重试数据包的源连接ID字段包含在retry_source_connection_id传输参数中。
来自对端的传输参数中的值必须与终端 在其发送的（对于服务端，则同时包括其接收到的）初始数据包的目标连接ID和源连接ID字段所使用的值保持一致。 终端必须验证其接收到的传输参数匹配接收到的连接ID值。 将连接ID值包含在传输参数中并认证，从而确保攻击者不能在握手期间通过插入携带有攻击者选择的连接ID的数据包影响连接ID的选择。
终端必须将 任意终端缺失initial_source_connection_id传输参数以及服务端缺失original_destination_connection_id传输参数视为TRANSPORT_PARAMETER_ERROR类型的连接错误。
终端必须将下述情况视为TRANSPORT_PARAMETER_ERROR或PROTOCOL_VIOLATION类型的连接错误：
 服务端在接收到一个重试数据包后，缺失retry_source_connection_id传输参数， 未接收到重试数据包，但是却存在retry_source_connection_id传输参数，或 从对端接收到的传输参数中的值与发送的初始数据包中相应目标连接ID或源连接ID字段不一致。  如果选择了一个零长度连接ID，则相应的传输参数包含一个零长度值。
图7展示了一个完整握手过程中连接ID的使用（其中DCID表示目标连接ID，SCID表示源连接ID）。 图中展示了初始数据包如何交换，以及随后1-RTT数据包的交换，其中包括握手期间创建的连接ID。
TODO：图7，握手期间连接ID的使用
图8展示了包含重试数据包的握手过程。
TODO：图8，使用重试数据包的握手中连接ID的使用
在上述两种情况（图7和图8）下，客户端设置其initial_source_connection_id传输参数值为C1。
当握手过程没有出现重试数据包（图7），服务端设置original_destination_connection_id为S1（注意该值是客户端选择的），设置initial_source_connection_id为S3。 在这种情况下，服务端不包含retry_source_connection_id传输参数。
When the handshake includes a Retry (Figure 8), the server sets original_destination_connection_id to S1, retry_source_connection_id to S2, and initial_source_connection_id to S3.
当握手过程出现了重试数据包（图8），服务端设置original_destination_connection_id为S1，设置retry_source_connection_id为S2，设置initial_source_connection_id为S3。</description>
    </item>
    
    <item>
      <title>7.4.1. 0-RTT传输参数</title>
      <link>/RFC9000_Chinese_Translation/Cryptographic_and_Transport_Handshake/Transport_Parameters/7.4.1_Values_of_Transport_Parameters_for_0_RTT/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9000_Chinese_Translation/Cryptographic_and_Transport_Handshake/Transport_Parameters/7.4.1_Values_of_Transport_Parameters_for_0_RTT/</guid>
      <description>是否使用0-RTT取决于客户端和服务端使用的传输参数是否由同一个旧连接协商的。 为了开启0-RTT，终端需要保存服务端传输参数的值及在连接上收到的任何会话票据（session ticket）。 终端也需要保存其他任何应用协议或加密握手所需要的信息，详见[QUIC TLS]的第4.6章。 保存的传输参数的值在使用会话票据尝试进行0-RTT建连时使用。
保存的传输参数适用于新连接，直到握手完成，客户端开始发送1-RTT数据包为止。 一旦握手完成，客户端就启用握手过程中创建的传输参数。 不是所有的传输参数都需要保存，因为部分参数不会在后续连接中生效，或是在0-RTT建连期间不起作用。
定义新的传输参数（详见第7.4.2章）时，必须明确说明其作为0-RTT参数进行保存是否是强制性的、可选的，或必须禁止的。 客户端不需要保存一个其不能处理的传输参数。
客户端必须不使用下述参数的保存值：ack_delay_exponent、max_ack_delay、initial_source_connection_id、original_destination_connection_id、preferred_address、retry_source_connection_id，以及stateless_reset_token。 客户端必须使用握手期间服务端给出的新值。 如果服务端没有提供新的值，就使用默认值。
试图发送0-RTT数据的客户端必须保存所有其他服务端需要使用且可以处理的传输参数。 服务端可以保存这些传输参数，或在会话票据中保存这些参数值的一份具备完整性保护的备份，并在收到0-RTT数据后恢复其具体信息。
如果服务端收到了0-RTT数据，服务端必须不能放宽任何限制，或采用任何其他可能与客户端发来的0-RTT数据产生冲突的值。 尤其需要注意的是，服务端在接收0-RTT数据后，必须不 可为下述参数（详见18.2）设置一个低于保存值的值：
 active_connection_id_limit initial_max_data initial_max_stream_data_bidi_local initial_max_stream_data_bidi_remote initial_max_stream_data_uni initial_max_streams_bidi initial_max_streams_uni  删除特定传输参数，或为之设置一个零值，可能导致启用0-RTT数据但却不可用。 允许发送应用数据的传输参数的适当子集应该被设置为非零值，以支持0-RTT。 这包括：initial_max_data和（1）initial_max_streams_bidi及initial_max_stream_data_bidi_remote，或（2）initial_max_streams_uni及initial_max_stream_data_uni。
服务端可能给流设置的初始流控上限大于保存的0-RTT数据包中由客户端设置的值。 一旦握手完成，客户端必须根据更新后的initial_max_stream_data_bidi_remote及initial_max_stream_data_uni的值更新所有发送流的流控上限。
服务端可以保存并恢复先前发送的max_idle_timeout、max_udp_payload_size及disable_active_migration参数的值，以及在选择更小值后拒绝0-RTT。 当接收0-RTT数据可能同时降低连接性能时，调低这些参数的值。 特别是调低max_udp_payload_size可能导致丢包，导致性能与直接拒绝0-RTT数据相比变得更差。
当服务端不支持恢复后的值时，其必须拒绝0-RTT数据。
当在0-RTT数据包中发送帧时，客户端必须只使用保存的传输参数；更重要的是，它必须不能使用 服务端更新后的传输参数，或使用从1-RTT数据包接收到的帧。 在握手过程中传输参数更新的值只适用于1-RTT数据包。 例如，保存的传输参数中的流控上限值适用于所有的0-RTT数据包，即使这些值通过握手或通过1-RTT数据包发送的帧调大了。 服务端可以将在0-RTT数据中使用更新后的传输参数视为一个PROTOCOL_VIOLATION类型的连接错误。</description>
    </item>
    
    <item>
      <title>7.4.2. 新传输参数</title>
      <link>/RFC9000_Chinese_Translation/Cryptographic_and_Transport_Handshake/Transport_Parameters/7.4.2_New_Transport_Parameters/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9000_Chinese_Translation/Cryptographic_and_Transport_Handshake/Transport_Parameters/7.4.2_New_Transport_Parameters/</guid>
      <description>新传输参数可以用于协商新的协议行为。 终端必须忽略其不支持的传输参数。 缺失某个传输参数会因此禁用掉任何可选的、通过该参数协商的协议特性。 正如第18.1章所述，保留某些标识符是为了满足这个需求。
对于一个传输参数，如果客户端不能识别，则客户端可以将其丢弃，并尝试在随后的连接中尝试0-RTT。 然而，如果客户端对一个丢弃的传输参数添加了支持，那么其在尝试0-RTT时就有可能与传输参数设置的限制出现冲突。 新传输参数可以通过设置一个最保守的默认值避免该问题。 客户端可以通过保存所有参数避免该问题，即使其中一些参数目前尚不支持。
新传输参数根据第22.3章描述的规则进行注册。</description>
    </item>
    
    <item>
      <title>7.5. 加密信息缓存</title>
      <link>/RFC9000_Chinese_Translation/Cryptographic_and_Transport_Handshake/7.5_Cryptographic_Message_Buffering/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9000_Chinese_Translation/Cryptographic_and_Transport_Handshake/7.5_Cryptographic_Message_Buffering/</guid>
      <description>QUIC实现需要维护一个用于保存乱序接收到的加密数据的缓存区。 由于加密帧没有流量控制，终端有可能强制对端缓存无限量的数据。
QUIC实现必须支持缓存至少4096字节从乱序加密帧收到的数据。 终端可以选择允许在握手期间缓存更多的数据。 更大的缓存上限意味着可以交换更大的密钥或证书。 终端的缓存区大小不必在整个连接生命周期内保持不变。
握手期间无法缓存加密帧可能导致连接失败。 如果终端的缓存区在握手期间溢出，则其可以通过暂时扩大缓存空间确保握手完成。 如果终端不扩大其缓存，则其必须以错误码CRYPTO_BUFFER_EXCEEDED关闭连接。
Once the handshake completes, if an endpoint is unable to buffer all data in a CRYPTO frame, it MAY discard that CRYPTO frame and all CRYPTO frames received in the future, or it MAY close the connection with a CRYPTO_BUFFER_EXCEEDED error code. Packets containing discarded CRYPTO frames MUST be acknowledged because the packet has been received and processed by the transport even though the CRYPTO frame was discarded.</description>
    </item>
    
    <item>
      <title>8.1. 协议协商</title>
      <link>/RFC9001_Chinese_Translation/QUIC-Specific_Adjustments_to_the_TLS_Handshake/8.1_Protocol_Negotiation/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9001_Chinese_Translation/QUIC-Specific_Adjustments_to_the_TLS_Handshake/8.1_Protocol_Negotiation/</guid>
      <description>QUIC要求加密握手提供经认证的协议协商过程。TLS使用应用层协议协商（ALPN，详见《ALPN》）来选择应用协议。终端必须使用ALPN来协商应用协议，除非使用了其他机制来就应用协议达成一致。
在使用ALPN时，如果没有协商出应用协议，那么终端必须立即使用值为no_application_protocol（无应用协议）的TLS警告（QUIC的错误码为0x0178；详见第4.8章）来关闭连接（详见《QUIC传输》的第10.2章）。尽管《ALPN》中只规定了服务器要使用此警告，但是QUIC客户端在ALPN协商失败时必须使用类型为0x0178的错误来终止连接。
应用协议可以限制它所操作的QUIC版本。服务器必须选择一个与客户端所选QUIC版本兼容的应用协议。服务器必须将无法选出兼容的应用协议的情况视作类型为0x0178（相当于no_application_protocol）的连接错误。类似地，客户端必须将服务器选择了不兼容的应用协议的情况视作类型为0x0178的连接错误。</description>
    </item>
    
    <item>
      <title>8.1. 标准参考文献</title>
      <link>/RFC8999_Chinese_Translation/References/8.1_Normative_References/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC8999_Chinese_Translation/References/8.1_Normative_References/</guid>
      <description>[RFC2119] Bradner, S. 《RFC文档中用于指出要求级别的关键字（Key words for use in RFCs to Indicate Requirement Levels）》, BCP 14, RFC 2119, DOI 10.17487/RFC2119, March 1997, https://www.rfc-editor.org/info/rfc2119.
  [RFC8174] Leiba, B. 《RFC2119中关键字大写与小写的歧义（Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words）》, BCP 14, RFC 8174, DOI 10.17487/RFC8174, May 2017, https://www.rfc-editor.org/info/rfc8174.</description>
    </item>
    
    <item>
      <title>8.1.1 令牌构建</title>
      <link>/RFC9000_Chinese_Translation/Address_Validation/Address_Validation_during_Connection_Establishment/8.1.1_Token_Construction/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9000_Chinese_Translation/Address_Validation/Address_Validation_during_Connection_Establishment/8.1.1_Token_Construction/</guid>
      <description>构建在新令牌帧或重试数据包中发送的令牌时，必须使用一种能够令服务器识别出令牌提供给客户端的途径的方法。这些令牌被携带于相同字段中但是需要服务器进行不同的处理。</description>
    </item>
    
    <item>
      <title>8.1.2 使用重试数据包进行地址验证</title>
      <link>/RFC9000_Chinese_Translation/Address_Validation/Address_Validation_during_Connection_Establishment/8.1.2_Address_Validation_Using_Retry_Packets/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9000_Chinese_Translation/Address_Validation/Address_Validation_during_Connection_Establishment/8.1.2_Address_Validation_Using_Retry_Packets/</guid>
      <description>当接收到客户端的初始数据包时，服务器可以通过发送包含令牌的重试数据包（详见第17.2.5章）来请求地址验证。接收到重试数据包之后，客户端必须在为那条连接发送的所有初始数据包中重复这个令牌。
作为处理包含了曾在重试数据包中提供的令牌的初始数据包的回应，服务器不能再发送重试数据包；它只能拒绝那条连接或允许连接继续进行。
只要不存在攻击者为它自己的地址生成一个有效令牌（详见第8.1.4章）的可能性，并且客户端有能力将那个令牌返回给服务器，就能证实客户端接收到了令牌。
服务器还能使用重试数据包来推迟连接建立所需的状态数据和处理的成本。要求服务器提供一个不同的连接ID，以及在第18.2章中定义的传输参数original_destination_connection_id（原始目标连接ID），能强制服务器表明它，或和它一起工作的实体，从客户端接收到了原始的初始数据包。提供一个不同的连接ID还确保服务器对后续数据包如何路由有一定的控制能力。这可以被用来将连接指向不同的服务器实例。
如果服务器接收到了一个除了无效的重试令牌字段外都合法的客户端初始数据包，那么它能肯定客户端不会接收另一个重试令牌。服务器可以丢弃这样的数据包，并且允许客户端以超时的形式检测到本次握手的失败，但这会对客户端施加强烈的延迟惩罚。取而代之的是，服务器应该使用错误INVALID_TOKEN（无效令牌）立即关闭（详见第10.2章）连接。注意，服务器在这个时候还没有为连接建立任何状态数据所以不会进入到关闭状态。
图9展示的是关于重试数据包的使用的流程图。
 TODO：图9
  图9：使用重试的握手样例
 </description>
    </item>
    
    <item>
      <title>8.1.3 为将来的连接进行地址验证</title>
      <link>/RFC9000_Chinese_Translation/Address_Validation/Address_Validation_during_Connection_Establishment/8.1.3_Address_Validation_for_Future_Connections/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9000_Chinese_Translation/Address_Validation/Address_Validation_during_Connection_Establishment/8.1.3_Address_Validation_for_Future_Connections/</guid>
      <description>在一条连接进行期间，服务器可以向客户端提供一个可以被用于后续连接的地址验证令牌。地址验证对于0-RTT特别重要，因为服务器响应0-RTT数据时可能向客户端发送大量的数据。
服务器使用新令牌帧（详见第19.7章）来向客户端提供一个可以被用于验证将来的连接的地址验证令牌。在将来的连接中，客户端将这个令牌包含在初始数据包中来提供地址验证。客户端必须将令牌包含在所有它发送的初始数据包中，除非有重试数据包将令牌替换为新的值。客户端必须不在将来的连接中使用重试数据包里提供的令牌。服务器可以丢弃任何没有携带期望的令牌的初始数据包。
不像为重试数据包创建的令牌要被立即使用掉，在新令牌帧中发送的令牌即使经过了一段时间也能使用。因此，令牌应该具有一个过期时间，它既可以是一个显式的过期时间，也可以是一个可以被用来动态计算过期时间的签发时间戳。服务器可以将过期时间存储起来或将它以加密的形式包含在令牌中。
使用新令牌帧签发的令牌必须不包含会令观测者将之关联到被签发令牌所在的连接上的信息。例如，它不能包含先前的连接ID或地址信息，除非这些值是经过加密的。除了因为先前发送的新令牌帧遭遇丢包而重新发送的那些帧外，服务器必须确保它发送的任何新令牌帧在所有客户端间都是唯一的。允许服务器区分令牌是来自重试数据包还是新令牌帧的信息还会被并非服务器的实体访问到。
客户端的端口号在两条不同的连接间保持相同是不太可能的；因此验证端口不太可能成功。
如果与某服务器间的连接具有权威性（例如，服务器的名称是被包含在证书中的），那么在新令牌帧中接收到的令牌应该适用于这台服务器。当客户端连接到一台服务器且它对此服务器仍保有对此服务器适用的且未使用的令牌时，它应该在初始数据包的令牌字段中使用令牌。使用令牌可以允许服务器不需要额外花费往返时间就验证客户端地址。客户端必须不在连接到服务器时使用不适用于此服务器的令牌，除非客户端知道签发令牌的服务器和它正在连接的服务器是共享令牌的管理机制的。客户端可以使用来自任何先前与那台服务器的连接的令牌。
令牌允许服务器将令牌签发时所在的连接和任何它被使用时所在的连接间的网络活动关联起来。想要打破在某个服务器上的身份连续性的客户端可以丢弃使用新连接帧提供的令牌。相反，在重试数据包中获取的令牌必须在连接尝试期间被立即使用且不能被用于后续的连接尝试。
客户端不应该在不同的连接尝试间重用来自新令牌帧的令牌。重用令牌使得连接会被网络路径上的实体关联起来；详见第9.5章。
客户端可能在单条连接上接收到数个令牌。只要记得防止可关联性，任何令牌可以被用于任何连接尝试。服务器可以发送额外的令牌既可以为多次连接尝试提供地址验证，又可以取代可能会变为无效的旧令牌。对于客户端来说，这种不明确的目的意味着发送最近的未使用的令牌是最有可能有效的。尽管保存并使用更旧的令牌没有负面影响，但是客户端可以将更旧的令牌视为更不太可能会对此服务器的地址验证有效。
当服务器接收到具有地址验证令牌的初始数据包时，它必须尝试验证令牌，除非它已经完成了地址验证。如果令牌是无效的，那么服务器应该表现得就好像客户端的地址未经验证一样，这包括在必要时发送重试数据包。使用新令牌帧和重试数据包提供的令牌能够被服务器区分（详见第8.1.1章），并且后者会被更严格地验证。如果验证通过，服务器随后应该允许握手继续进行。
 注意：将客户端地址视为未经验证的而不是丢弃数据包的原因是，客户端可能是在之前的连接中从新令牌帧中获得令牌的，并且如果服务器丢失过状态，它就可能无法验证令牌，此时若丢弃数据包则会导致连接失败。
 在无状态的设计中，服务器可以使用经过加密和认证的令牌来将信息传递给客户端，随后从中恢复信息并用它来验证客户端的地址。令牌没有被整合进加密握手，所以它们是未经认证的。这意味着，客户端将可以重用令牌。为了避免利用这一属性的攻击，服务器可以将令牌中的信息限制为仅仅验证客户端地址时所需要的那些信息。
客户端可以将从一条连接中获取的令牌用于任何使用相同版本的连接尝试。当选择使用的令牌时，客户端不需要考虑正在尝试的连接的其他属性，包括应用协议、会话票证或其他连接属性的可能的选择。</description>
    </item>
    
    <item>
      <title>8.1.4 地址验证令牌完整性</title>
      <link>/RFC9000_Chinese_Translation/Address_Validation/Address_Validation_during_Connection_Establishment/8.1.4_Address_Validation_Token_Integrity/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9000_Chinese_Translation/Address_Validation/Address_Validation_during_Connection_Establishment/8.1.4_Address_Validation_Token_Integrity/</guid>
      <description>地址验证令牌必须是难以猜测的。在令牌中包含一个有着至少128位的熵的随机值会是足够的，但是这需要服务器记录它发送给客户端的值。
基于令牌的方案允许服务器将关于验证的状态数据带来的负载转移到客户端上。要使这种设计正常工作，令牌必须被能够抵御客户端修改或伪造的完整性保护所覆盖。要是没有完整性保护，恶意的客户端就能生成或猜测会被服务器接收的令牌值。只有服务器需要访问令牌的完整性保护密钥。
对令牌制定单一的定义良好的格式是没有必要的，因为服务器即使生成者又是消费者。在重试数据包中发送的令牌应该包含允许服务器验证客户端数据包中的源IP地址和端口是否保持不变的信息。
在新令牌帧中发送的令牌必须包含允许服务器验证客户端的IP地址是否和令牌签发时的值一致的信息。服务器可以使用来自新令牌帧的令牌来做出不发送重试数据包的决定，即使客户端地址已经改变。如果客户端的IP地址已经改变，那么服务器必须遵守抗放大上限；详见第8章。注意，由于NAT的存在，这项要求可能不足以保护其他共享NAT的主机免于放大攻击。
攻击者可能在DDoS攻击中重放令牌来将服务器用作放大器。为了抵御这种攻击，服务器必须确保令牌的重放是被阻止或限制的。服务器应该确保在重试数据包中发送的令牌仅会在一段较短时间内被接受，因为它们会被客户端立即返回。在新令牌帧（详见第19.7章）中提供的令牌应该有更长的有效时间但是不应该能被多次接受。建议服务器尽可能只允许令牌被使用一次；令牌可以包含关于客户端的额外信息来进一步缩减适用范围或重用机会。</description>
    </item>
    
    <item>
      <title>8.2. QUIC传输参数扩展</title>
      <link>/RFC9001_Chinese_Translation/QUIC-Specific_Adjustments_to_the_TLS_Handshake/8.2_QUIC_Transport_Parameters_Extension/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9001_Chinese_Translation/QUIC-Specific_Adjustments_to_the_TLS_Handshake/8.2_QUIC_Transport_Parameters_Extension/</guid>
      <description>QUIC传输参数是使用TLS扩展来传递的。不同的QUIC版本可能为传输配置的协商定义不同方法。
在TLS握手中包含传输参数，就可以为这些值提供完整性保护。
enum { quic_transport_parameters(0x39), (65535) } ExtensionType; 
 quic_transport_parameters（QUIC传输参数）扩展的extension_data（扩展数据）字段中包含的是一个由正在使用的QUIC版本定义的值。
quic_transport_parameters扩展是在握手期间使用ClientHello（客户端问候）和EncryptedExtensions（加密扩展）消息来传递的。终端必须发送quic_transport_parameters扩展；接收到不带quic_transport_parameters扩展的ClientHello消息或EncryptedExtensions消息的终端必须使用类型为0x016d（相当于TLS中致命级别的missing_extension警告，详见第4.8章）的错误来关闭连接。
传输参数在握手完成前就会变为可用。服务器可以在握手完成前就使用这些值。不过，直到握手完成，传输参数的值都是未经认证的，所以即使提前使用这些参数也不要依赖于它们的真实性。任何对于传输参数的篡改最终都会使得握手失败。
终端必须不在并未使用QUIC的TLS连接中（例如在《TLS13》中定义的基于TCP的TLS连接）发送此扩展。如果在非QUIC的传输中接收到了这个扩展，那么支持此扩展的终端必须发送致命级别的unsupported_extension警告。
协商quic_transport_parameters扩展会使得EndOfEarlyData（早期数据结束）被移除；详见第8.3章。</description>
    </item>
    
    <item>
      <title>8.2. 非标准参考文献</title>
      <link>/RFC8999_Chinese_Translation/References/8.2_Informative_References/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC8999_Chinese_Translation/References/8.2_Informative_References/</guid>
      <description>[QUIC TLS] Thomson, M., Ed. and S. Turner, Ed. 《使用TLS加密QUIC（Using TLS to Secure QUIC）》, RFC 9001, DOI 10.17487/RFC9001, May 2021, https://www.rfc-editor.org/info/rfc9001.
  [QUIC传输协议] Iyengar, J., Ed. and M. Thomson, Ed. 《QUIC：一种基于UDP的多路复用安全传输协议（QUIC: A UDP-Based Multiplexed and Secure Transport）》, RFC 9000, DOI 10.17487/RFC9000, May 2021, https://www.rfc-editor.org/info/rfc9000.
  [RFC5116] McGrew, D. 《一种用于认证加密的接口及算法（An Interface and Algorithms for Authenticated Encryption）》, RFC 5116, DOI 10.17487/RFC5116, January 2008, https://www.rfc-editor.org/info/rfc5116.</description>
    </item>
    
    <item>
      <title>8.2.1 发起地址验证</title>
      <link>/RFC9000_Chinese_Translation/Address_Validation/Path_Validation/8.2.1_Initiating_Path_Validation/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9000_Chinese_Translation/Address_Validation/Path_Validation/8.2.1_Initiating_Path_Validation/</guid>
      <description>要发起路径验证，终端在要被验证的路径上发送一个包含不可预测的载荷的通道挑战帧。
终端可以发送多个通道挑战帧以抵御数据包丢包。然而，终端不应该使用同一个数据包发送这些通道挑战帧。
在用包含通道挑战帧的数据包探测新路径时，终端不应该发送得比初始数据包还要频繁。这确保连接迁移不会比建立新连接施加更多负载给新路径。
终端必须在每个通道挑战帧中使用不可预测的数据以使得它能将对端的响应与对应的通道挑战帧关联起来。
终端必须将包含通道挑战帧的数据报扩充至至少1200字节，这个在允许的最大数据报尺寸中的最小值，除非那条路径的抗放大上限不允许发送那么大的数据报。发送这个尺寸的UDP数据报确保终端与对端间的网络路径能够承载QUIC数据包；详见第14章。
当终端因为抗放大上限而不能将数据报扩充至1200字节时，路径的MTU将不会被验证。为了确保路径的MTU足够大，终端必须通过在至少1200字节的数据报中发送通道挑战帧的方式进行第二次路径验证。这次额外的验证可以在回复通道帧被成功接收到之后再进行，也可以等到在路径上收到了足够数量的字节而使得发送一个大一点的数据包也不会超过抗放大上限的时候再进行。
不像其他需要扩充数据报的情况，如果数据报包含了通道挑战帧或回复通道帧，那么终端必须不丢弃看起来过小的数据报。</description>
    </item>
    
    <item>
      <title>8.2.2 路径验证的响应</title>
      <link>/RFC9000_Chinese_Translation/Address_Validation/Path_Validation/8.2.2_Path_Validation_Responses/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9000_Chinese_Translation/Address_Validation/Path_Validation/8.2.2_Path_Validation_Responses/</guid>
      <description>当接收到通道挑战帧时，终端必须响应回复通道帧，并在其中回显通道挑战帧里的数据。除非被拥塞控制限制，终端必须不推迟传输包含回复通道帧的数据包。
回复通道帧必须在接收到通道挑战帧的网络路径上发送。这确保对端的路径验证仅当路径在两个方向上同时可用时才通过。这项要求必须不被发起路径验证的终端强制执行，因为这会使得针对迁移的攻击变为可能；详见第9.3.3章。
终端必须将包含回复通道帧的数据报扩充至至少1200字节，这个在允许的最大数据报尺寸中的最小值。这样就能验证这条路径在两个方向上都能够承载这个尺寸的数据报。然而如果产生的数据超过了抗放大上限，那么终端必须不扩充包含回复通道帧的数据报。这种情况应只会发生在接收到的通道挑战帧没有用扩充过的数据报发送时。
终端必须不在响应单个通道挑战帧时发送超过一个回复通道帧；详见第13.3章。对端应当根据需要发送更多通道挑战帧来唤起额外的回复通道帧。</description>
    </item>
    
    <item>
      <title>8.2.3 地址验证通过</title>
      <link>/RFC9000_Chinese_Translation/Address_Validation/Path_Validation/8.2.3_Successful_Path_Validation/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9000_Chinese_Translation/Address_Validation/Path_Validation/8.2.3_Successful_Path_Validation/</guid>
      <description>当接收到的回复通道帧包含着曾在通道挑战帧中发送的数据时，地址验证通过。在任何网络路径上接收到的回复通道帧所验证的路径都是发送通道挑战帧时使用的那条。
如果终端在一个未扩充至至少1200字节的数据报中发送通道挑战帧，并且它的响应验证了对端地址，那么该路径就是验证通过的，但这不包括路径的MTU。于是，终端现在可以发送超过已接收数据量三倍的数据。然而，终端必须使用经扩充的数据包发起另一次路径验证，来验证这条路径支持所需的MTU。
接收到对包含通道挑战帧的数据包的确认这一事实并不能作为合适的验证方法，因为确认可以是被恶意对端伪造出来的。</description>
    </item>
    
    <item>
      <title>8.2.4 地址验证失败</title>
      <link>/RFC9000_Chinese_Translation/Address_Validation/Path_Validation/8.2.4_Failed_Path_Validation/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9000_Chinese_Translation/Address_Validation/Path_Validation/8.2.4_Failed_Path_Validation/</guid>
      <description>仅当发起地址验证的终端放弃了验证地址的尝试时，地址验证失败。
终端应该基于倒计时放弃地址验证。在设置倒计时时，QUIC实现要注意新路径可能有着比原来的路径更长的往返时间。推荐使用的值是当前PTO和新路径PTO（使用《QUIC恢复》中定义的kInitialRtt）中的较大值的三倍。
这个倒计时使得在地址验证失败前可以经过数个PTO，于是一两个通道挑战帧或回复通道帧的丢包不会引起整个路径验证的失败。
注意，终端可能在新路径上接收到包含其他类型的帧的数据包，但是要使得路径验证通过，具有正确数据的回复通道帧是必需的。
当终端放弃地址验证时，它将这条路径认定为不可用。这不一定会暗示连接的失败——终端可以通过其他合适的路径继续发送数据包。如果没有路径可用，终端可以等待出现一条新的可用路径或关闭连接。没有通往对端的有效网络路径的终端可以用连接错误NO_VIABLE_PATH（无可行通道）来发送信号，不过这只有在有网络路径存在但是不支持所需的MTU（详见第14章）的情况下才可行。
地址验证可能因为除了失败外的其他原因而被放弃。这主要会发生在对旧路径进行验证期间发起了前往新路径的连接迁移时。</description>
    </item>
    
    <item>
      <title>8.3. 移除EndOfEarlyData消息</title>
      <link>/RFC9001_Chinese_Translation/QUIC-Specific_Adjustments_to_the_TLS_Handshake/8.3_Removing_the_EndOfEarlyData_Message/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9001_Chinese_Translation/QUIC-Specific_Adjustments_to_the_TLS_Handshake/8.3_Removing_the_EndOfEarlyData_Message/</guid>
      <description>QUIC中不会使用TLS的EndOfEarlyData消息。QUIC并不使用这条消息去标记0-RTT数据的结束位置，或去发送握手密钥发生变化的信号。
客户端必须不发送EndOfEarlyData消息。服务器必须将在0-RTT数据包中接收到加密帧的情况视作类型为PROTOCOL_VIOLATION（协议违背）的连接错误。
于是，EndOfEarlyData不会出现在TLS握手的记录单（transcript）中。</description>
    </item>
    
    <item>
      <title>8.4. 禁止TLS的中间设备兼容模式</title>
      <link>/RFC9001_Chinese_Translation/QUIC-Specific_Adjustments_to_the_TLS_Handshake/8.4_Prohibit_TLS_Middlebox_Compatibility_Mode/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9001_Chinese_Translation/QUIC-Specific_Adjustments_to_the_TLS_Handshake/8.4_Prohibit_TLS_Middlebox_Compatibility_Mode/</guid>
      <description>《TLS13》的附录D.4描述了TLS 1.3握手的一种替代方案，并将之作为某些中间设备上程序出错时的应对措施。TLS 1.3中的这种中间设备兼容模式需要将ClientHello和ServerHello（服务器问候）中的legacy_session_id（兼容会话ID）字段设置为一个32字节长的值，随后发送change_cipher_spec（更改加密设置）记录。这个字段和记录不传递任何具有语义的内容，并且会被忽略。
这个模式在QUIC中没有用处，因为它只适用于会干预基于TCP的TLS的中间设备。同时QUIC也没有提供任何传递change_cipher_spec记录的方法。客户端必须不请求使用TLS 1.3的兼容模式。服务器应该将接收到legacy_session_id字段非空的TLSClientHello的情况视作类型为PROTOCOL_VIOLATION的连接错误。</description>
    </item>
    
    <item>
      <title>9.1 探测新路径</title>
      <link>/RFC9000_Chinese_Translation/Connection_Migration/9.1_Probing_a_New_Path/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9000_Chinese_Translation/Connection_Migration/9.1_Probing_a_New_Path/</guid>
      <description>在将连接迁移到新的本地地址前，终端可以使用地址验证（详见第8.2章）从新的本地地址探测对端的可达性。地址验证的失败仅仅意味着新路径对此条连接来说无法使用。地址验证的失败不会引起连接被关闭，除非不存在其他可替代的有效路径。
通道挑战帧、回复通道帧、新连接ID帧和填充帧都属于“探测帧”，而其他类型的帧都是“非探测帧”。仅仅包含探测帧的数据包是“探测数据包”，而包含了其他类型的帧的数据包就是“非探测数据包”。</description>
    </item>
    
    <item>
      <title>9.1. 会话的可关联性</title>
      <link>/RFC9001_Chinese_Translation/Security_Considerations/9.1_Session_Linkability/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9001_Chinese_Translation/Security_Considerations/9.1_Session_Linkability/</guid>
      <description>TLS会话票据的使用使得服务器或其他实体能够将同一客户端创建的连接相互关联起来；有关细节详见第4.5章。</description>
    </item>
    
    <item>
      <title>9.2 发起连接迁移</title>
      <link>/RFC9000_Chinese_Translation/Connection_Migration/9.2_Initiating_Connection_Migration/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9000_Chinese_Translation/Connection_Migration/9.2_Initiating_Connection_Migration/</guid>
      <description>终端可以通过从新的本地地址发送包含非探测帧的数据包的方式来迁移连接。
每个终端都会在连接建立期间验证对端的地址。因此，正在迁移的终端可以在知道对端在其当前地址上愿意接收数据的前提下向对端发送数据。于是，终端不需要先验证对端的地址就可以迁移至新的本地地址。
为了在新的路径上建立可达性，终端在新路径上发起路径验证（详见第8.2章）。终端可以推迟路径验证，直到对端向它的新地址发送下一个非探测帧之时。
在迁移时，新路径可能不支持终端当前的发送速率。因此，终端如第9.4章所描述的那样重置它的拥塞控制器和RTT预估。
新的路径可能不具有相同的ECN功能。因此，终端如第13.4章所描述的那样验证ECN功能。</description>
    </item>
    
    <item>
      <title>9.2. 与0-RTT相关的重放攻击</title>
      <link>/RFC9001_Chinese_Translation/Security_Considerations/9.2_Replay_Attacks_with_0-RTT/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9001_Chinese_Translation/Security_Considerations/9.2_Replay_Attacks_with_0-RTT/</guid>
      <description>正如《TLS13》的第8章所述，只要使用了TLS早期数据就会被暴露于重放攻击之下。QUIC的0-RTT有着类似的风险。
终端必须实现并使用《TLS13》中描述的重放保护，然而这些保护并不被认为是完美的。因此，对于重放攻击的风险还需要更多考量。
QUIC并不易受到重放攻击，除非是利用QUIC传递的应用协议信息的攻击。基于在《QUIC传输》中定义的帧类型的QUIC协议状态管理机制不易受到重放攻击。QUIC帧的处理是幂等的，在帧被重放、乱序或遭遇丢包时不会引发连接状态异常。QUIC连接期间产生的副作用在连接的生命周期结束后就会失效，除非是那些由QUIC承载的应用协议产生的副作用。
TLS会话票据和地址验证令牌被用于在不同的连接间传递QUIC配置信息，尤其是，它使得服务器能够在连接建立和地址验证时高效地恢复状态数据。必须不使用它们在终端间传递应用语义；客户端必须将它们视作为内容不透明的值。如果这些令牌有可能被重用，那么它们就需要更强的针对重放攻击的保护。
在某条连接上接受0-RTT的服务器比不接受0-RTT的服务器要消耗更多的计算资源。服务器在接受0-RTT时需要考虑到重放的可能性以及其他相关资源的消耗。
管理与0-RTT相关的重放攻击的风险，其最终的责任在于应用协议。使用QUIC的应用协议必须描述该协议会怎样使用0-RTT以及用于抵御重放攻击的手段。对于重放风险的分析需要考虑所有会传递应用语义的QUIC协议特性。
要抵御重放攻击，完全禁用0-RTT是最有效的。
QUIC扩展必须描述重放攻击会如何影响扩展的行为，或禁止与0-RTT一起被使用。应用协议必须禁止使用会在0-RTT中传递应用语义的扩展，或提供抵御重放攻击的策略。</description>
    </item>
    
    <item>
      <title>9.3. 数据包放大攻击的抵御</title>
      <link>/RFC9001_Chinese_Translation/Security_Considerations/9.3_Packet_Reflection_Attack_Mitigation/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9001_Chinese_Translation/Security_Considerations/9.3_Packet_Reflection_Attack_Mitigation/</guid>
      <description>如果一条较小的ClientHello（客户端问候）能使得服务器响应巨大的握手消息，它就能被用于数据包放大攻击，放大攻击者生成的流量。
QUIC针对此类攻击，拥有三种防御手段。首先，包含ClientHello的数据包必须被扩充至一个下限值。其次，在向未经验证的源地址响应时，服务器发送的字节数禁止超过它接收到的字节数的三倍（详见《QUIC传输》的第8.1章）。最后，因为对于握手数据包的确认是经认证的，所有对此一无所知的攻击者无法伪造它们。综合起来，这些防御手段限制了放大攻击的放大量级。</description>
    </item>
    
    <item>
      <title>9.3.1 来自对端的地址伪造</title>
      <link>/RFC9000_Chinese_Translation/Connection_Migration/Responding_to_Connection_Migration/9.3.1_Peer_Address_Spoofing/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9000_Chinese_Translation/Connection_Migration/Responding_to_Connection_Migration/9.3.1_Peer_Address_Spoofing/</guid>
      <description>对端有可能伪造它的源地址来使得终端向不愿意接收的主机发送过量数据。如果终端发送的数据量比正在伪造的对端发送的要多得多，那么连接迁移可能被用来放大攻击者能够向受害者发送的数据量。
如第9.3章中所述，终端应该验证对端的新地址以确认对端在新地址上拥有处理能力。在对端的地址被认定为有效前，终端限制它向那个地址发送的数据量，详见第8章。如果没有这个限制，终端就要承担被用于针对毫无戒备的受害者的拒绝服务攻击的风险。
如果终端如上文一般跳过了对端地址验证，那么它就不需要限制它的发送速率。</description>
    </item>
    
    <item>
      <title>9.3.2 来自路径上设备的地址伪造</title>
      <link>/RFC9000_Chinese_Translation/Connection_Migration/Responding_to_Connection_Migration/9.3.2_On-Path_Address_Spoofing/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9000_Chinese_Translation/Connection_Migration/Responding_to_Connection_Migration/9.3.2_On-Path_Address_Spoofing/</guid>
      <description>在路径上的攻击者可以通过拷贝并转发具有伪造地址的数据包并使它比原始数据包更早到达的方式引发虚假的连接迁移。具有伪造地址的数据包将被视为来自连接迁移，而原始数据包将被视为重复并被丢弃。在一次虚假迁移之后，对源地址的验证将会失败，因为在源地址上的实体没有读取或响应发给它的通道挑战帧所需的加密密钥，哪怕它真的想这么做。
为了保护连接免于因为这样的虚假迁移而失败，当对于新对端地址的验证失败后，终端必须回退并使用最后一个经验证的对端地址。除此之外，从合法对端地址接收到具有最大数据包号的数据包，将触发另一次连接迁移。这将使得对虚假迁移的地址的验证被放弃，其中正包括由注入单个数据包的攻击者发起的迁移。
如果终端没有关于最后一个经验证的对端地址的状态，它必须以丢弃所有此连接的状态数据的方式静默地关闭连接。这会造成这条连接上的新数据包被以常规方式处理。例如，终端可以在响应将来的传入数据包时发送无状态重置。</description>
    </item>
    
    <item>
      <title>9.3.3 来自非路径上设备的数据包转发</title>
      <link>/RFC9000_Chinese_Translation/Connection_Migration/Responding_to_Connection_Migration/9.3.3_Off-Path_Packet_Forwarding/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9000_Chinese_Translation/Connection_Migration/Responding_to_Connection_Migration/9.3.3_Off-Path_Packet_Forwarding/</guid>
      <description>不在路径上的但能观测数据包的攻击者可以将真实数据包的副本转发到终端上。如果数据包副本比真实数据包更早到达，这就会表现得像是NAT重绑定一样。任何真实数据包都会因为重复而被丢弃。如果攻击者有能力继续转发数据包，它就有可能使得迁移的路径经过攻击者。这会使得攻击者位于路径上，给予它观测或丢弃任何后续数据包的能力。
这种形式的攻击要求攻击者使用一条有着和终端间的直连路径近乎相似的特征的路径。如果发送的数据包相对较少，或数据包丢包与计划的攻击同时发生，那么这种攻击的成功率就更加可靠。
在原始路径上接收到的会增加最大的已接收到的数据包号的非探测数据包将使得终端移动回那条路径。在这条路径上引发数据包增加了攻击失败的可能性。因此，这种攻击的抵御依赖于触发数据包交换。
在响应一个看起来很像的迁移时，终端必须使用通道挑战帧验证先前的活跃路径。这能在那条路径上引入新数据包的发送。如果那条路径不再可用，那么验证路径的尝试会超时并失败；如果路径时可用的但是不再被需要，验证就会成功但是仅仅使得那条路径上被多发送了几个探测数据包。
在活跃路径上接收到通道挑战帧的终端应该在发送非探测数据包作为响应。如果这个非探测数据包比任何攻击者创建的副本到达得都要早，这就能使得连接被迁移回原始路径。任何后续去往另一条路径的迁移都会重启上述整个过程。
这种防御是不完美的，但是它不被认为是一个严肃的问题。如果在尝试过数次原始路径的情况下，通过攻击者的路径还总是比原始路径更快，那么这很难说究竟是一次攻击，还是对路由的优化。
终端还可以使用启发式的方法来提升对这种形式的攻击的检测。例如，如果最近在旧路径上接收到过数据包，那么NAT重绑定是不太可能发生的；类似地，重绑定在IPv6路径上是很少见的。终端也可以寻找有没有重复的数据包。或者换个思路，连接ID上的改变更有可能表明这是一次有意的迁移，而不是一次攻击。</description>
    </item>
    
    <item>
      <title>9.4 丢包检测和拥塞控制</title>
      <link>/RFC9000_Chinese_Translation/Connection_Migration/9.4_Loss_Detection_and_Congestion_Control/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9000_Chinese_Translation/Connection_Migration/9.4_Loss_Detection_and_Congestion_Control/</guid>
      <description>新路径上的可用功能可能和旧路径上的不一样。在旧路径上发送的数据包必须不被计入新路径的拥塞控制或RTT预估中。
当承认对端对它新地址的所有权时，终端必须立即将新路径的拥塞控制器和往返时间预估器重置为初始值（详见《QUIC恢复》的附录A.3和附录B.3），除非对端地址的改变仅仅是换了个端口。因为仅改变端口通常是NAT重绑定或其他中间设备活动的结果，终端在这种情况下可以沿用拥塞控制状态和往返时间预估，而不是将它们重置为初始值。在来自旧路径的拥塞控制状态被沿用至具有完全不同特征的新路径上时，发送方一开始可能传输得过于激进，直到拥塞控制器和RTT预估器适应下来为止。一般来说，建议QUIC实现在沿用旧值至新路径时要谨慎。
在迁移期间，当终端发送数据和探测包自/至不同地址时，接收方一侧可能出现很明显的乱序，这是因为使用两条不同路径会有不同的往返时间。来自不同路径上的数据包的接收方仍然要为所有接收到的数据包发送ACK帧。
尽管在连接迁移期间会用到多条路径，但是最少只要使用单个拥塞控制上下文和单个丢包恢复上下文（如《QUIC恢复》中所述）就足够应对了。比如，终端可以推迟切换至新的拥塞控制上下文，直到它确认不再需要旧路径（就像第9.3.3章中描述的情形一样）。
发送方可以将探测数据包视作特例，以使得它们的丢包检测是独立的且不会使得拥塞控制器过度地抑制它的发送速率。当发送通道挑战帧时，终端可以设置一个单独的倒计时，并当相应的回复通道帧被接收到时取消倒计时。如果倒计时在回复通道帧前归零，终端可以发送一个新的通道挑战帧并且启动一个时间更长的倒计时。这个倒计时应该如《QUIC恢复》的第6.2.1章描述的那样被设置，并且必须不变得越来越严格。</description>
    </item>
    
    <item>
      <title>9.4. 对头部保护的分析</title>
      <link>/RFC9001_Chinese_Translation/Security_Considerations/9.4_Header_Protection_Analysis/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9001_Chinese_Translation/Security_Considerations/9.4_Header_Protection_Analysis/</guid>
      <description>《NAN》分析了许多能保护随机数的认证加密算法，它们被称为“随机数隐藏”（HN）转换。本文档中的头部保护构建方法大体上可以算作是这些算法中的其中一种（HN1）。头部保护会在数据包保护AEAD之后被应用，它从AEAD的输出中采样一组字节样本（表达式中的sample），并以此方法使用伪随机函数（表达式中的PRF）来加密头部字段：
protected_field = field XOR PRF(hp_key, sample) 
 本文档中的头部保护的不同之处在于使用伪随机排列（PRP）来代替常规的PRF。然而，由于所有PRP都算作PRF（详见《IMC》），所以这种修改并不违背HN1的构建原则。
由于hp_key与数据包保护密钥不同，因此头部保护能够达到《NAN》中描述的AE2安全级别，从而保护数据包头部中的字段。将来的基于相同构建方式的头部保护变体必须使用PRF来确保获得一致的安全保障。
多次使用相同的密钥和密文样本会有使头部保护失效的风险。使用相同的密钥和密文样本来保护两份不同的包头会泄露受保护字段的异或结果。假设以AEAD作为PRF，如果采样了L个比特位，那么两份密文样本一致的概率约为2-L/2，也就是所谓的生日攻击。对于在本文档中描述的算法，这个概率为264分之一。
为了防止被攻击者修改，数据包头部会受到数据包保护的认证；整个数据包头部都是受认证的额外数据的一部分。受保护的字段有没有被篡改只能在移除数据包保护后才被检测出来。</description>
    </item>
    
    <item>
      <title>9.5 连接迁移对隐私的影响</title>
      <link>/RFC9000_Chinese_Translation/Connection_Migration/9.5_Privacy_Implications_of_Connection_Migration/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9000_Chinese_Translation/Connection_Migration/9.5_Privacy_Implications_of_Connection_Migration/</guid>
      <description>在不同网络路径上使用相同的连接ID将允许被动观测者从那些路径上将网络活动互相关联起来。在不同网络间移动的终端可能不希望它们的网络活动被不是对端的任何实体给关联起来，所以当从不同的本地地址发送时，会使用不同的连接ID，如第5.1章所讨论的那样。为了使这个方法有效，终端应该确保它们提供的那些连接ID不会被任何其他实体找出相关性。
终端随时可以改变传输时所用的目标连接ID为一个从未在别的路径上使用过的值。
当发送自不止一个本地地址时——例如在如第9.2章所描述的发起连接迁移时或在如第9.1章所描述的探测新网络路径时——终端必须不重用连接ID。
类似地，当发送至不止一个目标地址时，终端必须不重用连接ID。由于不受对端控制的网络条件变化，终端可能从一个新的源地址接收到具有相同目标连接ID字段值的数据包，这时它可以在使用新的远程地址时继续使用当前连接ID，但是仍然从相同的本地地址发送。
以上有关重用连接ID的要求仅适用于数据包发送，因为数据包发送时的连接ID不变但是数据包传输的路径发生意想不到的变化的情况是有可能的。例如，在网络经过一段时间的沉默后，客户端恢复发送时，NAT重绑定可能使得数据包在一条新路径上被发送。终端如第9.3章所描述的那样响应这类事件。
为每条新网络路径上双向发送的数据包使用不同的连接ID消除了连接ID对于从不同网络路径中的相同连接间将数据包互相关联的作用。而头部保护确保了数据包号不能被用来关联网络活动。但这无法阻止数据包的其他属性，例如计时和尺寸，被用于关联网络活动。
终端不应该在对端申请了零长度连接ID时发起迁移，因为经过新路径的流量与经过旧路径的会很容易地被关联起来。如果服务器有能力将具有零长度连接ID的数据包与正确的那条连接关联起来，那么这就意味着服务器正使用其他信息来解除数据包的多路复用。举个例子，服务器可以给每个客户端提供唯一的地址——比如通过使用HTTP替代服务（详见《ALTSVC》）。这类能允许不同网络路径上的数据包被正确路由的信息同样能允许非对端的实体关联这些路径上的网络活动。
在沉默一段时间后，客户端在发送流量时可能希望通过切换至新连接ID、源UDP端口或IP地址（详见《RFC8981》）的方法减少网络活动的可关联性。改变用来发送数据包的地址同时会使得服务器检测到连接迁移。这确保了用于支持迁移的机制即使是对没有经历NAT重绑定或实际迁移的客户端来说也是用得上的。改变地址会使得对端重置它的拥塞控制状态（详见第9.4章），所以地址应该仅偶尔地被改变。
耗尽可用连接ID的终端既不能探测新路径或发起迁移，也不能响应探测包或对端发起的迁移。为了确保迁移可行并且在不同路径上发送的数据包不会被关联，终端应该在对端迁移前提供新连接ID，详见第5.1.1章。如果对端可能已经耗尽了可用的连接ID，正在迁移的那个终端可以在所有在新网络路径上发送的数据包中包含一个新连接ID帧。</description>
    </item>
    
    <item>
      <title>9.5. 头部保护的计时侧信道</title>
      <link>/RFC9001_Chinese_Translation/Security_Considerations/9.5_Header_Protection_Timing_Side_Channels/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9001_Chinese_Translation/Security_Considerations/9.5_Header_Protection_Timing_Side_Channels/</guid>
      <description>攻击者可以猜测数据包号或密钥阶段的值，并通过计时侧信道观察终端会不会接受这个值。类似地，对于数据包号长度也可以进行猜测和破解。如果数据包的接收方直接将数据包号重复的数据包丢弃，而没有尝试移除数据包保护，那么它们就会通过计时侧信道暴露此数据包号与一个已接收到的数据包匹配的事实。为了使认证过程不会对侧信道产生影响，必须完整地先移除头部保护、然后恢复数据包号，接着移除数据包保护，从而避免从计时或其他方面的侧信道泄露信息。
在数据包的发送方面，数据包载荷与数据包号的构建和保护过程必须不会从侧信道泄露数据包号或它的编码后长度。
在密钥更新期间，创建新密钥所花费的时间可能通过计时侧信道透露出有没有发生密钥更新。除此之外，当攻击者注入数据包时，该侧信道会泄露被注入的数据包里密钥阶段的值。在接收到密钥更新后，终端应该如第6.3章所述的那样，建立并储存下一组接受用的数据包保护密钥。通过在接收到密钥更新前就建立新密钥，数据包的接收就不会创建出会泄露密钥阶段的值的计时上的信号。
这项要求依赖于不在数据包处理期间建立新密钥，同时它可能需要终端维护三组接收用的数据包保护密钥：上一密钥阶段的、当前密钥阶段的和下一密钥阶段的。作为替代方案，终端可以选择延迟建立下一密钥阶段的数据包保护密钥，直到它弃用旧密钥为止，这使得它在同一时间只需要维护两组接收密钥。</description>
    </item>
    
    <item>
      <title>9.6. 密钥的隔离性</title>
      <link>/RFC9001_Chinese_Translation/Security_Considerations/9.6_Key_Diversity/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9001_Chinese_Translation/Security_Considerations/9.6_Key_Diversity/</guid>
      <description>在使用TLS时，会用到其核心的密钥衍生计划表。由于TLS握手消息被集成进了秘密值计算，QUIC传输参数扩展的使用能够确保握手密钥和1-RTT密钥与运行基于TCP的TLS的服务器所生成出来的密钥不一致。为了降低不同协议间出现密钥碰撞情况的可能性，有额外的措施来提高密钥的隔离性。
QUIC的数据包保护密钥和IV是使用与TLS中不同的标签来衍生的。
为了维持这种隔离性，新版本的QUIC应该为计算数据包保护密钥和IV的密钥，以及头部保护密钥，的衍生过程定义新的标签值。本版本的QUIC使用了字符串quic。其他版本可以使用与版本相关的标签来替换该字符串。
初始秘密值使用的是由协商出的QUIC版本指定的密钥。新的QUIC版本应该为秘密值的计算定义新的盐值。</description>
    </item>
    
    <item>
      <title>9.6.1 传达首选地址</title>
      <link>/RFC9000_Chinese_Translation/Connection_Migration/Servers_Preferred_Address/9.6.1_Communicating_a_Preferred_Address/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9000_Chinese_Translation/Connection_Migration/Servers_Preferred_Address/9.6.1_Communicating_a_Preferred_Address/</guid>
      <description>服务器通过在TLS握手中包含传输参数preferred_address的方式传达首选地址。
服务器可以为每一种地址族（IPv4和IPv6）传达首选地址，以允许客户端选择一个最适合它们网络连接的地址。
一旦握手被确认，客户端就应该选择客户端提供的两个地址中的一个并发起地址验证（详见第8.2章）。客户端从传输参数preferred_address或新连接ID帧中获取并使用任何之前没用过的活跃连接ID来构建数据包。
只要路径验证通过，客户端就应该开始使用新连接ID向新服务器地址发送所有将来的数据包，并且不再使用旧服务器地址。如果地址验证失败，那么客户端必须将所有将来的数据包继续发到服务器的原始IP地址。</description>
    </item>
    
    <item>
      <title>9.6.2 迁移至首选地址</title>
      <link>/RFC9000_Chinese_Translation/Connection_Migration/Servers_Preferred_Address/9.6.2_Migration_to_a_Preferred_Address/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9000_Chinese_Translation/Connection_Migration/Servers_Preferred_Address/9.6.2_Migration_to_a_Preferred_Address/</guid>
      <description>迁移至首选地址的客户端必须在迁移前验证它选择的地址，详见第21.5.3章。
服务器可能在接受一条连接后的任何时间接收到一个发到它的首选IP地址的数据包。如果这个数据包包含了通道挑战帧，那么服务器就要像第8.2章所描述的那样发送回复通道帧。服务器必须保持从它的原始地址发送非探测数据包，直到它在首选地址上接收到了来自客户端的非探测数据包并且它对新路径完成了验证。
服务器必须从它的首选地址探测通向客户端的路径。这有助于抵御由攻击者发起的虚假迁移。
一旦服务器完成了路径验证并且在首选地址上收到了具有新的最大数据包号的非探测数据包，它就开始仅仅从首选IP地址向客户端发送非探测数据包。如果服务器在旧IP地址上接收到了属于这条连接的更加新的数据包，那么服务器应该丢弃它们。服务器可以继续处理在旧IP地址上接收到的被延误的数据包。
服务器在传输参数preferred_address中提供的地址仅对提供地址时所处的连接有效。客户端必须不将它们用于其他连接，包括从当前连接恢复的连接。</description>
    </item>
    
    <item>
      <title>9.6.3 客户端迁移与首选地址的交互</title>
      <link>/RFC9000_Chinese_Translation/Connection_Migration/Servers_Preferred_Address/9.6.3_Interaction_of_Client_Migration_and_Preferred_Address/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9000_Chinese_Translation/Connection_Migration/Servers_Preferred_Address/9.6.3_Interaction_of_Client_Migration_and_Preferred_Address/</guid>
      <description>客户端可能想要在迁移到服务器的首选地址前先进行一次连接迁移。在这种情况下，客户端应该从它的新地址同时对原始的和首选的服务器地址进行路径验证。
如果对服务器首选地址的路径验证通过了，那么客户端必须放弃对原始地址的验证并且迁移至服务器的首选地址。如果对服务器首先地址的路径验证失败了但是对服务器原始地址的的验证成功了，那么客户端可以迁移到它的新地址，并且继续向服务器的原始地址发送数据。
如果在服务器的首选地址接收到的数据包有着与在握手期间观测到的值不同的客户端源地址，那么服务器必须如第9.3.1章和第9.3.2章描述的那样保护自己免受潜在的攻击。除了有意的同时迁移，这种情况还会因为客户端的网络在访问服务器首选地址时使用了不同的NAT绑定而发生。
服务器应该在接收到来自不同地址的探测数据包时向客户端的新地址发起路径验证，详见第8章。
迁移到新地址的客户端应该使用与服务器正使用的地址族一致的首选地址。
由传输参数preferred_address提供的连接ID不是特定于参数中提供的地址的。提供这个连接ID是为了客户端有一个可以用来迁移的连接ID，但客户端可以在任何路径上使用这个连接ID。</description>
    </item>
    
    <item>
      <title>9.7 迁移与IPv6流标签的使用</title>
      <link>/RFC9000_Chinese_Translation/Connection_Migration/9.7_Use_of_IPv6_Flow_Label_and_Migration/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9000_Chinese_Translation/Connection_Migration/9.7_Use_of_IPv6_Flow_Label_and_Migration/</guid>
      <description>使用IPv6发送数据的终端应该应用符合《RFC6437》要求的IPv6流标签，除非本地API不允许设置IPv6流标签。
流标签的生成必须被设计得能够最小化被关联到之前使用过的流标签的可能性，因为固定的流标签将使得多条路径上的网络活动被关联起来，详见第9.5章。
《RFC6437》建议用伪随机函数衍生数据的方式来生成流标签。在生成流标签时除了源地址和目标地址外还包含目标连接ID字段，可以确保流标签和其他能观测到的标识值是同步变化的。使用将这些输入和一个本地秘密值进行组合的加密哈希函数是实现这项要求的方法之一。</description>
    </item>
    
    <item>
      <title>9.7. 随机性</title>
      <link>/RFC9001_Chinese_Translation/Security_Considerations/9.7_Randomness/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9001_Chinese_Translation/Security_Considerations/9.7_Randomness/</guid>
      <description>QUIC依赖于终端生成安全的随机数的能力，这项能力既会被直接用在协议里的一些值上，如连接ID，也会经由TLS被使用到。有关安全的随机数生成的指导，详见《RFC4086》。</description>
    </item>
    
    <item>
      <title>10.1.1 存活确认</title>
      <link>/RFC9000_Chinese_Translation/Connection_Termination/Idle_Timeout/10.1.1_Liveness_Testing/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9000_Chinese_Translation/Connection_Termination/Idle_Timeout/10.1.1_Liveness_Testing/</guid>
      <description>在临近正在生效的超时时间时发送数据包的终端需要承担数据包被对端丢弃的风险，因为在这些数据包到达之前，对端的空闲时间可能已经逾期。
如果对端可能距离超时所剩的时间不多了，例如不到一个PTO，那么终端可以发送一个Ping帧或其他引发确认的帧来测试连接是否存活，详见《QUIC恢复》的第6.2章。这在没有可用的应用数据以供安全地重发时尤其有用。注意，哪些数据可以安全地重发是由应用决定的。</description>
    </item>
    
    <item>
      <title>10.1.2 推迟空闲超时</title>
      <link>/RFC9000_Chinese_Translation/Connection_Termination/Idle_Timeout/10.1.2_Deferring_Idle_Timeout/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9000_Chinese_Translation/Connection_Termination/Idle_Timeout/10.1.2_Deferring_Idle_Timeout/</guid>
      <description>如果终端正在等待响应数据但是没有或无法发送应用数据，那么终端可能需要发送ACK触发包以避免空闲超时。
QUIC实现可以向应用提供选项来推迟空闲超时。当应用希望避免丢失已经和一条连接关联的状态但不希望花时间重新交换应用数据，那么就可以使用这个选项。开启这个选项时，终端可以定期发送一个Ping帧（详见第19.2章），这会使得对端重置自己的空闲超时定时器。如果这包含Ping帧的数据包是自上一次接收到数据包后发送的第一个ACK触发包，那么发送这个包还会重置当前终端的空闲超时定时器。发送Ping帧会使得对端用确认来响应，这也会重置当前终端的空闲超时定时器。
使用QUIC的应用协议应该提供有关合适的推迟空闲超时的时机的指导。不必要地发送Ping帧可能对性能有负面影响。
如果一条连接上在一段超过用传输参数max_idle_timeout协商的时间内，没有数据包被发送或接收，那么这条连接会超时，详见第10章。然而，网络中间设备的状态可能比那个时间更早地超时。尽管《RFC4787》中的第5条要求推荐了每2分钟的超时间隔，但是经验表明至少要每30秒发送一次数据包才能避免大多数中间设备丢失有关UDP流量的状态，详见《GATEWAY》。</description>
    </item>
    
    <item>
      <title>10.2.1 连接的关闭状态</title>
      <link>/RFC9000_Chinese_Translation/Connection_Termination/Immediate_Close/10.2.1_Closing_Connection_State/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9000_Chinese_Translation/Connection_Termination/Immediate_Close/10.2.1_Closing_Connection_State/</guid>
      <description>终端发起立即关闭后进入关闭状态。
在关闭状态下，终端仅保留足够用于创建包含连接关闭帧的数据包和用于区分数据包是否属于此条已关闭连接的信息。处于关闭状态的终端发送包含连接关闭帧的数据包来响应任何属于这条连接的传入数据包。
终端应该限制它在关闭状态下创建数据包的速率。比如，终端可以在响应接收到的数据包前等待足够的数据包或时间，且等待的数据包数量或时间长短是逐渐增长的。
终端选择的连接ID和QUIC版本是区分数据包是否属于一条关闭状态的连接的充分信息；终端可以丢弃所有其他连接状态数据。处于关闭状态的终端没有必要处理任何接收到的帧。终端可以为传入数据包保留数据包保护密钥用于读取和处理连接关闭帧。
当进入关闭状态时，终端可以丢弃数据包保护密钥，然后在响应任何接收到的UDP数据报时都发送包含连接关闭帧的数据包。然而，丢弃了数据包保护密钥的终端没有能力区分并丢弃不合法的数据包。为了避免被用于放大攻击，这样的终端必须限制它发出的数据包尺寸总和不超过它接收到的且属于这条连接的数据包尺寸总和的三倍。为了最小化终端为关闭状态的连接所维护的状态数据，终端可以在响应任何接收到的数据包时发送完全相同的数据包。
 注意：允许在关闭状态下重传完全相同的数据包是“每个数据包都必须使用新的数据包号”要求的一个特例，详见第12.3章。发送新的数据包号主要是用于丢包恢复和拥塞控制，但这两者都和一个已关闭的连接关系不大。重传这最后一个数据包需要的状态数据更少。
 当处于关闭状态时，终端可能从新的源地址接收到数据包，这可能是连接迁移的结果；详见第9章。处于关闭状态的终端必须要么丢弃从未经验证的地址接收到的数据包，要么限制它发向未经验证的地址的数据包尺寸总和，使其小于它从那个地址接收到的数据包的尺寸总和。
处于关闭状态的终端不应处理密钥更新（详见《QUIC-TLS》的第6章）。密钥更新可能阻止终端从关闭状态转移到排空状态，因为终端将失去处理后续接收到的数据包的能力，但这没有什么影响。</description>
    </item>
    
    <item>
      <title>10.2.2 连接的排空状态</title>
      <link>/RFC9000_Chinese_Translation/Connection_Termination/Immediate_Close/10.2.2_Draining_Connection_State/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9000_Chinese_Translation/Connection_Termination/Immediate_Close/10.2.2_Draining_Connection_State/</guid>
      <description>一旦终端接收到连接关闭帧，他就会进入排空状态，这表明对端已处于关闭或排空状态。虽然在其他方面都和关闭状态一致，不过处于排空状态的终端必须不发送任何数据包。一旦连接处于排空状态，就没有必要再保留数据包保护密钥了。
接收到连接关闭帧的终端可以再进入排空状态前发送一个包含连接关闭帧的数据包，并且，如若合适，使用NO_ERROR（无错误）代码。除此之外，终端必须不发送更多数据包。不这么做会导致两个终端间保持不断交换连接关闭帧的状态，直到其中一个终端退出关闭状态。
如果终端接收到了连接关闭帧，那么它可以从关闭状态进入排空状态，这表明对端也处于关闭或排空状态。在这种情况下，排空状态会在原来关闭状态应该结束时结束。换句话说，终端使用相同的状态结束时机但是不再在这条连接上传输数据包。</description>
    </item>
    
    <item>
      <title>10.2.3 在握手期间立即关闭</title>
      <link>/RFC9000_Chinese_Translation/Connection_Termination/Immediate_Close/10.2.3_Immediate_Close_during_the_Handshake/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9000_Chinese_Translation/Connection_Termination/Immediate_Close/10.2.3_Immediate_Close_during_the_Handshake/</guid>
      <description>发送连接关闭帧时，要确保对端会处理这个帧。通常来说，这意味着将这个帧放到具有最高级别的数据包保护的数据包中发送，以避免数据包被丢弃。在握手确认后（详见《QUIC-TLS》的第4.1.2章），终端必须在1-RTT数据包中发送任何连接关闭帧。然而，在确认握手前，更高级的数据包保护密钥有可能在对端那还不可用，所以可以使用具有较低数据包保护级别的数据包多发送一个连接关闭帧。具体来说：
  客户端总是知道服务器有没有握手密钥（详见第17.2.2.1章），但是服务器不确定客户端有没有握手密钥。在这种条件下，服务器应该用握手数据包和初始数据包各发送一个连接关闭帧来确保它们中的至少一个是客户端可以处理的。
  在0-RTT数据包中发送连接关闭帧的客户端不能确信服务器会同意0-RTT的使用。用初始数据包发送连接关闭帧使得服务器更有可能接收到关闭的信号，哪怕应用错误码可能不会被接收到。
  在确认握手前，对端可能无法处理1-RTT数据包，所以终端应该用握手数据包和1-RTT数据包各发送一个连接关闭帧。服务器则应该用初始数据包发送连接关闭帧。
  用初始数据包或握手数据包发送类型为0x1d的连接关闭帧会暴露应用状态或被用于更改应用状态。用初始数据包或握手数据包发送时，必须将类型为0x1d的连接关闭帧替换为类型为0x1c的连接关闭帧。否则，有关应用状态的信息可能被泄露。终端在转换连接关闭帧的类型到0x1c时必须清除原因语句字段的值，并且应该使用APPLICATION_ERROR（应用错误）代码。
用不同数据包类型发送的连接关闭帧可以被合并至单个UDP数据报中；详见第12.2章。
终端可以用初始数据包发送连接关闭帧。这时可能是在响应接收自初始数据包或握手数据包的未通过认证的信息。这样的立即关闭行为可能将合法的连接暴露在拒绝服务攻击之下。QUIC对于握手过程中来自路径上设备的攻击并不提供防御措施；详见第21.2章。然而，如果牺牲发向合法对端的关于错误的反馈，并且终端直接丢弃不合法的数据包而不是用关闭连接帧终止连接，那么部分形式的拒绝服务攻击对于攻击者来说会变得更难实施。出于这个原因，如果在缺乏认证的数据包中检测出了错误，那么终端可以丢弃数据包而不是选择立即关闭。
尚未建立状态的终端，例如在初始数据包中检测到错误的服务器，并不会进入关闭状态。在发送连接关闭帧时，没有关于连接的状态的终端不会进入关闭或排空状态。</description>
    </item>
    
    <item>
      <title>10.3.1 检测无状态重置</title>
      <link>/RFC9000_Chinese_Translation/Connection_Termination/Stateless_Reset/10.3.1_Detecting_a_Stateless_Reset/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9000_Chinese_Translation/Connection_Termination/Stateless_Reset/10.3.1_Detecting_a_Stateless_Reset/</guid>
      <description>终端使用UDP数据报末尾的16个字节检测可能的无状态重置。终端记录所有无状态重置令牌，这些令牌关联着连接ID和终端最近发送的数据报的目标远程地址。这些令牌来自新连接ID帧的无状态重置令牌字段和服务器的传输参数，但不包含那些与未使用的或已停用的连接ID关联的无状态重置令牌。终端通过比较数据报的最后16个字节和所有与发送数据报的远程地址关联的无状态重置令牌，来将接收到的数据报识别为无状态重置。
这种比较可以为每个传入数据报进行。如果来自某个数据报的数据包被成功处理了，那么终端可以跳过这个检查。然而，如果一个传入数据报的首个数据包不能与一条连接关联上，或不能被解密，那么必须进行这种比较。
终端必须不为任何关联到它尚未使用或已停用的连接ID上的无状态重置令牌做检查。
在将数据报和无状态重置令牌的值比较时，终端必须在不泄露令牌的值的前提下进行比较。比如，用固定时间进行比较能保护无状态重置令牌免于利用计时侧信道的信息泄露。另一种方法是存储并比较经转换的无状态重置令牌值而不是原始的令牌值，这种转换指的是使用密钥并在密码学上安全的伪随机函数（例如数据块加密算法和散列消息认证码（HMAC，详见《RFC2104》））。终端不必保护有关数据包是否被成功解密和有效的无状态重置令牌数量的信息。
如果数据报的最后16个字节与无状态重置令牌的值一致，那么终端必须进入排空状态，并且在此连接上不再发送数据包。</description>
    </item>
    
    <item>
      <title>10.3.2 计算无状态重置令牌</title>
      <link>/RFC9000_Chinese_Translation/Connection_Termination/Stateless_Reset/10.3.2_Calculating_a_Stateless_Reset_Token/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9000_Chinese_Translation/Connection_Termination/Stateless_Reset/10.3.2_Calculating_a_Stateless_Reset_Token/</guid>
      <description>无状态重置令牌必须难以被猜测。为了创建无状态重置令牌，终端可以为每一个它创建的连接随机生成（详见《RANDOM》）一个秘密值。然而，当集群中有多个实例时它会带来协调上的问题，以及在终端丢失状态时带来存储上的问题。无状态重置是为了处理状态丢失的情况而专门设计的，因此这个方法不是最理想的。
通过使用以固定密钥和由终端选择的连接ID（详见第5.1章）作为输入的伪随机函数来生成令牌，单个固定密钥可以被用于与同一个终端有关的所有连接。终端可以使用HMAC（详见《RFC2104》）（例如，HMAC(固定密钥, 连接ID)）或基于HMAC的密钥衍生函数（HKDF，详见《RFC5869》）（例如，使用固定密钥作为输入密钥材料，使用连接ID作为盐）。这个函数的输出被截断至16字节来作为连接的无状态重置令牌。
丢失状态的终端可以使用相同的方法来生成有效的无状态重置令牌。连接ID来自终端接收到的那个数据包。
这种设计要求对端总是在数据包中发送连接ID，这样终端才可以使用来自数据包的连接ID来重置连接。使用这种设计的终端必须要么为所有连接使用相同长度的连接ID，要么将连接ID长度编码进连接ID以使得它可以在没有状态的情况下恢复。除此之外，它不能提供零长度连接ID。
泄露无状态重置令牌将允许任何实体终止连接，所以一个令牌值只能被使用一次。这种选择无状态重置令牌的方法意味着相同连接ID和固定密钥的组合必须不被用于另一个连接。如果共享同一个固定密钥的实例还使用了相同的连接ID，或者攻击者可以使数据包被路由到没有状态但是使用相同固定密钥的实例，那么就有可能发起拒绝服务攻击；详见第21.11章。如果一个连接ID所在的连接已通过使用无状态重置令牌的方法重置过，那么在共享相同固定密钥的节点上必须不将这个连接ID用于新的连接。
同一个无状态重置令牌必须不被用于多个连接ID。终端不需要将新的令牌值与所有先前的值进行比较，但是重复的值可能被视作类型为PROTOCOL_VIOLATION（协议违反）的连接错误。
注意，无状态重置不受到任何加密保护。</description>
    </item>
    
    <item>
      <title>10.3.3 死循环</title>
      <link>/RFC9000_Chinese_Translation/Connection_Termination/Stateless_Reset/10.3.3_Looping/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9000_Chinese_Translation/Connection_Termination/Stateless_Reset/10.3.3_Looping/</guid>
      <description>无状态重置的设计使得在不知道无状态重置令牌的情况下无法将它与合法的数据包区分开来。举例来说，如果一个服务器往另一个服务器发送了无状态重置，那么作为响应它可能收到另一个无状态重置，这会导致无尽的数据包交换。
终端必须确保每一个它发出的无状态重置都比触发它的数据包要小，除非终端维护着足以避免死循环的状态数据。在循环出现的情况下，这使得数据包最终变得过小而不能触发响应。
终端可以记录它已发送的无状态重置数量并且一旦到达限制数量就不再创建新的无状态重置。为不同的远程地址使用单独的限制可以确保其他对端或连接已到达限制时还能够使用无状态重置来关闭连接。
取决于对端的连接ID长度，小于41字节的无状态重置可能被观察者识别为无状态重置。反过来，对小型数据包不响应无状态重置可能导致无状态重置不能有效地检测连接损坏但是只有小型数据包被发送的情况；这样的失败可能只能被其他方法检测出来，例如计时器。</description>
    </item>
    
    <item>
      <title>11.1 连接错误</title>
      <link>/RFC9000_Chinese_Translation/Error_Handling/11.1_Connection_Errors/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9000_Chinese_Translation/Error_Handling/11.1_Connection_Errors/</guid>
      <description>如果出现的错误会导致连接变得不可用，比如违背了协议语义或损坏了可能影响整条连接的状态数据，那么必须使用连接关闭帧（详见第19.19章）来发送信号。
与应用相关的协议的错误出现时，使用帧类型为0x1d的连接关闭帧来发送信号。与传输相关的错误，包括所有在这份文档中描述的错误，都用帧类型为0x1c的连接关闭帧来携带。
携带连接关闭帧的数据包可能会遭遇丢包。终端应该准备好当在一条已终止的连接上收到更多数据包时，重传包含连接关闭帧的数据包。限制重传的次数和发送这个最终的数据包的时机能够限制在已终止的连接上投入的资源。
选择不重传连接关闭帧的终端需要承担对端错失首个包含连接关闭帧的数据包的风险。在一条已终止的连接上继续接收数据的终端，其唯一可用的机制是启动无状态重置的流程（第10.3章）。
鉴于初始数据包的AEAD不提供强力的认证，终端可以丢弃不合法的初始数据包。即使在本规范要求产生连接错误的地方，丢弃初始数据包也是允许的。只有终端不能处理某个数据包中的帧或回退所有已处理部分产生的副作用时，它才能丢弃这个数据包。丢弃不合法的初始数据包可以被用来减少拒绝服务产生的风险，详见第21.2章。</description>
    </item>
    
    <item>
      <title>11.1. 规范性参考文献</title>
      <link>/RFC9001_Chinese_Translation/References/11.1_Normative_References/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9001_Chinese_Translation/References/11.1_Normative_References/</guid>
      <description>[AEAD]：  McGrew, D., &amp;ldquo;An Interface and Algorithms for Authenticated Encryption&amp;rdquo;, RFC 5116, DOI 10.17487/RFC5116, January 2008, https://www.rfc-editor.org/info/rfc5116.
 [AES]：  &amp;ldquo;Advanced encryption standard (AES)&amp;rdquo;, National Institute of Standards and Technology report, DOI 10.6028/nist.fips.197, November 2001, https://doi.org/10.6028/nist.fips.197.
 [ALPN]：  Friedl, S., Popov, A., Langley, A., and E. Stephan, &amp;ldquo;Transport Layer Security (TLS) Application-Layer Protocol Negotiation Extension&amp;rdquo;, RFC 7301, DOI 10.17487/RFC7301, July 2014, https://www.rfc-editor.org/info/rfc7301.
 [CHACHA]：  Nir, Y. and A.</description>
    </item>
    
    <item>
      <title>11.2 流错误</title>
      <link>/RFC9000_Chinese_Translation/Error_Handling/11.2_Stream_Errors/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9000_Chinese_Translation/Error_Handling/11.2_Stream_Errors/</guid>
      <description>如果一个应用层错误仅影响了单个流且它所在的连接处于可以恢复的状态，那么终端可以发送一个使用适当的错误码的流重置帧（详见第19.4章）来仅仅终止受影响的流。
对流进行重置而不通知应用协议会使得应用协议进入不可恢复的状态。流重置帧必须只能由使用QUIC的应用协议发起。
在流重置帧中携带的应用错误码的语义是由应用协议定义的。只有应用协议有能力终止一条流。应用协议的本地实例直接调用API，远程实例则可以使用会自动触发流重置帧的停止发送帧。
应用协议应该定义规则来处理被任一终端提前取消的流。</description>
    </item>
    
    <item>
      <title>11.2. 资料性参考文献</title>
      <link>/RFC9001_Chinese_Translation/References/11.2_Informative_References/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9001_Chinese_Translation/References/11.2_Informative_References/</guid>
      <description>[AEBounds]：  Luykx, A. and K. Paterson, &amp;ldquo;Limits on Authenticated Encryption Use in TLS&amp;rdquo;, 28 August 2017, https://www.isg.rhul.ac.uk/~kp/TLS-AEbounds.pdf.
 [ASCII]：  Cerf, V., &amp;ldquo;ASCII format for network interchange&amp;rdquo;, STD 80, RFC 20, DOI 10.17487/RFC0020, October 1969, https://www.rfc-editor.org/info/rfc20.
 [CCM-ANALYSIS]：  Jonsson, J., &amp;ldquo;On the Security of CTR + CBC-MAC&amp;rdquo;, Selected Areas in Cryptography, SAC 2002, Lecture Notes in Computer Science, vol 2595, pp. 76-93, DOI 10.1007/3-540-36492-7_7, 2003, https://doi.org/10.1007/3-540-36492-7_7.
 [COMPRESS]：  Ghedini, A.</description>
    </item>
    
    <item>
      <title>12.1 受保护的数据包</title>
      <link>/RFC9000_Chinese_Translation/Packets_and_Frames/12.1_Protected_Packets/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9000_Chinese_Translation/Packets_and_Frames/12.1_Protected_Packets/</guid>
      <description>根据数据包类型不同，QUIC数据包具有不同级别的加密保护。有关数据包保护的细节，详见《QUIC-TLS》；本节对这种保护做了概述。
版本协商数据包没有加密保护，详见《QUIC不变量》。
重试数据包使用AEAD函数（带有关联数据的认证加密，详见《AEAD》）来保护数据包免于意外修改。
初始数据包也使用AEAD函数，函数的密钥是用一个在传输中对外界可见的值衍生出来的。因此初始数据包不具有有效的可信度保护。使用初始数据包保护是为了确保数据包发送方是存在于当前网络路径上的。任何接收到来自客户端的初始数据包的实体都能重建出一个密钥，这个密钥既能让它们读取数据包的内容，也可以让它们创建出能被任一终端认证成功的初始数据包。AEAD函数还保护初始数据包免于意外修改。
其他所有数据包都受衍生自加密握手的密钥保护。加密握手确保了只有正在交流的终端才能够接收到用于握手数据包、0-RTT数据包和1-RTT数据包的相应密钥。受0-RTT和1-RTT密钥保护的数据包具有强力的可信度和完整性保护。
某些数据包类型中出现的数据包号字段具有可替代的可信度保护，这种保护被用作头部保护的一部分，详见《QUIC-TLS》的第5.4章。在给定的数据包号空间中，受保护的数据包号会随着数据包的发送而增加，详见第12.3章。</description>
    </item>
    
    <item>
      <title>A.1. 密钥</title>
      <link>/RFC9001_Chinese_Translation/Sample_Packet_Protection/A.1_Keys/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9001_Chinese_Translation/Sample_Packet_Protection/A.1_Keys/</guid>
      <description>在HKDF-Expand-Label函数的执行期间生成的标签（也就是HkdfLabel.label），以及传给HKDF-Expand函数的参数为：
client in: 00200f746c73313320636c69656e7420696e00
server in: 00200f746c7331332073657276657220696e00
quic key: 00100e746c7331332071756963206b657900
quic iv: 000c0d746c733133207175696320697600
quic hp: 00100d746c733133207175696320687000
初始秘密值是通用的：
initial_secret = HKDF-Extract(initial_salt, cid) = 7db5df06e7a69e432496adedb0085192 3595221596ae2ae9fb8115c1e9ed0a44 
 用于保护客户端数据包的秘密值为：
client_initial_secret = HKDF-Expand-Label(initial_secret, &amp;quot;client in&amp;quot;, &amp;quot;&amp;quot;, 32) = c00cf151ca5be075ed0ebfb5c80323c4 2d6b7db67881289af4008f1f6c357aea key = HKDF-Expand-Label(client_initial_secret, &amp;quot;quic key&amp;quot;, &amp;quot;&amp;quot;, 16) = 1f369613dd76d5467730efcbe3b1a22d iv = HKDF-Expand-Label(client_initial_secret, &amp;quot;quic iv&amp;quot;, &amp;quot;&amp;quot;, 12) = fa044b2f42a3fd3b46fb255c hp = HKDF-Expand-Label(client_initial_secret, &amp;quot;quic hp&amp;quot;, &amp;quot;&amp;quot;, 16) = 9f50449e04a0e810283a1e9933adedd2 
 用于保护服务器数据包的秘密值为：
server_initial_secret = HKDF-Expand-Label(initial_secret, &amp;quot;server in&amp;quot;, &amp;quot;&amp;quot;, 32) = 3c199828fd139efd216c155ad844cc81 fb82fa8d7446fa7d78be803acdda951b key = HKDF-Expand-Label(server_initial_secret, &amp;quot;quic key&amp;quot;, &amp;quot;&amp;quot;, 16) = cf3a5331653c364c88f0f379b6067e37 iv = HKDF-Expand-Label(server_initial_secret, &amp;quot;quic iv&amp;quot;, &amp;quot;&amp;quot;, 12) = 0ac1493ca1905853b0bba03e hp = HKDF-Expand-Label(server_initial_secret, &amp;quot;quic hp&amp;quot;, &amp;quot;&amp;quot;, 16) = c206b8d9b9f0f37644430b490eeaa314</description>
    </item>
    
    <item>
      <title>12.2 合并数据包</title>
      <link>/RFC9000_Chinese_Translation/Packets_and_Frames/12.2_Coalescing_Packets/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9000_Chinese_Translation/Packets_and_Frames/12.2_Coalescing_Packets/</guid>
      <description>初始数据包（详见第17.2.2章）、0-RTT数据包（第17.2.3章）和握手数据包（第17.2.4章）包含可以用来判断数据包末尾位置的长度字段。这个长度既包括数据包号字段也包括载荷字段，这两个字段都被可信地保护着的，一开始它们的长度都是未知的。但只要头部保护被移除，就能知道载荷字段的长度。
使用长度字段，发送方可以将数个QUIC数据包合并至单个UDP数据报中。这可以减少为了完成加密握手并开始发送数据所需的UDP数据报数量。这也可以被用于构造路径最大传输单元（PMTU）探测包，详见第14.4.1章。接收方必须有能力处理被合并的数据包。
用加密级别递增（初始、0-RTT、握手、1-RTT；详见《QUIC-TLS》的第4.1.4章）的顺序合并数据包更有可能使接收方有能力一次性处理所有数据包。具有短包头的数据包并不包含长度，所以它只能作为最后一个数据包被包含进UDP数据报中。如果多个帧将以相同的加密级别发送，那么终端应该将它们包含在单个数据包中，而不是合并多个相同加密级别的数据包。
接收方可以根据UDP数据报包含的第一个数据包的信息来做路由。发送方必须不将具有不同连接ID的QUIC数据包合并至单个UDP数据报中。如果后续的某个数据包的目标连接ID字段与数据报中第一个数据包的值不同，那么接收方应该忽略这个数据包。
任何被合并至单个UDP数据报的QUIC数据包都是独立且完整的。被合并的QUIC数据包的接收方必须独立处理每个QUIC数据包并单独确认它们，就好像它们是作为不同UDP数据报的载荷被接收的。例如，如果对一个数据包的解密失败了（因为密钥出于某个理由而不可用），那么接收方可以要么丢弃这个数据包要么缓存它以供将来处理，并且必须尝试处理余下的数据包。
重试数据包（详见第17.2.5章）、版本协商数据包（第17.2.1章）和具有短包头的数据包（第17.3章）并不包含长度字段，因此在同一个UDP数据报中不能有其他数据包跟在它们后面。还要注意，不存在将重试数据包和版本协商数据包与另一个数据包合并的情况。</description>
    </item>
    
    <item>
      <title>A.2. 客户端初始数据包</title>
      <link>/RFC9001_Chinese_Translation/Sample_Packet_Protection/A.2_Client_Initial/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9001_Chinese_Translation/Sample_Packet_Protection/A.2_Client_Initial/</guid>
      <description>客户端会发送初始数据包。该数据包未经保护的载荷中包含着加密帧，以及足够多的填充帧以使得载荷长度达到1162字节：
060040f1010000ed0303ebf8fa56f129 39b9584a3896472ec40bb863cfd3e868 04fe3a47f06a2b69484c000004130113 02010000c000000010000e00000b6578 616d706c652e636f6dff01000100000a 00080006001d00170018001000070005 04616c706e0005000501000000000033 00260024001d00209370b2c9caa47fba baf4559fedba753de171fa71f50f1ce1 5d43e994ec74d748002b000302030400 0d0010000e0403050306030203080408 050806002d00020101001c0002400100 3900320408ffffffffffffffff050480 00ffff07048000ffff08011001048000 75300901100f088394c8f03e51570806 048000ffff 
 在未经保护的头部中，长度字段的值表示着后方数据的总长度，即1182字节：4字节长的数据包号，1162字节长的帧，还有16字节长的认证标签。头部中还包含了连接ID和值为2的数据包号：
c300000001088394c8f03e5157080000449e00000002 
 对载荷进行保护后，其输出密文会被头部保护采样。因为头部中的数据包号被编码为四字节，所以受保护载荷的前16个字节被作为样本（sample），应用在头部保护中：
sample = d1b1c98dd7689fb8ec11d242b123dc9b mask = AES-ECB(hp, sample)[0..4] = 437b9aec36 header[0] ^= mask[0] &amp;amp; 0x0f = c0 header[18..21] ^= mask[1..4] = 7b9aec34 header = c000000001088394c8f03e5157080000449e7b9aec34 
 最后，经保护的数据包的内容为：
c000000001088394c8f03e5157080000 449e7b9aec34d1b1c98dd7689fb8ec11 d242b123dc9bd8bab936b47d92ec356c 0bab7df5976d27cd449f63300099f399 1c260ec4c60d17b31f8429157bb35a12 82a643a8d2262cad67500cadb8e7378c 8eb7539ec4d4905fed1bee1fc8aafba1 7c750e2c7ace01e6005f80fcb7df6212 30c83711b39343fa028cea7f7fb5ff89 eac2308249a02252155e2347b63d58c5 457afd84d05dfffdb20392844ae81215 4682e9cf012f9021a6f0be17ddd0c208 4dce25ff9b06cde535d0f920a2db1bf3 62c23e596d11a4f5a6cf3948838a3aec 4e15daf8500a6ef69ec4e3feb6b1d98e 610ac8b7ec3faf6ad760b7bad1db4ba3 485e8a94dc250ae3fdb41ed15fb6a8e5 eba0fc3dd60bc8e30c5c4287e53805db 059ae0648db2f64264ed5e39be2e20d8 2df566da8dd5998ccabdae053060ae6c 7b4378e846d29f37ed7b4ea9ec5d82e7 961b7f25a9323851f681d582363aa5f8 9937f5a67258bf63ad6f1a0b1d96dbd4 faddfcefc5266ba6611722395c906556 be52afe3f565636ad1b17d508b73d874 3eeb524be22b3dcbc2c7468d54119c74 68449a13d8e3b95811a198f3491de3e7 fe942b330407abf82a4ed7c1b311663a c69890f4157015853d91e923037c227a 33cdd5ec281ca3f79c44546b9d90ca00 f064c99e3dd97911d39fe9c5d0b23a22 9a234cb36186c4819e8b9c5927726632 291d6a418211cc2962e20fe47feb3edf 330f2c603a9d48c0fcb5699dbfe58964 25c5bac4aee82e57a85aaf4e2513e4f0 5796b07ba2ee47d80506f8d2c25e50fd 14de71e6c418559302f939b0e1abd576 f279c4b2e0feb85c1f28ff18f58891ff ef132eef2fa09346aee33c28eb130ff2 8f5b766953334113211996d20011a198 e3fc433f9f2541010ae17c1bf202580f 6047472fb36857fe843b19f5984009dd c324044e847a4f4a0ab34f719595de37 252d6235365e9b84392b061085349d73 203a4a13e96f5432ec0fd4a1ee65accd d5e3904df54c1da510b0ff20dcc0c77f cb2c0e0eb605cb0504db87632cf3d8b4 dae6e705769d1de354270123cb11450e fc60ac47683d7b8d0f811365565fd98c 4c8eb936bcab8d069fc33bd801b03ade a2e1fbc5aa463d08ca19896d2bf59a07 1b851e6c239052172f296bfb5e724047 90a2181014f3b94a4e97d117b4381303 68cc39dbb2d198065ae3986547926cd2 162f40a29f0c3c8745c0f50fba3852e5 66d44575c29d39a03f0cda721984b6f4 40591f355e12d439ff150aab7613499d bd49adabc8676eef023b15b65bfc5ca0 6948109f23f350db82123535eb8a7433 bdabcb909271a6ecbcb58b936a88cd4e 8f2e6ff5800175f113253d8fa9ca8885 c2f552e657dc603f252e1a8e308f76f0 be79e2fb8f5d5fbbe2e30ecadd220723 c8c0aea8078cdfcb3868263ff8f09400 54da48781893a7e49ad5aff4af300cd8 04a6b6279ab3ff3afb64491c85194aab 760d58a606654f9f4400e8b38591356f bf6425aca26dc85244259ff2b19c41b9 f96f3ca9ec1dde434da7d2d392b905dd f3d1f9af93d1af5950bd493f5aa731b4 056df31bd267b6b90a079831aaf579be 0a39013137aac6d404f518cfd4684064 7e78bfe706ca4cf5e9c5453e9f7cfd2b 8b4c8d169a44e55c88d4a9a7f9474241 e221af44860018ab0856972e194cd934</description>
    </item>
    
    <item>
      <title>12.3 数据包号</title>
      <link>/RFC9000_Chinese_Translation/Packets_and_Frames/12.3_Packet_Numbers/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9000_Chinese_Translation/Packets_and_Frames/12.3_Packet_Numbers/</guid>
      <description>数据包号是范围在0至262-1中的整数。这个数值被用来为数据包保护决定加密随机值。每个终端为发送和接收分别维护单独的数据包号。
数据包号被限制在这个范围内是因为它们需要在ACK帧（详见第19.3章）的最大确认数字段中被完整表示。然而在长包头或短包头中表示时，数据包号被截断并被编码至1至4字节中，详见第17.1章。
版本协商数据包（详见第17.2.1章）和重试数据包（第17.2.5章）并不包含数据包号。
在QUIC中，数据包号被划分到三个空间里：
 初始空间（Initial space）：  所有初始数据包（详见第17.2.2章）都在这个空间中。
 握手空间（Handshake space）：  所有握手数据包（详见第17.2.4章）都在这个空间中。
 应用数据空间（Application data space）：  所有0-RTT数据包（详见第17.2.3章）和1-RTT数据包（第17.3.1章）都在这个空间中。
  如《QUIC-TLS》所述，每种数据包类型使用不同的保护密钥。
概念上，数据包号空间是数据包被处理和确认的上下文。初始数据包只能使用初始数据包保护密钥发送，也只能在初始数据包中被确认。类似地，握手数据包使用握手加密级别发送，且只能在握手数据包中被确认。
这样，在不同数据包号空间中发送的数据的加密得到了强制隔离。每个空间中的数据包号都从0开始。在相同数据包号空间中发送的后续数据包必须将数据包号增加至少1。
0-RTT数据和1-RTT数据出现在相同数据包号空间，是为了使得丢包检测算法在这两种数据包类型间更好实现。
在一条连接的同一个数据包号空间中，QUIC终端必须不重用数据包号。如果发送用的数据包号到达了262-1，发送方必须关闭连接但不发送任何连接关闭帧或更多数据包；终端可以发送一个无状态重置（详见第10.3章）以响应将来它接收到的数据包。
除非接收方确信它没有处理过另一个具有相同数据包号空间和数据包号的数据包，否则它必须丢弃眼前刚去除保护的数据包。出于在《QUIC-TLS》的第9.5章中所述的原因，必须在移除数据包保护后进行这个去除重复的步骤。
为了检测重复的目的而追踪一个个数据包的终端会面临状态数据不断扩容的风险。检测重复所需的数据可以通过维护一个最小的数据包号来限制，低于这个数据包号的数据包都会被立即丢弃。使用任何最小的数据包号时，都要考虑往返时间可能发生的大幅度变化，原因之一是对端可能用更大的往返时间来探测网络路径，详见第9章。
有关数据包号在发送方的编码和在接收方的解码，详见第17.1章。</description>
    </item>
    
    <item>
      <title>A.3. 服务器初始数据包</title>
      <link>/RFC9001_Chinese_Translation/Sample_Packet_Protection/A.3_Server_Initial/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9001_Chinese_Translation/Sample_Packet_Protection/A.3_Server_Initial/</guid>
      <description>作为回应，服务器会发送以下载荷，其中包含一个ACK帧和一个加密帧，并且不包含填充帧：
02000000000600405a020000560303ee fce7f7b37ba1d1632e96677825ddf739 88cfc79825df566dc5430b9a045a1200 130100002e00330024001d00209d3c94 0d89690b84d08a60993c144eca684d10 81287c834d5311bcf32bb9da1a002b00 020304 
 来自服务器的头部包含着一个新的连接ID和一个值为1且被编码至双字节中数据包号：
c1000000010008f067a5502a4262b50040750001 
 对载荷进行保护后，从第三个密文字节起的一段数据被取作头部保护的样本。
sample = 2cd0991cd25b0aac406a5816b6394100 mask = 2ec0d8356a header = cf000000010008f067a5502a4262b5004075c0d9 
 最后，经保护的数据包的内容为：
cf000000010008f067a5502a4262b500 4075c0d95a482cd0991cd25b0aac406a 5816b6394100f37a1c69797554780bb3 8cc5a99f5ede4cf73c3ec2493a1839b3 dbcba3f6ea46c5b7684df3548e7ddeb9 c3bf9c73cc3f3bded74b562bfb19fb84 022f8ef4cdd93795d77d06edbb7aaf2f 58891850abbdca3d20398c276456cbc4 2158407dd074ee 
 </description>
    </item>
    
    <item>
      <title>12.4 帧和帧类型</title>
      <link>/RFC9000_Chinese_Translation/Packets_and_Frames/12.4_Frames_and_Frame_Types/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9000_Chinese_Translation/Packets_and_Frames/12.4_Frames_and_Frame_Types/</guid>
      <description>如图11所示，移除数据包保护后的QUIC数据包，其载荷由一系列完整的帧组成。版本协商数据包、无状态重置数据包和重试数据包中不包含帧。
数据包载荷 { 帧 (8..) ..., } 图11：QUIC载荷
 包含帧的数据包载荷必须包含至少1个帧，可以包含多个帧和多种帧类型。终端必须将接收到不包含帧的数据包的情况视作类型为PROTOCOL_VIOLATION（协议违背）的连接错误。帧总是能被放进单个QUIC数据包中且不能横跨多个数据包。
任何帧的开头都是表明其类型的帧类型字段，后面跟着额外的与类型相关的字段：
帧 { 帧类型 (i), 与类型相关的字段 (..), } 图12：通用的帧结构
 表格3罗列并概述了有关本规范中定义的各种帧类型的信息。表格后是对于这份概述的描述。
   类型值 帧类型名称 定义 数据包类型 特殊规则     0x00 填充帧 第19.1章 IH01 NP   0x01 Ping帧 第19.2章 IH01    0x02-0x03 ACK帧 第19.3章 IH_1 NC   0x04 流重置帧 第19.4章 __01    0x05 停止发送帧 第19.5章 __01    0x06 加密帧 第19.</description>
    </item>
    
    <item>
      <title>A.4. 重试数据包</title>
      <link>/RFC9001_Chinese_Translation/Sample_Packet_Protection/A.4_Retry/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9001_Chinese_Translation/Sample_Packet_Protection/A.4_Retry/</guid>
      <description>这里展示了一个可以被用于响应附录A.2中的初始数据包的重试数据包。完整性检查中使用了了由客户端选择的值为0x8394c8f03e515708的连接ID，但是这个值不会被包含在最终的重试数据包的明文中：
ff000000010008f067a5502a4262b574 6f6b656e04a265ba2eff4d829058fb3f 0f2496ba 
 </description>
    </item>
    
    <item>
      <title>12.5 帧和数据包号空间</title>
      <link>/RFC9000_Chinese_Translation/Packets_and_Frames/12.5_Frames_and_Number_Spaces/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9000_Chinese_Translation/Packets_and_Frames/12.5_Frames_and_Number_Spaces/</guid>
      <description>有一些类型的帧在某些数据包号空间中是被禁止的。这里的规则概述了TLS的规则，即与建立连接有关的帧通常能出现在任何数据包号空间的数据包中，而与传输数据有关的帧只能出现在应用数据空间中。
  填充帧、Ping帧和加密帧可以出现在任何数据包号空间中。
  标志着QUIC层错误（类型为0x1c）的连接关闭帧可以出现在任何数据包号空间中。标志着应用错误（类型为0x1d）的连接关闭帧必须只能出现在应用数据空间中。
  ACK帧可以出现在任何数据包号空间中，但是只能确认在同一个数据包号空间中的数据包。然而，如下文所述，0-RTT数据包不能包含ACK帧。
  所有其他类型的帧必须只能出现在应用数据空间中。
  注意，不管出于什么理由，都不能在0-RTT数据包中发送以下类型的帧：ACK帧、加密帧、握手完成帧、新令牌帧、回复通道帧和撤销连接ID帧。服务器可以将在0-RTT数据包中接收到以上帧的情况视作类型为PROTOCOL_VIOLATION的连接错误。</description>
    </item>
    
    <item>
      <title>A.5. 使用ChaCha20-Poly1305的短包头数据包</title>
      <link>/RFC9001_Chinese_Translation/Sample_Packet_Protection/A.5_ChaCha20-Poly1305_Short_Header_Packet/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9001_Chinese_Translation/Sample_Packet_Protection/A.5_ChaCha20-Poly1305_Short_Header_Packet/</guid>
      <description>本例展示了保护短包头数据包时所需的一些步骤。本例使用了AEAD_CHACHA20_POLY1305。
在本例中，TLS生成了一个应用写入秘密值（secret），服务器使用HKDF-Expand-Label从这个秘密值生成四个值：一个密钥（key）、一个IV（iv）、一个头部保护密钥（hp），和一个将被在密钥被更新后使用到的秘密值（ku，但它在本例中没有被使用到）。
secret = 9ac312a7f877468ebe69422748ad00a1 5443f18203a07d6060f688f30f21632b key = HKDF-Expand-Label(secret, &amp;quot;quic key&amp;quot;, &amp;quot;&amp;quot;, 32) = c6d98ff3441c3fe1b2182094f69caa2e d4b716b65488960a7a984979fb23e1c8 iv = HKDF-Expand-Label(secret, &amp;quot;quic iv&amp;quot;, &amp;quot;&amp;quot;, 12) = e0459b3474bdd0e44a41c144 hp = HKDF-Expand-Label(secret, &amp;quot;quic hp&amp;quot;, &amp;quot;&amp;quot;, 32) = 25a282b9e82f06f21f488917a4fc8f1b 73573685608597d0efcb076b0ab7a7a4 ku = HKDF-Expand-Label(secret, &amp;quot;quic ku&amp;quot;, &amp;quot;&amp;quot;, 32) = 1223504755036d556342ee9361d25342 1a826c9ecdf3c7148684b36b714881f9 
 下面展示了保护一个目标连接ID为空的最小数据包时所需的一些步骤。这个数据包仅包含了一个Ping帧（也就是说，载荷是0x01），并且其数据包号为654360564。在本例中，使用长度为3的数据包号编码方式（也就是编码为49140）避免了扩充数据包载荷的需要；如果数据包号被编码至更少的字节中，那么就需要填充帧。
pn = 654360564 # 十进制 nonce = e0459b3474bdd0e46d417eb0 unprotected header = 4200bff4 payload plaintext = 01 payload ciphertext = 655e5cd55c41f69080575d7999c25a5bfb 
 其结果密文的长度是在可能的范围中最小的。在为头部保护采样时，会跳过一个字节。</description>
    </item>
    
    <item>
      <title>13.1 数据包处理</title>
      <link>/RFC9000_Chinese_Translation/Packetization_and_Reliability/13.1_Packet_Processing/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9000_Chinese_Translation/Packetization_and_Reliability/13.1_Packet_Processing/</guid>
      <description>在数据包保护被成功移除且所有包含在数据包中的帧都被处理之前，必须不确认这个数据包。对于流帧，这个时机指其中的数据已经被置入队列，且准备被应用协议接收之时，但它不要求数据被分发和消费。
一旦数据包已经被完全处理，接收方通过发送一个或多个ACK帧来确认这个数据包的接收，这些ACK帧中包含被接收到的这个数据包的数据包号。
如果终端有能力检测出收到了一个它未发送过的数据包的确认的情况，它应该将这种情况视作一种类型为PROTOCOL_VIOLATION（协议违背）的错误。有关如何做到这件事，详见第21.4章。</description>
    </item>
    
    <item>
      <title>B.1.1. 可信度上限</title>
      <link>/RFC9001_Chinese_Translation/AEAD_Algorithm_Analysis/Analysis_of_AEAD_AES_128_GCM_and_AEAD_AES_256_GCM_Usage_Limits/B.1.1_Confidentiality_Limit/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9001_Chinese_Translation/AEAD_Algorithm_Analysis/Analysis_of_AEAD_AES_128_GCM_and_AEAD_AES_256_GCM_Usage_Limits/B.1.1_Confidentiality_Limit/</guid>
      <description>在可信度方面，《GCM-MU》中的定理4.3指出，对于一个不会重复随机数的用户，计算攻击者随机选择的AEAD算法相比实际使用的真实AEAD算法的优势程度的表达式为：
2 * (q * l)^2 / 2^n 
 当目标优势度为2-57时，会得到这样的关系：
q &amp;lt;= 2^35 / l 
 因此，发送不超过211字节的数据包的终端无法在单条连接中保护228个以上的数据包却不让攻击者获得超过2-57优势度。对于允许数据包尺寸达到216字节的终端，则该限制为223个数据包。</description>
    </item>
    
    <item>
      <title>B.1.2. 完整性上限</title>
      <link>/RFC9001_Chinese_Translation/AEAD_Algorithm_Analysis/Analysis_of_AEAD_AES_128_GCM_and_AEAD_AES_256_GCM_Usage_Limits/B.1.2_Integrity_Limit/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9001_Chinese_Translation/AEAD_Algorithm_Analysis/Analysis_of_AEAD_AES_128_GCM_and_AEAD_AES_256_GCM_Usage_Limits/B.1.2_Integrity_Limit/</guid>
      <description>在完整性方面，《GCM-MU》中的定理4.3指出，攻击者在伪造数据包时次数不需要超过此值就能获得明显优势：
(1 / 2^(8 * n)) + ((2 * v) / 2^(2 * n)) + ((2 * o * v) / 2^(k + n)) + (n * (v + (v * l)) / 2^k) 
 我们的目标是将此优势限制到2-57以下。对于AEAD_AES_128_GCM，不等式中的第四项占据主导地位，所以其余项可以被移除而不会对结果产生重要影响。这会产生以下近似结果：
v &amp;lt;= 2^64 / l 
 不会尝试对超过211字节的数据包移除保护的终端最多可以尝试为257个数据包移除保护。并不限制所处理的数据包尺寸的终端最多可以尝试为252个数据包移除保护。
对于AEAD_AES_256_GCM，占据主导地位的是同一项，但是较大的k值会产生以下近似结果：
v &amp;lt;= 2^192 / l 
 这比对AEAD_AES_128_GCM的限制要大得多。但是，本文档建议对两个函数施加同样的限制，因为任一限制都是可接受且足够大的。</description>
    </item>
    
    <item>
      <title>B.2. 对于AEAD_AES_128_CCM用量上限的分析</title>
      <link>/RFC9001_Chinese_Translation/AEAD_Algorithm_Analysis/B.2_Analysis_of_AEAD_AES_128_CCM_Usage_Limits/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9001_Chinese_Translation/AEAD_Algorithm_Analysis/B.2_Analysis_of_AEAD_AES_128_CCM_Usage_Limits/</guid>
      <description>TLS（详见《TLS13》）和《AEBounds》都没有为AEAD_AES_128_CCM的用量设定上限。然而，任何与QUIC一起使用的AEAD都需要在用量上设定上限以确保可信度和完整性都能得到维持。本节记述了关于此上限的分析。
《CCM-ANALYSIS》被用作本分析的基础。该文献中的分析结果被用于计算用量上限。
在可信度方面，《CCM-ANALYSIS》中的定理2指出，攻击者相比理想的伪随机排列（PRP）获得的优势不会超过此值：
(2l * q)^2 / 2^n 
 在相同消息数量的情况下，《CCM-ANALYSIS》中的定理1中的完整性上限给予了攻击者更多优势。由于可信度方面优势与完整性方面优势的目标值是相同的，所以只需要考虑定理1。
定理1指出，攻击者相比理想的PRP获得的优势不会超过此值：
v / 2^t + (2l * (v + q))^2 / 2^n 
 由于t和n都是128，第一项相比第二项变得微不足道，因此第一项可以被移除而不会对结果产生重要影响。
这产生了一种关系，它将加密尝试次数和解密尝试次数关联到了相同的上限值上，这个上限值是定理为可信度生成的。当目标优势度为2-57时，这会产生以下结果：
v + q &amp;lt;= 2^34.5 / l 
 通过设置q = v，可信度上限和完整性上限的值就都能被推导出来。因此限制数据包尺寸不超过211字节的终端使用226.5个数据包的可信度上限和完整性上限。不限制数据包尺寸的终端则使用值为221.5的上限。</description>
    </item>
    
    <item>
      <title>13.2.1 发送ACK帧</title>
      <link>/RFC9000_Chinese_Translation/Packetization_and_Reliability/Generating_Acknowledgments/13.2.1_Sending_ACK_Frames/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9000_Chinese_Translation/Packetization_and_Reliability/Generating_Acknowledgments/13.2.1_Sending_ACK_Frames/</guid>
      <description>所有数据包都应该被确认至少一次，ACK触发包必须在终端使用传输参数max_ack_delay（最大ACK延迟）沟通的最大延迟时间内被确认至少一次，详见第18.2章。max_ack_delay 声明了一个显式的约定：终端承诺不会故意拖延ACK触发包的确认以致延迟时间超过那个约定值。如果它这么做了，那么超出量会积累到RTT预估值上，并且导致来自对端的无效的或延迟的重传。发送方使用接收方的max_ack_delay值来决定基于计时器的重传的超时时间，详见《QUIC恢复》的第6.2章。
除了以下例外，终端必须立即确认所有引发确认的初始数据包和握手数据包，并且在它宣告的max_ack_delay之内确认所有引发确认的0-RTT数据包和1-RTT数据包。终端如果在握手确认前就收到了握手数据包、0-RTT数据包和1-RTT数据包，那么它可能还没有用来解密这些数据包的数据包保护密钥。因此它可以缓存这些数据包，等得到了必要的密钥再确认它们。
由于仅包含ACK帧的数据包不受拥塞控制，终端在响应一个ACK触发包时，必须不发送超过一个这样的数据包。
终端在响应非ACK触发包时，必须不发送非ACK触发包，即便在接收到的数据包前存在数据包空档。这避免了用确认响应确认的无限循环，避免连接无法进入闲置状态。非ACK触发包最终会在终端响应其他事件而发送的ACK帧中被确认。
一味发送ACK帧的终端不会从对端收到确认，除非这些帧和ACK触发帧一起被包含在数据包中。当有新的ACK触发包要确认时，终端应该将这些ACK帧一块发送。当只有非ACK触发包要确认时，终端可以选择等接收到一个ACK触发包时再将这些ACK帧一块发送。
只发送非ACK触发包的终端可以选择偶尔添加一个ACK触发帧到这些数据包中以确保它能收到确认，详见第13.2.4章。在那种情况下，终端必须不在所有本来不引发确认的数据包中都添加ACK触发帧，以避免用确认响应确认的无限循环。
为了辅助发送方的丢包检测，在以下情况中若收到一个ACK触发包，终端应该立即生成并发送ACK帧：
  当接收到的数据包的数据包号小于另一个已经被接收到的ACK触发包的时；
  当接收到的数据包的数据包号大于已接收到的ACK触发包的数据包号最大值，且在它们之间有缺失的数据包时。
  类似地，标记了IP头部的ECN拥塞预警（CE）码点的数据包应该被立即确认，以减少对端对拥塞事件的响应时间。
对没有遵守以上指导的接收方，《QUIC恢复》中的算法应当是能适应的。即使如此，QUIC实现也应该在谨慎地考虑任何变更会对性能的影响之后，再违背这些要求，既要考虑对终端建立的连接的性能影响，也要考虑对网络中其他用户的性能影响。</description>
    </item>
    
    <item>
      <title>13.2.2 确认频率</title>
      <link>/RFC9000_Chinese_Translation/Packetization_and_Reliability/Generating_Acknowledgments/13.2.2_Acknowledgment_Frequency/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9000_Chinese_Translation/Packetization_and_Reliability/Generating_Acknowledgments/13.2.2_Acknowledgment_Frequency/</guid>
      <description>作为ACK触发包的响应而发送的确认，其频率是由接收方决定的。这个决策包含了一种权衡。
终端依靠及时的确认以检测丢包，详见《QUIC恢复》的第6章。基于窗口的拥塞控制器，例如《QUIC恢复》的第7章中描述的那个，依靠确认来管理它们的拥塞窗口。在这两种情况中，延迟确认都会对性能产生不利影响。
另一方面，降低仅携带确认的数据包的频率能同时减少两个终端在传输和处理上的资源消耗。它能提高在极端不对称的链路上的连接吞吐量，并使用返回路径的容量来减少因确认而产生的流量，详见《RFC3449》的第3章。
接收方在接收到至少两个ACK触发包后应该发送一个ACK帧。这一推荐做法本质上是通用的，并且和TCP终端行为（《RFC5681》）的推荐做法是一致的。有关网络条件的知识、有关对端拥塞控制器的知识或将来的研究和实验可能建议替代本做法的有着更好的性能特征的确认策略。
接收方可以在决定是否要发送ACK帧作为响应前先处理掉几个可用的数据包。</description>
    </item>
    
    <item>
      <title>13.2.3 管理ACK块</title>
      <link>/RFC9000_Chinese_Translation/Packetization_and_Reliability/Generating_Acknowledgments/13.2.3_Managing_ACK_Ranges/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9000_Chinese_Translation/Packetization_and_Reliability/Generating_Acknowledgments/13.2.3_Managing_ACK_Ranges/</guid>
      <description>被发送的ACK帧中包含一个或多个已确认数据包的块。包含对更早期的数据包的确认减少了因之前发送的ACK帧丢包而引起无效重传的可能性，代价是ACK帧会变得更大。
ACK帧应该始终确认最近接收到的数据包，同时接收到的数据包越是乱序，尽快发送更新后的ACK帧就越是重要，以避免对端将某个数据包认定为丢包而对其中包含的帧进行无效的重传。一个ACK帧应当能被放进单个QUIC数据包中。如果不能，那么更早期的块（有着最小的数据包号的那些）会被省略。
接收方限制它记录的ACK块（详见第19.3.1章）的数量和在ACK帧中发送的ACK块的数量，这既是为了限制ACK帧的尺寸也是为了避免耗尽资源。在接收到对一个ACK帧的确认后，接收方应该停止追踪那些在帧中被确认的ACK块。发送方可以期待绝大多数数据包都被确认，但是QUIC不保证接收方处理的所有数据包的确认都被对端接收到。
因保留了许多ACK块而使得ACK帧变得过大是有可能的。接收方可以丢弃未被确认的ACK块以限制ACK帧的尺寸，代价是来自发送方的更多重传。如果一个ACK帧大到放不进一个数据包中，那么就有必要这么做。接收方还可以进一步限制ACK帧的尺寸来为其他帧腾出空间，或为了限制确认所消耗的数据包容量。
除非接收方能确信它后续接收到的数据包号不会落在某个ACK块中，否则它必须保留那个块。使用最少的状态来做到这一点的方法之一是维护一个最小的数据包号，它会随着块被丢弃而增大。
接收方可以丢弃所有ACK块，但是必须保留最大的已被成功处理的数据包号，因为它被用于从后续数据包中恢复数据包号，详见第17.1章。
接收方应该在所有ACK帧中包含最大的已接收到的数据包号。这个最大确认数字段被用于在发送方一侧进行的ECN验证，使用一个比先前发送的ACK帧中的更小的值会造成ECN被不必要地禁用，详见第13.4.2章。
第13.2.4章描述了一个如何决定在各个ACK帧中分别确认哪些数据包的示例方法。尽管这个算法的目标是为每个已处理的数据包生成一个确认，但是确认依旧有可能遭遇丢包。</description>
    </item>
    
    <item>
      <title>13.2.4 通过追踪ACK帧来限制块</title>
      <link>/RFC9000_Chinese_Translation/Packetization_and_Reliability/Generating_Acknowledgments/13.2.4_Limiting_Ranges_by_Tracking_ACK_Frames/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9000_Chinese_Translation/Packetization_and_Reliability/Generating_Acknowledgments/13.2.4_Limiting_Ranges_by_Tracking_ACK_Frames/</guid>
      <description>当发送包含某个ACK帧的数据包时，可以记录那个帧中的最大确认数。当接收到包含某个ACK帧的数据包的确认时，如果某个数据包的数据包号小于等于为那个ACK帧记录的最大确认数，那么接收方就可以不再确认这个数据包。
只发送非ACK触发包，例如ACK帧，的接收方可能很长一段时间都接收不到确认。这会导致接收方需要为大量ACK帧的状态维护很长一段时间，同时它发送的ACK帧会不必要地变得特别大。在这种情况下，接收方可以偶尔，比如每经过一轮往返时间就进行一次，发送一个Ping帧或其他小型的ACK触发帧，来引发来自对端的ACK帧。
在ACK帧没有遇到丢包的情况下，这个算法在每至少1RTT内提供一次重排ACK块的机会。在ACK帧遇到丢包和乱序的情况下，这个方法并不能保证所有确认都在它们不再被包含进ACK帧前就被发送方接收到。数据包还有可能在接收时已经被打乱顺序，或者所有后续包含它们的数据包号的ACK帧都遇到丢包。在这种情况下，丢包恢复算法可能引起无效的重传，但是发送方会继续进行有效的传输。</description>
    </item>
    
    <item>
      <title>13.2.5 测量和报告主机延迟</title>
      <link>/RFC9000_Chinese_Translation/Packetization_and_Reliability/Generating_Acknowledgments/13.2.5_Measuring_and_Reporting_Host_Delay/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9000_Chinese_Translation/Packetization_and_Reliability/Generating_Acknowledgments/13.2.5_Measuring_and_Reporting_Host_Delay/</guid>
      <description>从具有最大数据包号的数据包被接收到的那一刻起，到对于它的确认被发送时，这期间的时间会作为一个被有意引入的延迟而被终端测量。终端将这个确认延迟编码在ACK帧的ACK延迟字段，详见第19.3章。这使得这个ACK帧的接收方能够获知这些有意引入的延迟并作出调整，当确认出现延误时这一调整对更好地评估路径RTT是很重要的。
在得到处理前，数据包可能被暂留在操作系统内核或主机的其他什么地方。在填写ACK帧的ACK延迟字段时，终端必须不在值中包括不受它控制的延迟。然而，终端应该在值中包含由缺少解密密钥造成的缓存延迟，因为这些延迟可以变得很大，而且有可能是非重复出现的。
当测量到的确认延迟比max_ack_delay大时，终端应该报告这个测量到的延迟。这个信息在握手期间延迟可能会很大的情况下是特别有用的，详见第13.2.1章。</description>
    </item>
    
    <item>
      <title>13.2.6 ACK帧和数据包保护</title>
      <link>/RFC9000_Chinese_Translation/Packetization_and_Reliability/Generating_Acknowledgments/13.2.6_ACK_Frames_and_Packet_Protection/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9000_Chinese_Translation/Packetization_and_Reliability/Generating_Acknowledgments/13.2.6_ACK_Frames_and_Packet_Protection/</guid>
      <description>ACK帧必须被携带于一个和正在确认的数据包的数据包号空间相同的数据包中，详见第12.1章。举个例子，受1-RTT密钥保护的数据包必须在同样被1-RTT密钥保护的数据包中被确认。
客户端发送的受0-RTT数据包保护的数据包必须被服务器在受1-RTT密钥保护的数据包中确认。这意味着如果服务器的加密握手消息被延误或丢失，则客户端有可能无法使用这些确认。注意，同样的限制还适用于服务器发送的受1-RTT密钥保护的其他数据。</description>
    </item>
    
    <item>
      <title>13.2.7 填充帧消耗拥塞窗口</title>
      <link>/RFC9000_Chinese_Translation/Packetization_and_Reliability/Generating_Acknowledgments/13.2.7_PADDING_Frames_Consume_Congestion_Window/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9000_Chinese_Translation/Packetization_and_Reliability/Generating_Acknowledgments/13.2.7_PADDING_Frames_Consume_Congestion_Window/</guid>
      <description>包含填充帧的数据包会被纳入拥塞控制的考量，详见《QUIC恢复》。而仅仅包含填充帧的数据包虽然会消耗拥塞窗口但是不会引发确认来恢复拥塞窗口。为了避免死锁，发送方应该确保每隔一段时间会发送一次除填充帧外的其他帧，来引发来自接收方的确认。</description>
    </item>
    
    <item>
      <title>13.3 信息重传</title>
      <link>/RFC9000_Chinese_Translation/Packetization_and_Reliability/13.3_Retransmission_of_Information/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9000_Chinese_Translation/Packetization_and_Reliability/13.3_Retransmission_of_Information/</guid>
      <description>被认定丢包的QUIC数据包不会被整个重传。被丢包的数据包中包含的帧也是这样。取而代之的是这些帧中可能携带的信息会按照需要在新的帧中被再次发送。
携带被认定为丢失的信息时，使用新的帧和数据包。一般来说，信息会在携带它的数据包被认定为丢包时被再次发送，同时当携带那个信息的数据包被确认时发送即停止。
  在加密帧中的数据按照《QUIC恢复》中的规则重新传输，直到所有数据都已被确认。当有关数据包号空间的密钥被弃用时，初始数据包和握手数据包的加密帧中的数据会被丢弃。
  原本在流帧中发送的应用数据会在新的流帧被重传，除非终端已经为那条流发送了流重置帧。一旦终端发送了流重置帧，就不再需要发送流帧。
  ACK帧携带最近的一系列确认和来自最大已确认数据包的确认延迟，如第13.2.1章所述。延误包含ACK帧的数据包的传输或重发旧的ACK帧会使得对端生成过高的RTT样本或不必要地禁用ECN。
  流传输的中止信息只有在携带它的流重置帧被确认前且在所有流数据都被对端确认（也就是流的发送方进入“重置接收”或“接收完成”状态）前才能被发送。当再次发送时必须不改变流重置帧的内容。
  类似地，被编码在停止发送帧帧中的取消流传输的请求，只有在流的接收方进入“接收完成”或“重置接收”状态前才能被发送，详见第3.5章。
  当数据包丢包被检测到时，连接关闭的信号，包括那些包含连接关闭帧的数据包，不会被再次发送。有关重发这些信号，详见第10章。
  当前连接的最大数据量是使用最大数据量帧发送的。如果包含最近发送的最大数据量帧的数据包被认定丢包或终端决定更新限制，那么更新后的值还是使用最大数据量帧发送。由于限制可以被频繁提高而造成大量不必要的最大数据量帧被发送出去，必须小心以避免过于频繁地发送这种帧，详见第4.2章。
  当前最大流数据偏移量是使用最大流数据量帧发送的。像最大数据量帧一样，如果包含最近的最大流数据量帧的数据包遭遇丢包或限制被更新，那么就要发送更新后的值，并且小心以避免过于频繁地发送此类帧。当流的接收方进入“数据量确认”或“重置接收”状态时，终端应该不再发送最大流数据量帧。
  对给定类型的流的限制是使用最大流帧发送的。像最大数据量帧一样，如果对于给定的流类型，包含其最近的最大流帧的数据包被认定丢包或限制被更新，那么就要发送更新后的值，并且小心以避免过于频繁地发送此类帧。
  阻塞信号是在流阻塞帧、流数据阻塞帧和流阻塞帧中被携带的。流阻塞帧是连接层面上的，流数据阻塞帧是流层面上的，而流阻塞帧是在某种特定的流层面上的。当包含某一层面上的最近的上述帧的数据包遭遇丢包且仅当终端被阻塞于相应限制时，才发送一个新的帧。这些帧总是包含那个引起阻塞的限制在这些帧被传输时的值。
  使用通道挑战帧的存活确认或路径验证检查每隔一段时间被发送一次，直到接收到与之匹配的回复通道帧或已经没有必要再做存活确认或路径验证检查。每次发送通道挑战帧时都使用不同的载荷。
  响应路径验证时使用回复通道帧且仅发送一次。对端应当根据需要发送更多通道挑战帧来唤起额外的回复通道帧。
  新的连接ID是使用新连接ID帧发送的，如果包含它们的数据包遭遇丢包，依旧用这种帧重传。这种帧重传时携带相同序列数值。类似地，撤销连接ID的信息是在撤销连接ID帧中被发送的，如果包含它们的数据包遭遇丢包，依旧用这种帧重传。
  新令牌帧在包含它们的数据包遭遇丢包时会被重传。除了直接比较帧的内容之外，没有提供特殊的方法来检测乱序和重复的新令牌帧。
  Ping帧和填充帧不包含信息，因此丢失的这两种帧不需要修复。
  握手完成帧必须被重传，除非它已经被确认了。
  终端应该使数据重传优先于新数据发送，除非应用指定的优先级表明了相反的策略，详见第2.3章。
尽管鼓励发送方每次发送数据包时都使用最新的信息来装配帧，但是重传从丢包的数据包中拷贝来的帧数据这一行为并未被禁止。重传帧拷贝的发送方需要解决可用载荷大小上的降低，这是由数据包号长度、连接ID长度和路径MTU上的变化引起的。如果一个数据包包含了过时的帧，比如一个携带着比先前数据包中的值更小的最大数据量的最大数据量帧，那么接收方必须接收它们。
只要数据包已经被确认，发送方就应该避免重传来自这些数据包的信息。这包含数据包在被认定为丢包后又被确认的情况，这种情况会因为网络重排序而发生。这么做需要发送方在数据包被认定为丢包后保留有关它们的信息。发送方可以在丢弃此信息前保留一段足以允许重排序的时间，例如一个PTO（详见《QUIC恢复》的第6.2章），或基于其他事件做决定，例如到达内存限制。
在丢包检测时，发送方必须采取合适的拥塞控制措施。有关丢包检测和拥塞控制的细节，详见《QUIC恢复》。</description>
    </item>
    
    <item>
      <title>13.4.1 报告ECN计数</title>
      <link>/RFC9000_Chinese_Translation/Packetization_and_Reliability/Explicit_Congestion_Notification/13.4.1_Reporting_ECN_Counts/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9000_Chinese_Translation/Packetization_and_Reliability/Explicit_Congestion_Notification/13.4.1_Reporting_ECN_Counts/</guid>
      <description>要使用ECN，要求接收数据的终端从IP数据包读取ECN字段，但这不是在所有平台上都能做得到的。如果一个终端没有实现对ECN的支持或访问不了接收到的ECN字段，它就不会为它接收到的数据包报告ECN计数。
即使终端不会在它发送的数据包中设置ECN字段，它也必须为它接收到ECN标记提供反馈，除非访问不了。不报告ECN计数会使得发送方为这条连接禁用ECN。
当接收到一个具有ECT(0)、ECT(1)或ECN-CE码点的IP数据包，一个启用ECN的终端访问ECN字段并增加相应的ECT(0)、ECT(1)或ECN-CE计数。这些ECN计数会被包含在后续ACK帧中，详见第13.2章和第19.3章。
每个数据包号空间维护单独的确认状态和单独的ECN计数。被合并的QUIC数据包（详见第12.2章）共享相同的IP头部，所以每个被合并的QUIC数据包对应的ECN计数都要增加。
举例来说，若将QUIC的初始数据包、握手数据包和1-RTT数据包各一个合并至单个UDP数据报中，那么这三个数据包号空间的ECN计数都要分别基于同一个的IP头部的ECN字段来增加。
ECN计数仅当来自接收到的IP数据包的QUIC数据包被处理时才增加。于是，重复的QUIC数据包不会被处理所以就不会增加ECN计数；有关安全考量，详见第21.10章。</description>
    </item>
    
    <item>
      <title>13.4.2.1 接收具有ECN计数的ACK帧</title>
      <link>/RFC9000_Chinese_Translation/Packetization_and_Reliability/Explicit_Congestion_Notification/ECN_Validation/13.4.2.1_Receiving_ACK_Frames_with_ECN_Counts/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9000_Chinese_Translation/Packetization_and_Reliability/Explicit_Congestion_Notification/ECN_Validation/13.4.2.1_Receiving_ACK_Frames_with_ECN_Counts/</guid>
      <description>被网络错误地使用的ECN-CE标记会造成连接性能低下。因此接收到具有ECN计数的ACK帧的终端在使用前要验证它们。终端用比较新接收到的计数和那些在最近成功处理了的ACK帧中的计数的方法进行这项验证。任何在ECN计数上的增加都会被验证，这项验证基于被应用到最近在ACK帧中被确认的原始数据包上的ECN标记。
如果一个ACK帧最近确认了一个由终端发送的数据包且这个数据包被设置了ECT(0)或ECT(1)码点，同时相应的ECN计数并未在这个ACK帧中出现，那么ECN验证就会失败。这项检查能够检测出将ECN字段归零的网络元素或并不报告ECN标记的对端。
如果ECT(0)计数和ECN-CE计数的增加量的总和小于被新确认的且发送时具有ECT(0)标记的数据包的数量，那么ECN验证也会失败。类似地，如果ECT(1)计数和ECN-CE计数的增加量的总和小于被新确认的且发送时具有ECT(1)标记的数据包的数量，那么ECN验证也会失败。这些检查可以检测网络重设ECN-CE标记的行为。
在ACK帧有可能丢失的情况下，终端允许忽略对某个数据包的确认。因此ECT(0)、ECT(1)和ECN-CE的增加量的总和大于被一个ACK帧新确认的的数据包数量是有可能的。这就是为什么允许ECN计数大于被确认的数据包的总数。
为经过重排序的ACK帧验证ECN计数，其结果是不准确的。终端必须不因为处理一个没有增加最大已确认数据包号的ACK帧而将ECN验证结果记为失败。
如果接收到的ECT(0)或ECT(1)中任意一个的总计数，超过了已发送的具有的相应ECT码点的数据包总数，ECN验证就会失败。特别是，当终端接收到一个非零的ECN计数但那个相应的ECT码点从未使用过，验证就应失败。这项检查可以检测网络重设数据包的ECT(0)和ECT(1)的行为。</description>
    </item>
    
    <item>
      <title>13.4.2.2 ECN验证结果</title>
      <link>/RFC9000_Chinese_Translation/Packetization_and_Reliability/Explicit_Congestion_Notification/ECN_Validation/13.4.2.2_ECN_Validation_Outcomes/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9000_Chinese_Translation/Packetization_and_Reliability/Explicit_Congestion_Notification/ECN_Validation/13.4.2.2_ECN_Validation_Outcomes/</guid>
      <description>如果验证失败，那么终端必须禁用ECN。它在发送的IP数据包中不会再设置ECT码点，就当作网络路径或对端不支持ECN。
即使验证失败，终端也可以在连接中的任意时间对相同的路径重新验证ECN。终端可以继续定期尝试验证。
当验证成功后，终端可以继续在它发送的后续数据包中设置ECT码点，并认定这条路径是支持ECN的。网络路由和路径上的元素可能在连接中途发生变化；将来如果验证失败，则终端必须禁用ECN。</description>
    </item>
    
    <item>
      <title>14.1 初始数据报尺寸</title>
      <link>/RFC9000_Chinese_Translation/Datagram_Size/14.1_Initial_Datagram_Size/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9000_Chinese_Translation/Datagram_Size/14.1_Initial_Datagram_Size/</guid>
      <description>客户端必须通过向初始数据包增加填充帧或合并初始数据包的方式，对所有携带初始数据包的UDP数据报载荷进行扩充，至少扩充至1200字节，这个在允许的最大数据报尺寸中的最小值，详见第12.2章。初始数据包甚至可以和不合法的数据包合并，后者会被接收方丢弃。相似的，服务器必须对所有携带引发确认的初始数据包的UDP数据报载荷进行扩充，至少扩充至1200字节，这个在允许的最大数据报尺寸中的最小值。
以上述尺寸发送UDP数据报确保网络路径在两个方向上都支持一个合理的路径最大传输单元（PMTU）值。除此之外，扩充初始数据包的客户端有助于减少因服务器响应未经验证的客户端地址而引起的放大攻击的幅度，详见第8章。
如果发送方确信网络路径和对端均支持它选择的数据报尺寸，那么包含初始数据包的数据报可以超过1200字节。
如果一个UDP数据报的载荷小于1200字节，这个在允许的最大数据报尺寸中的最小值，那么服务器必须丢弃这个数据报中的初始数据包。服务器还可以通过发送一个错误码为PROTOCOL_VIOLATION（协议违背）的连接关闭帧来立即关闭连接，详见第10.2.3章。
服务器还必须限制它在验证客户端地址前发送的字节数，详见第8章。</description>
    </item>
    
    <item>
      <title>14.2.1 使用PMTUD处理ICMP消息</title>
      <link>/RFC9000_Chinese_Translation/Datagram_Size/Path_Maximum_Transmission_Unit/14.2.1_Handling_of_ICMP_Messages_by_PMTUD/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9000_Chinese_Translation/Datagram_Size/Path_Maximum_Transmission_Unit/14.2.1_Handling_of_ICMP_Messages_by_PMTUD/</guid>
      <description>PMTUD（详见《RFC1191》和《RFC8201》）依赖一种ICMP消息（也就是IPv6数据包过大（PTB）消息）的接收，这种消息表明了何时IP数据包由于超过本地路由器MTU而被丢弃。DPLPMTUD可以选择使用这些消息。使用这种ICMP消息潜在地容易受到路径上不能观测数据包但可能成功猜测到地址的实体的攻击。
如果一个ICMP消息宣称PMTU已降低，且降低至QUIC允许的最大数据报尺寸中的最小值以下，那么终端必须忽略它。
生成ICMP消息的要求（详见《RFC1812》和《RFC4443》）指出，被引用的数据包应该包含尽可能多的原始数据包且不超过当前IP版本的最小MTU。被引用的数据包的尺寸实际上可以更小，或信息可以更难以理解，如《DPLPMTUD》的第1.1章所述。
使用PMTUD的QUIC终端应该验证ICMP消息以免于如《RFC8201》和《RFC8085》的第5.2章所述的数据包注入。这种验证应该使用ICMP消息的载荷中提供的被引用数据包，来将这条消息与一条有关的传输连接相关联（详见《DPLPMTUD》的第4.6.1章）。ICMP消息验证必须在一个活跃的QUIC上下文中包含匹配的IP地址和UDP端口（详见《RFC8085》）以及，如果可以的话，连接ID。终端应该忽略所有未通过验证的ICMP消息。
终端必须不基于ICMP消息提高PMTU，详见《DPLPMTUD》的第3章中的第6款。在QUIC的丢包检测算法认定被引用的数据包确实被丢失了之前，任何作为ICMP消息的响应而降低的QUIC最大数据报尺寸都可以是临时的。</description>
    </item>
    
    <item>
      <title>14.3.1 DPLPMTUD与初始连接</title>
      <link>/RFC9000_Chinese_Translation/Datagram_Size/Datagram_Packetization_Layer_PMTU_Discovery/14.3.1_DPLPMTUD_and_Initial_Connectivity/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9000_Chinese_Translation/Datagram_Size/Datagram_Packetization_Layer_PMTU_Discovery/14.3.1_DPLPMTUD_and_Initial_Connectivity/</guid>
      <description>从DPLPMTUD的视角看，QUIC是个进行过确认的分包层（PL）。因此QUIC发送方当QUIC连接的握手阶段完成时可以进入DPLPMTUD的BASE（基本）状态。</description>
    </item>
    
    <item>
      <title>14.3.2 用DPLPMTUD验证网络路径</title>
      <link>/RFC9000_Chinese_Translation/Datagram_Size/Datagram_Packetization_Layer_PMTU_Discovery/14.3.2_Validating_the_Network_Path_with_DPLPMTUD/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9000_Chinese_Translation/Datagram_Size/Datagram_Packetization_Layer_PMTU_Discovery/14.3.2_Validating_the_Network_Path_with_DPLPMTUD/</guid>
      <description>QUIC是一个进行过确认的PL（分包层）；因此当处于SEARCH_COMPLETE（搜索完成）状态时，QUIC的发送方不需要实现DPLPMTUD的CONFIRMATION_TIMER（确认计时器），详见《DPLPMTUD》的第5.2章。</description>
    </item>
    
    <item>
      <title>14.3.3 使用DPLPMTUD处理ICMP消息</title>
      <link>/RFC9000_Chinese_Translation/Datagram_Size/Datagram_Packetization_Layer_PMTU_Discovery/14.3.3_Handling_of_ICMP_Messages_by_DPLPMTUD/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9000_Chinese_Translation/Datagram_Size/Datagram_Packetization_Layer_PMTU_Discovery/14.3.3_Handling_of_ICMP_Messages_by_DPLPMTUD/</guid>
      <description>如《DPLPMTUD》的第4.6章所述，使用DPLPMTUD的终端在使用任何PTB信息前都需要验证接收到的那条ICMP消息。除了验证UDP端口外，QUIC还通过使用其他PL信息（例如，验证所有接收到的ICMP消息的被引用数据包中的连接ID）来验证一条ICMP消息。
如果某条ICMP消息被DPLPMTUD使用，那么还要考虑第14.2.1章中描述的有关处理ICMP消息时的注意事项。</description>
    </item>
    
    <item>
      <title>14.4.1 包含源连接ID的PMTU探测包</title>
      <link>/RFC9000_Chinese_Translation/Datagram_Size/Sending_QUIC_PMTU_Probes/14.4.1_PMTU_Probes_Containing_Source_Connection_ID/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9000_Chinese_Translation/Datagram_Size/Sending_QUIC_PMTU_Probes/14.4.1_PMTU_Probes_Containing_Source_Connection_ID/</guid>
      <description>依赖目标连接ID字段来路由传入的QUIC数据包的终端，有可能需要连接ID被包含在PMTU探测包中，才能将产生的ICMP消息（详见第14.2.1章）路由回正确的终端。
构建PMTU探测包的方法之一是将一个有长包头的数据包，例如握手数据包或0-RTT数据包（详见第17.2章），与一个短包头数据包合并（详见第12.2章）至单个UDP数据报中。如果产生的PMTU探测包到达了对端，那么具有长包头的数据包会被忽略，但是短包头数据包会被确认。如果PMTU探测包触发了一条ICMP消息，那么探测包的起始部分会被引用进那条消息。如果源连接ID字段在探测包被引用的部分里，它就能被用来路由或验证那条ICMP消息。
 注意：使用具有长包头的数据包的目的仅仅是确保ICMP消息中被引用的数据包里包含源连接ID字段。这个数据包并不需要是一个合法的数据包，并且即使当时那种数据包没有用处也可以发送它。
 </description>
    </item>
    
    <item>
      <title>17.1 数据包号编码与解码</title>
      <link>/RFC9000_Chinese_Translation/Packet_Formats/17.1_Packet_Number_Encoding_and_Decoding/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9000_Chinese_Translation/Packet_Formats/17.1_Packet_Number_Encoding_and_Decoding/</guid>
      <description>数据包号是范围在0至262-1中的整数（第12.3章）。当在长包或短包的头部出现时 ，它们被编码在1至4字节中。通过仅使用数据包号的几个最低有效位，用于表示数据包号的比特位数量得以被减少。
经过编码的数据包号是受保护的，如《QUIC-TLS》第5.4章所述。
在接收到对于某数据包号空间的确认前，必须使用完整的数据包号；它不可以如下文所述那样被截断。
在接收到对于某数据包号空间的确认后，发送方必须使用一个足够大的数据包号尺寸，这个尺寸能够表示的范围大小至少是最大已确认数据包号和正在发送的数据包号之差的两倍。接收到该数据包的对端将正确解码数据包号，除非此包在传输过程中被延误得比很多更大编号的数据包更晚才被接收到。终端应该使用一个足够大的数据包号编码，使得即便此数据包比后续发送的数据包更晚到达，其数据包号也能被恢复。
于是，某数据包号编码的尺寸至少要比连续未被确认的数据包号的数量（包括此数据包本身）的以2为底的对数值大1比特。在附录A.2中可以找到数据包号编码的伪代码和一个样例。
在接收方一侧，数据包号的保护在恢复完整数据包号前被移除。完整的数据包号随后被重建，重建基于数据包中出现的包号有效比特位的数量和值，以及已接收的且成功认证的数据包中最大的数据包号。恢复完整的数据包号对于成功移除数据包保护很有必要。
一旦头部保护被移除，通过找到与下一个预期数据包更接近的数据包号值即可将数据包号解码。下一个预期数据包就是将最大的已接收数据包编号加上1。在附录A.3中可以找到数据包号解码的伪代码和一个样例。</description>
    </item>
    
    <item>
      <title>17.2.1 版本协商数据包</title>
      <link>/RFC9000_Chinese_Translation/Packet_Formats/Long_Header_Packets/17.2.1_Version_Negotiation_Packet/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9000_Chinese_Translation/Packet_Formats/Long_Header_Packets/17.2.1_Version_Negotiation_Packet/</guid>
      <description>版本协商数据包（Version Negotiation packet）本质上不是版本特定的。客户端收到后，将根据版本字段值为0将其识别为版本协商数据包。
版本协商数据包是对一个包含了服务器不支持的版本的客户端数据包的响应。它只能被服务器发送。
一个版本协商数据包的结构如下：
版本协商数据包 { 包头形式 (1) = 1, 未使用 (7), 版本 (32) = 0, 目标连接ID长度 (8), 目标连接ID (0...2040), 源连接ID长度 (8), 源连接ID (0...2040), 支持的版本 (32) ..., } 图14：版本协商数据包
 未使用字段中的值由服务器设置为任意值。客户端必须忽略此字段的值。当QUIC可能被与其他协议多路复用时（详见RFC7983），服务器应该将这个字段的最高有效位（0x40）设置为1以使得版本协商数据包看起来具有固定比特位字段。要注意的是其他版本的QUIC不一定做出类似的推荐。
版本协商数据包的版本字段必须被设置为0x00000000。
服务器在目标连接ID字段中使用的值必须来自接收到的那个数据包的源连接ID字段。源连接ID字段的值必须是从接收到的那个数据包的目标连接ID字段中拷贝来的，这是个来自客户端的随机选择的值。回显两个连接ID可以让客户端确信服务器收到了数据包，并且版本协商数据包不是由没有观察初始数据包的实体生成的。
将来版本的QUIC可以对连接ID的长度有不同要求。特别是，连接ID可能具有更小的最小长度或更大的最大长度。
版本协商数据包的剩余部分是一个列表，包含服务器支持的一个个32位长的版本号。
版本协商包不会被确认。它只会作为一个使用了不受支持的版本的数据包的响应而被发送，详见第5.2.5章。
版本协商数据包不包含在其他使用了长包头形式的数据包中存在的数据包号和长度字段。因此，一个版本协商数据包消耗一整个UDP数据报。
服务器必须不对单个UDP数据报响应超过1个版本协商数据包。
有关版本协商的过程，详见第6章。</description>
    </item>
    
    <item>
      <title>17.2.2.1 停用初始数据包</title>
      <link>/RFC9000_Chinese_Translation/Packet_Formats/Long_Header_Packets/Initial_Packet/17.2.2.1_Abandoning_Initial_Packets/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9000_Chinese_Translation/Packet_Formats/Long_Header_Packets/Initial_Packet/17.2.2.1_Abandoning_Initial_Packets/</guid>
      <description>从客户端发送它的第一个握手数据包时起，它就不再发送和处理初始数据包。从服务器收到第一个握手数据包时起，它就不再发送和处理初始数据包。尽管可能有数据包仍在传输途中或等待确认，但从那一时刻起不再有初始数据包需要进行交换。此时，初始数据包保护密钥将被弃用（详见《QUIC-TLS》的第4.9.1章），一起被丢弃的还有丢包恢复与拥塞控制状态（详见《QUIC恢复》的第6.4章）。
当初始密钥被弃用时，加密帧中的所有数据都会被丢弃，且不再重传。</description>
    </item>
    
    <item>
      <title>17.2.3 0-RTT</title>
      <link>/RFC9000_Chinese_Translation/Packet_Formats/Long_Header_Packets/17.2.3_0-RTT/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9000_Chinese_Translation/Packet_Formats/Long_Header_Packets/17.2.3_0-RTT/</guid>
      <description>0-RTT数据包使用类型值为0x01的长包头，后面跟着长度和数据包号字段，详见第17.2章。首个字节包含保留比特位和数据包号长度比特位，详见第17.2章。0-RTT数据包被用来在握手完成前，携带来自客户端的“早期”数据，作为第一轮通信的一部分被发向服务器。
有关0-RTT数据及其局限的讨论，详见《TLS13》的第2.3章。
初始数据包 { 包头形式 (1) = 1, 固定比特位 (1) = 1, 长数据包类型 (2) = 1, 保留比特位 (2), 数据包号长度 (2), 版本 (32), 目标连接ID长度 (8), 目标连接ID (0..160), 源连接ID长度 (8), 源连接ID (0..160), 长度 (i), 数据包号 (8..32), 数据包载荷 (8..), } 图16：0-RTT数据包
 受0-RTT保护的数据包，与受1-RTT保护的数据包使用相同的数据包号空间。
在客户端接收到重试数据包时，0-RTT数据包有可能是被弄丢了，或者被服务器丢弃了。客户端应该在发送新的初始数据包后尝试用0-RTT数据包重新发送数据。所有新发送的数据包都必须使用新的数据包号；如第17.2.5.3章所述，重用数据包号可能使数据包保护失效。
客户端只有在握手完成后才会收到0-RTT数据包的确认，如《QUIC-TLS》的第4.1.1章所述。
一旦客户端开始处理来自服务器的1-RTT数据包，它就必须不再发送0-RTT数据包。这意味着0-RTT数据包不能包含任何对于来自1-RTT数据包中的帧的回复。比如说，客户端不能在0-RTT数据包中发送ACK帧，因为它只能被用来确认1-RTT数据包。必须用1-RTT数据包来携带对于1-RTT数据包的确认。
服务器必须视违反已记录的限制的情况为一个合适类型的连接错误（例如，超过流数据限制时使用FLOW_CONTROL_ERROR（流量控制错误））。</description>
    </item>
    
    <item>
      <title>17.2.4 握手数据包</title>
      <link>/RFC9000_Chinese_Translation/Packet_Formats/Long_Header_Packets/17.2.4_Handshake_Packet/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9000_Chinese_Translation/Packet_Formats/Long_Header_Packets/17.2.4_Handshake_Packet/</guid>
      <description>握手数据包（Handshake packet）使用类型值为0x02的长包头，后面跟着长度和数据包号字段，详见第17.2章。首个字节包含保留比特位和数据包号长度比特位，详见第17.2章。这种数据包被用来携带来自服务器和客户端的加密握手消息和确认。
握手数据包 { 包头形式 (1) = 1, 固定比特位 (1) = 1, 长数据包类型 (2) = 2, 保留比特位 (2), 数据包号长度 (2), 版本 (32), 目标连接ID长度 (8), 目标连接ID (0..160), 源连接ID长度 (8), 源连接ID (0..160), 长度 (i), 数据包号 (8..32), 数据包载荷 (8..), } 图17：受握手保护的数据包
 一旦客户端接收到了来自服务器的握手数据包，它就开始使用握手数据包来向服务器发送后续加密握手消息和确认。
握手数据包的目标连接ID字段包含一个由数据包接收方选择的连接ID；源连接ID包含的是数据包的发送方想要使用的连接ID，详见第7.2章。
握手数据包有它们自己的数据包号空间，因此由服务器发送的首个握手数据包使用的是值为0的数据包号。
这种数据包的载荷是加密帧，也可以包含Ping帧、填充帧或ACK帧。握手数据包可以包含类型为0x1c的连接关闭帧。若握手数据包中出现了其他种类的帧，则接收到该数据包的终端必须将该情况视作一个类型为PROTOCOL_VIOLATION（协议违背）的连接错误。
如初始数据包一样（详见第17.2.2.1章），当握手保护密钥被弃用时，握手数据包中的加密帧里的数据会被丢弃且不再重新传输。</description>
    </item>
    
    <item>
      <title>17.2.5.1 发送重试数据包</title>
      <link>/RFC9000_Chinese_Translation/Packet_Formats/Long_Header_Packets/Retry_Packet/17.2.5.1_Sending_a_Retry_Packet/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9000_Chinese_Translation/Packet_Formats/Long_Header_Packets/Retry_Packet/17.2.5.1_Sending_a_Retry_Packet/</guid>
      <description>服务器在填写目标连接ID时，使用客户端在初始数据包中填写的源连接ID的值。
服务器在源连接ID字段中使用自己选择的连接ID。这个值必须不与发送自客户端的数据包的目标连接ID字段相同。如果客户端发现一个重试数据包中包含的的源连接ID字段与它发送的初始数据包中的目标连接ID字段一致，那么它必须将这个数据包丢弃。客户端必须使用来自重试数据包中源连接ID字段的值，作为目标连接ID字段来发送后续数据包。
服务器可以发送重试数据包来回复初始数据包和0-RTT数据包。服务器可以丢弃或缓存它收到的0-RTT数据包。当服务器接收到数个初始数据包或0-RTT数据包时，它可以发送数个重试数据包。服务器必须不发送超过一个重试数据包以回应单个UDP数据报。</description>
    </item>
    
    <item>
      <title>17.2.5.2 处理重试数据包</title>
      <link>/RFC9000_Chinese_Translation/Packet_Formats/Long_Header_Packets/Retry_Packet/17.2.5.2_Handling_a_Retry_Packet/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9000_Chinese_Translation/Packet_Formats/Long_Header_Packets/Retry_Packet/17.2.5.2_Handling_a_Retry_Packet/</guid>
      <description>对于单次连接尝试，客户端必须接受和处理至多一个重试数据包。在客户端已经接收和处理来自服务器的初始数据包或重试数据包之后，它必须丢弃后续接收到的任何重试数据包。
对于重试完整性标签无法被验证的重试数据包，客户端必须丢弃它们，详见《QUIC-TLS》的第5.8章。这会降低攻击者注入重试数据包的能力并且保护重试数据包免于意外受损。客户端必须丢弃重试令牌字段长度为零的重试数据包。
作为重试数据包的回复，客户端使用包含了前者提供的重试令牌的初始数据包来继续连接的建立过程。
客户端使用来自重试数据包中源连接ID字段的值，作为这个初始数据包的目标连接ID字段。更改目标连接ID字段会改变用来保护初始数据包的密钥。客户端还将令牌字段设置为重试数据包中提供的令牌。客户端必须不更改源连接ID因为服务器可能将连接ID作为了它令牌验证逻辑的一部分，详见第8.1.4章。
重试数据包不包含数据包号且不能被客户端显式确认。</description>
    </item>
    
    <item>
      <title>17.2.5.3 重试后继续握手</title>
      <link>/RFC9000_Chinese_Translation/Packet_Formats/Long_Header_Packets/Retry_Packet/17.2.5.3_Continuing_a_Handshake_after_Retry/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9000_Chinese_Translation/Packet_Formats/Long_Header_Packets/Retry_Packet/17.2.5.3_Continuing_a_Handshake_after_Retry/</guid>
      <description>后续来自客户端的初始数据包包含着来自重试数据包的连接ID和令牌值。客户端从重试数据包中拷贝源连接ID字段至目标连接ID字段并且持续使用它，直到接收到一个包含着更新过的值的初始数据包，详见第7.2章。令牌字段的值被拷贝至所有后续初始数据包，详见第8.1.2章。
除了要更新目标连接ID和令牌字段外，客户端后续发出的初始数据包与首个初始数据包受到同样的限制。客户端必须使用和首个初始数据包中相同的加密握手消息。对于包含了不同加密握手消息的数据包，服务器可以将其视作为一种连接错误，或丢弃它。注意，包含令牌字段会减少数据包中加密握手消息的可用空间，这可能导致客户端需要发送多个初始数据包。
客户端可以在接收到重试数据包后尝试0-RTT，方法是向服务器提供的连接ID发送0-RTT数据包。
客户端必须不在处理完重试数据包后重置任何数据包号空间中的数据包号。尤其是，0-RTT数据包包含着的机密信息很有可能在接收到重试数据包时被重新传输。由于是在回复一个重试数据包，用于保护这些新0-RTT数据包的密钥不会改变。然而，这些数据包中发送的数据可能和之前发送的不一样。用相同的数据包号发送这些新数据包可能使这些数据包的数据包保护失效，因为相同的密钥和随机数可能被用于保护不同内容。服务器如果检测到客户端重置了数据包号。它可以中止这次连接。
在客户端和服务器间被交换的初始数据包和重试数据包中的那些连接ID会被拷贝到传输参数中并且被验证，详见第7.3章。</description>
    </item>
    
    <item>
      <title>17.3.1 1-RTT数据包</title>
      <link>/RFC9000_Chinese_Translation/Packet_Formats/Short_Header_Packets/17.3.1_1-RTT_Packet/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9000_Chinese_Translation/Packet_Formats/Short_Header_Packets/17.3.1_1-RTT_Packet/</guid>
      <description>1-RTT数据包使用短数据包包头。它在协商出版本和1-RTT密钥之后被使用。
1-RTT数据包 { 包头形式 (1) = 0, 固定比特位 (1) = 1, 自旋比特位 (1), 保留比特位 (2), 密钥阶段 (1), 数据包号长度 (2), 目标连接ID (0..160), 数据包号 (8..32), 数据包载荷 (8..), } 图19：1-RTT数据包
 1-RTT数据包包含以下字段：
 包头形式（Header Form）：  对于短包头，字节0的最高有效位（0x80）被设置为0。
 固定比特位（Fixed Bit）：  字节0中的下一个比特位（0x40）被设置为1。此比特位为0的数据包表示它不是当前版本的合法数据包且必须被丢弃。此比特位为1允许QUIC与其他协议共存，详见《RFC7983》。
 自旋比特位（Spin Bit）：  字节0的第三高有效比特位（0x20）是延迟自旋比特位，按第17.4章中描述的那样去设置。
 保留比特位（Reserved Bits）：  字节0中的后两个比特位（掩码为0x18的那两个）被保留使用。这些比特位被头部保护所保护，详见《QUIC-TLS》的第5.4章。在进行保护前，这两个比特位的值必须被设置为0。若在移除数据包保护和头部保护之后发现这些位被设置为非零值，则接收到该数据包的终端必须将该情况视作一个类型为PROTOCOL_VIOLATION的连接错误。仅在移除头部保护后就丢弃这样的数据包会使终端暴露于攻击之下，详见《QUIC-TLS》的第9.5章。
 密钥阶段（Key Phase）：  字节0中的下一个比特位（0x04）表明了密钥阶段，它允许数据包的接收方辨别用于保护数据包的数据包保护密钥。有关细节见《QUIC-TLS》。这个比特位被头部保护所保护，详见《QUIC-TLS》的第5.4章。
 数据包号长度（Packet Number Length）：  在包含数据包号字段的数据包类型中，字节0最低的两个有效位（掩码为0x03的那两个）包含数据包号字段的长度。该长度被编码为一个2位无符号整型值，这个值比数据包号字段的字节长度小1。也就是说，数据包号字段的长度等于这个字段的值加1。这些比特位被头部保护所保护，详见《QUIC-TLS》的第5.4章。
 目标连接ID（Destination Connection ID）：  目标连接ID是一个由此数据包意图的接收方选择的一个连接ID，详见第5.1章。
 数据包号（Packet Number）：  这个字段的长度是1至4字节。数据包号被头部保护所保护，详见《QUIC-TLS》的第5.</description>
    </item>
    
    <item>
      <title>17.4 延迟自旋比特位</title>
      <link>/RFC9000_Chinese_Translation/Packet_Formats/17.4_Latency_Spin_Bit/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9000_Chinese_Translation/Packet_Formats/17.4_Latency_Spin_Bit/</guid>
      <description>为1-RTT数据包（第17.3.1章）定义的延迟自旋比特位允许网络路径上的各个观察点在整个连接期间进行被动的延迟监测。
自旋比特位仅在1-RTT数据包中出现，因为若要测量一条连接的初始RTT，可以通过观察握手过程来实现。因此，自旋比特位在版本协商和连接建立完成后才可用。《QUIC可管理性》中进一步讨论了延迟自旋比特位在链路上的测量和使用。
在本QUIC版本中，自旋比特位是一个可选特性。如下文所述，不支持此特性的终端必须禁用它。
每个终端对一条连接是否启用自旋比特位做单方面的决定。各个实现必须允许客户端和服务器的管理员能够禁用自旋比特位，要么全局禁用要么基于单条连接禁用。即使自旋比特位没有被管理员禁用，终端也必须在每16条网络路径中随机地选择至少一条，或每16个连接ID中选择一个，然后在使用这些选出的路径或连接ID时禁用自旋比特位，这是为了确保在网络上能经常观测到禁用自旋比特位的QUIC连接。当每个终端独立地禁用自旋比特位时，能确保自旋比特位信号量在大约八分之一的网络路径中是关闭的。
当自旋比特位被禁用时，终端可以将自旋比特位设置为任意值，且必须忽略任何传入值。推荐终端将自旋比特位设置为随机值，要么为每个数据包独立选择，要么为每个连接ID独立选择。
如果自旋比特位在当前连接中是启用的，终端就要为每条网络路径维护一个自旋值，并且当1-RTT数据包要在某条网络路径上发送时，将数据包头部中的自旋比特位设置为当前存储的自旋值。每个终端还要记录在每条路径上的对端所看到的最大数据包号。
当服务器在某条网络路径上接收到一个1-RTT数据包且它增大了服务器所记录的客户端看到的最大数据包号，服务器就将那条路径上的自旋值设置为接收到的那个数据包中的自旋值。
当客户端在某条网络路径上接收到一个1-RTT数据包且它增大了客户端所记录的服务器看到的最大数据包号，客户端就将那条路径上的自旋值设置为接收到的那个数据包中的自旋值的相反值。
当在一条网络路径上改变所使用的连接ID时，终端将那条网络路径上的自旋值重置为0。</description>
    </item>
    
    <item>
      <title>18.1 保留传输参数</title>
      <link>/RFC9000_Chinese_Translation/Transport_Parameter_Encoding/18.1_Reserved_Transport_Parameters/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9000_Chinese_Translation/Transport_Parameter_Encoding/18.1_Reserved_Transport_Parameters/</guid>
      <description>标识符为31 * N + 27——其中N为整数——的传输参数保留用于执行未知传输参数。 这些传输参数没有语义，可以携带任意值。</description>
    </item>
    
    <item>
      <title>18.2 传输参数定义</title>
      <link>/RFC9000_Chinese_Translation/Transport_Parameter_Encoding/18.2_Transport_Parameter_Definitions/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9000_Chinese_Translation/Transport_Parameter_Encoding/18.2_Transport_Parameter_Definitions/</guid>
      <description>本章描述本文定义的传输参数的细节。
这里列出的许多传输参数都是整型值。 那些整型的传输参数使用变长整数编码，详见第16章。 除非有额外说明，否则传输参数在不设置时的默认值是0。
各个传输参数具体定义如下：
 原始目标连接IDoriginal_destination_connection_id (0x00)：  这个参数是由客户端发出的第一个初始包的目标连接ID字段的值，详见第16章。 该传输参数只会由服务端发出。
 最大空闲超时时间max_idle_timeout (0x01)：  最大空闲超时是一个编码为整型的值，单位毫秒，详见第10.1章。 当双端均忽略此传输参数或设置其值为0时，空闲超时将被禁用。
 无状态重置令牌stateless_reset_token (0x02)：  无状态重置令牌用于验证无状态重置，详见第10.3章。 这个传输参数是一个16字节的序列。 客户端必须不能发送这个参数，但是服务端可以发送。 没有发送此参数的服务端不能对握手期间协商的连接ID使用无状态重置。
 最大UDP载荷max_udp_payload_size (0x03)：  最大UDP载荷参数是一个整型值，用于终端限制愿意接收的UDP载荷的大小。 UDP报文的载荷如果大于这个限制将不太可能被服务端处理。
  该参数默认值是最大UDP载荷65527。 该值不能小于1200。
  这个限制是对报文大小的一个与通道MTU一样的附加约束，但其是终端的属性而非通道的属性，详见第14章。 应该认为这是终端用于保存传入数据包的空间。
 初始最大数据量initial_max_data (0x04)：  初始最大数据量参数是一个包含连接可发送初始最大数据量的整型值。 等效于连接在完成握手后立即发送一个最大数据帧（MAX_DATA，详见第19.9章）。
 初始本地最大双向流数据量initial_max_stream_data_bidi_local (0x05)：  本参数是一个整型值，用于指定本地初始化的双向流的初始流量控制限制。 这个限制适用于由发送传输参数端打开的新创建双向流。 在客户端传输参数中，其适用于流标识符最低两个有效位设置为0x00的流；在服务端，其适用于流标识符最低两个有效位设置为0x01的流。
 初始远端最大双向流数据量initial_max_stream_data_bidi_remote (0x06):  本参数是一个整型值，用于指定对端初始化的双向流的初始流量控制限制。 这个限制适用于由接收传输参数端打开的新创建双向流。 在客户端传输参数中，其适用于流标识符最低两个有效位设置为0x01的流；在服务端，其适用于流标识符最低两个有效位设置为0x00的流。
 初始最大单向流数据量initial_max_stream_data_uni (0x07):  本参数是一个整型值，用于指定单向流的初始流量控制限制。 这个限制适用于接收传输参数端打开的新创建单向流。 在客户端传输参数中，其适用于流标识符最低两个有效位设置为0x03的流；在服务端，其适用于流标识符最低两个有效位设置为0x02的流。
 初始最大双向流数量initial_max_streams_bidi (0x08):  初始最大双向流数量参数是一个整型值，包含接收该传输参数的终端允许初始化的最大双向流数量。 如果这个参数未设置或置为0，则对端不能开启双向流直到发完最大流帧。 设置该参数等效于发送一个相关流类型的数值一致的最大流帧（第19.</description>
    </item>
    
    <item>
      <title>4.1. 单独的数据包号空间</title>
      <link>/RFC9002_Chinese_Translation/Relevant_Differences_between_QUIC_and_TCP/4.1_Separate_Packet_Number_Spaces/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9002_Chinese_Translation/Relevant_Differences_between_QUIC_and_TCP/4.1_Separate_Packet_Number_Spaces/</guid>
      <description>除了0-RTT密钥会和所有的1-RTT密钥共享数据包号空间外，QUIC为每个密级使用单独的数据包号空间。单独的数据包号空间确保了以某个密级发送的数据包确认不会引发以另一密级发送的数据包被无效地重传。拥塞控制和往返时间（RTT）测量在不同数据包号空间之间是通用的。</description>
    </item>
    
    <item>
      <title>4.2. 单调递增的数据包号</title>
      <link>/RFC9002_Chinese_Translation/Relevant_Differences_between_QUIC_and_TCP/4.2_Monotonically_Increasing_Packet_Numbers/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9002_Chinese_Translation/Relevant_Differences_between_QUIC_and_TCP/4.2_Monotonically_Increasing_Packet_Numbers/</guid>
      <description>TCP强制接收方的接收顺序与发送方的发送顺序一致，这会引发重传歧义问题（详见《RETRANSMISSION》）。QUIC将发送顺序与接收顺序分离：数据包号表明了发送顺序，而接收顺序是由流帧中的流偏移决定的。
QUIC的数据包号在同一个数据包号空间中是严格递增的，并且其中直接编码了传输顺序。较大的数据包号表明该数据包是在较晚的时候被发送的，而较小的数据包号表明该数据包是在较早的时候被发送的。当包含ACK触发帧的数据包被认定为丢包时，QUIC会在具有新数据包号的新数据包中发送所有必要的帧，并在接收到确认时弄清楚实际送达了哪些数据包。此外，还可以基于数据包号更精确地进行RTT测量、更简单地检测无效重传、更通用地使用快速重传等机制。
这一设计极大地简化了QUIC的丢包检测机制。大多数TCP机制都隐式地试图基于TCP序列号推断发送顺序——这是一项困难的工作，尤其是当TCP时间戳不可用时。</description>
    </item>
    
    <item>
      <title>4.3. 更准确的丢包计时器</title>
      <link>/RFC9002_Chinese_Translation/Relevant_Differences_between_QUIC_and_TCP/4.3_Clearer_Loss_Epoch/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9002_Chinese_Translation/Relevant_Differences_between_QUIC_and_TCP/4.3_Clearer_Loss_Epoch/</guid>
      <description>QUIC会在数据包丢包时启动一个丢包计时器。该丢包计时器会在其启动后被发送的任一数据包得到确认时停止计时。而在TCP中的行为是等到序列号空间的空档被填上为止，因此当某数据段连续遭遇丢包时，丢包计时器哪怕经过数轮往返时间也不会停止。因为两者都应该在每次计时期间仅缩小一次拥塞窗口，所以QUIC能够在每轮遭遇丢包的往返时间内缩小一次窗口，而TCP可能要经过数段往返时间才缩小一次。</description>
    </item>
    
    <item>
      <title>4.4. 禁止食言</title>
      <link>/RFC9002_Chinese_Translation/Relevant_Differences_between_QUIC_and_TCP/4.4_No_Reneging/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9002_Chinese_Translation/Relevant_Differences_between_QUIC_and_TCP/4.4_No_Reneging/</guid>
      <description>QUIC的ACK帧包含着的信息与TCP的可选确认（SACK）（详见《RFC2018》）中的类似。然而在QUIC中，禁止更改对某个数据包的确认，这极大地简化了两侧终端的实现并降低了发送方的内存压力。</description>
    </item>
    
    <item>
      <title>4.5. 更多ACK块</title>
      <link>/RFC9002_Chinese_Translation/Relevant_Differences_between_QUIC_and_TCP/4.5_More_ACK_Ranges/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9002_Chinese_Translation/Relevant_Differences_between_QUIC_and_TCP/4.5_More_ACK_Ranges/</guid>
      <description>与TCP的三个SACK块不同，QUIC支持多个ACK块。在高丢包率的环境下，这能加速恢复，减少无效重传，并且确保有效发送而不需要依赖超时机制。</description>
    </item>
    
    <item>
      <title>4.6. 显式纠正确认延迟</title>
      <link>/RFC9002_Chinese_Translation/Relevant_Differences_between_QUIC_and_TCP/4.6_Explicit_Correction_for_Delayed_Acknowledgments/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9002_Chinese_Translation/Relevant_Differences_between_QUIC_and_TCP/4.6_Explicit_Correction_for_Delayed_Acknowledgments/</guid>
      <description>QUIC终端会测量在接收到数据包时和在发送相应的确认时之间的延迟，使得对端能够维护更准确的RTT预估；详见《QUIC传输》的第13.2章。</description>
    </item>
    
    <item>
      <title>4.7. 探测包超时取代了RTO和TLP</title>
      <link>/RFC9002_Chinese_Translation/Relevant_Differences_between_QUIC_and_TCP/4.7_Probe_Timeout_Replaces_RTO_and_TLP/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9002_Chinese_Translation/Relevant_Differences_between_QUIC_and_TCP/4.7_Probe_Timeout_Replaces_RTO_and_TLP/</guid>
      <description>QUIC使用了探测包超时（PTO，详见第6.2章）和一个基于TCP的重传超时（RTO）计算法的计时器；详见《RFC6298》。QUIC的PTO中包含着对端的最大预估确认延迟，而没有使用固定的最小超时时间。
与TCP的RACK-TLP丢包检测算法（详见《RFC8985》）类似，QUIC不会在PTO超时时缩小拥塞窗口，因为单个队尾数据包遭遇丢包并不能表明持续的拥塞。取而代之的是，QUIC会在持续拥塞出现时再次缩小拥塞窗口；详见第7.6章。在此过程中，QUIC会避免不必要的拥塞窗口缩减，从而避免需要前向RTO恢复（F-RTO，详见《RFC5682》）等纠正机制。由于QUIC不会在PTO超时时缩小拥塞窗口，所以QUIC发送方在仍有剩余拥塞窗口时，即使是在PTO超时后也不会在发送更多在途数据包时受限。这种情况会在发送方受到应用限制并且PTO计时器超时时发生。当受到应用限制时，这种做法会比TCP的RTO机制更激进，但是当不受到应用限制时，它是很理想的。
无论计时器何时超时，QUIC都允许在发送探测数据包时临时超过拥塞窗口。</description>
    </item>
    
    <item>
      <title>4.8. 最小拥塞窗口为两个数据包</title>
      <link>/RFC9002_Chinese_Translation/Relevant_Differences_between_QUIC_and_TCP/4.8_The_Minimum_Congestion_Window_Is_Two_Packets/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9002_Chinese_Translation/Relevant_Differences_between_QUIC_and_TCP/4.8_The_Minimum_Congestion_Window_Is_Two_Packets/</guid>
      <description>TCP使用的最小拥塞窗口为一个数据包。然而，如果该单个数据包遭遇丢包，那么发送方就需要等待一个PTO时间才能恢复（详见第6.2章），这可能远大于单个RTT时间。当接收方有意延迟确认时，仅发送单个ACK触发包还增加了引入额外延迟的可能性。
因此QUIC推荐最小拥塞窗口为两个数据包。尽管这会增加网络负载，但是因为发送方仍然会在遇到持续拥塞时以指数形式降低自身的发送速率，因此这种做法被认为是安全的。</description>
    </item>
    
    <item>
      <title>4.9. 握手数据包并不特殊</title>
      <link>/RFC9002_Chinese_Translation/Relevant_Differences_between_QUIC_and_TCP/4.9_Handshake_Packets_Are_Not_Special/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9002_Chinese_Translation/Relevant_Differences_between_QUIC_and_TCP/4.9_Handshake_Packets_Are_Not_Special/</guid>
      <description>TCP将SYN数据包或SYN-ACK数据包遭遇丢包的情况视作为持续拥塞并且缩小拥塞窗口至一个数据包；详见《RFC5681》。QUIC将包含握手数据的数据包遭遇丢包的情况与其他丢包的情况一视同仁。</description>
    </item>
    
    <item>
      <title>5.1. 创建RTT样本</title>
      <link>/RFC9002_Chinese_Translation/Estimating_the_Round-Trip_Time/5.1_Generating_RTT_Samples/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9002_Chinese_Translation/Estimating_the_Round-Trip_Time/5.1_Generating_RTT_Samples/</guid>
      <description>终端在接收到一个符合以下两项条件的ACK帧时，会创建一份RTT样本：
  最大已确认数据包号是此次新确认的，并且
  此次新确认的数据包中至少有一个是ACK触发包。
  随着时间流逝，最新的RTT样本latest_rtt会因为最大已确认数据包的不断更新而不断创建：
latest_rtt = 确认时间 - 最大已确认数据包的发送时间 
 创建RTT样本时只会使用到接收到的那个ACK帧中的最大已确认数据包号。这是因为对端只会为ACK帧中的最大已确认数据包报告确认延迟。尽管报告的那个确认延迟不会在测量RTT样本时被用到，但是它会在后续计算smoothed_rtt和rttvar时（详见第5.3章）被用于调整RTT样本。
为了避免为同一数据包创建多份RTT样本，如果ACK帧中的最大已确认数据包号不是此次新确认的，那么它不应该被用于更新RTT预估。
当接收到的ACK帧没有新确认任何ACK触发包时，必须不创建RTT样本。在仅接收到非ACK触发包时，对端通常不会发送ACK帧。因此，仅包含对非ACK触发包的确认的ACK帧中可能有着极高的ACK延迟值。忽略这样的ACK帧避免了后续计算smoothed_rtt和rttvar时的复杂度。
当在一个RTT内接收到多个ACK帧时，发送方可能会在一个RTT内创建多个RTT样本。正如《RFC6298》中建议的那样，这么做可能会造成smoothed_rtt和rttvar中出现冗余的历史记录。确保RTT预估保持适量的历史记录是一个开放的待研究问题。</description>
    </item>
    
    <item>
      <title>5.2. 预估min_rtt</title>
      <link>/RFC9002_Chinese_Translation/Estimating_the_Round-Trip_Time/5.2_Estimating_min_rtt/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9002_Chinese_Translation/Estimating_the_Round-Trip_Time/5.2_Estimating_min_rtt/</guid>
      <description>min_rtt是发送方对于一段时间内在给定网络路径上观测到的最小RTT的预估。在本文中，min_rtt会被丢包检测用于去除那些过小的RTT样本。
在首份RTT样本上，min_rtt必须被设置为latest_rtt。在其余样本上，min_rtt必须被设置为min_rtt和latest_rtt（详见第5.1章）中的较小值。
终端在计算min_rtt时仅使用本地观测到的时间，不会因对端报告的确认延迟而做出调整。这么做使得终端能够为完全基于其观测结果的smoothed_rtt设置较低的下限，并且减少潜在的因为对端误报的延迟而产生的过低估计。
一条网络路径的RTT可能会随时间变化。如果一条路径的实际RTT降低了，那么min_rtt就会立即在首个低值样本上作出响应。然而，如果一条路径的实际RTT升高了，那么min_rtt不会作出响应，从而允许将来的比此新RTT要小的RTT样本能被包含在smoothed_rtt中。
终端应该在检测到持续拥塞后将min_rtt设置为最新的RTT样本。这避免了当RTT升高时反复报告持续拥塞。这还使得连接能够在一次网络中断事件后重置它的min_rtt和smoothed_rtt；详见第5.3章。
中断可以在其他时间点重建连接的min_rtt，例如当流量较低时和当接收到具有较低的确认延迟的确认时。QUIC实现不应该过于频繁地重置min_rtt，因为一条路径真正的最小RTT不会经常被观测到。</description>
    </item>
    
    <item>
      <title>5.3. 预估smoothed_rtt和rttvar</title>
      <link>/RFC9002_Chinese_Translation/Estimating_the_Round-Trip_Time/5.3_Estimating_smoothed_rtt_and_rttvar/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9002_Chinese_Translation/Estimating_the_Round-Trip_Time/5.3_Estimating_smoothed_rtt_and_rttvar/</guid>
      <description>smoothed_rtt是终端RTT样本的以指数形式加权的滑动平均值，而rttvar用平均差的方式预估了RTT样本间的偏差。
smoothed_rtt的计算需要用到经过确认延迟调整的RTT样本。这些延迟是按照《QUIC传输》的第19.3章中所描述的那样，从ACK帧的ACK延迟字段中解码出来的。
对端报告的确认延迟可能会比它在握手期间宣称的max_ack_delay（最大ACK延迟，详见《QUIC传输》的第13.2.1章）还大。为了解决这个问题，终端在握手确认前应该按照《QUIC-TLS》的第4.1.2章中描述的那样，忽略max_ack_delay。当这种情况发生时，这些巨大的确认延迟很有可能不会反复出现，并且仅限于在握手期间出现。因此终端可以使用它们而不受限于max_ack_delay，避免RTT预估不必要地膨胀。
注意，如果在对端报告确认延迟或预估min_rtt的过程中出现错误，那么巨大的确认延迟会导致smoothed_rtt的显著膨胀。因此，在握手确认前，如果使用确认延迟调整后的RTT样本低于min_rtt，那么终端可以忽略这样的RTT样本。
在握手确认后，对端报告的任何大于其max_ack_delay的确认延迟都可以被认为是无意中重复计量的延迟，例如对端的调度器延迟或因之前的确认遭遇丢包而产生的延迟。不遵守协议的接收方也有可能引入额外的延迟。因此，这些额外的延迟被认为是路径延迟的有效部分，并被计入RTT预估。
因此，当使用由对端报告的确认延迟来调整RTT样本时：
  可以忽略对初始数据包的确认延迟，因为这些确认不是被对端延误的（详见《QUIC传输》的第13.2.1章）；
  在握手确认前，应该忽略对端的max_ack_delay；
  在握手确认后，必须使用确认延迟和对端的max_ack_delay中的较小值；并且
  当产生的结果小于min_rtt时，必须不从RTT样本中减去确认延迟。这减少了因为对端错误地报告而对于smoothed_rtt作出过低估计的情况。
  除此之外，终端可能在相应的解密密钥尚未可用时推迟确认的处理。例如，客户端可能接收到一个对于0-RTT数据包的确认但它却无法解密，因为1-RTT数据包保护密钥尚未可用。在这种情况下，终端应该在握手确认前从它的RTT样本中减去这些由本机产生的延迟。
与《RFC6298》类似，smoothed_rtt和rttvar的计算过程如下所述。
终端在连接建立期间初始化RTT预估器，以及在连接迁移期间重置预估器时也会将它初始化；详见《QUIC传输》的第9.4章。在任何新路径的RTT样本可用前，或在预估器被重置后，预估器都会使用初始RTT来初始化；详见第6.2.2章。
smoothed_rtt和rttvar会以这种方式初始化，其中kInitialRtt为初始RTT值：
smoothed_rtt = kInitialRtt rttvar = kInitialRtt / 2 
 网络路径的RTT样本被记录在latest_rtt中；详见第5.1章。在初始化后得到首份RTT样本时，使用该样本来重置预估器。这确保了预估器中不留有过去样本的历史记录。在其他路径上发送的数据包并不会为当前路径的RTT样本做出贡献，如《QUIC传输》的第9.4章所述。
在初始化后得到首份RTT样本时，以这种方式设置smoothed_rtt和rttvar：
smoothed_rtt = latest_rtt rttvar = latest_rtt / 2 
 在得到后续RTT样本时，以这种方式更新smoothed_rtt和rttvar：
ack_delay = 从ACK帧中解码的确认延迟 if (握手已确认): ack_delay = min(ack_delay, max_ack_delay) adjusted_rtt = latest_rtt if (latest_rtt &amp;gt;= min_rtt + ack_delay): adjusted_rtt = latest_rtt - ack_delay smoothed_rtt = 7/8 * smoothed_rtt + 1/8 * adjusted_rtt rttvar_sample = abs(smoothed_rtt - adjusted_rtt) rttvar = 3/4 * rttvar + 1/4 * rttvar_sample</description>
    </item>
    
    <item>
      <title>6.1.1. 数据包数量阈值</title>
      <link>/RFC9002_Chinese_Translation/Loss_Detection/Acknowledgment-Based_Detection/6.1.1_Packet_Threshold/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9002_Chinese_Translation/Loss_Detection/Acknowledgment-Based_Detection/6.1.1_Packet_Threshold/</guid>
      <description>基于TCP丢包检测的最佳实践（详见《RFC5681》和《RFC6675》）推荐将针对乱序的数据包数量阈值（kPacketThreshold）初始值设置为3。为了和TCP保持相似，QUIC实现不应该使用低于3的数据包数量阈值；详见《RFC5681》。
一些网络可能表现出高度的数据包乱序特征，使得发送方错误地检测到数据包丢包的情况。除此之外，数据包乱序在QUIC中可能比在TCP中更常见，因为有能力观测TCP数据包并重建顺序的网络设备不能为QUIC做同样的处理，还因为QUIC数据包的数据包号是经过加密的。在错误地检测到丢包后提升乱序阈值的算法，例如RACK（详见《RFC8985》），被证明在TCP中是有用的，它们在QUIC中应该至少有同样的效果。</description>
    </item>
    
    <item>
      <title>6.1.2. 数据包发送时间阈值</title>
      <link>/RFC9002_Chinese_Translation/Loss_Detection/Acknowledgment-Based_Detection/6.1.2_Time_Threshold/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9002_Chinese_Translation/Loss_Detection/Acknowledgment-Based_Detection/6.1.2_Time_Threshold/</guid>
      <description>一旦相同数据包号空间内的后续数据包得到确认，终端就应该将比它更早发送的且已经超过一定时间的数据包认定为丢包。为了避免过早地将数据包认定为丢包，该时间阈值必须至少被设置为本机计时器的粒度；后者用常量kGranularity来表示。时间阈值可以表示为：
max(kTimeThreshold * max(smoothed_rtt, latest_rtt), kGranularity) 
 如果某个比最大已确认数据包更早发送的数据包尚未被认定为丢包，那么应该以其残余时间设置一个计时器。
使用max(smoothed_rtt, latest_rtt)可以避免以下两种情况：
  最新的RTT样本低于经平滑的RTT，这可能是因为包含着确认的数据包走了一条更短路径而产生了乱序；
  最新的RTT样本高于经平滑的RTT，这可能是因为真实RTT升高了，但是经平滑的RTT还没有追上此变化。
  推荐将时间阈值（kTimeThreshold），也就是RTT倍率，设置为9/8。推荐将计时器粒度（kGranularity）设置为1毫秒。
 注意：出于类似的目的，TCP的RACK（详见《RFC8985》）指定了一个稍微大一些的阈值，该值相当于5/4。在QUIC中实践表明9/8表现得更好一些。
 QUIC实现可以尝试使用绝对阈值、来自先前连接的阈值、自适应阈值或引入RTT偏差。较小的阈值会降低对乱序的容忍度并增加无效重传，较大的阈值会增大丢包检测的响应时间。</description>
    </item>
    
    <item>
      <title>6.2.1. 计算PTO</title>
      <link>/RFC9002_Chinese_Translation/Loss_Detection/Probe_Timeout/6.2.1_Computing_PTO/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9002_Chinese_Translation/Loss_Detection/Probe_Timeout/6.2.1_Computing_PTO/</guid>
      <description>当发送ACK触发包时，发送方会启动一个PTO计时器，它的计算方式如下：
PTO = smoothed_rtt + max(4*rttvar, kGranularity) + max_ack_delay 
 PTO就是发送方为某数据包的确认应该等待的时间量。该时间量包含了预估的网络RTT（smoothed_rtt）、预估的偏差量（4*rttvar）和max_ack_delay，包含max_ack_delay能将接收方可以在发送确认前延迟的最长时间考虑进来。
当在初始数据包号空间或握手数据包号空间中使用PTO时，其计算式中的max_ack_delay要设为0，因为对端不应该有意推迟发送这些数据包；详见《QUIC传输》的第13.2.1章。
PTO的值必须不小于kGranularity，以避免计时器立即超时。
当多个数据包号空间中的ACK触发包均在途时，计时器必须被设置为在初始数据包号空间和握手数据包号空间中较早超时的那个值。
终端在握手确认前必须不为应用数据数据包号空间设置其PTO计时器。这么做避免了终端在对端还没有用于处理的密钥或终端还没有用于处理确认的密钥时就重传信息。举例来说，这种情况可能在客户端向服务器发送0-RTT数据包时出现；它无需了解服务器是否会有能力解密就会发送它们。类似地，这种情况还可能在服务器未等到确认客户端已验证完服务器证书从而读取1-RTT数据包就发送这些数据包时出现。
发送方应该在每次发送或确认ACK触发包时，或当启用初始密钥或握手密钥时（详见《QUIC-TLS》的第4.9章），重启自己的PTO计时器。这确保了计算出来的PTO总是基于最新的RTT预估的，并且针对的总是不同数据包号空间中的那个正确的数据包。
当PTO计时器超时时，必须增加PTO补偿，使得PTO被设置为当前量的两倍。除非是下文所述的情况，否则PTO补偿因子会在接收到确认时被重置。服务器可能在握手期间花费比其他时候更长的时间来响应数据包。为了保护这样的服务器免于重复的客户端探测包，尚未确定服务器是否已验证完自身地址的客户端处的PTO补偿不会被重置。也就是说，客户端不会在接收到来自初始数据包中的确认的时候重置PTO补偿因子。
发送方速率的指数级降低非常重要，因为严重的拥塞引发的数据包或确认的丢包可能连续导致PTO超时。即使多个数据包号空间中均有在途数据包，所有空间中PTO的指数级增加也能避免对网络施加额外的负载。举个例子，初始数据包号空间中的超时会使得握手数据包号空间中的超时时间翻倍。
连续PTO超时的总时长会受到空闲超时时间的限制。
如果已经为基于发送时间阈值的丢包检测设置了计时器，那么必须不设置PTO计时器。为基于发送时间阈值的丢包检测设置的计时器在大多数情况下都会比PTO计时器更早超时，并且更不太可能会无效地重传数据。</description>
    </item>
    
    <item>
      <title>6.2.2.1. 在地址验证之前</title>
      <link>/RFC9002_Chinese_Translation/Loss_Detection/Probe_Timeout/Handshakes_and_New_Paths/6.2.2.1_Before_Address_Validation/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9002_Chinese_Translation/Loss_Detection/Probe_Timeout/Handshakes_and_New_Paths/6.2.2.1_Before_Address_Validation/</guid>
      <description>如《QUIC传输》的第8.1章所规定的那样，在服务器验证完客户端在路径上的地址前，它能发送的数据量被限制于它所接收到数据量的三倍。如果不能发送更多数据，那么服务器必须不启动PTO计时器，除非接收到了来自客户端的数据报，因为在PTO超时时发送的数据包会被计入抗放大上限。
当服务器接收到了来自客户端的数据报时，抗放大上限会被提升，服务器会重置PTO计时器。如果这时PTO计时器被设置为了一个已过去的时间，那么它会立即超时。这么做能避免在发送对完成握手至关重要的数据包前发送新的1-RTT数据包。这种情况尤其会在服务器接受了0-RTT但是没有成功验证客户端地址时发生。
由于服务器在接收到来自客户端的更多数据报前处于禁言状态，发送数据包来解禁服务器就成了客户端的责任，除非它能确定服务器已经完成了对它的地址验证（详见《QUIC传输》的第8章）。也就是说，如果客户端没有接收到任何对于它的握手数据包的确认，并且握手尚未确认（详见《QUIC-TLS》的第4.1.2章），那么它必须设置PTO计时器，哪怕没有在途数据包。当此PTO超时时，如果客户端持有握手密钥，那么它必须发送一个握手数据包，否则它必须用一个载荷至少长1200字节的UD数据报P来发送一个初始数据包。</description>
    </item>
    
    <item>
      <title>6.2.3. 加速握手完成</title>
      <link>/RFC9002_Chinese_Translation/Loss_Detection/Probe_Timeout/6.2.3_Speeding_up_Handshake_Completion/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9002_Chinese_Translation/Loss_Detection/Probe_Timeout/6.2.3_Speeding_up_Handshake_Completion/</guid>
      <description>当服务器接收到了一个包含重复的加密帧数据的初始数据包时，它可以假定客户端没有接收到服务器用初始数据包发送的任何数据，或客户端的预估RTT过小。当客户端在取得握手密钥前就接收到了握手数据包或1-RTT数据包，那么它可以假定服务器的部分甚至全部初始数据包都遭遇了丢包。
为了在这些条件下加速握手完成，终端可以，但在每条连接上仅尝试数次，在PTO超时前发送一个包含未经确认的加密帧数据的数据包，不过这仍受到《QUIC传输》的第8.1章中的地址验证限制。在每条连接上至多一次这么做，非常适合快速地从单个数据包丢包的状态中恢复。总是用重传数据包来响应接收到了但无法处理的数据包的终端要承担无限交换数据包的风险。
终端还可以使用合并数据包（详见《QUIC传输》的第12.2章）的方法来确保每份数据报都能触发至少一次确认。例如，客户端可以将包含Ping帧和填充帧的初始数据包与0-RTT数据包合并，服务器可以将包含Ping帧的初始数据包与一个或多个其他数据包合并到首次发送的数据报中。</description>
    </item>
    
    <item>
      <title>6.2.4. 加速握手完成</title>
      <link>/RFC9002_Chinese_Translation/Loss_Detection/Probe_Timeout/6.2.4_Sending_Probe_Packets/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9002_Chinese_Translation/Loss_Detection/Probe_Timeout/6.2.4_Sending_Probe_Packets/</guid>
      <description>当PTO计时器超时时，发送方必须发送一个在该数据包号空间中的ACK触发包来作为探测包。终端可以发送至多两个完整尺寸的包含ACK触发包的数据报来避免因为单个数据报遭遇丢包引发的代价高昂的连续PTO超时，或是为了在多个数据包号空间中发送数据。所有在PTO超时时发送的探测数据包都必须是能触发ACK的。
除了在超时的计时器所在的数据包号空间中发送数据外，发送方应该在其他具有在途数据的数据包号空间中发送ACK触发包，并且尽可能合并数据包。这在服务器同时具有在途的初始数据或握手数据时或在客户端同时具有在途的握手数据和应用数据时是非常有用的，因为对端可能只持有两个数据包号空间的接收密钥中的一个。
如果发送方想要在PTO超时时更快地引发确认，它可以跳过数据包号来消除确认延迟。
终端应该在因为PTO超时而发送的数据包中包含新数据。如果没有新数据可供发送，那么可以发送先前发送过的数据。QUIC实现可以使用其他策略来决定探测数据包的内容，比如基于应用所指定的优先级来发送新的数据或重传数据。
发送方有可能没有新数据也没有先前的数据用于发送。考虑这样一个例子：新的应用数据被发送于流帧中，被认定为丢包，随后在新的数据包中被重传，接着先前的数据包实际上得到了确认。当没有新数据可以发送时，发送方应该在数据包中发送Ping帧或其他ACK触发帧，来重新启动PTO计时器。
作为发送ACK触发包的替代，发送方可以将仍在途的数据包标记为丢包。这么做避免了发送额外的数据包，但是增大了过于激进地将数据包认定为丢包的风险，导致拥塞控制器不必要地降低发送速率。
连续的PTO超时会使得PTO的值以指数形式上升，随着数据包在网络中被持续丢弃，连接恢复所需的时间会以指数形式增长。在PTO超时时发送两个数据包提高了对数据包丢包的容忍度，因而降低了连续出现PTO超时事件的可能性。
当PTO计时器多次超时，没有新数据可以发送时，QUIC实现必须选择要么每次发送相同的载荷，要么发送不同的载荷。发送相同的载荷可能会更简单，并且确保了能首先送达最高优先级的帧。每次发送不同的载荷则减少了出现无效重传的机会。</description>
    </item>
    
    <item>
      <title>6.3. 处理重试数据包</title>
      <link>/RFC9002_Chinese_Translation/Loss_Detection/6.3_Handling_Retry_Packets/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9002_Chinese_Translation/Loss_Detection/6.3_Handling_Retry_Packets/</guid>
      <description>重试数据包使得客户端再发送一个初始数据包，能有效地重启连接的过程。重试数据包表明了初始数据包已被接收到但是没有得到处理。重试数据包不能被当作确认来对待，因为它既不表明数据包得到了处理，也没有指明数据包号。
接收到重试数据包的客户端会重置拥塞控制器和丢包恢复状态，包括重置任何进行中的计时器。其他连接状态，尤其是加密握手消息，会得到保留；详见《QUIC传输》的第17.2.5章。
客户端可以为服务器计算一份RTT预估，该值从首个初始数据包被发送起，至接收到重试数据包或版本协商数据包为止。客户端可以使用该值来作为初始RTT预估的默认值。</description>
    </item>
    
    <item>
      <title>6.4. 弃用密钥和数据包状态</title>
      <link>/RFC9002_Chinese_Translation/Loss_Detection/6.4_Discarding_Keys_and_Packet_State/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9002_Chinese_Translation/Loss_Detection/6.4_Discarding_Keys_and_Packet_State/</guid>
      <description>当初始数据包保护密钥和握手数据包保护密钥被弃用时（详见《QUIC-TLS》的第4.9章）所有用这些密钥发送的数据包都不再能被确认，因为对于这些数据包的确认无法得到处理。发送方必须丢弃所有于这些数据包相关的用于恢复的状态数据，并且必须将它们从在途字节计数中移除。
终端一旦开始使用握手数据包通信，就会停止发送和接收初始数据包；详见《QUIC传输》的第17.2.2.1章。在这时，所有在途初始数据包的用于恢复的状态数据都会被丢弃。
当0-RTT被拒绝时，所有在途0-RTT数据包的用于恢复的状态数据都会被丢弃。
如果服务器接受0-RTT，但是没有缓存比初始数据包更早到达的0-RTT数据包，那么提前到达的0-RTT数据包会被认定为丢包，但是这种情况不太会频繁出现。
在用某密钥加密的数据包得到确认或被认定为丢包后一段时间后，该密钥应该被弃用。然而，在握手密钥和1-RTT密钥被认为同时对客户端和服务器可用时，初始秘密值和握手秘密值就会被弃用；详见《QUIC-TLS》的第4.9.1章。</description>
    </item>
    
    <item>
      <title>7.1. 显式拥塞通知</title>
      <link>/RFC9002_Chinese_Translation/Congestion_Control/7.1_Explicit_Congestion_Notification/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9002_Chinese_Translation/Congestion_Control/7.1_Explicit_Congestion_Notification/</guid>
      <description>如果一条路径被验证为支持显式拥塞通知（ECN，详见《RFC3168》和《RFC8311》），那么QUIC会将IP头部中的拥塞预警（CE）码点识别为一次拥塞的信号。本文档规定了终端在由对端报告的ECN-CE计数增加时应该如何作出响应；详见《QUIC传输》的第13.4.2章。</description>
    </item>
    
    <item>
      <title>7.2. 初始拥塞窗口及其最小值</title>
      <link>/RFC9002_Chinese_Translation/Congestion_Control/7.2_Initial_and_Minimum_Congestion_Window/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9002_Chinese_Translation/Congestion_Control/7.2_Initial_and_Minimum_Congestion_Window/</guid>
      <description>QUIC以慢启动的方式启动每条连接，并将拥塞窗口设置为初始值。终端应该将初始拥塞窗口设置为最大数据报尺寸（max_datagram_size）的十倍大小，并且限制窗口不小于14720字节与最大数据报尺寸的两倍大小中的较大值。这种做法遵循的是《RFC6928》中的分析与推荐，并且提高了字节数限制来适应UDP中较小的8字节头部，而不是TCP中的20字节头部。
如果在连接过程中最大数据报尺寸发生了变化，那么初始拥塞窗口应该用新的尺寸值来计算。如果为了完成握手而降低了最大数据报尺寸，那么应该将拥塞窗口设置为新的值。
如《QUIC传输》的第8.1章所述，在验证完客户端的地址前，服务器会被抗放大上限所限制。尽管抗放大上限会阻止拥塞窗口被完全利用，因而减缓拥塞窗口的尺寸增长，但是它并不会直接影响到拥塞窗口。
最小拥塞窗口是拥塞窗口在应对丢包、由对端报告的ECN-CE计数增加或持续拥塞时能达到的最小值。推荐将该值设置为2 * max_datagram_size。</description>
    </item>
    
    <item>
      <title>7.3.1. 慢启动</title>
      <link>/RFC9002_Chinese_Translation/Congestion_Control/Congestion_Control_States/7.3.1_Slow_Start/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9002_Chinese_Translation/Congestion_Control/Congestion_Control_States/7.3.1_Slow_Start/</guid>
      <description>只要拥塞窗口低于慢启动阈值，使用NewReno的发送方就会进入慢启动状态。发送方一开始会处于慢启动状态，是因为慢启动阈值的初始值为无穷大。
当发送方处于慢启动状态时，拥塞窗口就会在每次处理到确认时按照已确认的字节数逐渐扩大。这会使得拥塞窗口以指数形式扩大。
当数据包遭遇丢包或当由对端报告的ECN-CE计数增加时，发送方必须退出慢启动状态并进入恢复期。
任何时候，只要拥塞窗口低于慢启动阈值，发送方就会重新进入慢启动状态，这种情况只会在检测到持续拥塞时才会出现。</description>
    </item>
    
    <item>
      <title>7.3.2. 恢复</title>
      <link>/RFC9002_Chinese_Translation/Congestion_Control/Congestion_Control_States/7.3.2_Recovery/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9002_Chinese_Translation/Congestion_Control/Congestion_Control_States/7.3.2_Recovery/</guid>
      <description>当检测到丢包或当由对端报告的ECN-CE计数增加时，使用NewReno的发送方就会进入恢复期。已经处于恢复期的发送方不会重新进入恢复期。
在进入恢复期时，发送方必须将慢启动阈值设置为检测到丢包时的拥塞窗口大小的一半。必须在退出恢复期前完成此减半操作。
QUIC实现可以在进入恢复期时立即缩小拥塞窗口，或使用其他机制，例如比例降速法（详见《PRP》），来逐渐缩小拥塞窗口。如果选择立即缩小拥塞窗口，那么可以在缩小前先发送一个数据包。如《RFC6675》的第5章所述，如果遭遇丢包的数据包中的数据得到重传，那么这种做法能加速丢包恢复，并且与TCP中的行为一致。
恢复期的目的是将缩小拥塞窗口的频率控制在每一轮往返时间内不超过一次。因此，在恢复期中，拥塞窗口不会对新的丢包事件或ECN-CN计数的增加作出响应。
一旦在恢复期中发送的数据包得到确认，恢复期就会结束，发送方会进入拥塞回避状态。这与TCP中对恢复的定义稍微有点区别，在后者中，恢复期是在引发恢复的那个被丢失的数据段得到确认时结束的。</description>
    </item>
    
    <item>
      <title>7.3.3. 拥塞回避</title>
      <link>/RFC9002_Chinese_Translation/Congestion_Control/Congestion_Control_States/7.3.3_Congestion_Avoidance/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9002_Chinese_Translation/Congestion_Control/Congestion_Control_States/7.3.3_Congestion_Avoidance/</guid>
      <description>任何时候，只要拥塞窗口超过或等于慢启动阈值并且当前并不处于恢复期，使用NewReno的发送方就会进入拥塞回避状态。
处于拥塞回避状态的发送方使用加法递增乘法递减（AIMD）的策略，且必须将在每次得到数据包确认时对拥塞窗口的扩大量限制至不超过最大数据报尺寸的一倍。
当数据包遭遇丢包或由对端报告的ECN-CE计数增加时，发送方就会退出拥塞回避状态并进入恢复期。</description>
    </item>
    
    <item>
      <title>7.4. 忽略无法解密数据包的丢包事件</title>
      <link>/RFC9002_Chinese_Translation/Congestion_Control/7.4_Ignoring_Loss_of_Undecryptable_Packets/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9002_Chinese_Translation/Congestion_Control/7.4_Ignoring_Loss_of_Undecryptable_Packets/</guid>
      <description>在握手期间，一些数据包保护密钥可能在某数据包抵达时尚未可用，并且接收方可以选择丢弃这样的数据包。特别是，握手和0-RTT数据包在初始数据包抵达前无法得到处理，并且1-RTT数据包在握手完成前也无法得到处理。如果握手数据包、0-RTT数据包和1-RTT数据包有可能先于用于处理它们的数据包保护密钥变为可用就抵达了，那么终端可以忽略这些数据包的丢包事件。如果在给定数据包号空间中，晚于首个得到确认的数据包发送的数据包遭遇了丢包，那么终端必须不忽略它们。</description>
    </item>
    
    <item>
      <title>7.5. 探测包超时</title>
      <link>/RFC9002_Chinese_Translation/Congestion_Control/7.5_Probe_Timeout/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9002_Chinese_Translation/Congestion_Control/7.5_Probe_Timeout/</guid>
      <description>拥塞控制器必须不阻拦探测数据包。然而发送方必须将这些数据包额外计入在途字节中，因为这些数据包增加了网络负载。注意，发送探测数据包可能使得发送方的在途字节数超过拥塞窗口，直到接收到了那个能够确定该数据包是遭遇了丢包还是已被送达的确认。</description>
    </item>
    
    <item>
      <title>7.6.1. 时长</title>
      <link>/RFC9002_Chinese_Translation/Congestion_Control/Persistent_Congestion/7.6.1_Duration/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9002_Chinese_Translation/Congestion_Control/Persistent_Congestion/7.6.1_Duration/</guid>
      <description>持续拥塞的时长是以这种方式计算的：
(smoothed_rtt + max(4*rttvar, kGranularity) + max_ack_delay) * kPersistentCongestionThreshold 
 与第6.2章中的PTO计算式不同，该时长的计算式中也包含了max_ack_delay但无需关心发生丢包的数据包号空间。
该时长使得发送方能够在出现持续拥塞前发送的数据包数量与TCP用尾部丢失探测（详见《RFC8985》）和RTO（详见《RFC5681》）时能发送的数量一样，其中包括在PTO超时时发送的那些数据包。
更大的kPersistentCongestionThreshold值使得发送方对网络中的持续拥塞变得更不敏感，这会导致它向拥塞的网络中激进地继续发送数据包。过小的值会导致发送方不必要地检测到持续拥塞，降低发送方的吞吐量。
推荐将kPersistentCongestionThreshold的值设为3，这使得发送方的行为与在两个TLP后建立一个RTO的TCP发送方的行为几乎一致。
这种设计没有使用连续的PTO事件来识别持续拥塞，因为应用的行为模式会影响PTO的超时。举个例子，间歇地发送少量数据且在两次发送间存在静默期的发送方会在每次发送数据时重启PTO计时器，有可能使得PTO计时器很长时间都没有出现超时，哪怕它没有接收到任何确认。时长的计算使得发送方无需依赖PTO超时就能识别持续拥塞。</description>
    </item>
    
    <item>
      <title>7.6.2. 判定持续拥塞</title>
      <link>/RFC9002_Chinese_Translation/Congestion_Control/Persistent_Congestion/7.6.2_Establishing_Persistent_Congestion/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9002_Chinese_Translation/Congestion_Control/Persistent_Congestion/7.6.2_Establishing_Persistent_Congestion/</guid>
      <description>要使发送方判定持续拥塞，需要其接收到的确认能反映出有两个ACK触发包遭遇了丢包，并且：
  在所有数据包号空间中，这两个数据包的发送时间之间没有任何数据包是得到确认了的；
  这两个数据包的发送时间之差超过了持续拥塞的时长（详见第7.6.1章）；并且
  在这两个数据包被发送前，存在RTT样本。
  这两个数据包必须是触发ACK的，因为接收方仅被要求在其最大确认延迟之内确认触发ACK的数据包；详见《QUIC传输》的第13.2章。
不应该在没有RTT样本时就开始一段持续拥塞。在得到首份RTT样本前，发送方基于初始RTT（详见第6.2.2章）建立PTO计时器，它可能会比实际RTT要大。存在RTT样本的这项要求防止了发送方在几乎没有发送过探测包的情况下就开始识别持续拥塞。
由于网络拥塞不会受到数据包号空间的影响，所以持续拥塞应该将在所有数据包号空间中发送的数据包都考虑进来。尚未为全部数据包号空间建立状态数据的发送方或无法在不同数据包号空间间比较发送时间的QUIC实现可以仅使用得到确认的数据包号空间的状态数据。这种做法可能导致错误地识别到持续拥塞，但它不会引发漏判。
与TCP的发送方对RTO（详见《RFC5681》）作出的响应行为类似，当识别出持续拥塞时，发送方的拥塞窗口必须被缩小至拥塞窗口的最小值（kMinimumWindow）。</description>
    </item>
    
    <item>
      <title>7.6.3. 样例</title>
      <link>/RFC9002_Chinese_Translation/Congestion_Control/Persistent_Congestion/7.6.3_Example/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9002_Chinese_Translation/Congestion_Control/Persistent_Congestion/7.6.3_Example/</guid>
      <description>接下来的样例展示了发送方是怎样判定持续拥塞的。假设：
smoothed_rtt + max(4*rttvar, kGranularity) + max_ack_delay = 2 kPersistentCongestionThreshold = 3 
 考虑下列事件序列：
   时间 行为     t=0 发送1号数据包（应用数据）   t=1 发送2号数据包（应用数据）   t=1.2 接收到对于1号数据包的确认   t=2 发送3号数据包（应用数据）   t=3 发送4号数据包（应用数据）   t=4 发送5号数据包（应用数据）   t=5 发送6号数据包（应用数据）   t=6 发送7号数据包（应用数据）   t=8 发送8号数据包（PTO 1）   t=12 发送9号数据包（PTO 2）   t=12.2 接收到对于9号数据包的确认    表1</description>
    </item>
    
    <item>
      <title>7.7. 限速</title>
      <link>/RFC9002_Chinese_Translation/Congestion_Control/7.7_Pacing/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9002_Chinese_Translation/Congestion_Control/7.7_Pacing/</guid>
      <description>发送方应该基于来自拥塞控制器的输入来限制发送在途数据包的速率。
不带间隔地向网络中发送多个数据包的行为将构成一次数据包暴发，这可能引发短暂的拥塞与丢包。发送方必需要么使用限速器要么限制这样的暴发。发送方应该将一次暴发的数量限制至不超过初始拥塞窗口的尺寸，详见第7.2章。如果发送方能够了解到通向接收方的网络路径可以吸收较大的暴发，那么它可以使用更高的上限值。
QUIC实现应该小心地设计其拥塞控制器的架构以使之与限速器协作良好。比如，限速器可以包装拥塞控制器并且控制拥塞窗口的可用性，或者限速器可以限制由拥塞控制器传出的数据包的发送速率。
按时送达ACK帧对于高效的丢包检测是非常重要的。因此，为了避免延误，仅包含ACK帧的数据包应该不受限速器影响。
终端可以自由实现限速器。完美地进行限速的发送方能将数据包等间隔地发送出去。对于基于窗口的拥塞控制器，例如本文档中描述的这种，该发送速率可以用将拥塞窗口平摊到RTT上的方法来计算。其表示方法如下，其中速率（rate）和拥塞窗口（congestion_window）都用字节来度量：
rate = N * congestion_window / smoothed_rtt 
 或用每两个数据包间的时间间隔（interval）的方式来表示（packet_size表示数据包尺寸）：
interval = ( smoothed_rtt * packet_size / congestion_window ) / N 
 使用较小的但至少为1的N值（例如1.25）确保了RTT间的偏差不会导致拥塞窗口的不完全利用。
在实践时要考量的方面，例如分包、调度延迟和计算效率，可能使得发送方在远小于RTT的时间间隔内偏离该速率。
限速器的一种可能实现策略是使用漏桶算法，其中“桶”的容量被限制为最大暴发量，填充“桶”的速率由上文中的函数决定。</description>
    </item>
    
    <item>
      <title>7.8. 不完全利用的拥塞窗口</title>
      <link>/RFC9002_Chinese_Translation/Congestion_Control/7.8_Underutilizing_the_Congestion_Window/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9002_Chinese_Translation/Congestion_Control/7.8_Underutilizing_the_Congestion_Window/</guid>
      <description>当在途字节数小于拥塞窗口且发送数据包未受到限速时，拥塞窗口将处于不完全利用的状态。这种情况可能因为应用数据不充足或流量控制限制而发生。当该情况发生且处于慢启动或拥塞回避状态时，拥塞窗口不应该被扩大。
对数据包进行限速（详见第7.7章）的发送方可能推迟发送数据包，从而使得拥塞窗口没有被完全利用。如果发送方在不受到限速延迟的影响下其实能够完全利用拥塞窗口，那么它不应该认为自己受到的是应用的限制。。
发送方可以实现替代机制以在不完全利用的时期过去之后更新其拥塞窗口，例如那些在《RFC7661》中为TCP提出的方案。</description>
    </item>
    
    <item>
      <title>8.1. 丢包与拥塞的信号</title>
      <link>/RFC9002_Chinese_Translation/Security_Considerations/8.1_Loss_and_Congestion_Signals/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9002_Chinese_Translation/Security_Considerations/8.1_Loss_and_Congestion_Signals/</guid>
      <description>丢包检测与拥塞控制实际上会使用到来自未经认证的实体的信号，例如延误、丢包，以及ECN标记。攻击者能够通过控制这些信号的方式使得终端降低发送速率：它可以丢弃数据包、有意改变路径上的数据包延迟表现，或修改ECN码点。</description>
    </item>
    
    <item>
      <title>8.2. 流量分析</title>
      <link>/RFC9002_Chinese_Translation/Security_Considerations/8.2_Traffic_Analysis/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9002_Chinese_Translation/Security_Considerations/8.2_Traffic_Analysis/</guid>
      <description>可以通过观测数据包尺寸的方法启发式地识别出仅携带ACK帧的数据包。与确认有关的一些行为模式可能暴露关于链路特征或应用行为的信息。要减少遭泄露的信息，终端可以将确认与其他帧打包到一起，或者在承担潜在的性能影响的基础上使用填充帧。</description>
    </item>
    
    <item>
      <title>8.3. 误报ECN标记</title>
      <link>/RFC9002_Chinese_Translation/Security_Considerations/8.3_Misreporting_ECN_Markings/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9002_Chinese_Translation/Security_Considerations/8.3_Misreporting_ECN_Markings/</guid>
      <description>接收方可以通过误报ECN标记的方法改变发送方对于拥塞的响应行为。抑制ECN-CE标记的报告可以使得发送方提高其发送速率。这种提高可能导致拥塞与丢包。
发送方可以对发送的数据包偶尔添加ECN-CE标记的方式检测出抑制行为。如果某个带着ECN-CE标记的数据包在被确认时没有被报告为带有CE标记，那么发送方就可以通过不再在该路径上的后续数据包上设置ECN传输能力（ECT）码点的方式对该路径禁用ECN。
额外报告ECN-CE标记会使得发送方降低其发送速率，这与在连接上宣称降低流量控制限制的效果相似而且相比起来没有额外的优势。
终端可以选择其使用的拥塞控制器。拥塞控制器送过降低其速率的方式对ECN-CE报告作出响应，但是响应的行为可能各不一样。对待这些标记时可以将它们等价于丢包事件（详见《RFC3168》），不过也可以指定其他的响应行为，例如《RFC8511》或《RFC8311》中的那些。</description>
    </item>
    
    <item>
      <title>9.1. 规范性参考文献</title>
      <link>/RFC9002_Chinese_Translation/References/9.1_Normative_References/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9002_Chinese_Translation/References/9.1_Normative_References/</guid>
      <description>[QUIC-TLS]：  Thomson, M., Ed. and S. Turner, Ed., &amp;ldquo;Using TLS to Secure QUIC&amp;rdquo;, RFC 9001, DOI 10.17487/RFC9001, May 2021, https://www.rfc-editor.org/info/rfc9001.
 [QUIC-TRANSPORT]：  Iyengar, J., Ed. and M. Thomson, Ed., &amp;ldquo;QUIC: A UDP-Based Multiplexed and Secure Transport&amp;rdquo;, RFC 9000, DOI 10.17487/RFC9000, May 2021, https://www.rfc-editor.org/info/rfc9000.
 [RFC2119]：  Bradner, S., &amp;ldquo;Key words for use in RFCs to Indicate Requirement Levels&amp;rdquo;, BCP 14, RFC 2119, DOI 10.17487/RFC2119, March 1997, https://www.rfc-editor.org/info/rfc2119.</description>
    </item>
    
    <item>
      <title>9.2. 资料性参考文献</title>
      <link>/RFC9002_Chinese_Translation/References/9.2_Informative_References/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9002_Chinese_Translation/References/9.2_Informative_References/</guid>
      <description>[FACK]：  Mathis, M. and J. Mahdavi, &amp;ldquo;Forward acknowledgement: Refining TCP Congestion Control&amp;rdquo;, ACM SIGCOMM Computer Communication Review, DOI 10.1145/248157.248181, August 1996, https://doi.org/10.1145/248157.248181.
 [PRR]：  Mathis, M., Dukkipati, N., and Y. Cheng, &amp;ldquo;Proportional Rate Reduction for TCP&amp;rdquo;, RFC 6937, DOI 10.17487/RFC6937, May 2013, https://www.rfc-editor.org/info/rfc6937.
 [RETRANSMISSION]：  Karn, P. and C. Partridge, &amp;ldquo;Improving Round-Trip Time Estimates in Reliable Transport Protocols&amp;rdquo;, ACM Transactions on Computer Systems, DOI 10.1145/118544.118549, November 1991, https://doi.</description>
    </item>
    
    <item>
      <title>A.1.1. 已发送的数据包的追踪字段</title>
      <link>/RFC9002_Chinese_Translation/Loss_Recovery_Pseudocode/Tracking_Sent_Packets/A.1.1_Sent_Packet_Fields/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9002_Chinese_Translation/Loss_Recovery_Pseudocode/Tracking_Sent_Packets/A.1.1_Sent_Packet_Fields/</guid>
      <description> 数据包号（packet_number）：  已发送数据包的数据包号。
 是否触发ACK（ack_eliciting）：  一个表明该数据包是否触发ACK的布尔值。若为真值，则应该接收到确认，不过对端可以推迟发送包含该确认的ACK帧，但不会晚于max_ack_delay。
 是否计入在途字节数（in_flight）：  一个表明该数据包是否会被计入在途字节数的布尔值。
 发送字节数（sent_bytes）：  在数据包中发送的字节数，不包含UDP或IP的头部，但包含QUIC的头部。
 发送时间（time_sent）：  该数据包被发送时的时间。
  </description>
    </item>
    
    <item>
      <title>A.2. 感兴趣的常量</title>
      <link>/RFC9002_Chinese_Translation/Loss_Recovery_Pseudocode/A.2_Constants_of_Interest/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9002_Chinese_Translation/Loss_Recovery_Pseudocode/A.2_Constants_of_Interest/</guid>
      <description>在丢包恢复中使用到的常量是基于一系列RFC、论文和常用实践的组合。
 kPacketThreshold：  在基于数据包数量阈值的丢包检测法认定某数据包丢包前允许出现乱序数据包的最大数量。在第6.1.1章中推荐的值为3。
 kTimeThreshold：  在基于数据包发送时间阈值的丢包检测法认定某数据包丢包前允许出现乱序数据包的最长时间。它被指定为RTT倍率。在第6.1.2章中推荐的值为9/8。
 kGranularity：  计时器粒度。这是一个与系统相关的值，在第6.1.2章中推荐的值为1毫秒。
 kInitialRtt：  在对RTT进行采样前使用的RTT初始值。在第6.2.2章中推荐的值为333毫秒。
 kPacketNumberSpace：  用于枚举三个数据包号空间的枚举值。
  enum kPacketNumberSpace { Initial, Handshake, ApplicationData, } 
 </description>
    </item>
    
    <item>
      <title>A.3. 感兴趣的变量</title>
      <link>/RFC9002_Chinese_Translation/Loss_Recovery_Pseudocode/A.3_Variables_of_Interest/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9002_Chinese_Translation/Loss_Recovery_Pseudocode/A.3_Variables_of_Interest/</guid>
      <description>本节描述了实现丢包检测机制所需的变量。
 latest_rtt：  当接收到对于一个未曾确认过的数据包的确认时的最近一次的RTT测量值。
 smoothed_rtt：  当前连接的经平滑的RTT，有关计算方法详见第5.3章。
 rttvar：  RTT的偏差，有关计算方法详见第5.3章。
 min_rtt：  在一段时间内观测到的RTT最小值，并忽略确认延迟，详见第5.2章。
 first_rtt_sample：  取得首份RTT样本的时间。
 max_ack_delay：  接收方有意拖延对处于应用数据数据包号空间中的数据包的确认的最长时间，其定义与同名传输参数一致（详见《QUIC传输》的第18.2章）。注意在接收到的ACK帧中的实际ack_delay可能会因为计时器延迟、数据包乱序或丢包的原因而超过该值。
 loss_detection_timer：  用于丢包检测的多用途计时器。
 pto_count：  在没有接收到确认的情况下PTO超时的触发次数。
 time_of_last_ack_eliciting_packet[kPacketNumberSpace]：  最近一个ACK触发包被发送时的时间。
 largest_acked_packet[kPacketNumberSpace]：  至今为止在该数据包号空间中发送过的最大数据包号。
 loss_time[kPacketNumberSpace]：  该数据包号空间中的下一个数据包会因为超过乱序数据包的时间阈值而被认定为丢包的时间。
 sent_packets[kPacketNumberSpace]：  该数据包号空间中数据包号与其对应的数据包信息之间的关联。在上文的附录A.1中已详细描述。
  </description>
    </item>
    
    <item>
      <title>A.4. 初始化</title>
      <link>/RFC9002_Chinese_Translation/Loss_Recovery_Pseudocode/A.4_Initialization/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9002_Chinese_Translation/Loss_Recovery_Pseudocode/A.4_Initialization/</guid>
      <description>在连接的一开始，以这种方式初始化丢包检测变量：
loss_detection_timer.reset() pto_count = 0 latest_rtt = 0 smoothed_rtt = kInitialRtt rttvar = kInitialRtt / 2 min_rtt = 0 first_rtt_sample = 0 for pn_space in [ Initial, Handshake, ApplicationData ]: largest_acked_packet[pn_space] = infinite time_of_last_ack_eliciting_packet[pn_space] = 0 loss_time[pn_space] = 0 
 </description>
    </item>
    
    <item>
      <title>A.5. 在发送数据包时</title>
      <link>/RFC9002_Chinese_Translation/Loss_Recovery_Pseudocode/A.5_On_Sending_a_Packet/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9002_Chinese_Translation/Loss_Recovery_Pseudocode/A.5_On_Sending_a_Packet/</guid>
      <description>在发送某个数据包后，有关该数据包的信息会被储存。OnPacketSent的参数已在上文的附录A.1.1中描述。
OnPacketSent的伪代码如下：
OnPacketSent(packet_number, pn_space, ack_eliciting, in_flight, sent_bytes): sent_packets[pn_space][packet_number].packet_number = packet_number sent_packets[pn_space][packet_number].time_sent = now() sent_packets[pn_space][packet_number].ack_eliciting = ack_eliciting sent_packets[pn_space][packet_number].in_flight = in_flight sent_packets[pn_space][packet_number].sent_bytes = sent_bytes if (in_flight): if (ack_eliciting): time_of_last_ack_eliciting_packet[pn_space] = now() OnPacketSentCC(sent_bytes) SetLossDetectionTimer() 
 </description>
    </item>
    
    <item>
      <title>A.6. 在接收到数据报时</title>
      <link>/RFC9002_Chinese_Translation/Loss_Recovery_Pseudocode/A.6_On_Receiving_a_Datagram/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9002_Chinese_Translation/Loss_Recovery_Pseudocode/A.6_On_Receiving_a_Datagram/</guid>
      <description>当服务器被抗放大上限阻止发送时，接收到的数据报能够为它解除禁言，即使该数据报中没有一个数据包成功得到处理。在这种情况下，需要重新设置PTO计时器。
OnDatagramReceived的伪代码如下：
OnDatagramReceived(datagram): // 如果该数据报能为服务器解禁， // 那么设置PTO计时器来避免死锁。 if (服务器被抗放大上限阻止发送): SetLossDetectionTimer() if loss_detection_timer.timeout &amp;lt; now(): // 假设抗放大上限仍生效， // 如果PTO会超时，那么执行它。 OnLossDetectionTimeout() 
 </description>
    </item>
    
    <item>
      <title>A.7. 在接收到确认时</title>
      <link>/RFC9002_Chinese_Translation/Loss_Recovery_Pseudocode/A.7_On_Receiving_an_Acknowledgment/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9002_Chinese_Translation/Loss_Recovery_Pseudocode/A.7_On_Receiving_an_Acknowledgment/</guid>
      <description>当接收到某ACK帧时，它可能新确认任意数量的数据包。
OnAckReceived和UpdateRtt的伪代码如下：
IncludesAckEliciting(packets): for packet in packets: if (packet.ack_eliciting): return true return false OnAckReceived(ack, pn_space): if (largest_acked_packet[pn_space] == infinite): largest_acked_packet[pn_space] = ack.largest_acked else: largest_acked_packet[pn_space] = max(largest_acked_packet[pn_space], ack.largest_acked) // `DetectAndRemoveAckedPackets`找到新确认的数据包 // 并将它们从`sent_packets`中移除。 newly_acked_packets = DetectAndRemoveAckedPackets(ack, pn_space) // 如果没有新确认的数据包，那么什么都不做。 if (newly_acked_packets.empty()): return // 如果最大已确认数据包是此次新确认的， // 并且此次至少确认一个ACK触发包，那么更新RTT。 if (newly_acked_packets.largest().packet_number == ack.largest_acked &amp;amp;&amp;amp; IncludesAckEliciting(newly_acked_packets)): latest_rtt = now() - newly_acked_packets.largest().time_sent UpdateRtt(ack.ack_delay) // 如果存在ECN信息，那么处理它们。 if (ACK frame contains ECN information): ProcessECN(ack, pn_space) lost_packets = DetectAndRemoveLostPackets(pn_space) if (!</description>
    </item>
    
    <item>
      <title>A.8. 设置丢包检测计时器</title>
      <link>/RFC9002_Chinese_Translation/Loss_Recovery_Pseudocode/A.8_Setting_the_Loss_Detection_Timer/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9002_Chinese_Translation/Loss_Recovery_Pseudocode/A.8_Setting_the_Loss_Detection_Timer/</guid>
      <description>QUIC的丢包检测使用一个计时器来检测所有超时事件，计时器的时长取决于计时器的模式，后者是在下文描述的数据包事件和计时器事件中指定的。下文定义的SetLossDetectionTimer展示了怎样设置这个计时器。
本算法可能导致计时器被设置到一个过去的时间，尤其是计时器没有被及时唤醒时。被设置到过去的时间的计时器会立即超时。
SetLossDetectionTimer的伪代码如下（其中^符号表示幂运算）：
GetLossTimeAndSpace(): time = loss_time[Initial] space = Initial for pn_space in [ Handshake, ApplicationData ]: if (time == 0 || loss_time[pn_space] &amp;lt; time): time = loss_time[pn_space]; space = pn_space return time, space GetPtoTimeAndSpace(): duration = (smoothed_rtt + max(4 * rttvar, kGranularity)) * (2 ^ pto_count) // 解死锁PTO从当前时间启动。 if (没有在途的ACK触发包): assert(!PeerCompletedAddressValidation()) if (有握手密钥): return (now() + duration), Handshake else: return (now() + duration), Initial pto_timeout = infinite pto_space = Initial for space in [ Initial, Handshake, ApplicationData ]: if (该space中没有在途的ACK触发包): continue; if (space == ApplicationData): // 除非握手已确认，否则跳过应用数据。 if (未确认握手): return pto_timeout, pto_space // 为应用数据空间将`max_ack_delay`和补偿纳入考量 duration += max_ack_delay * (2 ^ pto_count) t = time_of_last_ack_eliciting_packet[space] + duration if (t &amp;lt; pto_timeout): pto_timeout = t pto_space = space return pto_timeout, pto_space PeerCompletedAddressValidation(): // 假定客户端已隐式地验证了服务器的地址。 if (终端是服务器): return true // 当接收到受保护的数据包时， // 服务器完成地址验证。 return 已接收到对于握手的确认 || 握手已确认 SetLossDetectionTimer(): earliest_loss_time, _ = GetLossTimeAndSpace() if (earliest_loss_time !</description>
    </item>
    
    <item>
      <title>A.9. 在超时时</title>
      <link>/RFC9002_Chinese_Translation/Loss_Recovery_Pseudocode/A.9_On_Timeout/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9002_Chinese_Translation/Loss_Recovery_Pseudocode/A.9_On_Timeout/</guid>
      <description>当丢包检测计时器超时时，计时器的模式决定了需要采取的行动。
OnLossDetectionTimeout的伪代码如下：
OnLossDetectionTimeout(): earliest_loss_time, pn_space = GetLossTimeAndSpace() if (earliest_loss_time != 0): // 基于数据包发送时间阈值的丢包检测法。 lost_packets = DetectAndRemoveLostPackets(pn_space) assert(!lost_packets.empty()) OnPacketsLost(lost_packets) SetLossDetectionTimer() return if (没有在途的ACK触发包): assert(!PeerCompletedAddressValidation()) // 客户端发送了解死锁数据包：填充了初始数据包来挣得 // 更多的抗放大额度，握手数据包则证明了对地址的所有权。 if (有握手密钥): SendOneAckElicitingHandshakePacket() else: SendOneAckElicitingPaddedInitialPacket() else: // PTO。如果有新数据可用，那就发送，否则重传旧数据。 // 如果两者均不可用，那就发送一个Ping帧。 _, pn_space = GetPtoTimeAndSpace() SendOneOrTwoAckElicitingPackets(pn_space) pto_count++ SetLossDetectionTimer() 
 </description>
    </item>
    
    <item>
      <title>A.10. 检测丢包</title>
      <link>/RFC9002_Chinese_Translation/Loss_Recovery_Pseudocode/A.10_Detecting_Lost_Packets/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9002_Chinese_Translation/Loss_Recovery_Pseudocode/A.10_Detecting_Lost_Packets/</guid>
      <description>每次接收到ACK帧或时间阈值丢包检测计时器超时时，都会调用DetectAndRemoveLostPackets。该函数对响应数据包号空间中的已发送数据包（sent_packets）进行操作，并返回一份最新被认定为丢包的数据包的列表。
DetectAndRemoveLostPackets的伪代码如下：
DetectAndRemoveLostPackets(pn_space): assert(largest_acked_packet[pn_space] != infinite) loss_time[pn_space] = 0 lost_packets = [] loss_delay = kTimeThreshold * max(latest_rtt, smoothed_rtt) // 在数据包被认定为丢失前经过的最少时间，但不小于`kGranularity`。 loss_delay = max(loss_delay, kGranularity) // 在此时间之前发送的数据包被认定为丢包。 lost_send_time = now() - loss_delay foreach unacked in sent_packets[pn_space]: if (unacked.packet_number &amp;gt; largest_acked_packet[pn_space]): continue // 标记数据包为丢包，或设置一个它应该被标记为丢包的时间。 // 注意：这里使用`kPacketThreshold`的前提是 // 假定了在数据包号空间中没有由发送方引入的空档。 if (unacked.time_sent &amp;lt;= lost_send_time || largest_acked_packet[pn_space] &amp;gt;= unacked.packet_number + kPacketThreshold): sent_packets[pn_space].remove(unacked.packet_number) lost_packets.insert(unacked) else: if (loss_time[pn_space] == 0): loss_time[pn_space] = unacked.time_sent + loss_delay else: loss_time[pn_space] = min(loss_time[pn_space], unacked.</description>
    </item>
    
    <item>
      <title>A.11. 在启用初始密钥或握手密钥时</title>
      <link>/RFC9002_Chinese_Translation/Loss_Recovery_Pseudocode/A.11_Upon_Dropping_Initial_or_Handshake_Keys/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9002_Chinese_Translation/Loss_Recovery_Pseudocode/A.11_Upon_Dropping_Initial_or_Handshake_Keys/</guid>
      <description>当弃用初始密钥或握手密钥时，位于这些空间中的数据包会被丢弃，且丢包检测状态会被更新。
OnPacketNumberSpaceDiscarded的伪代码如下：
OnPacketNumberSpaceDiscarded(pn_space): assert(pn_space != ApplicationData) RemoveFromBytesInFlight(sent_packets[pn_space]) sent_packets[pn_space].clear() // 重置丢包检测计时器和PTO计时器。 time_of_last_ack_eliciting_packet[pn_space] = 0 loss_time[pn_space] = 0 pto_count = 0 SetLossDetectionTimer() 
 </description>
    </item>
    
    <item>
      <title>B.1. 感兴趣的常量</title>
      <link>/RFC9002_Chinese_Translation/Congestion_Control_Pseudocode/B.1_Constants_of_Interest/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9002_Chinese_Translation/Congestion_Control_Pseudocode/B.1_Constants_of_Interest/</guid>
      <description>在拥塞控制中使用到的常量是基于一系列RFC、论文和常用实践的组合。
 kInitialWindow：  在途字节数的初始值，详见第7.2章。
 kMinimumWindow：  拥塞窗口的最小字节数，详见第7.2章。
 kLossReductionFactor：  当检测到新的丢包事件而缩小拥塞窗口时使用的缩放因子。在第7章中推荐的值为0.5。
 kPersistentCongestionThreshold：  用于判定持续拥塞的时间量，它被指定为PTO倍率。在第7.6章中推荐的值为3。
  </description>
    </item>
    
    <item>
      <title>B.2. 感兴趣的变量</title>
      <link>/RFC9002_Chinese_Translation/Congestion_Control_Pseudocode/B.2_Variables_of_Interest/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9002_Chinese_Translation/Congestion_Control_Pseudocode/B.2_Variables_of_Interest/</guid>
      <description>本节描述了实现拥塞控制机制所需的变量。
 max_datagram_size：  发送方当前的最大载荷尺寸。其中不包含UDP或IP头部。最大的数据包尺寸会被用于计算拥塞窗口。终端基于其路径最大传输单元（PMTU；详见《QUIC传输》的第14.2章）来设置该值，且不会低于1200字节。
 ecn_ce_counters[kPacketNumberSpace]：  该数据包号空间中由对端在ACK帧中为ECN-CE计数器报告的最大值。该值被用于检测ECN-CE计数是否增加。
 bytes_in_flight：  所有已发送的、包含至少一个ACK触发帧或填充帧的且尚未得到确认或被认定为丢包的数据包以字节为单位的尺寸总和。其中不包含IP或UDP头部，但是包含QUIC头部和带有关联数据的认证加密（AEAD）开销。仅包含ACK帧的数据包不会被计入bytes_in_flight以确保拥塞控制不会妨碍拥塞反馈。
 congestion_window：  允许的在途字节数的最大值。
 congestion_recovery_start_time：  因为检测到丢包或ECN而进入当前恢复期的时间。当在此时间后发送的数据包得到确认时，QUIC会退出拥塞恢复。
 ssthresh：  慢启动以字节为单位的阈值。当拥塞窗口尺寸低于ssthresh时，就会处于慢启动状态，并且窗口会随着得到确认的字节数增长而扩大。
  拥塞控制的伪代码还访问了一些来自丢包恢复伪代码中的变量。</description>
    </item>
    
    <item>
      <title>B.3. 初始化</title>
      <link>/RFC9002_Chinese_Translation/Congestion_Control_Pseudocode/B.3_Initialization/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9002_Chinese_Translation/Congestion_Control_Pseudocode/B.3_Initialization/</guid>
      <description>在连接的一开始，以这种方式初始化拥塞控制变量：
congestion_window = kInitialWindow bytes_in_flight = 0 congestion_recovery_start_time = 0 ssthresh = infinite for pn_space in [ Initial, Handshake, ApplicationData ]: ecn_ce_counters[pn_space] = 0 
 </description>
    </item>
    
    <item>
      <title>B.4. 在发送数据包时</title>
      <link>/RFC9002_Chinese_Translation/Congestion_Control_Pseudocode/B.4_On_Packet_Sent/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9002_Chinese_Translation/Congestion_Control_Pseudocode/B.4_On_Packet_Sent/</guid>
      <description>只要被发送的数据包中包含非ACK帧，该数据包就会使得bytes_in_flight增长。
OnPacketSentCC(sent_bytes): bytes_in_flight += sent_bytes 
 </description>
    </item>
    
    <item>
      <title>B.5. 在数据包得到确认时</title>
      <link>/RFC9002_Chinese_Translation/Congestion_Control_Pseudocode/B.5_On_Packet_Acknowledgment/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9002_Chinese_Translation/Congestion_Control_Pseudocode/B.5_On_Packet_Acknowledgment/</guid>
      <description>该过程会被丢包检测的OnAckReceived调用，并且会被传入在sent_packets中最新的已确认数据包（acked_packets）。
在拥塞回避状态下，为拥塞窗口尺寸使用整型来表达的实现者应该小心的进行除法操作，并且可以使用在《RFC3465》的第2.1章中建议的替代方案。
InCongestionRecovery(sent_time): return sent_time &amp;lt;= congestion_recovery_start_time OnPacketsAcked(acked_packets): for acked_packet in acked_packets: OnPacketAcked(acked_packet) OnPacketAcked(acked_packet): if (!acked_packet.in_flight): return; // 从`bytes_in_flight`中移除 bytes_in_flight -= acked_packet.sent_bytes // 如果是受到应用或流量控制的限制， // 那么不要扩大拥塞窗口。 if (IsAppOrFlowControlLimited()) return // 在恢复期不要扩大拥塞窗口。 if (InCongestionRecovery(acked_packet.time_sent)): return if (congestion_window &amp;lt; ssthresh): // 慢启动。 congestion_window += acked_packet.sent_bytes else: // 拥塞回避。 congestion_window += max_datagram_size * acked_packet.sent_bytes / congestion_window 
 </description>
    </item>
    
    <item>
      <title>B.6. 在响应新的拥塞事件时</title>
      <link>/RFC9002_Chinese_Translation/Congestion_Control_Pseudocode/B.6_On_New_Congestion_Event/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9002_Chinese_Translation/Congestion_Control_Pseudocode/B.6_On_New_Congestion_Event/</guid>
      <description>该过程会在检测到新的拥塞事件时被ProcessECN和OnPacketsLost 调用。如果此时并不处于恢复期，那么就会启动恢复期，立即降低慢启动阈值并且缩小拥塞窗口。
OnCongestionEvent(sent_time): // 如果已经处于恢复期，那么不进行任何动作。 if (InCongestionRecovery(sent_time)): return // 进入恢复期。 congestion_recovery_start_time = now() ssthresh = congestion_window * kLossReductionFactor congestion_window = max(ssthresh, kMinimumWindow) // 可以发送一个数据包来加速丢包检测。 MaybeSendOnePacket() 
 </description>
    </item>
    
    <item>
      <title>B.7. 处理ECN信息</title>
      <link>/RFC9002_Chinese_Translation/Congestion_Control_Pseudocode/B.7_Process_ECN_Information/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9002_Chinese_Translation/Congestion_Control_Pseudocode/B.7_Process_ECN_Information/</guid>
      <description>该过程会在从对端接收到具有ECN相关字段的ACK帧时被调用。
ProcessECN(ack, pn_space): // 如果由对端报告的`ECN-CE`计数增加了， // 那么这可能是一次新的拥塞事件。 if (ack.ce_counter &amp;gt; ecn_ce_counters[pn_space]): ecn_ce_counters[pn_space] = ack.ce_counter sent_time = sent_packets[ack.largest_acked].time_sent OnCongestionEvent(sent_time) 
 </description>
    </item>
    
    <item>
      <title>B.8. 在丢包时</title>
      <link>/RFC9002_Chinese_Translation/Congestion_Control_Pseudocode/B.8_On_Packets_Lost/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9002_Chinese_Translation/Congestion_Control_Pseudocode/B.8_On_Packets_Lost/</guid>
      <description>该过程会在DetectAndRemoveLostPackets将数据包认定为丢包时被调用。
OnPacketsLost(lost_packets): sent_time_of_last_loss = 0 // 从`bytes_in_flight`中移除遭遇丢包的数据包。 for lost_packet in lost_packets: if lost_packet.in_flight: bytes_in_flight -= lost_packet.sent_bytes sent_time_of_last_loss = max(sent_time_of_last_loss, lost_packet.time_sent) // 如果在途数据包遭遇丢包，那么触发拥塞事件。 if (sent_time_of_last_loss != 0): OnCongestionEvent(sent_time_of_last_loss) // 如果这些数据包的丢包表明了持续拥塞， // 那么重置拥塞窗口。 // 只考虑在取得首份RTT样本后发送的数据包。 if (first_rtt_sample == 0): return pc_lost = [] for lost in lost_packets: if lost.time_sent &amp;gt; first_rtt_sample: pc_lost.insert(lost) if (InPersistentCongestion(pc_lost)): congestion_window = kMinimumWindow congestion_recovery_start_time = 0 
 </description>
    </item>
    
    <item>
      <title>B.9. 从在途字节数中移除被丢弃的数据包</title>
      <link>/RFC9002_Chinese_Translation/Congestion_Control_Pseudocode/B.9_Removing_Discarded_Packets_from_Bytes_in_Flight/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9002_Chinese_Translation/Congestion_Control_Pseudocode/B.9_Removing_Discarded_Packets_from_Bytes_in_Flight/</guid>
      <description>当初始密钥或握手密钥被弃用时，在这些空间中发送的数据包不再被计入在途字节数中。
RemoveFromBytesInFlight的伪代码如下：
RemoveFromBytesInFlight(discarded_packets): // 从在途字节数中移除所有未得到确认的数据包。 foreach packet in discarded_packets: if packet.in_flight bytes_in_flight -= size 
 </description>
    </item>
    
    <item>
      <title>19.1 填充帧</title>
      <link>/RFC9000_Chinese_Translation/Frame_Types_and_Formats/19.1_PADDING_Frames/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9000_Chinese_Translation/Frame_Types_and_Formats/19.1_PADDING_Frames/</guid>
      <description>填充帧（PADDING frame，类型0x00）无语义值。 填充帧可以用于提高数据包大小。 填充可以用于填充初始包以达到被要求的最小包大小，或对受保护数据包进行流量分析提供保护。
填充帧的格式如图23所示，可见填充帧没有内容。 也就是说，填充帧由标识该帧类型的单个字节构成。
填充帧 { 类型 (i) = 0x00, } 图23：填充帧格式
 </description>
    </item>
    
    <item>
      <title>19.2 Ping帧</title>
      <link>/RFC9000_Chinese_Translation/Frame_Types_and_Formats/19.2_PING_Frames/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9000_Chinese_Translation/Frame_Types_and_Formats/19.2_PING_Frames/</guid>
      <description>终端可以使用Ping帧（类型为0x01）验证其对端是否仍然活跃，或检查到对端的可达性。
Ping帧格式如图24所示，可见Ping帧无内容。
Ping帧 { 类型 (i) = 0x01, } 图24：Ping帧格式
 </description>
    </item>
    
    <item>
      <title>19.3.1 ACK块</title>
      <link>/RFC9000_Chinese_Translation/Frame_Types_and_Formats/ACK_Frames/19.3.1_ACK_Ranges/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9000_Chinese_Translation/Frame_Types_and_Formats/ACK_Frames/19.3.1_ACK_Ranges/</guid>
      <description>每个ACK块由交替的空档和ACK块长度值构成，按包号降序排列。 ACK块可以重复。 空档和ACK块长度值的数量由ACK块计数字段决定，每个ACK块中的一个值（空档或ACK块长度）对应ACK块计数字段的每个值。
ACK块的结构如图26所示。
ACK块 { 空档 (i), ACK块长度 (i), } 图26：ACK块
 构成ACK块的字段是：
 空档（Gap）：  一个可变长度整型值，表示比前述ACK块中的最小数据包号小一的数据包之前连续未被确认数据包的数目。
 ACK块长度（ACK Range Length）：  一个可变长度整型值，表示先前空档确定的最大数据包号之前连续被确认数据包的数目。
  空档和ACK块长度值使用一个相对整型编码以提高效率。 即使每个编码结果是正值，但也会被减去，因此每个ACK块表示的都是包号逐渐递减的数据包。
每个ACK块确认一段包号连续的数据包，通过ACK块内包号最大的被确认数据包之前的包数指定确认范围。 值为0表示只有包号最大的数据包被确认。 更大的ACK块值表示更大的确认范围，与此同时该块内最小数据包号则更小。 换言之，给定ACK块最大数据包号，则最小数据包号通过下述公式计算：
最小数据包号 = 最大数据包号 - ACK块值 一个ACK块确认最小数据包号到最大数据包号之间的全部数据包，包含两端。
一个ACK块的最大数据包号通过累积减去先前的所有ACK块长度和空档确定。
每个空档表示一段未被确认的数据包。 空档内未被确认的数据包数目比空档字段中的编码值多1。
空档字段值使用以下公式为后续ACK块生成最大的数据包号值：
最大数据包号 = 先前最小数据包号 - 空档值 - 2 如果任何有关计算得到的数据包号是负数，则终端必须产生一个FRAME_ENCODING_ERROR类型的连接错误。</description>
    </item>
    
    <item>
      <title>19.3.2 ECN计数</title>
      <link>/RFC9000_Chinese_Translation/Frame_Types_and_Formats/ACK_Frames/19.3.2_ECN_Counts/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9000_Chinese_Translation/Frame_Types_and_Formats/ACK_Frames/19.3.2_ECN_Counts/</guid>
      <description>ACK帧使用类型值的最小有效位（也就是类型0x03）表示ECN反馈，并通告收到在IP头部中带有与ECT(0)、ECT(1)或ECN-CE有关的ECN码点（codepoint）的QUIC数据包。 ECN计数只由类型为0x03的ACK帧携带。
ACK帧中ECN计数如图27所示。
ECN计数 { ECT0计数 (i), ECT1计数 (i), ECN-CE计数 (i), } 图27：ECN帧格式
 ECN计数各个字段分别是：
 ECT0计数：  一个可变长度整型值，表示收到的ACK帧所在数据包号空间里且携带ECT(0)码点的数据包总数。
 ECT1计数：  一个可变长度整型值，表示收到的ACK帧所在数据包号空间里且携带ECT(1)码点的数据包总数。
 ECN-CE计数：  一个可变长度整型值，表示收到的ACK帧所在数据包号空间里且携带ECN-CE码点的数据包总数。
  每个数据包号空间单独维护各自的ECN计数。</description>
    </item>
    
    <item>
      <title>19.4 重置帧</title>
      <link>/RFC9000_Chinese_Translation/Frame_Types_and_Formats/19.4_RESET_STREAM_Frames/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9000_Chinese_Translation/Frame_Types_and_Formats/19.4_RESET_STREAM_Frames/</guid>
      <description>终端使用重置帧（RESET_STREAM frame，类型为0x04）立即关闭流的发送部分。
发送完重置帧后，终端停止在相应的流上传输或重传流帧。 重置帧的接收方可以忽略任何已经在该流上收到的数据。
终端收到一条只用于发送的流的重置帧时必须以STREAM_STATE_ERROR类型错误关闭连接。
重置帧格式如图28所示。
重置帧 { 类型 (i) = 0x04, 流ID (i), 应用层协议错误码 (i), 最终大小 (i), } 图28：重置帧格式
 重置帧包含下述字段：
 流ID：  一个可变长度整型，编码需要关闭的流的流ID。
 应用层协议错误码（Application Protocol Error Code）：  一个可变长度整型值，包含表明为何关闭该流的应用层协议错误码（详见第20.2章）。
 最终大小（Final Size）：  一个可变长度整型值，表示重置帧发送方的流最终大小，单位字节，详见第4.5章。
  </description>
    </item>
    
    <item>
      <title>19.5 停止发送帧</title>
      <link>/RFC9000_Chinese_Translation/Frame_Types_and_Formats/19.5_STOP_SENDING_Frames/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9000_Chinese_Translation/Frame_Types_and_Formats/19.5_STOP_SENDING_Frames/</guid>
      <description>终端使用停止发送帧（STOP_SENDING frame，类型是0x05）告知对方收到每个应用层请求时传入的数据将被丢弃。 停止发送帧要求对端停止在某条流上传输数据。
一个停止发送帧可以在流的“接收”和“数据量确认”状态发送，详见第3.2章。 收到一条由本地初始化但是却尚未被创建的流的停止发送帧必须视为一个STREAM_STATE_ERROR类型的连接错误。 终端收到只用于接收的流的停止发送帧必须以STREAM_STATE_ERROR类型的错误关闭连接。
停止发送帧格式如图29所示。
停止发送帧 { 类型 (i) = 0x05, 流ID (i), 应用层协议错误码 (i), } 图29：停止发送帧格式
 停止发送帧包含如下字段：
 流ID：  一个可变长度整型值，携带需要忽略其数据的流的流ID。
 应用层协议错误码（Application Protocol Error Code）：  一个可变长度整型值，包含应用层指定的发送者忽略该流数据的原因，详见第20.2章。
  </description>
    </item>
    
    <item>
      <title>19.6 加密帧</title>
      <link>/RFC9000_Chinese_Translation/Frame_Types_and_Formats/19.6_CRYPTO_Frames/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9000_Chinese_Translation/Frame_Types_and_Formats/19.6_CRYPTO_Frames/</guid>
      <description>加密帧（CRYPTO frame，类型是0x06）用于传输加密握手信息。 其可以被除0-RTT包以外的其他类型包发送。 加密帧为加密协议提供了一个有序的字节流。 加密帧除了不携带流标识符（流ID）、不进行流控，以及不携带可选偏移量、可选长度及流结束标记外，它们在功能上与流帧完全相同。
加密帧格式如图30所示。
加密帧 { 类型 (i) = 0x06, 偏移 (i), 长度 (i), 加密数据 (i), } 图30：加密帧格式
 加密帧包含下述字段：
 偏移（Offset）：  一个可变长度整型值，表示加密帧中加密数据在数据流中的字节偏移量。
 长度：  一个可变长度整型值，表示加密帧的加密数据字段携带数据长度。
 加密数据（Crypto Data）：  加密信息数据。
  每个加密级别都有一条单独的加密握手数据流，每条流都从偏移量0开始。 也就是说每个加密级别都被视为一条单独的加密数据流。
这样的数据流其最大偏移量——偏移量与数据长度之和——不能超过226-1。 收到一个超过此上限的的帧必须视为一个FRAME_ENCODING_ERROR类型或CRYPTO_BUFFER_EXCEEDED类型的连接错误。
不同于流帧有着流ID用以区分数据属于哪条流，加密帧为每个加密级别携带单条流的数据。 数据流没有一个明确的结束点，所以加密帧没有FIN位。</description>
    </item>
    
    <item>
      <title>19.7 新令牌帧</title>
      <link>/RFC9000_Chinese_Translation/Frame_Types_and_Formats/19.7_NEW_TOKEN_Frames/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9000_Chinese_Translation/Frame_Types_and_Formats/19.7_NEW_TOKEN_Frames/</guid>
      <description>服务端发送新令牌帧（NEW_TOKEN frame，类型是0x07）给客户端提供一张令牌，以便客户端在一条后续流的初始包包头中携带该令牌发送过来。
新令牌帧格式如图31所示。
新令牌帧 { 类型 (i) = 0x07, 令牌长度 (i), 令牌 (i), } 图30：新令牌帧格式
 新令牌帧包含如下字段：
 令牌长度（Token Length）：  一个可变长度整型值，表示令牌的字节长度。
 令牌：  一个不透明blob，客户端可以在后续的初始包中使用。 令牌必须不为空。 客户端必须将收到带空令牌字段的新令牌帧的情况视为一个FRAME_ENCODING_ERROR类型的连接错误。
  如果包含这类帧的数据包被误认为丢失了，那么客户端可能收到多个携带相同令牌值的新令牌帧。 客户端负责丢弃重复的令牌，这些令牌可能用于连接重试，详见第8.1.3章。
客户端必须不能发送新令牌帧。 服务端必须将收到新令牌帧视为一个PROTOCOL_VIOLATION类型连接错误。</description>
    </item>
    
    <item>
      <title>19.8 流帧</title>
      <link>/RFC9000_Chinese_Translation/Frame_Types_and_Formats/19.8_STREAM_Frames/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9000_Chinese_Translation/Frame_Types_and_Formats/19.8_STREAM_Frames/</guid>
      <description>流帧明确地创建一条流并携带流数据。 流帧的类型字段格式形如0b00001XXX（即从0x08到0x0f之间的值）。 帧类型的三个低比特位标示帧的如下字段：
 帧类型中的OFF位（0x04）用于标识帧的偏移字段。 当置为1，则表示偏移字段存在。 当置为0，则偏移字段不存在，且流数据的偏移量从0另开（也就是说，该帧携带这条流的起始字节，或该流的终点且不携带任何数据）。 帧类型的LEN位（0x02）用于标识帧的长度字段。 当置为1，则表示长度字段不存在，且流数据字段延续到数据包的末尾。 当置为1，则表示长度字段存在。 帧类型的FIN位（0x01）标志流的结束。 流的最终数据量等于偏移量与该帧的长度之和。  如果收到属于一条由本地初始化却尚未创建的流或一条只用于发送的流的流帧，则终端必须以STREAM_STATE_ERROR类型错误关闭连接。
流帧格式如图32所示。
流帧 { 类型 (i) = 0x08..0x0f, 流ID (i), [偏移 (i)], [长度 (i)], 流数据 (..), } 图32：流帧格式
 流帧包含如下字段：
 流ID：  一个可变长度整型值，表示流的流ID，详见第2.1章。
 偏移（Offset）：  一个可变长度整型值，表示流帧中的流数据在整条流中的字节偏移量。 这个字段在OFF位置为1时存在。 当偏移字段不存在时，偏移量为0。
 长度：  一个可变长度整型值，表示流帧中的流数据字段的长度。 该字段在LEN位置为1时存在。 当LEN位置为0，则流数据字段会囊括数据包的所有剩余字节。
 流数据（Stream Data）：  指定流中需要传递的字节。
  当流数据字段长度为0，流帧的偏移量就是下一个将要发送的字节的偏移量。
流的首字节的偏移量是0。 流传输的最大偏移量——帧的偏移值与数据长度之和——不能超过262-1，因为无法为这样的数据量分配流量控制额度。 收到一个超过该限制的帧的情况必须视为一个FRAME_ENCODING_ERROR类型或FLOW_CONTROL_ERROR类型的连接错误。</description>
    </item>
    
    <item>
      <title>19.9 最大数据量帧</title>
      <link>/RFC9000_Chinese_Translation/Frame_Types_and_Formats/19.9_MAX_DATA_Frames/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9000_Chinese_Translation/Frame_Types_and_Formats/19.9_MAX_DATA_Frames/</guid>
      <description>最大数据量帧（MAX_DATA frame，类型是0x10）用于流量控制，告知对端可以在整个连接上发送的最大数据量。
最大数据量帧格式如图33所示。
最大数据量帧 { 类型 (i) = 0x10, 最大数据量 (i), } 图32：最大数据量帧格式
 最大数据量帧包含下述字段：
 最大数据量（Maximum Data）：  一个可变长度整型值，表示可以在整个连接上发送的最大数据量，单位字节。
  流帧上发送的所有数据的总和趋近该限制。 所有流的最终数据量之和——包括处于关闭状态的流——必须不可超过接收方指定的这个值。 如果终端收到的数据量超过了它发出的最大数据量值，其必须以FLOW_CONTROL_ERROR类型错误关闭流。 这包括违背早期数据记录的限制，详见第7.4.1章。</description>
    </item>
    
    <item>
      <title>19.10 最大流数据量帧</title>
      <link>/RFC9000_Chinese_Translation/Frame_Types_and_Formats/19.10_MAX_STREAM_DATA_Frames/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9000_Chinese_Translation/Frame_Types_and_Formats/19.10_MAX_STREAM_DATA_Frames/</guid>
      <description>最大流数据量帧（MAX_STREAM_DATA frame，类型是0x11）用于流量控制中通知对端一条流上可以发送的最大数据量。
最大流数据量帧可以在流的“接收”状态发送，详见第3.2章。 收到一条由本地初始化却尚未创建的流的最大流数据量帧的情况必须视为一个STREAM_STATE_ERROR类型连接错误。 收到只用于发送的流的最大流数据量帧的终端必须以STREAM_STATE_ERROR类型错误关闭连接。
最大流数据量帧格式如图34所示。
最大流数据量帧 { 类型 (i) = 0x11, 流ID (i), 最大流数据量 (i), } 图34：最大流数据量帧格式
 最大流数据量帧包含如下字段：
 流ID：  被作用的流的流ID，以可变长度整数值编码。
 最大流数据量（Maximum Stream Data）：  一个可变长度整型值，表示可以在标识流上发送的最大数据量，单位字节。
  当累计数据量趋近该限制，终端统计在流上发送或接收的数据的最大接收偏移量。 丢失或乱序可能意味着一条流的最大接收数据偏移量可能会大于该流上收到的总数据量。 收到流帧可能不会提升最大接收偏移量。
流上发送的数据必须不可以超过接收方发出的最大流数据量值的最大值。 如果终端收到比其给相关流发出的最大流数据量的最大值更多的数据量，终端必须以FLOW_CONTROL_ERROR类型错误关闭连接。 这包括违背早期数据记录的限制，详见第7.4.1章。</description>
    </item>
    
    <item>
      <title>19.11 最大流帧</title>
      <link>/RFC9000_Chinese_Translation/Frame_Types_and_Formats/19.11_MAX_STREAMS_Frames/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9000_Chinese_Translation/Frame_Types_and_Formats/19.11_MAX_STREAMS_Frames/</guid>
      <description>最大流帧（MAX_STREAMS frame，类型是0x12或0x13）用于告知对端允许打开给定类型的流的累积数量。 类型0x12的最大流帧用于双向流，类型0x13的则用于单向流。
最大流帧格式如图35所示。
最大流帧 { 类型 (i) = 0x12..0x13, 最大流数 (i), } 图35：最大流帧格式
 最大流帧包含下述字段：
 最大流数：  在连接的生命周期内可以打开的相应类型流的累积总数。 该值不能超过260，因为不能编码大于260-1的流ID。 收到允许开启高于该限制数量流的最大流帧的情况必须视为一个FRAME_ENCODING_ERROR类型的连接错误。
  丢失或乱序可能导致终端收到一个最大流帧，其限制低于之前收到的最大流帧。 必须忽略不能提高流数量限制的最大流帧。
终端必须不打开超过其对端设置的当前流限制所允许的更多的流。 例如，服务端收到限制单向流数量为3，则其可以打开流3、7和11，但是不能打开流15。 如果对端打开超过其被允许的流，那么终端必须以STREAM_LIMIT_ERROR类型错误关闭连接。 这包括违背早期数据记录的限制，详见第7.4.1章。
注意这些帧（以及有关传输参数）并未描述可以并发打开的流的数量。 该限制包括已经关闭的流和打开的流。</description>
    </item>
    
    <item>
      <title>19.12 数据阻塞帧</title>
      <link>/RFC9000_Chinese_Translation/Frame_Types_and_Formats/19.12_DATA_BLOCKED_Frames/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9000_Chinese_Translation/Frame_Types_and_Formats/19.12_DATA_BLOCKED_Frames/</guid>
      <description>发送方应该在其希望发送数据却因连接级流量控制而无法发送时，发送数据阻塞帧（DATA_BLOCKED frame，类型是0x14），详见第4章。 数据阻塞帧可以用于流量控制算法的调控输入。
数据阻塞帧格式如图36所示。
数据阻塞帧 { 类型 (i) = 0x14, 最大数据量 (i), } 图36：数据阻塞帧格式
 数据阻塞帧包含下述字段：
 最大数据量：  一个可变长度整型值，表示连接阻塞时的连接级限制。
  </description>
    </item>
    
    <item>
      <title>19.13 流数据阻塞帧</title>
      <link>/RFC9000_Chinese_Translation/Frame_Types_and_Formats/19.13_STREAM_DATA_BLOCKED_Frames/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9000_Chinese_Translation/Frame_Types_and_Formats/19.13_STREAM_DATA_BLOCKED_Frames/</guid>
      <description>发送方应该在其希望发送数据却因流级流量控制而无法发送时，发送流数据阻塞帧（STREAM_DATA_BLOCKED frame，类型是0x15）。 该传输参数类似于数据阻塞帧，详见第19.12章。
收到一条只用于发送的流的流数据阻塞帧时，终端必须以STREAM_STATE_ERROR类型错误关闭连接。
流数据阻塞帧格式如图37所示。
流数据阻塞帧 { 类型 (i) = 0x15, 最大流数据量 (i), } 图37：流数据阻塞帧格式
 流数据阻塞帧包含如下字段：
 流ID：  一个可变长度整型值，表示被流量控制阻塞的流。
 最大流数据量：  一个可变长度整型值，表示阻塞发生时流的偏移量。
  </description>
    </item>
    
    <item>
      <title>19.14 流阻塞帧</title>
      <link>/RFC9000_Chinese_Translation/Frame_Types_and_Formats/19.14_STREAMS_BLOCKED_Frames/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9000_Chinese_Translation/Frame_Types_and_Formats/19.14_STREAMS_BLOCKED_Frames/</guid>
      <description>发送方应该在其希望打开一条流但是被对端设置的最大流上限（详见第19.11章）所限制时，发送流阻塞帧（STREAM_BLOCKED frame，类型是0x16或0x17）。 类型为0x16的流阻塞帧用于表示双向流达到上限，而类型0x17则表示单向流达到上限。
流阻塞帧不会打开流，而是告知对端需要打开一条流，但是当前的流数上限阻止了这条流的创建。
流阻塞帧格式如图38所示。
流阻塞帧 { 类型 (i) = 0x16..0x17, 最大流数 (i), } 图38：流阻塞帧格式
 流阻塞帧包含如下字段：
 最大流数：  一个可变长度整型值，表示该帧发送时允许创建的最大流数量。 该值不能超过260，因为不能编码超过262-1的流ID。 收到编码值超过这个限制的流阻塞帧的情况必须被视为一个STREAM_LIMIT_ERROR或FRAME_ENCODING_ERROR类型的连接错误。
  </description>
    </item>
    
    <item>
      <title>19.15 新连接ID帧</title>
      <link>/RFC9000_Chinese_Translation/Frame_Types_and_Formats/19.15_NEW_CONNECTION_ID_Frames/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9000_Chinese_Translation/Frame_Types_and_Formats/19.15_NEW_CONNECTION_ID_Frames/</guid>
      <description>终端发送新连接ID帧（NEW_CONNECTION_ID frame，类型为0x18）给对端提供可选连接ID，其可以用于连接迁移时中断连接性，详见第9.5章。
新连接ID帧格式如图39所示。
新连接ID帧 { 类型 (i) = 0x18, 序列号 (i), 停用前 (i), 长度 (i), 连接ID (8..160), 无状态重置令牌 (128), } 图39：新连接ID帧格式
 新连接ID帧包含如下字段：
 序列号：  序列号由发送方分配给连接ID，编码为可变长度整型值，详见第15.11章。
 停用前（Retire Prior To）：  一个可变长度整型值，表示被停用的连接ID（们），详见第5.1.2章。
 长度（Length）：  一个8位无符号整型值，包含连接ID的长度。 小于1或大于20的长度值均是无效的，且必须视其为一个FRAME_ENCODING_ERROR类型连接错误。
 连接ID：  一个指定长度的连接ID。
 无状态重置令牌（Stateless Reset Token）：  一个128位值，在对关联的连接ID进行无状态重置时使用，详见第10.3章。
  如果终端当前需要对端使用0长度的目标连接ID，那么其必须不能发送该帧。 将连接ID长度改为0长度或从0长度改为非0长度都会使得难以辨别连接ID值何时发生了改变。 终端发送0长度目标连接ID的数据包时，必须将收到新连接ID帧的情况视为一个PROTOCOL_VIOLATION类型连接错误。
传输错误、超时和重传可能导致相同的新连接ID帧被重复接收。 重复接收相同的该类帧的情况必须不能被当作连接错误处理。 接收方可以根据新连接ID帧提供的序列号处理重复收到相同新连接ID帧的情况。
如果终端收到一个新连接ID帧重复了之前发布的连接ID，却有着不同的无状态重置令牌或不同的序列号字段值或该序列号用于其他不同的连接ID，终端可以将之视为一个PROTOCOL_VIOLATION类型连接错误。
“停用前”字段适用于在连接设置期间创建的连接ID以及preferred_address传输参数，详见第5.1.2章。 “停用前”字段值必须小于或等于“序列号”字段值。 收到“停用前”字段值大于序列号字段值必须视为一个FRAME_ENCODING_ERROR类型连接错误。
一旦发送方指定了一个“停用前”字段值，在后续新连接ID帧中发送的较小值就不再发挥作用了。 接收方必须忽略任何没有提高最大“停用前”值的“停用前”字段。
收到序列号小于已收到新连接ID帧的“停用前”字段值的新连接ID帧的终端必须发送一个相应的停用新收到连接ID的停用连接ID帧，除非其已经对该序列号发过这个帧了。</description>
    </item>
    
    <item>
      <title>19.16 停用连接ID帧</title>
      <link>/RFC9000_Chinese_Translation/Frame_Types_and_Formats/19.16_RETIRE_CONNECTION_ID_Frames/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9000_Chinese_Translation/Frame_Types_and_Formats/19.16_RETIRE_CONNECTION_ID_Frames/</guid>
      <description>终端发送停用连接ID帧（RETIRE_CONNECTION_ID frame，类型是0x19）来表明其将不再使用对端发布的某个连接ID。 这包含握手期间提供的连接ID。 发送一个停用连接ID帧也作为一个请求令对端发送额外的连接ID以备后续使用，详见第5.1章。 新连接ID可以通过新连接ID帧发往对端。
停用一个连接ID会令该连接ID关联的无状态重置令牌失效。
停用连接ID帧格式如图40所示。
停用连接ID帧 { 类型 (i) = 0x19, 序列号 (i), } 图40：停用连接ID帧格式
 停用连接ID帧包含如下字段：
 序列号：  被停用的连接ID的序列号，详见第5.1.2章。
  收到包含大于任何先前发往对端的序列号的停用连接ID帧的情况必须视为一个PROTOCOL_VIOLATION类型连接错误。
停用连接ID帧指定的序列号必须不能指向包含该帧的数据包的目标连接ID。 对端可以将这种情况视为一个PROTOCOL_VIOLATION类型连接错误。
如果对端提供过一个零长度连接ID，终端不能发生这类帧。 提供零长度连接ID的终端必须将收到停用连接ID帧视为一个PROTOCOL_VIOLATION类型连接错误。</description>
    </item>
    
    <item>
      <title>19.17 通道挑战帧</title>
      <link>/RFC9000_Chinese_Translation/Frame_Types_and_Formats/19.17_PATH_CHALLENGE_Frames/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9000_Chinese_Translation/Frame_Types_and_Formats/19.17_PATH_CHALLENGE_Frames/</guid>
      <description>终端可以使用通道挑战帧（PATH_CHALLENGE frame，类型是0x1a）检查到对端的可达性以及进行连接迁移过程中的通道验证。
通道挑战帧格式如图41所示。
通道挑战帧 { 类型 (i) = 0x1a, 数据 (64), } 图41：通道挑战帧格式
 通道挑战帧包含如下字段：
 数据：  8字节字段包含一段任意数据。
  包含64位任意数据的通道挑战帧确保接收数据包比猜测值的正确性更简单。
接收方收到该帧后必须生成一个包含同样数据字段内容的回复通道帧（详见第19.18章）。</description>
    </item>
    
    <item>
      <title>19.18 回复通道帧</title>
      <link>/RFC9000_Chinese_Translation/Frame_Types_and_Formats/19.18_PATH_RESPONSE_Frames/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9000_Chinese_Translation/Frame_Types_and_Formats/19.18_PATH_RESPONSE_Frames/</guid>
      <description>回复通道帧（PATH_RESPONSE frame，类型为0x1b）作为通道挑战帧的响应发送。
回复通道帧格式如图42所示。 回复通道帧格式与通道挑战帧一致，详见第19.17章。
回复通道帧 { 类型 (i) = 0x1a, 数据 (64), } 图42：回复通道帧格式
 如果回复通道帧的内容与先前发送的通道挑战帧内容不匹配，终端可以生成一个PROTOCOL_VIOLATION类型连接错误。</description>
    </item>
    
    <item>
      <title>19.19 连接关闭帧</title>
      <link>/RFC9000_Chinese_Translation/Frame_Types_and_Formats/19.19_CONNECTION_CLOSE_Frames/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9000_Chinese_Translation/Frame_Types_and_Formats/19.19_CONNECTION_CLOSE_Frames/</guid>
      <description>终端发送连接关闭帧（CONNECTION_CLOSE frame，类型是0x1c或0x1d）通知对端连接正在关闭中。 0x1c类型的连接关闭帧用于QUIC层发送错误信号，或没有错误（携带NO_ERROR码）。 0x1d类型的连接关闭帧用于使用QUIC的应用程序发送错误信号。
如果有打开的流尚未被显式关闭，当连接关闭时它们将被隐式关闭。
连接关闭帧格式如图43所示。
连接关闭帧 { 类型 (i) = 0x1c..0x1d, 错误码 (i), [帧类型 (i)], 原因语句长度 (i), 原因语句 (..), } 图43：连接关闭帧格式
 连接关闭帧包含如下字段：
 错误码：  一个可变长度整型值，表示关闭该连接的原因。 0x1c类型连接关闭帧使用第20.1章定义的错误码； 0x1d类型连接关闭帧使用第20.2章定义的错误码。
 帧类型：  一个可变长度整型值，编码触发该错误的帧类型。 值为0（相当于填充帧）用于未知帧类型。 应用层型连接关闭帧（类型0x1d）不包含此字段。
 原因语句长度（Reason Phrase Length）：  一个可变长度整型值，指定原因语句的字节长度。 由于连接关闭帧不能被拆分到多个数据包，因此任何对数据包大小作出的限制也会相应得限制原因语句的可用空间。
 原因语句（Reason Phrase）：  关闭相关的附加诊断信息。 如果发送方选择不在错误码之外给出更多细节，该字段可以是零长度。 该字段应该是UTF-8编码字符串RFC3629，即使该帧没有携带如语言标签之类的信息，这些信息有助于帮助创建文本之外的其他实体理解。
  连接关闭帧（0x1d类型）的应用指定变量只可以通过0-RTT或1-RTT包发送，详见第12.5章。 当应用层意图在握手阶段放弃一条连接时，终端可以通过初始包或握手包发送一个错误码为APPLICATION_ERROR的连接关闭帧（类型0x1c）。</description>
    </item>
    
    <item>
      <title>19.20 握手完成帧</title>
      <link>/RFC9000_Chinese_Translation/Frame_Types_and_Formats/19.20_HANDSHAKE_DONE_Frames/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9000_Chinese_Translation/Frame_Types_and_Formats/19.20_HANDSHAKE_DONE_Frames/</guid>
      <description>服务端使用握手完成帧（HANDSHAKE_DONE frame，类型0x1e）向客户端发送确认握手的信号。
握手完成帧格式如图44所示，可见该类帧没有内容。
握手完成帧 { 类型 (i) = 0x1e, } 图44：握手完成帧格式
 握手完成帧只可以由服务端发送。 服务端必须不能在完成握手前发送握手完成帧。 服务的必须必须将收到握手完成帧视为一个PROTOCOL_VIOLATION类型连接错误。</description>
    </item>
    
    <item>
      <title>19.21 扩展帧</title>
      <link>/RFC9000_Chinese_Translation/Frame_Types_and_Formats/19.21_Extension_Frames/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9000_Chinese_Translation/Frame_Types_and_Formats/19.21_Extension_Frames/</guid>
      <description>QUIC帧不使用自描述编码。 终端因而需要理解所有帧的语法才能成功处理数据包。 这使帧的编码得以高效，但是也意味着终端不能发送一个对端不知道类型的帧。
意图使用新类型帧的QUIC扩展必须事先确保对端能够理解该帧。 终端可以使用传输参数表示其愿意接收的扩展帧类型。 一个传输参数可以表示支持一个或多个扩展帧类型。
修改或替换核心协议功能（包括帧类型）的扩展将难以与其他修改相同功能的扩展兼容，除非明确定义了组合的行为方式。 这种扩展应该定义如何与先前定义的修改了相同协议组件的扩展进行互动。
扩展帧必须是受拥塞控制的，且必须触发ACK帧发送。 替换或补充ACK帧的扩展帧除外。 扩展帧不包含在流量控制中，除非在扩展中有指定。
IANA注册表用于管理帧类型的分配，详见第22.2章。</description>
    </item>
    
    <item>
      <title>20.1. 传输层错误码</title>
      <link>/RFC9000_Chinese_Translation/Error_Codes/20.1_Transport_Error_Codes/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9000_Chinese_Translation/Error_Codes/20.1_Transport_Error_Codes/</guid>
      <description>本章列出可能在0x1c类型连接关闭帧中使用的QUIC错误码的定义。 这些错误可能在整个连接期间发生。
 NO_ERROR (0x00，无错误):  终端在连接关闭帧中携带该错误码以通知连接在没有发生任何错误之下关闭。
  INTERNAL_ERROR (0x01，内部错误):
： 终端遇到内部错误而不能继续维持连接。
 CONNECTION_REFUSED (0x02，连接拒绝):  服务端拒绝接收新连接。
 FLOW_CONTROL_ERROR (0x03，流量控制错误):  终端收到的数据量多于其被推荐的数据量上限，详见第4章。
 STREAM_LIMIT_ERROR (0x04，流限制错误):  终端收到一个流标识对应帧超过了该相关类型的流被推荐的流上限。
 STREAM_STATE_ERROR (0x05，流状态错误):  终端收到流的一个帧，但是当前所处状态不允许接收该类帧，详见第3章。
 FINAL_SIZE_ERROR (0x06，最终大小错误):  1、终端收到包含超过先前确立的最终大小数据量数据的流帧； 2、终端收到包含一个最终大小的流帧或流重置帧，该最终大小小于该流已经收到数据的大小； 3、或终端收到包含的最终大小与已经确立的最终大小不一致的流帧或流重置帧。
 FRAME_ENCODING_ERROR (0x07，帧编码错误):  终端收到一个错误格式的帧——例如，一个未知类型的帧，或包含过多确认范围以至于超出数据包剩余空间所能承载的ACK帧。
 TRANSPORT_PARAMETER_ERROR (0x08，传输参数错误):  终端收到的传输参数存在格式错误、包含无效值、省略了强制要求传输的、传输了禁止传输的，或存在其他错误。
 CONNECTION_ID_LIMIT_ERROR (0x09，连接ID限制错误):  对端提供的连接ID数量超出了active_connection_id_limit的限制。
 PROTOCOL_VIOLATION (0x0a，协议违背):  终端检测到未被更具体的错误码覆盖的违背协议错误。
 INVALID_TOKEN (0x0b，无效令牌):  服务端收到客户端包含无效令牌字段的初始包。
 APPLICATION_ERROR (0x0c，应用错误):  应用程序或应用层协议导致连接关闭。</description>
    </item>
    
    <item>
      <title>20.2 应用协议错误码</title>
      <link>/RFC9000_Chinese_Translation/Error_Codes/20.2_Application_Protocol_Error_Codes/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9000_Chinese_Translation/Error_Codes/20.2_Application_Protocol_Error_Codes/</guid>
      <description>应用程序错误码留给应用协议管理。 应用协议错误码用于重置帧（第19.4章）、停止发送帧（第19.5章），以及0x1d类型的连接关闭帧（第19.19章）。</description>
    </item>
    
    <item>
      <title>21.1.1.1. 抗放大</title>
      <link>/RFC9000_Chinese_Translation/Security_Considerations/Overview_of_Security_Properties/Handshake/21.1.1.1_Anti-Amplification/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9000_Chinese_Translation/Security_Considerations/Overview_of_Security_Properties/Handshake/21.1.1.1_Anti-Amplification/</guid>
      <description>地址验证（详见第8章）被用于验证声称位于某个地址的实体是否有在那个地址接收数据包的能力。对于一些地址，攻击者能够观测到发向这些地址的数据包，而地址验证能限制针对这些地址的放大攻击。
在完成地址验证前，终端在能够发送的数据量上会受到限制。终端向未经验证的地址发送的数据量不能超过从那个地址接收到的数据量的三倍。
 注意：抗放大限制仅适用于终端对接收自未经验证地址的数据包进行响应的情况。抗放大限制不适用于客户端建立新连接或发起连接迁移的情况。
 </description>
    </item>
    
    <item>
      <title>21.1.1.2. 针对服务器的拒绝服务</title>
      <link>/RFC9000_Chinese_Translation/Security_Considerations/Overview_of_Security_Properties/Handshake/21.1.1.2_Server-Side_DoS/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9000_Chinese_Translation/Security_Considerations/Overview_of_Security_Properties/Handshake/21.1.1.2_Server-Side_DoS/</guid>
      <description>服务器为完整的握手过程计算首轮数据可能需要耗费大量资源，其中需要涉及签名和密钥交换的计算。为了抵御针对计算资源的拒绝服务攻击，重试数据包提供了一种低成本的令牌交换机制，使得服务器能够以单轮数据包往返的代价，在进行大量计算前先验证客户端的IP地址。在成功完成握手后，服务器可以向客户端签发新令牌，这使得下次建立连接时不需要引入上述代价。</description>
    </item>
    
    <item>
      <title>21.1.1.3. 在路径上的握手终止</title>
      <link>/RFC9000_Chinese_Translation/Security_Considerations/Overview_of_Security_Properties/Handshake/21.1.1.3_On-Path_Handshake_Termination/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9000_Chinese_Translation/Security_Considerations/Overview_of_Security_Properties/Handshake/21.1.1.3_On-Path_Handshake_Termination/</guid>
      <description>在路径上的或不在路径上的攻击者都可以通过替换或竞速初始数据包的方式强制握手失败。一旦合法的初始数据包完成交换，后续的握手数据包就会受到握手密钥的保护，于是在路径上的攻击者就不能再强制握手失败，除非它丢弃掉数据包从而使得终端放弃尝试连接。
在路径上的攻击者还可以替换任意一侧的数据包中的地址，从而使得客户端或服务器得知虚假的远程地址。这样的攻击无法与NAT进行的转换相区分。</description>
    </item>
    
    <item>
      <title>21.1.1.4. 参数协商</title>
      <link>/RFC9000_Chinese_Translation/Security_Considerations/Overview_of_Security_Properties/Handshake/21.1.1.4_Parameter_Negotiation/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9000_Chinese_Translation/Security_Considerations/Overview_of_Security_Properties/Handshake/21.1.1.4_Parameter_Negotiation/</guid>
      <description>整个握手都受到加密保护，其中初始数据包被由QUIC版本指定的密钥加密，握手数据包和后续数据包被衍生自TLS密钥交换的密钥加密。此外，参数协商会被包含在TLS的记录单（transcript）中，因此它与普通的TLS协商提供相同的完整性保证。攻击者可以观测客户端的传输参数（只要它知道那个由QUIC版本指定的盐），但是却不能观测到服务器的传输参数，因此无法影响到参数协商。
连接ID不会被加密，但是会在所有数据包中受到完整性保护。
本QUIC版本中不包含版本协商机制；互不兼容的版本的实现之间无法建立连接。</description>
    </item>
    
    <item>
      <title>21.1.2. 受保护的数据包</title>
      <link>/RFC9000_Chinese_Translation/Security_Considerations/Overview_of_Security_Properties/21.1.2_Protected_Packets/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9000_Chinese_Translation/Security_Considerations/Overview_of_Security_Properties/21.1.2_Protected_Packets/</guid>
      <description>数据包保护（详见第12.1章）将认证加密应用到除版本协商数据包外的所有数据包上，不过出于使用了由QUIC版本指定的密钥材料的缘故，初始数据包和重试数据包仅受到有限的保护；有关细节详见《QUIC-TLS》。本节考量了针对受保护数据包的被动与主动攻击。
在路径上和不在路径上的攻击者都能发起被动攻击，在这种攻击中，攻击者将观测到的数据包保存起来，将之用于将来的针对数据包保护的离线攻击；这对任何网络中任何数据包的任何观测者都是成立的。
没有观测连接中数据包的能力就注入数据包的攻击者不太可能会成功，因为数据包保护确保了合法的数据包只能由拥有在握手期间建立的密钥材料的终端才能创建出来；详见第7章和第21.1.1章。类似地，任何观测数据包并尝试往这些数据包中插入新数据或修改原有数据的主动攻击者应该都无法创建出能被接收方认定为合法的数据包，除非它操作的是初始数据包。
伪造攻击，也就是由主动攻击者改写由它转发或被它注入的数据包中未经保护的部分，例如源地址或目标地址，只有在攻击者能够将数据包转发到原始终端上时才会生效。数据包保护确保了数据包载荷只能被完成了握手的终端所处理，并且非法的数据包会被终端忽略。
攻击者还能修改数据包与UDP数据报间的边界，使得多个数据包被合并至单个数据报中，或将经合并的数据包拆分至多个数据报中。除了需要扩充的包含初始数据包的数据报外，对数据包在数据报中的排列方式的修改对于连接没有实际效果，不过它可以改变一些性能上的特征。</description>
    </item>
    
    <item>
      <title>21.1.3.1. 在路径上的主动攻击</title>
      <link>/RFC9000_Chinese_Translation/Security_Considerations/Overview_of_Security_Properties/Connection_Migration/21.1.3.1_On-Path_Active_Attacks/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9000_Chinese_Translation/Security_Considerations/Overview_of_Security_Properties/Connection_Migration/21.1.3.1_On-Path_Active_Attacks/</guid>
      <description>能够令观测到的数据包抵达不了它原本目的地的攻击者被认为是在路径上的攻击者。当客户端和服务器间存在攻击者时，终端为了在给定路径上建立连接，发送的数据包不得不经过此攻击者。
在路径上的攻击者可以做到：
  检视数据包
  修改IP数据包和UDP数据包头部
  注入新数据包
  使数据包延误
  对数据包重新排序
  丢弃数据包
  拆分与合并数据报和数据包
  在路径上的攻击者不能做到：
 既修改数据包中经认证的部分又使得接收方接收该数据包。  在路径上的攻击者有修改它观测到的数据包的机会；然而，对于数据包中经认证部分的任何修改都会使得它被接收方认定为非法而遭到丢弃，因为数据包载荷是经过认证与加密的。
QUIC旨在将在路径上的攻击者的能力限制至：
  在路径上的攻击者可以阻止将一条路径用于建立连接，如果终端找不到一条不包含攻击者的路径，连接就会失败。这可以通过丢弃所有数据包、修改数据包以使得它们无法通过解密或其他方式来做到。
  在路径上的攻击者可以通过使新路径上的地址验证失败的方式，阻止连接迁移到一条依旧包含攻击者的路径上。
  在路径上的攻击者不能阻止客户端迁移到一条不包含攻击者的路径上。
  在路径上的攻击者可以通过使数据包延误或丢弃数据包的方式，降低连接的吞吐量。
  在路径上的攻击者不能令终端接受一个被它修改过经认证部分的数据包。
  </description>
    </item>
    
    <item>
      <title>21.1.3.2. 不在路径上的主动攻击</title>
      <link>/RFC9000_Chinese_Translation/Security_Considerations/Overview_of_Security_Properties/Connection_Migration/21.1.3.2_Off-Path_Active_Attacks/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9000_Chinese_Translation/Security_Considerations/Overview_of_Security_Properties/Connection_Migration/21.1.3.2_Off-Path_Active_Attacks/</guid>
      <description>不在路径上的攻击者并不直接位于客户端与服务器间的路径上，但是拥有获得客户端与服务器间发送的部分或全部数据包的能力。它还能够将那些数据包的副本发送给任一终端。
不在路径上的攻击者可以做到：
  检视数据包
  注入新数据包
  对注入的数据包重新排序
  不在路径上的攻击者不能做到：
  修改由终端发送的数据包
  使数据包延误
  丢弃数据包
  对原始数据包重新排序
  不在路径上的攻击者可以为它观测到的数据包创建修改过的副本，并将这些副本注入网络中，副本的源地址和目标地址可以是伪造的。
在本讨论中，我们假定不在路径上的攻击者具有将修改后的数据包副本注入到网络中的能力，并且这个数据包会比它观测的那个原始数据包更早抵达目标终端。换句话说，攻击者具有持续“赢下”与原始数据包间的竞速的能力，并使得原始数据包被接收方忽略。
我们还假设了攻击者具有影响NAT状态所需的资源。尤其是，攻击者有能力使某终端丢失它的NAT绑定，然后取代它，使用与终端先前所使用的相同的端口来吞吐流量。
QUIC旨在将不在路径上的攻击者的能力限制至：
  不在路径上的攻击者可以竞速数据包并尝试成为在“受限”路径上的攻击者。
  不在路径上的攻击者可以通过转发数据包并将源地址改为自己的地址的方式，使自己的地址通过验证，前提是它可以在客户端和服务器间提供更优秀的连接质量。
  不在路径上的攻击者不能在握手完成后引发连接关闭。
  不在路径上的攻击者不能在无法观测新路径的条件下使得连接迁移到这条路径上。
  不在路径上的攻击者可以在迁移到新路径的期间成为一个在受限路径上的攻击者，而它在新路径上仍是一个不在路径上的攻击者。
  不在路径上的攻击者可以通过影响与客户端共享的NAT状态的方式成为一个在受限路径上的攻击者，以便从客户端曾使用过的IP地址和端口向服务器发送数据包。
  </description>
    </item>
    
    <item>
      <title>21.1.3.3. 在受限路径上的主动攻击</title>
      <link>/RFC9000_Chinese_Translation/Security_Considerations/Overview_of_Security_Properties/Connection_Migration/21.1.3.3_Limited_On-Path_Active_Attacks/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9000_Chinese_Translation/Security_Considerations/Overview_of_Security_Properties/Connection_Migration/21.1.3.3_Limited_On-Path_Active_Attacks/</guid>
      <description>在受限路径上的攻击者指的是一个通过在服务器和客户端间复制并转发原始数据包的方式提供更优秀路由质量的不在路径上的攻击者，这会使得那些数据包比原始数据包要更早抵达，从而令原始数据包被目标终端丢弃。
在受限路径上的攻击者与在路径上的攻击者的不同之处在于它并不在终端间的原始路径上，因此由终端发送的原始数据包仍然在前往它们目的地的途中。这意味着只要没有将数据包副本更快地路由到目的地，就无法阻止原始数据包抵达目的地。
在受限路径上的攻击者可以做到：
  检视数据包
  注入新数据包
  修改未经加密的数据包头部
  对数据包重新排序
  在受限路径上的攻击者不能做到：
  使数据包延误，从而令它们比在原始路径上发送的数据包更晚抵达
  丢弃数据包
  修改数据包中经认证和加密的部分，并使得接收方接受该数据包
  在受限路径上的攻击者只能够使数据包副本延误至原始数据包抵达为止，这意味着它不能提供比原始路径的延迟表现要差的路由质量。就算在受限路径上的攻击者将数据包副本丢弃，原始数据包仍然会抵达目标终端。
QUIC旨在将在受限路径上的攻击者的能力限制至：
  在受限路径上的攻击者不能在握手完成后引发连接关闭。
  在受限路径上的攻击者不能在客户端首先恢复活动的条件下引发空闲连接的关闭。
  在受限路径上的攻击者可以在服务器首先恢复活动的条件下使得空闲连接被认定为丢失。
  注意，出于完全相同的原因，这些保证与任何NAT所提供的保证是一致的。</description>
    </item>
    
    <item>
      <title>21.2. 针对握手的拒绝服务攻击</title>
      <link>/RFC9000_Chinese_Translation/Security_Considerations/21.2_Handshake_Denial_of_Service/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9000_Chinese_Translation/Security_Considerations/21.2_Handshake_Denial_of_Service/</guid>
      <description>作为一种经加密和认证的传输层协议，QUIC针对拒绝服务提供了诸多保护措施。一旦加密握手完成，QUIC终端就会丢弃绝大多数未经认证的数据包，极大地限制了攻击者介入已建立的连接的能力。
在连接被建立后，QUIC终端可以接受一些未经认证的ICMP数据包（详见第14.2.1章），但是对这些数据包的使用是极度受限的。终端可以接受的另一种数据包是无状态重置（详见第10.3章），它依赖于在令牌被使用前保持令牌的机密性。
在创建连接期间，QUIC提供的保护仅针对不在路径上的攻击。所有的QUIC数据包都包含着能表明终端接收到了来自对端的前序数据包的依据。
在握手期间无法更改地址，所以终端可以丢弃另一条网络路径上接收到的数据包。
在握手期间，源连接ID字段和目标连接ID字段是抵御不在路径上的攻击的主要手段；详见第8.1章。这些字段必须与对端填写的对应字段匹配。除了初始数据包和无状态重置外，终端只接受包含着与终端之前选择的值匹配的目标连接ID字段的数据包。这是为版本协商数据包提供的唯一保护。
初始数据包中的目标连接ID字段是由客户端选择的不可预测的值，它起着额外的作用。传递加密握手消息的数据包会受到密钥的保护，该密钥衍生自此连接ID和由QUIC版本指定的盐。这使得终端在加密握手完成后始终使用一致的计算过程来认证接收到的数据包。未能通过认证的数据包会被丢弃。以这种方式保护数据包能提供一种强有力的保证，保证数据包的发送方接收到了初始数据包并且能够理解它。
这些保护在面对有能力在连接建立前就接收到QUIC数据包的攻击者时并不一定有效。这样的攻击者可能发送出会被QUIC终端接受的数据包。本QUIC版本尝试检测出此类攻击，但是终端应该令连接的建立过程直接失败，而不是试图从中恢复。在握手期间检测出篡改行为的责任主要在于加密握手协议（详见《QUIC-TLS》）。
允许终端使用其他手段来检测出握手被介入的情况并尝试从中恢复。非法数据包可以被其他手段识别出来并被丢弃，不过在本文档中没有推荐什么特别的方法。</description>
    </item>
    
    <item>
      <title>21.3. 放大攻击</title>
      <link>/RFC9000_Chinese_Translation/Security_Considerations/21.3_Amplification_Attack/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9000_Chinese_Translation/Security_Considerations/21.3_Amplification_Attack/</guid>
      <description>攻击者也许有能力在从服务器接收到地址验证令牌（详见第8章）后释放掉它用于接收令牌的IP地址。一段时间后，攻击者可以伪造出相同的地址，并向服务器发起0-RTT连接，但这时该地址指向的会是另一个（受害者）终端。攻击者于是有机会令服务器向受害者发送多达一整个初始拥塞窗口的数据。
服务器应该通过限制地址验证令牌的使用范围与有效期限的方式抵御此类攻击；详见第8.1.3章。</description>
    </item>
    
    <item>
      <title>21.4. 针对乐观ACK的攻击</title>
      <link>/RFC9000_Chinese_Translation/Security_Considerations/21.4_Optimistic_ACK_Attack/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9000_Chinese_Translation/Security_Considerations/21.4_Optimistic_ACK_Attack/</guid>
      <description>会对尚未接收到的数据包进行确认的终端可能使得拥塞控制器允许以超过网络所支持的速率进行发送。要检测此行为，终端可以在发送数据包时跳过某些数据包号。终端在检测到对端的此类行为后可以立即用类型为PROTOCOL_VIOLATION（协议违背）的连接错误来关闭连接；详见第10.2章。</description>
    </item>
    
    <item>
      <title>21.5.1. 控制终端的途径</title>
      <link>/RFC9000_Chinese_Translation/Security_Considerations/Request_Forgery_Attacks/21.5.1_Control_Options_for_Endpoints/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9000_Chinese_Translation/Security_Considerations/Request_Forgery_Attacks/21.5.1_Control_Options_for_Endpoints/</guid>
      <description>QUIC给了攻击者一些影响或操纵其对端的UDP数据报发送目标的机会：
  初始的连接建立（详见第7章），此时服务器拥有操纵客户端的数据包发送目标的能力——例如，通过填写DNS记录的方式；
  首选地址（详见第9.6章），此时服务器拥有操纵客户端的数据包发送目标的能力；
  虚假的连接迁移（详见第9.3.1章），此时客户端具有使用伪造的源地址来操纵服务器后续数据报的发送目标的能力；以及
  伪造的数据包，这能令服务器发送版本协商数据包（详见第21.5.5章）。
  在任一情况下，攻击者都能令其对端向某个受害者发送数据报，无论受害者能不能理解QUIC。也就是说，这些数据包会在对端进行地址验证前就被发送出去；详见第8章。
在数据包经加密的部分之外，QUIC给予了终端一些可选项，用于控制其对端发送的UDP数据报的内容。目标连接ID字段提供了针对对端发送的数据包中位置靠前的字节的直接控制；详见第5.1章。初始数据包中的令牌字段提供了针对初始数据包中其他字节的控制；详见第17.2.2章。
在本QUIC版本中没有任何方法来阻止针对数据包中经加密的部分的间接控制。假定终端能够控制对端所发送的帧内容是很有必要的，尤其是那些传递应用数据的帧，例如流帧。尽管它在一定程度上依赖于应用协议的细节部分，但是在多数协议的使用场景中都有可能出现某种程度的控制能力。只要攻击者能访问到数据包保护密钥，它们就有能力预测对端会如何加密后续数据包。于是，要成功控制数据报内容，只需要攻击者有能力预测数据包号和数据包中的帧大概会出现的位置。
本节假定了我们无法限制攻击者对数据报内容的控制。在后续章节中，抵御手段的重点在于限制数据报会在进行地址验证前就被发送出去的情况，以防止它们被用于进行请求伪造。</description>
    </item>
    
    <item>
      <title>21.5.2. 使用客户端初始数据包的请求伪造</title>
      <link>/RFC9000_Chinese_Translation/Security_Considerations/Request_Forgery_Attacks/21.5.2_Request_Forgery_with_Client_Initial_Packets/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9000_Chinese_Translation/Security_Considerations/Request_Forgery_Attacks/21.5.2_Request_Forgery_with_Client_Initial_Packets/</guid>
      <description>假扮成服务器的攻击者可以自由宣称自己所在的IP地址和端口，所以发送自客户端的初始数据包被假定为可以用于此类攻击。在握手中隐含着的地址验证确保了——在建立新连接时——客户端不会向一个不理解QUIC或不愿意接受QUIC连接的目标发送其他类型的数据包。
初始数据包保护（详见《QUIC-TLS》的第5.2章）使得服务器难以操纵由客户端发送的初始数据包内容。客户端会选择一个不可预测的目标连接ID，确保了服务器无法操纵客户端初始数据包中任何经加密的部分。
然而，令牌字段是开放给服务器去控制的，并且它确实允许服务器利用客户端来进行请求伪造攻击。使用由新令牌帧（详见第8.1.3章）提供的令牌成为了在连接建立期间进行请求伪造的唯一途径。
不过，客户端并没有一定要使用新令牌帧的义务。只需要客户端在服务器的地址与发送新令牌帧时的不同的情况下发送空的令牌字段，依赖于令牌字段的请求伪造攻击就可以被避免。
客户端可以在服务器地址变化时避免使用新令牌帧。然而，不使用令牌字段会对性能产生不利影响。服务器可能依赖于新令牌帧以在发送数据时超过三倍限制；详见第8.1章。尤其是，这会影响客户端使用0-RTT来从服务器请求数据的情况。
重试数据包为服务器提供了改变令牌字段的一种途径。在发送了重试数据包后，服务器还可以控制客户端后续初始数据包中的目标连接ID字段。这还有可能实现对初始数据包中经加密的内容的间接控制。然而，有关重试数据包的通信验证了服务器的地址，于是阻止了将后续初始数据包用于请求伪造。</description>
    </item>
    
    <item>
      <title>21.5.3. 使用首选地址的请求伪造</title>
      <link>/RFC9000_Chinese_Translation/Security_Considerations/Request_Forgery_Attacks/21.5.3_Request_Forgery_with_Preferred_Addresses/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9000_Chinese_Translation/Security_Considerations/Request_Forgery_Attacks/21.5.3_Request_Forgery_with_Preferred_Addresses/</guid>
      <description>服务器可以指定首选地址，客户端在确认完握手之后就会发起迁移；详见第9.6章。客户端发向首选地址的数据包中的目标连接ID字段可以被用于请求伪造。
客户端必须不在验证某首选地址前就向它发送非探测帧；详见第8章。这极大地减少了服务器能够操纵数据报中经加密的部分的途径数量。
本文档没有提供额外的与使用首选地址有关的和能够由终端实现的对抗措施。在第21.5.6章中描述的通用措施可以被用作更进一步的抵御手段。</description>
    </item>
    
    <item>
      <title>21.5.4. 使用虚假迁移的请求伪造</title>
      <link>/RFC9000_Chinese_Translation/Security_Considerations/Request_Forgery_Attacks/21.5.4_Request_Forgery_with_Spoofed_Migration/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9000_Chinese_Translation/Security_Considerations/Request_Forgery_Attacks/21.5.4_Request_Forgery_with_Spoofed_Migration/</guid>
      <description>客户端能够在连接迁移中使用伪造的源地址，使得服务器向该地址发送数据报。
服务器后续向这个假地址发送的任何数据包中的目标连接ID字段都能被用于请求伪造。客户端可能还有影响密文的能力。
在进行地址验证前只会向该地址发送探测数据包（详见第9.1章）的服务器让攻击者对数据报中经加密的部分仅持有有限的控制。然而，尤其是对NAT重绑定来说，这会对性能产生不利影响。如果服务器发送了携带着应用数据的帧，那么攻击者就可能控制数据报中的绝大多数内容。
除了在第21.5.6章中描述的通用措施外，本文档没有提供终端能够实现的专门的对抗措施。然而，在网络层面的针对地址伪造的对抗措施——尤其是传入流量过滤（详见BCP38）——对于使用伪造地址且源自外部网络的攻击是极其有效的。</description>
    </item>
    
    <item>
      <title>21.5.5. 使用版本协商的请求伪造</title>
      <link>/RFC9000_Chinese_Translation/Security_Considerations/Request_Forgery_Attacks/21.5.5_Request_Forgery_with_Version_Negotiation/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9000_Chinese_Translation/Security_Considerations/Request_Forgery_Attacks/21.5.5_Request_Forgery_with_Version_Negotiation/</guid>
      <description>有能力在数据包中使用虚假源地址的客户端能够令服务器向该地址发送版本协商数据包（详见第17.2.1章）。
在未知版本的数据包中对于连接ID字段长度限制的缺失提高了客户端能够在产生的数据报中控制的数据量。该数据包的首个字节不在客户端控制之下，并且后四个字节均为零，但是客户端可以控制从第五个字节开始的至多512个字节。
针对此类攻击，没有提供专门的对抗措施，不过通用的保护手段（详见第21.5.6章）是适用的。在这种情况下，传入流量过滤（详见《BCP38》）也是有效的。</description>
    </item>
    
    <item>
      <title>21.5.6. 针对请求伪造的通用对抗措施</title>
      <link>/RFC9000_Chinese_Translation/Security_Considerations/Request_Forgery_Attacks/21.5.6_Generic_Request_Forgery_Countermeasures/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9000_Chinese_Translation/Security_Considerations/Request_Forgery_Attacks/21.5.6_Generic_Request_Forgery_Countermeasures/</guid>
      <description>针对请求伪造攻击的最有效防御方法就是修改易受攻击的服务，让它使用强有力的鉴权认证。然而，这一点并不总是在QUIC部署的控制之下。本节概述了QUIC终端可以单方面采取的一些其他措施。这些额外措施都应该酌情使用，因为根据情况的不同，它们可能干涉或阻止QUIC的正常工作。
通过回环接口提供的服务通常缺乏恰当的鉴权认证。终端可以阻止指向回环地址的连接尝试或迁移。当指向的服务曾在另一个接口上开放过，或者指向的回环地址是由位于非回环地址的服务提供的，那么终端不应该批准指向这个回环地址的连接或迁移。依赖于这些能力的终端可以提供一个可以禁用这些保护的选项。
类似地，终端可以将从全球唯一地址、唯一本地地址（详见《RFC4193》）或非私有地址变更到链路本地地址（详见《RFC4291》）或处于私有使用范围的地址（详见《RFC1918》）的情况视作潜在的对请求伪造的企图。终端可以完全拒绝使用以上地址，但是要承担干涉QUIC合法用途的巨大风险。终端不应该拒绝使用某个地址，除非它对于网络的先验知识告诉它向某范围内的未经验证的地址发送数据报是不安全的。
终端可以选择以不使用来自初始数据包中新令牌帧的值的方式或只有在完成地址验证后才在数据包中发送探测帧的方式来减少请求伪造的风险。注意，这不能阻止攻击者将目标连接ID用于攻击中。
终端不需要专门持有容易成为请求伪造攻击目标的服务器的位置信息。然而，经过一段时间后，识别出某些常常成为攻击目标的UDP端口或被用于进行攻击的数据报中的特定模式是有可能的。终端可以选择避免向那些端口发送数据报或不在验证目标地址前发送符合这种模式的数据包。终端可以撤销符合已知可能产生问题的模式的连接ID而不使用它们。
注意： 修改终端来应用以上保护措施比起部署基于网络的保护措施要更高效，因为终端在向经验证的地址发送数据时不需要进行额外的处理。</description>
    </item>
    
    <item>
      <title>21.6. 慢速连接攻击</title>
      <link>/RFC9000_Chinese_Translation/Security_Considerations/21.6_Slowloris_Attacks/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9000_Chinese_Translation/Security_Considerations/21.6_Slowloris_Attacks/</guid>
      <description>通常被称为慢速连接攻击（详见《SLOWLORIS》）的攻击方式会尝试打开许多与目标终端的连接并且尽可能长地维持它们。这类攻击可以通过进行最低限度的活动以避免连接因无活动而被关闭的方式攻击某个QUIC终端。其中可能还包含发送少量数据，逐渐打开流量控制窗口从而控制发送者的速率，以及制造能模拟高丢包率的ACK帧。
QUIC部署应该针对慢速连接攻击提供抵御手段，例如扩大服务器允许的最大客户端数量、限制单个IP地址能够创建的连接数量、向连接所允许的最低传输速率施加限制，以及限制终端能够保持连接的时长。</description>
    </item>
    
    <item>
      <title>21.7. 流分段与重组攻击</title>
      <link>/RFC9000_Chinese_Translation/Security_Considerations/21.7_Stream_Fragmentation_and_Reassembly_Attacks/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9000_Chinese_Translation/Security_Considerations/21.7_Stream_Fragmentation_and_Reassembly_Attacks/</guid>
      <description>恶意的攻击者可能有意不发送一部分流数据，使得接收者为那些未发送的数据预留资源。这会造成接收方出现极高的缓存占用并且/或者创建出巨大且低效的数据结构。
恶意的接收者可能有意不确认包含流数据的数据包，为的是强制发送方持续存储未确认的流数据以便重传。
当流量控制窗口与可用内存相关时，针对接收方的攻击就能被抵御。然而，一些接收方会过度占用内存，并且在合计的时候宣告会超过实际可用内存的流量控制偏移值。这种透支策略在终端运行状态良好时能够提高性能，但是会在遭受流分段攻击时使得终端变得脆弱。
QUIC实现应该针对流分段攻击提供抵御手段。其中可以包含避免透支内存、限制持续维护的数据结构的尺寸、延迟组装流帧、实现基于数据重组缺口时长的启发式方法，以及以上措施的各种组合。</description>
    </item>
    
    <item>
      <title>21.8. 流占用攻击</title>
      <link>/RFC9000_Chinese_Translation/Security_Considerations/21.8_Stream_Commitment_Attack/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9000_Chinese_Translation/Security_Considerations/21.8_Stream_Commitment_Attack/</guid>
      <description>恶意的终端可以打开大量的流并耗尽终端的状态。恶意的终端可以在大量连接上重复此过程，就像TCP中的SYN泛洪攻击那样。
通常情况下，客户端会按顺序打开流，就像第2.1章中解释的那样。然而，当短时间内发起多个流时，丢包或乱序会使得打开流的流帧被乱序地接收到。在接收到较高编号的流ID时，接收者需要打开同类型的所有低编号流；详见第3.2章。因此，在一条新连接上，打开了编号为4000000的流就会打开一百万零一条由客户端发起的双向流。
活跃流的数量是由传输参数initial_max_streams_bidi（初始最大双向流数量）和initial_max_streams_uni（初始最大单向流数量）限制的，并会随着接收到的最大流帧而被更新，如第4.6章所述。只要审慎地选择，这些限制就能抵御流占用攻击会产生的效果。然而，将限制设置得过低则会在应用希望打开大量流时影响性能。</description>
    </item>
    
    <item>
      <title>21.9. 来自对端的拒绝服务攻击</title>
      <link>/RFC9000_Chinese_Translation/Security_Considerations/21.9_Peer_Denial_of_Service/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9000_Chinese_Translation/Security_Considerations/21.9_Peer_Denial_of_Service/</guid>
      <description>QUIC和TLS中的一些帧和消息在某些情况下具有合理用途，但也可以被滥用，使得终端花费大量计算资源却对连接的状态产生不了肉眼可见的影响。
消息还能被用于以简短快捷的方式更改和回退状态数据，例如向流量控制的限制值发送较小的增量更改。
如果计算上的代价比起带宽上的消耗或对状态的影响要大得多，那么这可能使得恶意的对端能够耗尽终端计算资源。
尽管所有消息都有其合理用途，但是QUIC实现应该监视处理过程中在计算上的消耗并且将任何投入巨大却产出低下的数据包处理过程视作潜在的攻击。终端可以用连接错误或数据包的丢弃来响应这种情况。</description>
    </item>
    
    <item>
      <title>21.10. 显式拥塞通知攻击</title>
      <link>/RFC9000_Chinese_Translation/Security_Considerations/21.10_Explicit_Congestion_Notification_Attacks/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9000_Chinese_Translation/Security_Considerations/21.10_Explicit_Congestion_Notification_Attacks/</guid>
      <description>在路径上的攻击者可以操纵IP头部中ECN字段的值来影响发送方的速率。在《RFC3168》中更详细地讨论了操纵方式及其效果。
在受限路径上的攻击者可以拷贝并发送修改过ECN字段的数据包，从而影响发送方的速率。如果重复的数据包会被接收方丢弃，那么攻击者就要使数据包副本与原始数据包竞速，才能使攻击成功。因此，除非IP数据包中至少有一个QUIC数据包被成功处理，否则QUIC终端会忽略IP数据包中的ECN字段；详见第13.4章。</description>
    </item>
    
    <item>
      <title>21.11. 无状态重置泄密</title>
      <link>/RFC9000_Chinese_Translation/Security_Considerations/21.11_Stateless_Reset_Oracle/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9000_Chinese_Translation/Security_Considerations/21.11_Stateless_Reset_Oracle/</guid>
      <description>无状态重置会创建一种潜在的拒绝服务攻击，它与TCP重置注入很相似。这种攻击的成功需要攻击者对于连接ID为特定值的连接，具有触发其无状态重置令牌的生成的能力。能够触发终端生成该令牌的攻击者就能重置具有该连接ID的活跃连接。
如果数据包会被路由至共享同一静态密钥的其他实例上——例如，通过改变IP地址或端口——那么攻击者就能令服务器发送无状态重置。要抵御这种形式的拒绝服务攻击，共享用于无状态重置的同一密钥的终端（详见第10.3.2章）必须被妥善安排，从而使具有给定连接ID的数据包总是抵达具有连接状态的那个实例，除非该连接不再处于活跃状态。
更一般地，如果具有相同连接ID的连接在使用相同静态密钥的其他终端上可能处于活跃状态，那么服务器就必须不创建无状态重置。
在服务器集群使用动态负载均衡的情况中，可能出现对负载均衡器配置进行了更改而活跃的实例仍维护着连接状态的现象。即使某个实例维护着连接状态，路由和作为结果的无状态重置的变化会使得连接被终止。如果数据包没有机会被路由到正确的实例上，那么比起等待连接超时，最好发送无状态重置。然而，该做法只有在攻击者无法影响到路由的情况下才能被使用。</description>
    </item>
    
    <item>
      <title>21.12. 版本降级</title>
      <link>/RFC9000_Chinese_Translation/Security_Considerations/21.12_Version_Downgrade/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9000_Chinese_Translation/Security_Considerations/21.12_Version_Downgrade/</guid>
      <description>本文档定义了QUIC的版本协商包（详见第6章），它能被用于协商在两个终端间使用的QUIC版本。然而，本文档没有规定在本版本与后续版本之间如何进行协商。尤其是，版本协商数据包中并不包含任何能阻止版本降级攻击的机制。将来的使用版本协商数据包的QUIC版本必须定义一种针对版本降级攻击的健壮的防御机制。</description>
    </item>
    
    <item>
      <title>21.13. 通过路由的定向攻击</title>
      <link>/RFC9000_Chinese_Translation/Security_Considerations/21.13_Targeted_Attacks_by_Routing/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9000_Chinese_Translation/Security_Considerations/21.13_Targeted_Attacks_by_Routing/</guid>
      <description>QUIC部署应该限制攻击者将新连接定向至特定服务器实例的能力。理想情况下，路由决策应该与客户端的相关值无关，包括地址。一旦选定了某个实例，就能决定连接ID，以便将来的数据包都被路由至同一实例。</description>
    </item>
    
    <item>
      <title>21.14. 流量分析</title>
      <link>/RFC9000_Chinese_Translation/Security_Considerations/21.14_Traffic_Analysis/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9000_Chinese_Translation/Security_Considerations/21.14_Traffic_Analysis/</guid>
      <description>QUIC数据包的长度会透露出有关这些数据包内容长度的信息。填充帧给予了终端混淆数据包内容长度的能力；详见第19.1章。
对流量分析的防御是充满挑战的，并且是很多积极研究的主题。长度不是唯一会泄露信息的途径。终端还可能通过其他侧信道泄露敏感信息，例如数据包的计时侧信道。</description>
    </item>
    
    <item>
      <title>22.1.1. 临时注册项</title>
      <link>/RFC9000_Chinese_Translation/IANA_Considerations/Registration_Policies_for_QUIC_Registries/22.1.1_Provisional_Registrations/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9000_Chinese_Translation/IANA_Considerations/Registration_Policies_for_QUIC_Registries/22.1.1_Provisional_Registrations/</guid>
      <description>码点的临时注册项是为了支持私有用途和QUIC的实验性扩展。临时注册项中只需要包含码点值和联系方式。然而，临时注册项可以被释放或重新指定为另一用途。
临时注册项需要经过专家评审（Expert Review），就像《RFC8126》的第4.5章中定义的那样。建议被指派的专家或专家组仅对那些在不在剩余码点空间中的申请，或者对可用码点空间中首个未分配值的申请（详见第22.1.2章）做出拒绝。
临时注册项中将包含日期字段，它表明了该注册项的最后更新时间。对任何临时注册项的日期进行更新的申请不需要经过专家（组）的评审。
为了支持临时注册项，所有QUIC注册表都包含以下字段：
 值：  分配的码点。
 状态：  “永久”或“临时”。
 规范：  指向一份公开可用的针对此值的规范的引用。
 日期：  最后一次更新此注册项的日期。
 更改责任人：  对此注册项的定义负责的实体。
 联系方式：  注册者的联系方式。
 备注：  关于此注册项的补充性备注。
  临时注册项中可以省略规范和备注字段，以及任何对永久注册项来说必需的额外字段。日期字段在申请注册时不是必需的，因为它会在创建或更新注册项时被设置上去。</description>
    </item>
    
    <item>
      <title>22.1.2. 挑选码点</title>
      <link>/RFC9000_Chinese_Translation/IANA_Considerations/Registration_Policies_for_QUIC_Registries/22.1.2_Selecting_Codepoints/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9000_Chinese_Translation/IANA_Considerations/Registration_Policies_for_QUIC_Registries/22.1.2_Selecting_Codepoints/</guid>
      <description>对来自QUIC注册表中的码点的申请应该使用一个随机选择的码点，并且避开已分配的码点和选定空间中的首个未分配码点。可以使用一个连续的范围来申请复数码点。这使得不同实现将相差过大的语义赋给同一码点的风险能够降至最低。
首个未分配码点是保留码点，对它的分配遵循着标准行为（Standards Action）流程；详见《RFC8126》的第4.9章。早期码点分配过程（详见《EARLY-ASSIGN》）适用于这些值。
对于以可变长度整型编码（详见第16章）的码点，例如帧类型，应该使用被编码至四字节或八字节（也就是大于等于214的值）的码点，除非它对编码结果的长度有特殊要求。
在QUIC注册表中注册码点的应用可以申请一个码点并作为注册的一部分。如果这个码点未被分配并且符合注册流程的各项要求，那么IANA必须分配所选码点。</description>
    </item>
    
    <item>
      <title>22.1.3. 释放临时码点</title>
      <link>/RFC9000_Chinese_Translation/IANA_Considerations/Registration_Policies_for_QUIC_Registries/22.1.3_Reclaiming_Provisional_Codepoints/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9000_Chinese_Translation/IANA_Considerations/Registration_Policies_for_QUIC_Registries/22.1.3_Reclaiming_Provisional_Codepoints/</guid>
      <description>可以申请从注册表中移除一条未使用的临时注册项从而腾出注册表中的空间，也可以申请移除注册表的一块区域（例如从64至16383的范围，它们是使用了可变长度整型编码的码点）。该申请应该只从具有最早记录日期的码点开始进行，并且一年内曾被更新过的注册项不应该被释放。
对于移除码点的申请必须得到所指派的专家组的评审。专家组必须尝试判断该码点是否仍在使用中。专家组应该联系注册项中列出的联系方式，和尽可能多的协议实现方，从而判断该码点是否仍有使用场景。专家组还应该拥有至少四周的时间用于做出答复。
如果上文中查找使用场景的结果是认定该码点仍在使用，或出现了更新此注册项的申请，那么必须不释放该码点。取而代之的是，注册表项的日期会被更新。可以为此注册项新增一条备注，记录在此过程中了解到的相关信息。
如果没有找到该码点的使用场景，并且没有出现更新此注册项的申请，那么该码点可以被移除出注册表。
这种评审与商讨的过程还适用于将临时注册项变更为永久注册项的申请，只不过目标不是判断有没有该码点的使用场景，而是判断此注册项是否准确地表达了它在某一部署场景中的用途。</description>
    </item>
    
    <item>
      <title>22.1.4. 永久注册项</title>
      <link>/RFC9000_Chinese_Translation/IANA_Considerations/Registration_Policies_for_QUIC_Registries/22.1.4_Permanent_Registrations/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9000_Chinese_Translation/IANA_Considerations/Registration_Policies_for_QUIC_Registries/22.1.4_Permanent_Registrations/</guid>
      <description>QUIC注册表中的永久注册项遵循的是强制规范（Specification Required）流程（详见《RFC8126》的第4.6章），除非有特别规定。被指派的专家或专家组验证规范文件是否存在并且具备可访问性。鼓励专家组倾向于批准注册申请，除非申请自身带有辱骂、轻蔑或者其他有害性质（不仅仅是在美学上令人不快或在结构上令人怀疑）。在创建注册项时可以对永久注册项指定额外限制。
注册项的创建可以指定一定范围的码点，使它们受到另一种注册流程的管理。例如，注册表“QUIC帧类型”（详见第22.4章）中从0至63的码点受到更严格流程的控制。
对永久注册项的任何更严格的要求都不会影响相关码点上的临时注册项。例如，可以为帧类型61申请临时注册项。
所有由标准化出版物创建的注册项必须是永久的。
本文档中的所有注册项均被指定为永久状态，更改责任人为IETF，联系方式为QUIC工作组（quic@ietf.org）。</description>
    </item>
    
    <item>
      <title>22.2. QUIC版本注册表</title>
      <link>/RFC9000_Chinese_Translation/IANA_Considerations/22.2_QUIC_Versions_Registry/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9000_Chinese_Translation/IANA_Considerations/22.2_QUIC_Versions_Registry/</guid>
      <description>IANA在“QUIC”条目下新增了“QUIC版本”注册表。
“QUIC版本”注册表管理着一段32位长的空间；详见第15章。该注册表遵循着来自第22.1章的注册流程。该注册表中的永久注册项被指定为使用强制规范流程（详见《RFC8126》的第4.6章）。
QUIC协议的码点0x00000001被指定为本文档中定义的协议，并具有永久状态。码点0x00000000的使用被永久保留；该码点的备注表明了此版本被预留为版本协商。
遵循模式0x?a?a?a?a的所有码点的使用都被保留，它们必须不被IANA指定，并且必须不被列出在已指定的值中。</description>
    </item>
    
    <item>
      <title>22.3. QUIC传输参数注册表</title>
      <link>/RFC9000_Chinese_Translation/IANA_Considerations/22.3_QUIC_Transport_Parameters_Registry/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9000_Chinese_Translation/IANA_Considerations/22.3_QUIC_Transport_Parameters_Registry/</guid>
      <description>IANA在“QUIC”条目下新增了“QUIC传输参数”注册表。
“QUIC传输参数”注册表管理着一段62位长的空间。该注册表遵循着来自第22.1章的注册流程。该注册表中的永久注册项被指定为使用强制规范流程（详见《RFC8126》的第4.6章），但是从0x00至0x3f间（十六进制，包含两端）的值除外，这些值会以标准行为或IESG批准的方式指定，有关定义详见《RFC8126》的第4.9章和第4.10章。
除了在第22.1.1章中列出的字段外，该注册表中的永久注册项还必须包含以下字段：
 参数名称：  该参数简短的帮助记忆的名称。
  该注册表的初始内容如表6所示。
   值 参数名称 规范     0x00 original_destination_connection_id 第18.2章   0x01 max_idle_timeout 第18.2章   0x02 stateless_reset_token 第18.2章   0x03 max_udp_payload_size 第18.2章   0x04 initial_max_data 第18.2章   0x05 initial_max_stream_data_bidi_local 第18.2章   0x06 initial_max_stream_data_bidi_remote 第18.2章   0x07 initial_max_stream_data_uni 第18.2章   0x08 initial_max_streams_bidi 第18.2章   0x09 initial_max_streams_uni 第18.2章   0x0a ack_delay_exponent 第18.</description>
    </item>
    
    <item>
      <title>22.4. QUIC帧类型注册表</title>
      <link>/RFC9000_Chinese_Translation/IANA_Considerations/22.4_QUIC_Frame_Types_Registry/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9000_Chinese_Translation/IANA_Considerations/22.4_QUIC_Frame_Types_Registry/</guid>
      <description>IANA在“QUIC”条目下新增了“QUIC帧类型”注册表。
“QUIC帧类型”注册表管理着一段62位长的空间。该注册表遵循着来自第22.1章的注册流程。该注册表中的永久注册项被指定为使用强制规范流程（详见《RFC8126》的第4.6章），但是从0x00至0x3f间（十六进制，包含两端）的值除外，这些值会以标准行为或IESG批准的方式指定，有关定义详见《RFC8126》的第4.9章和第4.10章。
除了在第22.1.1章中列出的字段外，该注册表中的永久注册项还必须包含以下字段：
 帧类型名称：  该参数简短的帮助记忆的名称。
  除了在第22.1章中给出的建议外，新的永久注册项的规范应该提供一份描述，描述终端可以用于判断是否能够发送该类型的帧的方法。对绝大多数注册项来说，还应该同时注册相关的传输参数；详见第22.3章。永久注册项的规范还需要描述该类型的帧中所有字段的格式及其语义。
该注册表的初始内容被罗列在表3中。注意，实际的注册表中并不包含表3中的“数据包类型”一栏和“特殊规则”一栏。</description>
    </item>
    
    <item>
      <title>22.5. QUIC传输层错误码注册表</title>
      <link>/RFC9000_Chinese_Translation/IANA_Considerations/22.5_QUIC_Transport_Error_Codes_Registry/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9000_Chinese_Translation/IANA_Considerations/22.5_QUIC_Transport_Error_Codes_Registry/</guid>
      <description>IANA在“QUIC”条目下新增了“QUIC传输层错误码”注册表。
“QUIC传输层错误码”注册表管理着一段62位长的空间。该空间被拆分为三段由不同注册流程管理的空间。该注册表遵循着来自第22.1章的注册流程。该注册表中的永久注册项被指定为使用强制规范流程（详见《RFC8126》的第4.6章），但是从0x00至0x3f间（十六进制，包含两端）的值除外，这些值会以标准行为或IESG批准的方式指定，有关定义详见《RFC8126》的第4.9章和第4.10章。
除了在第22.1.1章中列出的字段外，该注册表中的永久注册项还必须包含以下字段：
 代码：  该参数简短的帮助记忆的名称。
 描述：  对该错误码语义的简要描述，当提供了指向规范文件的引用时，此内容可以是一份概述。
  该注册表的初始内容如表7所示。
   值 代码 描述 规范     0x00 NO_ERROR 无错误 第20章   0x01 INTERNAL_ERROR 实现中的错误 第20章   0x02 CONNECTION_REFUSED 服务器拒绝了连接 第20章   0x03 FLOW_CONTROL_ERROR 流量控制错误 第20章   0x04 STREAM_LIMIT_ERROR 打开了过多流 第20章   0x05 STREAM_STATE_ERROR 接收到了在当前流状态下非法的帧 第20章   0x06 FINAL_SIZE_ERROR 最终尺寸发生了变化 第20章   0x07 FRAME_ENCODING_ERROR 帧编码错误 第20章   0x08 TRANSPORT_PARAMETER_ERROR 传输参数中出现错误 第20章   0x09 CONNECTION_ID_LIMIT_ERROR 接收到了过多的连接ID 第20章   0x0a PROTOCOL_VIOLATION 通用的协议违背错误 第20章   0x0b INVALID_TOKEN 接收到了非法的令牌 第20章   0x0c APPLICATION_ERROR 应用错误 第20章   0x0d CRYPTO_BUFFER_EXCEEDED 加密数据缓存溢出 第20章   0x0e KEY_UPDATE_ERROR 对数据包保护密钥的非法更新 第20章   0x0f AEAD_LIMIT_REACHED 对数据包保护密钥的超量使用 第20章   0x10 NO_VIABLE_PATH 无可用网络路径 第20章   0x0100-0x01ff CRYPTO_ERROR TLS警告码 第20章    表6：QUIC传输参数注册表的初始项</description>
    </item>
    
    <item>
      <title>23.1. 规范性参考文献</title>
      <link>/RFC9000_Chinese_Translation/References/23.1_Normative_References/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9000_Chinese_Translation/References/23.1_Normative_References/</guid>
      <description>[BCP38]：  Ferguson, P. and D. Senie, &amp;ldquo;Network Ingress Filtering: Defeating Denial of Service Attacks which employ IP Source Address Spoofing&amp;rdquo;, BCP 38, RFC 2827, May 2000, https://www.rfc-editor.org/info/bcp38
 [DPLPMTUD]：  Fairhurst, G., Jones, T., Tüxen, M., Rüngeler, I., and T. Völker, &amp;ldquo;Packetization Layer Path MTU Discovery for Datagram Transports&amp;rdquo;, RFC 8899, DOI 10.17487/RFC8899, September 2020, https://www.rfc-editor.org/info/rfc8899.
 [EARLY-ASSIGN]：  Cotton, M., &amp;ldquo;Early IANA Allocation of Standards Track Code Points&amp;rdquo;, BCP 100, RFC 7120, DOI 10.</description>
    </item>
    
    <item>
      <title>A.1. 可变长度整型解码样例</title>
      <link>/RFC9000_Chinese_Translation/Pseudocode/A.1_Sample_Variable-Length_Integer_Decoding/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9000_Chinese_Translation/Pseudocode/A.1_Sample_Variable-Length_Integer_Decoding/</guid>
      <description>图45中的伪代码展示了如何从字节流中读取可变长度整型值。ReadVarint函数接收单个参数——一个字节序列，它将以网络字节序被读取。
ReadVarint(data): // 可变长度整型值的长度被编码在首个字节的前两个比特位中。 v = data.next_byte() prefix = v &amp;gt;&amp;gt; 6 length = 1 &amp;lt;&amp;lt; prefix // 一旦长度已知，就移除这些比特位，并读取剩余字节。 v = v &amp;amp; 0x3f repeat length-1 times: v = (v &amp;lt;&amp;lt; 8) + data.next_byte() return v 图45：可变长度整型解码算法样例
 举例来说，八字节序列0xc2197c5eff14e88c会被解码为十进制值151,288,809,941,952,652；四字节序列0x9d7f3e7d 会被解码为494,878,333；双字节序列0x7bbd 会被解码为15,293；而单字节0x25会被解码为37（和解码双字节序列0x4025的结果一致）。</description>
    </item>
    
    <item>
      <title>23.2. 资料性参考文献</title>
      <link>/RFC9000_Chinese_Translation/References/23.2_Informative_References/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9000_Chinese_Translation/References/23.2_Informative_References/</guid>
      <description>[AEAD]：  McGrew, D., &amp;ldquo;An Interface and Algorithms for Authenticated Encryption&amp;rdquo;, RFC 5116, DOI 10.17487/RFC5116, January 2008, https://www.rfc-editor.org/info/rfc5116.
 [ALPN]：  Friedl, S., Popov, A., Langley, A., and E. Stephan, &amp;ldquo;Transport Layer Security (TLS) Application-Layer Protocol Negotiation Extension&amp;rdquo;, RFC 7301, DOI 10.17487/RFC7301, July 2014, https://www.rfc-editor.org/info/rfc7301.
 [ALTSVC]：  Nottingham, M., McManus, P., and J. Reschke, &amp;ldquo;HTTP Alternative Services&amp;rdquo;, RFC 7838, DOI 10.17487/RFC7838, April 2016, https://www.rfc-editor.org/info/rfc7838.
 [COOKIE]：  Barth, A.</description>
    </item>
    
    <item>
      <title>A.2. 数据包号编码算法样例</title>
      <link>/RFC9000_Chinese_Translation/Pseudocode/A.2_Sample_Packet_Number_Encoding_Algorithm/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9000_Chinese_Translation/Pseudocode/A.2_Sample_Packet_Number_Encoding_Algorithm/</guid>
      <description>图46中的伪代码展示了QUIC实现怎样选择合适长度的数据包号编码。
EncodePacketNumber函数接收两个参数：
  full_pn是正在发送的数据包的完整数据包号。
  largest_acked是当前数据包号空间中已被对端确认的最大数据包号，如果有的话。
  EncodePacketNumber(full_pn, largest_acked): // 比特位的数量必须至少比连续未被确认的数据包号的数量（包括此数据包本身）的 // 以`2`为底的对数值大`1` if largest_acked is None: num_unacked = full_pn + 1 else: num_unacked = full_pn - largest_acked min_bits = log(num_unacked, 2) + 1 num_bytes = ceil(min_bits / 8) // 将整型值编码，并截断为仅剩最低`num_bytes`个字节 return encode(full_pn, num_bytes) 图46：数据包号编码算法样例
 举例来说，如果终端接收到了对于数据包0xabe8b3的确认，并且正在发送数据包号为0xac5c02的数据包，那么就存在着29,519（0x734f）个未确认的数据包号。为了能够至少表示这个数量的两倍大小（59,038个，或者说0xe69e个数据包），就需要16个比特位。
在相同的状态下，发送数据包号为0xace8fe的数据包会使用长度为24比特位的编码方式，因为至少需要18个比特位才能表示缺口数量的两倍（131,222个，或者说0x020096个数据包）。</description>
    </item>
    
    <item>
      <title>A.3. 数据包号解码算法样例</title>
      <link>/RFC9000_Chinese_Translation/Pseudocode/A.3_Sample_Packet_Number_Decoding_Algorithm/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9000_Chinese_Translation/Pseudocode/A.3_Sample_Packet_Number_Decoding_Algorithm/</guid>
      <description>图47中的伪代码包含了在移除头部保护后解码数据包号的算法样例。
DecodePacketNumber函数接收三个参数：
  largest_pn是当前数据包号空间中已成功处理的最大数据包号
  truncated_pn是数据包号字段的值
  pn_nbits是数据包号字段中比特位的数量（8、16、24或32）。
  DecodePacketNumber(largest_pn, truncated_pn, pn_nbits): expected_pn = largest_pn + 1 pn_win = 1 &amp;lt;&amp;lt; pn_nbits pn_hwin = pn_win / 2 pn_mask = pn_win - 1 // 传入数据包号应该大于`expected_pn - pn_hwin`且小于等于 // `expected_pn + pn_hwin` // // 这意味着我们不能简单地去掉`expected_pn`中末尾的比特位再加上`truncated_pn` // 因为那样会产生一个超过窗口范围的值。 // // 接下来的代码计算了一个候选值，并确保它处于数据包号窗口范围中。 // 注意用于防止数值过大和数值过小的额外检查。 candidate_pn = (expected_pn &amp;amp; ~pn_mask) | truncated_pn if candidate_pn &amp;lt;= expected_pn - pn_hwin and candidate_pn &amp;lt; (1 &amp;lt;&amp;lt; 62) - pn_win: return candidate_pn + pn_win if candidate_pn &amp;gt; expected_pn + pn_hwin and candidate_pn &amp;gt;= pn_win: return candidate_pn - pn_win return candidate_pn 图47：数据包号解码算法样例</description>
    </item>
    
    <item>
      <title>A.4. ECN验证算法样例</title>
      <link>/RFC9000_Chinese_Translation/Pseudocode/A.4_Sample_ECN_Validation_Algorithm/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9000_Chinese_Translation/Pseudocode/A.4_Sample_ECN_Validation_Algorithm/</guid>
      <description>每次终端开始在新的网络路径上发送时，它都要判断该路径是否支持ECN；详见第13.4章。如果该路径支持ECN，那么就要将ECN利用起来。终端还可以每隔一段时间重新判断一次被认为不支持ECN的路径。
本节描述了一种用于测试新路径的方法。本算法的意图是展示如何测试一条路径是否支持ECN。终端可以用其他方法实现。
受测试的路径会被指定一种ECN状态，它会是“测试中”、“未知”、“失败”和“支持”中的一种。在状态为“测试中”或“支持”的路径上，终端发送的数据包会带有ECT标记——默认是ECT(0)；否则，终端发送的数据包上不带标记。
要启动对一条路径的测试，其ECN状态会被置为“测试中”，并且当前的ECN计数被记录为基准值。
测试期间会持续发送数个数据包，或者持续一段指定的时间，这由终端决定。此处的目标不是要限制测试的时长，而是确保发送了足够多经标记的数据包以使得接收到的ECN计数能够清晰地表明该路径会怎样对待经标记的数据包。第13.4.2章建议将此时长限制为发送10个数据包的耗时或PTO的三倍大小。
在测试期结束时，该路径的ECN状态会转为“未知”。对ACK帧中ECN计数的成功验证会使得该路径的状态从“未知”转为“支持”，除非没有经标记的数据包得到确认。
一旦对ECN计数的验证失败，那么相关路径的ECN状态就会转为“失败”。终端还可以在经标记的数据包全部被认定为丢包或全部被标记上ECN-CE时将ECN状态置为“失败”。
按照本算法，能够确保在正确支持ECN的路径上ECN几乎不会被禁用。任何错误地修改了标记的路径都会使得ECN被禁用。对于那些经标记数据包被路径丢弃的罕见情况，短暂的测试期能够限制被丢弃数据包的数量。</description>
    </item>
    
    <item>
      <title></title>
      <link>/RFC9000_Chinese_Translation/README/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9000_Chinese_Translation/README/</guid>
      <description>RFC9000 QUIC中文翻译 QUIC传输协议中文翻译。
搭建运行环境 本站点基于hugo。下面介绍如何运行本站开发环境：
如何运行安装及运行hugo Linux下可以直接apt install hugo安装环境，mac下可以用brew命令安装，windows下则需要去hugo站点下载hugo.exe执行文件并添加到环境变量里， 使得在命令行下执行hugo --help不会提示说找不到执行文件。
更多请移步Hugo文档。
翻译说明 在翻译的过程中，深刻体会到英语与汉语语法思维上的差别，其也体现在行文的方方面面。以下记录翻译QUIC系列文档时应该做的处理：
1. 方括号引用参考文献 形如：
The integration of TLS and QUIC is described in more detail in [[QUIC-TLS](#QUIC-TLS)]. [QUIC-TLS]是句子里实际提到的参考文献，这个结构本身参与语法构建，按照中文的习惯一般使用书名号《》将这种引用括起来。因此其应该翻译为：
《[QUIC TLS](#QUIC-TLS)》 但是下述这种：
QUIC integrates the TLS handshake [[TLS13](#TLS13)]. [TLS13]并不是语句的一部分，更类似于书本中的上标或下标引用。本站将其统一用html的上标引用之：
TLS握手&amp;lt;sup&amp;gt;[TLS 1.3](#TLS13)&amp;lt;/sup&amp;gt; 2. 图或表格 为了支持文档中的图及表格，这里fork了kraiklyn主题并添加了一个shortcode方法专门用来绘图及表格，例如：
&amp;lt;div id=Table_1_Stream_ID_Types class=&amp;#34;block ref&amp;#34;&amp;gt; \`\`\` |位 |流类型| |:---|:-----| |0x00|客户端创建的双向流| |0x01|服务端创建的双向流| |0x02|客户端创建的单向流| |0x03|服务端创建的单向流| \`\`\` [表格1：流类型](#Table_1_Stream_ID_Types) &amp;lt;/div&amp;gt; 这里，block_ref是专门定义的shortcode，indx用来指定锚点（请注意锚点不能使用的特殊字符），title表示图表名称。 block_ref会将title转成一个带跳转的href结构。引用该图表的方式：
[表1](#Table_1_Stream_ID_Types) 3. 何时添加英语原文 只在如下情况添加：
 在正式介绍一个名词的时候，在该章节其首次出现的地方用中文括号（）添加英语原文； 使用英语括号()括起来的一个名词或短语在翻译时使用中文括号（）括起来翻译内容，并在逗号后添加英语原文，逗号用中文；  4.</description>
    </item>
    
  </channel>
</rss>
