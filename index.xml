<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Autumn Navigation</title>
    <link>/</link>
    <description>Recent content on Autumn Navigation</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>cn</language><atom:link href="/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>前言</title>
      <link>/RFC8999_Chinese_Translation/Foreword/forword/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC8999_Chinese_Translation/Foreword/forword/</guid>
      <description>本文是关于QUIC传输层协议基础属性的网络规范文档译文，尚未完成翻译，欢迎指正。</description>
    </item>
    
    <item>
      <title>前言</title>
      <link>/RFC9000_Chinese_Translation/Foreword/forword/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9000_Chinese_Translation/Foreword/forword/</guid>
      <description>本文是QUIC传输层协议的网络规范文档译文，尚未完成翻译，欢迎指正。</description>
    </item>
    
    <item>
      <title>摘要</title>
      <link>/RFC8999_Chinese_Translation/Foreword/abstract/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC8999_Chinese_Translation/Foreword/abstract/</guid>
      <description>本文定义了在所有版本的QUIC传输协议间均通用的属性。</description>
    </item>
    
    <item>
      <title>摘要</title>
      <link>/RFC9000_Chinese_Translation/Foreword/abstract/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9000_Chinese_Translation/Foreword/abstract/</guid>
      <description>本文定义了QUIC传输协议的核心。QUIC是能支持应用程序进行有流量控制的多流结构化通信机制，支持低延迟连接建立和网络迁移。QUIC自带机密、完整的安全措施，能广泛支持各种各样的部署。有关文档描述了QUIC如何将TLS的秘钥协商、丢包检测及众多拥塞控制算法整合。</description>
    </item>
    
    <item>
      <title>备忘状态</title>
      <link>/RFC8999_Chinese_Translation/Foreword/status_of_this_memo/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC8999_Chinese_Translation/Foreword/status_of_this_memo/</guid>
      <description>本文是互联网标准追踪文档。
本文产自互联网工程任务组（IETF），已接受公开审查，并由互联网互联网工程指导委员会（IESG）批准出版。更多互联网标准相关信息详见RFC 7841第2章。
关于本文当前状态、勘误及反馈方式等相关信息请移步https://www.rfc-editor.org/info/rfc8999。</description>
    </item>
    
    <item>
      <title>备忘状态</title>
      <link>/RFC9000_Chinese_Translation/Foreword/status_of_this_memo/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9000_Chinese_Translation/Foreword/status_of_this_memo/</guid>
      <description>本文是互联网标准追踪文档。
本文产自互联网工程任务组（IETF），已接受公开审查，并由互联网互联网工程指导委员会（IESG）批准出版。更多互联网标准相关信息详见RFC 7841第2章。
关于本文当前状态、勘误及反馈方式等相关信息请移步https://www.rfc-editor.org/info/rfc9000。</description>
    </item>
    
    <item>
      <title>版权声明</title>
      <link>/RFC8999_Chinese_Translation/Foreword/copyright_notice/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC8999_Chinese_Translation/Foreword/copyright_notice/</guid>
      <description>版权所有（c）2021 IETF信托及确认为文档作者的个人。保留所有权利。
本文遵守BCP 78及在本文发布之日起生效的IETF信托涉及IETF文档的法律条文（https://trustee.ietf.org/license-info）。请仔细阅读相关条文，因为其描述了你对本文所有的权利及限制。从本文中摘录的代码组件必须包含信托法律条文第4.e章的简版BSD License文件，并且不附带任何该文件所描述的保证。</description>
    </item>
    
    <item>
      <title>版权声明</title>
      <link>/RFC9000_Chinese_Translation/Foreword/copyright_notice/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9000_Chinese_Translation/Foreword/copyright_notice/</guid>
      <description>版权所有（c）2021 IETF信托及确认为文档作者的个人。保留所有权利。
本文遵守BCP 78及在本文发布之日起生效的IETF信托涉及IETF文档的法律条文（https://trustee.ietf.org/license-info）。请仔细阅读相关条文，因为其描述了你对本文所有的权利及限制。从本文中摘录的代码组件必须包含信托法律条文第4.e章的简版BSD License文件，并且不附带任何该文件所描述的保证。</description>
    </item>
    
    <item>
      <title>1.1. 文档结构</title>
      <link>/RFC9000_Chinese_Translation/Overview/1.1_document_structure/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9000_Chinese_Translation/Overview/1.1_document_structure/</guid>
      <description>本文描述了QUIC协议的核心部分，文章组织如下：
  第1章流是QUIC支持的基本服务抽象层。
 第2章描述流相关的核心概念， 第3章提供一个流状态的参考模型， 第4章概述流量控制的过程。    连接是QUIC终端交流的上下文。
 第5章描述连接相关的核心概念， 第6章描述版本协商 第7章详细描述连接连接建立的过程， 第8章描述地址验证及危险的拒绝服务迁移攻击， 第9章描述终端如何将一个连接迁移到新的网络通道上， 第10章列举关闭一个已打开连接的各个方式，以及 第11章给流与连接错误处理提供指导。    数据包和帧是QUIC交流的基本单元。
 第12章描述数据包与帧相关的概念， 第13章定义数据传输、重传和确认的模型，以及 第14章描述指定携带QUIC数据包的数据报大小的规则。    最后，QUIC协议要素的编码细节描述在：
 第15章版本， 第16章整形编码， 第17章数据包头部， 第18章传输参数， 第19章帧，以及 第20章错误。    相关文档《QUIC恢复》描述QUIC的数据丢失检测及拥塞控制，《QUIC TLS》描述TLS及其他加密机制的使用。
本文定义了QUIC版本1，支持《QUIC不变量》所定义的不变量。
若引用QUIC版本1，请引用本文（你还是引用《》吧）。若引用QUIC支持的独立版本的某个子集，请引用《QUIC不变量原文》。</description>
    </item>
    
    <item>
      <title>QUIC相关翻译说明</title>
      <link>/Translation_Norms/For_RFCs/QUIC_related/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/Translation_Norms/For_RFCs/QUIC_related/</guid>
      <description>1. 帧类型翻译展示 ACK、STREAM、NEW_CONNECTION_ID等帧类型如果直接使用原文实为不妥，并不直观。然而，其又以大写形式表现，固所以需要进行特别处理。
本文决定暂时采用将其加粗展示的方式进行区分。
2. 帧字段翻译展示 如下是重置帧的定义：
RESET_STREAM Frame { Type (i) = 0x04, Stream ID (i), Application Protocol Error Code (i), Final Size (i), } 其中Type、Stream ID等均是帧字段。 用“”将字段括起来。
2. 错误类型翻译展示 形如CONNECTION_ID_LIMIT_ERROR的错误类型也比较麻烦，因其可能细碎地提前引用。因此，需要将其特别考虑。 在其正式介绍前，如果首次出现在一个大章节中，则该大写字段以括号（）附上中文翻译。同章节后续再出现则不再附上翻译。
3. 传输参数翻译展示 传输参数（transport parameters）展示方式同第2点。</description>
    </item>
    
    <item>
      <title>1.2. 术语及定义</title>
      <link>/RFC9000_Chinese_Translation/Overview/1.2_terms_and_definitions/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9000_Chinese_Translation/Overview/1.2_terms_and_definitions/</guid>
      <description>本文中的关键字“必须（MUST）”、“必须不（MUST NOT）”、“需要（REQUIRED）”、“强烈要求（SHALL）”、“强烈要求不（SHALL NOT）”、“应该（SHOULD）”、“不应该（SHOULD NOT）”、“推荐（RECOMMENDED）”、“不推荐（NOT RECOMMENDED）”、“可以（MAY）”，以及“可选（OPTIONAL）”应理解为BCP 14 《RFC2119》《RFC8174》所描述的，当且仅当它们像本段一样以斜体加粗方式出现的时候。
本文常用术语列述如下：
QUIC：本文描述的传输协议。QUIC是名称，不是首字母缩写。
终端（Endpoint）：一个能够以创建、接收及处理QUIC数据包参与QUIC连接的实体。QUIC终端有两种类型：客户端（client）及服务端（server）。
客户端：初始化QUIC连接的终端。
服务端：接收QUIC连接的终端。
QUIC数据包：QUIC的一个可以封装进UDP报文中的完整处理单元。单个UDP报文可以封装进一个或多个QUIC数据包。
ACK触发包：一个包含除确认帧（ACK）、填充帧（PADING）及连接关闭帧（CONNECTION_CLOSE）外的帧的QUIC数据包。接收方收到这类包会发确认，详见第13.2.1章。
帧：一个结构化的协议信息单元。帧有多种类型，不同类型的帧携带不同类型的信息。帧由QUIC数据包承载。
地址：当使用不受限制，由IP版本、IP地址及UDP端口号构成的元组表示网络通道的一端。
连接ID：终端用来标识一条QUIC连接的标识符。每个终端选择一个或多个连接ID，从而在对端发送给本端的QUIC包中包含这些连接ID。该值对对端是不透明的。
流：QUIC连接上一个单向或双向的有序字节通道。一个QUIC连接可以同时承载多条流。
应用：一个使用QUIC发送及接收数据的实体。
本文使用术语“QUIC数据包”、“UDP报文”及“IP数据包”表示相应协议的传输单元。换言之，一个或多个QUIC包被封装到一个UDP报文里，最终封装到一个IP数据包中。</description>
    </item>
    
    <item>
      <title>1.3. 标准规范</title>
      <link>/RFC9000_Chinese_Translation/Overview/1.3_notational_conventions/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9000_Chinese_Translation/Overview/1.3_notational_conventions/</guid>
      <description>本文数据包及帧的图解使用一种定制格式，目的是总结而不是定义协议元素。文中定义了完整的语义及详细的结构。
复杂的字段被命名后，由紧随命名的一个以一对花括号括起来的字段列表描述，列表中的字段以逗号分隔。
单个字段包括长度信息、带正号的定值、可选值或本字段的副本。单个字段使用下述标准规范，且所有长度都以比特为单位：
x (A): 表示x是A比特长度
x (i): 表示x是一个使用第6章描述的变量长度编码的整形值
x (A..B): 表示x的长度可以是从A到B的所有值，省略A表示最小零位，并且省略B表示没有设置上限。这种格式的值总是以字符边界结束。
x (L) = C: 表示x有一个定值C，且x的长度为L，L可以用上述任何长度格式
x (L) = C..D: 表示x的值介于C到D之间，包括边界值C和D，L表示长度，同上
[x (L)]: 表示x是一个可选的值，长度为L
x (L)...: 表示x重复0次或以上次数，且每个实例长度为L
本文使用网络字节序（也就是大端）值。字段每个字节的各个比特从高位到低位排列。
约定单个字段通过使用复合字段的名称引用复合字段。</description>
    </item>
    
    <item>
      <title>2.1. 流类型及标识符</title>
      <link>/RFC9000_Chinese_Translation/Streams/2.1_Stream_Types_and_Identifiers/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9000_Chinese_Translation/Streams/2.1_Stream_Types_and_Identifiers/</guid>
      <description>流可以是单向或双向的。单向流往一个方向传输数据：从流发起端向对端发送；双向流允许双端向对端发送数据。
在连接中，流以一个数字值标识，称为流ID。一个流ID是一个62比特的整数（0-262-1），且与同连接中其他流的流ID严格区分。流ID编码为一个可变长度整形，详见第16章。一个QUIC终端必须不能在同一个连接的不同流上重复使用同一个数值作为流ID。
流ID的最小有效位（0x01）标识流的发起者。 客户端发起的流的ID是偶数（该位被置为0），服务端发起的流的ID是奇数（该位被置为1）。
流ID的次小有效位（0x02）标识流是双向流（该位被置为0）抑或单向流（该位被置为1）。
也就是说，流ID的最小两个有效位用来标识一条流是总共四种流类型中的哪一种，总结在如下表格1中：
   位 流类型     0x00 客户端创建的双向流   0x01 服务端创建的双向流   0x02 客户端创建的单向流   0x03 服务端创建的单向流    表格1：流类型
 每种流类型的流空间从其最小值开始（依次从0x00到0x03）；每种流的每个流ID根据创建顺序依次线性递增。 一个流ID如果超出了次序，将导致其所在类型的所有小于该流ID的流都被开启。</description>
    </item>
    
    <item>
      <title>2.2. 数据发送与接收</title>
      <link>/RFC9000_Chinese_Translation/Streams/2.2_Sending_and_Receiving_Data/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9000_Chinese_Translation/Streams/2.2_Sending_and_Receiving_Data/</guid>
      <description>流帧（第19.8章）封装应用层发送的数据。 终端使用流帧的流ID及偏移字段整理数据。
终端必须将流数据以一个有序字节流传递给应用层。 传递一个有序字节流需要终端缓存任何接收到的乱序数据，直到到达了建议的流量控制限制的上限。
QUIC对于传递流的无序数据并没有做额外的打算。 然而，实现上 可以选择支持传递无序数据给应用层接收。
终端可以从一条流的同一个偏移位置多次接收数据。 如果数据已经被接收过了，就会直接被丢弃。 处在任何偏移位置的数据如果被重复发送，其必须不能更改。 终端可以将在流的同一偏移处收到不同数据的情况视为PROTOCOL_VIOLATION类型（违反协议）的连接错误。
流是一个抽象的有序字节流，QUIC不感知除此以外的任何结构。 流帧的边界在数据被传输、丢包后重传以及被传递给应用层接收者后，不会继续保留。
终端必须不能在对端设置的流量控制限制之外发送任何数据。流量控制详见第4章。</description>
    </item>
    
    <item>
      <title>2.3. 流优先级</title>
      <link>/RFC9000_Chinese_Translation/Streams/2.3_Stream_Prioritization/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9000_Chinese_Translation/Streams/2.3_Stream_Prioritization/</guid>
      <description>如果资源以正确的优先级分配给多条流，那么流的多路复用可以对应用性能产生显著影响。
QUIC并不支持交换优先级信息，相反，其依赖从应用层接收的优先级信息。
QUIC在实现上应该提供某种方法使得应用层能够因此确定各条流的相对优先级。 一种实现是使用应用层提供的信息决定分配多少资源来激活流。</description>
    </item>
    
    <item>
      <title>2.4. 流操作</title>
      <link>/RFC9000_Chinese_Translation/Streams/2.4._Operations_on_Streams/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9000_Chinese_Translation/Streams/2.4._Operations_on_Streams/</guid>
      <description>本文没有定义QUIC API，而是定义了一系列流操作相关的函数可以用于应用层协议的构建。 应用层协议可以假定QUIC有关实现提供了本章描述的操作对应的接口。 为一个特定应用层协议设计实现的QUIC协议可能仅仅提供该协议需要的这些操作。
在流的发送部分，应用层协议可以：
 写数据，只有当流量控制给数据写出留足空间（第4.1章）才能成功写出； 结束流（清理并关闭），发送一个设置FIN位为1的流帧（第19.8章）； 重置流（中止并关闭），当流未处在终止状态时发送一个RESET_STREAM帧（第19.4章）。  在流的接收部分，应用层协议可以：
 读数据，以及 中止读取流数据并请求关闭流，该操作可能需要发送STOP_SENDING帧（第19.5章）。  应用层协议也可以请求在流状态改变的时候收到通知信息，包括当对端开启或重置流、对端中止流数据读取、有新数据可以读取、以及数据可以写出或因流控不能写出。</description>
    </item>
    
    <item>
      <title>3.1. 流发送状态</title>
      <link>/RFC9000_Chinese_Translation/Stream_States/3.1_Sending_Stream_States/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9000_Chinese_Translation/Stream_States/3.1_Sending_Stream_States/</guid>
      <description>图2展示了通过流向对端发送发送数据的状态。
 图2：流数据发送部分状态
 终端发起的流的发送部分（客户端发起的流类型是0和2，1和3则是由服务端发起的）由应用层打开。 用于发送的流数据可能被缓存起来。
发送首个流帧（STREAM）或流阻塞帧（STREAM_DATA_BLOCKED）使流的发送部分进入“发送”状态。 QUIC实现可以选择延迟分配流ID直到其发送首个流帧并进入“发送”状态，这样可以实现更好的流优先级。
由对端发起的双向流的发送部分（服务端发起的流类型是0，客户端发起的是1）在接收部分创建时就已处于“就绪”状态，并从此状态开始。
在“发送”状态，终端通过流帧传输——必要时重传——流数据。 终端遵从其对端设置的流量控制限制，同时持续接收与处理最大流数据帧（MAX_STREAM_DATA）。 当发送过程被流的流量控制限制（第4.1章）所阻塞时，处在“发送”状态的终端会生成流阻塞帧。
在应用层表示所有应用数据及一个带FIN置位的流帧都发送完成后，流的发送部分进入“发送完成”状态。 从这个状态开始，终端只会做必要的数据重传。 在对端收到最终流下标前，都有可能收到最大流数据帧。 处与此状态的终端可以忽略任何其收到的最大流数据帧，这样是安全的。
当所有流数据都被成功确认后，发送部分进入“接收完成”状态，这是一个最终状态。
处在“就绪”、“发送”及“发送完成”状态中的任何一个状态时，应用层都可以提出取消发送流数据。 相应地，终端也可能从其对端收到一个停止发送帧（STOP_SENDING）。 不论哪种情况，终端都会发送流重置帧（RESET_STREAM），随后流进入“重置发送”状态。
终端可以发送一个流重置帧作为流的首个帧，这会导致该流的发送部分开启然后立即转到“重置发送”状态。
一旦一个包含流重置帧的数据包被确认，流的发送部分即进入“重置接收”状态，这也是一个最终状态。</description>
    </item>
    
    <item>
      <title>3.2. 接收流状态</title>
      <link>/RFC9000_Chinese_Translation/Stream_States/3.2_Receiving_Stream_States/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9000_Chinese_Translation/Stream_States/3.2_Receiving_Stream_States/</guid>
      <description>图3展示了通过流从对端接收数据的状态。 流的接收部分只会反映对端流发送部分的一些状态。 流的接收部分不能追踪发送部分那些不可见的状态，例如“就绪”状态。 相反，流的接收部分追踪向应用层传递的数据，其中一些数据对发送端不可见。
 图3：流数据接收部分状态
 由对端发起的流（客户端发起的流类型是1和3，服务端发起的是0和2）的接收部分在收到该流的第一个流帧、流阻塞帧或流重置帧时创建。 对于由对端创建的双向流，发送部分收到最大流数据帧或停止发送帧时也会创建该流的接收部分。 流的接收部分的初始状态是“发送”状态。
由本端发起的双向流（客户端发起的流类型是0，服务端发起的是1），当其发送部分进入“就绪”状态时，其接收部分进入“接收”状态。
终端在收到最大流数据帧或停止发送帧后打开一条双向流。 接收到一条未开启的流的最大流数据帧意味着对端已经开启了该流，并开始支持流量控制信用。 而接收到一条未开启流的停止发送帧意味着对端不会再从该流接收数据。 无论这两种帧的哪一种都可能先于流帧或流阻塞帧到达本端，原因是包丢失或乱序。
在一条流创建前，所有数值小于该流ID的同类型流都必须被创建。 这样能确保双端流的创建次序保持一致。
在“接收”状态，终端接收流帧和流阻塞帧。 传入数据将被缓存，并可以按照正确顺序重组以便递给应用层。 随着应用层不断消耗数据，缓冲区重新空出来，终端发送最大流数据帧告知对端可以发送更多数据。
当收到一个带FIN置位的流帧时，数据的最终大小确定下来，详见第4.5章。 流的接收部分随后转到“数据量确认”状态。 在此状态，终端不再需要发送最大流数据帧，只需要接收重传数据即可。
一旦收完了一条流的所有数据，流的接收部分转入“接收完成”状态。 【TODO further transmition】 在接收到导致状态转换到“接收量确认”的流帧后，可能同时导致转入“接收完成”状态。 在所有数据都收完后，可以丢弃该流的任何流帧或流阻塞帧。
“接收完成”状态会一直持续直到数据全部传递到应用层。 一旦流数据传递完成，即转到“读取完成”状态，这是一个最终状态。
如果在“接收”或“数据量确认”状态收到一个流重置帧，将导致流转到“重置接收”状态。 这可能打断流数据传递到应用层。
流重置帧也有可能在所有流数据都收完后才收到（即在“接收完成”阶段）。 同样地，也可能在收完流重置帧后收到了剩下的流数据（即在“重置接收”状态）。 在QUIC的具体实现上，可以自由选择如何处理这两种情况。
发送流重置帧意味着终端不能保证流数据的传输。 然而，并没有要求在收到流重置帧后不传输流数据。 QUIC实现可以打断流数据的传输，丢弃任何没有被消耗的数据，并通知对端收到了流重置帧。 如果流数据完成了接收并被缓存起来以供应用层读取，此时收到流重置帧信号，则该信号可能被抑制或扣留。 如果流重置帧被抑制，流的接收部分仍然维持在“接收完成”状态。
一旦应用层收到流被重置的信号，流的接收部分转到“重置读取”阶段，这是一个最终状态。</description>
    </item>
    
    <item>
      <title>3.3. 许可帧</title>
      <link>/RFC9000_Chinese_Translation/Stream_States/3.3_Permitted_Frame_Types/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9000_Chinese_Translation/Stream_States/3.3_Permitted_Frame_Types/</guid>
      <description>流的发送端发送的帧只有三种能同时影响发送端和接收端状态：流帧（第19.8章）、流阻塞帧（第19.13章），以及流重置帧（第19.4章）。
发送端必须不在最终状态（“接收完成”或“重置接收”）发送任何这些帧。当流处在“重置发送”或任何最终状态时，发送端必须不发送流帧或流阻塞帧——也就是说，在发送完一个流重置帧后。接收端可以在任何状态接收这三种帧，原因在于被延迟的包可能携带这些帧。
流的接收端发送最大流数据帧（第19.19章）及停止发送帧（第19.5章）。
接收端只可以在“接收”状态发送最大流数据帧。如果接收端尚未收到过流重置帧，其可以在任何状态发送一个停止发送帧——也就是除“重置接收”、“重置读取”之外的状态。然而，在“接收完成”状态发送停止发送帧意义不大，因为所有流数据都已经收到了。由于可能存在数据包延迟，因此发送端可以在任何状态接收这两种帧。</description>
    </item>
    
    <item>
      <title>3.4. 双向流状态</title>
      <link>/RFC9000_Chinese_Translation/Stream_States/3.4_Bidirectional_Stream_States/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9000_Chinese_Translation/Stream_States/3.4_Bidirectional_Stream_States/</guid>
      <description>双向流同时包括接收部分和发送部分。 QUIC的实现可以将双向流的状态表示成发送及接收流状态的组合状态。 在最简单的模型里，当发送和接收部分均处在非最终状态时，表示流处于“打开”状态；当两者均处于最终状态时，表示流处于“关闭”状态。
表格2展示了一个更复杂的双向流状态映射，粗略对应HTTP/2（HTTP2）中定义的流状态。 这表明流的发送或接收部分多个状态映射到同一个组合状态。 注意这仅仅是一个可能的映射，这种映射需要数据全部被确认后才能转入“关闭”或“半关闭”状态。
   发送部分 接收部分 组合状态     无流、就绪 无流、接收① 空闲   就绪、发送、发送完成 接收、数据量确认 打开   就绪、发送、发送完成 接收完成、读取完成 半关闭（对端）   就绪、发送、发送完成 重置接收、重置读取 半关闭（对端）   接收完成 接收、数据量确认 半关闭（本端）   重置发送、重置接收 接收、数据量确认 半关闭（本端）   重置发送、重置接收 接收完成、读取完成 关闭   重置发送、重置接收 重置接收、重置读取 关闭   接收完成 接收完成、读取完成 关闭   接收完成 重置接收、重置读取 关闭    表2：流状态到HTTP/2间可能的映射方式
  注意（①）：如果一条流尚未被创建或其接收部分处于“接收”状态而尚未收到任何帧，则流处于“空闲”状态。</description>
    </item>
    
    <item>
      <title>3.5. 请求状态转换</title>
      <link>/RFC9000_Chinese_Translation/Stream_States/3.5_Solicited_State_Transitions/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9000_Chinese_Translation/Stream_States/3.5_Solicited_State_Transitions/</guid>
      <description>如果应用层不再需要流接收到的数据，应用层可以中止流的读取，并指定一个应用层错误码。
如果流处在“接收”或“数据量确认”状态，传输层应该发送一个停止发送帧通知对端及时在反方向关闭流。 这通常表明接收方应用层不再读取流接收到的数据，但这并不意味着传入的数据一定会被忽略。
在发送完停止发送帧后收到的流帧仍然会被连接及流级别的流量控制统计，即使这些帧可能在接收时即被丢弃。
停止发送帧请求接收端发送一个流重置帧。 如果流处在“就绪”或“发送”状态，收到停止发送帧的一端必须发送一个流重置帧。 如果流处在“发送完成”状态，终端可以推迟发送流重置帧直到含有未发完数据的数据包被确认或明确的被丢弃。 如果任何未发完数据得到明确被丢弃了，终端应该发送一个流重置帧而非重传数据。
终端应该从停止发送帧复制错误码到要发出的流重置帧，但是其可以使用任何应用层错误码。 发送停止发送帧的终端可以忽略任何随后被流接收到的流重置帧里的错误码。
停止发送帧应该只能在流尚未被对端重置前发送出去。 停止发送帧主要在流的“接收”或“数据量确认”状态使用。
如果包含前一个停止发送帧的数据包丢失了，期望终端发送另外的停止发送帧。 然而，一旦流收到了所有流数据或一个流重置帧——也就是说流处在“接收”或“数据量确认”之外的状态——发送停止发送帧就不再必要了。
如果双向流的一端想要将流的两个方向同时关闭，那么其可以通过发送一个流重置帧关闭一个方向，并发送一个停止发送帧促使相反方向也迅速得到关闭。</description>
    </item>
    
    <item>
      <title>4.1. 数据流量控制</title>
      <link>/RFC9000_Chinese_Translation/Flow_Control/4.1_Data_Flow_Control/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9000_Chinese_Translation/Flow_Control/4.1_Data_Flow_Control/</guid>
      <description>QUIC使用一个基于限制的流量控制模型，接收者给出其准备在给定流或整个连接上准备接收的总字节数的上限。 这使得QUIC中存在两层数据流量控制：
 流的流量控制：通过限制每条流可以发送的数据量，防止单条流耗尽一条连接的全部接收缓冲区； 连接流量控制：通过限制所有流经由流帧可以发送的数据量，防止发送方超过连接接收方的缓冲区容量。  发送方发送数据必须不能超过上述任何一个限制。
接收方可以通过发送一个含相关流ID的最大流数据帧告知对方提高流接收缓存区上限。 最大流数据帧表示流的最大绝对字节偏移量。 接收方可以根据当前流消耗数据的偏移量确定后续发出的流量控制的偏移量。
接收方可以通过发送一个最大数据帧告知对方提高连接的接收缓存区上限，亦即所有流绝对字节偏移量之和的上限。 接收方维护一个在所有流上累计接收数据的总字节数，用以检查是否超过了连接或流流量控制上限。 接收方可以基于在所有流上消耗数据总字节数确定后续发出的最大数据偏移量。
接收方发布连接或流的流量控制上限若低于之前的上限，这不是错误，只是这个更低的上限不会生效而已。
如果发送方违反了推荐的连接或流的流量控制上限，接收方必须以FLOW_CONTROL_ERROR类型错误关闭连接，更多错误处理相关细节详见第11章。
发送方必须忽略任何不会提高流量控制上限的最大流数据帧或最大数据帧。
如果发送方发送数据达到了流量控制上限，其将不能再发送新数据，且应认为其被阻塞住了。 发送方应该发送一个流数据阻塞帧或数据阻塞帧来告知接收方其有数据要写出但是被流量控制所阻塞。 如果发送方被阻塞的时间超过空等超时时间（第10.1章），接收方可以关闭连接，即便发送方有可传输的数据。 为了保持连接不被关闭，在没有可引发ACK的数据包处于传输中时，被流量控制限制所阻塞的发送方应该定期发送一个流数据阻塞帧或数据阻塞帧。</description>
    </item>
    
    <item>
      <title>4.2. 提高流量控制限制</title>
      <link>/RFC9000_Chinese_Translation/Flow_Control/4.2_Increasing_Flow_Control_Limits/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9000_Chinese_Translation/Flow_Control/4.2_Increasing_Flow_Control_Limits/</guid>
      <description>QUIC实现决定什么时候以什么额度通过最大流数据帧及最大数据帧提高流量控制限制，但是本章提出了一些注意事项。
为了避免阻塞发送方，接收方可以在一个往返时间（RTT）内多次发送一个最大流数据帧或最大数据帧，或者尽可能早地发送，从而为帧的丢失及随后的恢复留出时间。
控制帧也会引入连接开销。 也就是说频繁发送最大流数据帧及最大数据帧做极其微小的调整是不可取的。 另一方面，如果更新不够频繁，每次更新时就要对接收方上限做更大幅度的提升以防发送方被阻塞，使得接收方耗费需要更多资源。 因此，确定决定接收方推荐上限需要权衡资源耗费与连接开销。
接收方可以使用一个常见于TCP实现的基于往返时间及接收数据应用层消耗速率的自动调谐机制来调整推荐接收上限的频率和增量。 作为优化，终端只有在有其他帧要发送时才可以发送流量控制相关帧，以确保流量控制不会导致额外的数据包发送。
被阻塞发送方不需要发送流阻塞帧或数据阻塞帧。 也就是说，接收方必须不能在发送最大流数据帧及最大数据帧前等待接收流阻塞帧或数据阻塞帧，否则可能导致发送方在连接的其余部分被阻塞。 即使发送方发送了这些帧，等待它们也会导致发送方至少被阻塞一个完整的往返周期。
当终端在阻塞期间收到可发送数据额度时，它可能会回复大量数据，造成短暂的拥塞，详见《QUIC快速恢复》第7.7章有关终端如何避免这类拥塞的讨论。
秋航注：这里将credit翻译为额度、增量等，指的是最大流数据帧及最大数据帧所带来的接收方新流量控制上限相对之前的提升量，这个提升量是发送方后续可发送新数据的空间。
 </description>
    </item>
    
    <item>
      <title>4.3. 流量控制性能</title>
      <link>/RFC9000_Chinese_Translation/Flow_Control/4.3_Flow_Control_Performance/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9000_Chinese_Translation/Flow_Control/4.3_Flow_Control_Performance/</guid>
      <description>如果终端不能确保其对端始终在该连接上有大于对端带宽时延积的流量控制额度，其接收吞吐量将被流量控制限制。
包丢失会导致接收缓冲区出现空隙，从而阻碍应用层消耗数据并释放接收缓冲空间。
及时发送流量控制上限更新能提高性能。 发送只包含流量控制更新的数据包会增加网络负载，对性能产生不利影响。 将流量控制更新与其他帧一起发出，例如如ACK帧，可以降低此类更新带来的消耗。</description>
    </item>
    
    <item>
      <title>4.4. 处理流取消</title>
      <link>/RFC9000_Chinese_Translation/Flow_Control/4.4_Handling_Stream_Cancellation/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9000_Chinese_Translation/Flow_Control/4.4_Handling_Stream_Cancellation/</guid>
      <description>终端之间最终必须在每条流消耗的流量控制额度上达成一致，从而能够计算出连接级流量控制的字节数。
收到流重置帧后，终端就会关闭相应流的状态，并忽略后续从该流上收到的数据。
流重置帧会立即中止流的一个方向。 对于一条双向流，流重置帧不会影响另一个方向的数据流。 双端必须给一条流尚未关闭的方向维持流量控制状态直到该方向转入终止状态。
秋航注：“中止”与“终止”的区别在于“中止”强调突然地、异常地结束一个过程，而“终止”没有这种强调意味。可以认为，“终止”包含流程的正常结束和异常“中止”两种情况。
 </description>
    </item>
    
    <item>
      <title>4.5. 流的最终数据量</title>
      <link>/RFC9000_Chinese_Translation/Flow_Control/4.5_Stream_Final_Size/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9000_Chinese_Translation/Flow_Control/4.5_Stream_Final_Size/</guid>
      <description>流的最终数据量是流消耗的流量控制额度的总量。 假设流的每个连续的字节只被发送一次，那么其最终数据量就是发出的总字节数。 更一般地来说，这比流上发送的最大偏移的字节高1，若无字节发送则为0。
不管流是如何终止的，发送方始终试图将流的最终数据量可靠地发送给接收方。 最终数据量是 带有FIN置位的流帧的Offset（下标）和Length（长度）字段值的总和，注意这些字段可能是隐式的。 或者，流重置帧的Final Size字段也可以携带最终数据量值。 这保证了双端发送方在该流上消耗的流量控制额度上达成一致。
终端在流的接收部分转入“数据量确认”或“重置接收”状态（第3章）后将得知最终数据量。 接收方必须根据流的最终数据量在其连接层流量控制上统计该流发送的字节数。
终端在一条流上发送的数据必须不能大于或等于其最终数据量。
一旦流的最终数据量得到确认，就不能再更改。 如果收到流重置神或流帧表示要修改流的最终数据量，终端应该回复一个FINAL_SIZE_ERROR类型的错误，更多细节详见第11章有关错误处理部分。 接收方应该将收到达到或超过最终数据量数据的情况视为FINAL_SIZE_ERROR类型的错误，即使是在关闭后收到的。 并不强制要求生成这些错误，因为终端若要做到这一点往往意味着终端需要给已关闭流维持一个最终数据量状态，也就意味着需要增加一个重要的状态确认。</description>
    </item>
    
    <item>
      <title>4.6. 并发控制</title>
      <link>/RFC9000_Chinese_Translation/Flow_Control/4.6_Controlling_Concurrency/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9000_Chinese_Translation/Flow_Control/4.6_Controlling_Concurrency/</guid>
      <description>终端限制对端累计可以开启的流的数量。 只有流ID小于(max_streams * 4 + first_stream_id_of_type)的流可以被开启，详见表1。 初始化限制由传输参数设置，详见第18.2章。 随后的限制由最大流帧推出，详见第19.11。 针对单向及双向流由单独的限制。
如果经由max_streams传输参数或最大流帧收到的值大于260，这将使得最大流ID不能表示为变长整数，详见第16章。 如果收到了这两者的其中一个，必须立即关闭连接： 如果这个值是通过传输参数收到的，就以TRANSPORT_PARAMETER_ERROR错误关闭连接；如果是通过帧收到的，就以FRAME_ENCODING_ERROR错误关闭连接，详见第10.2章。
终端必须不能触达对端设置的流数量限制。 终端收到一个有个触达其设置的流数量上限的流ID的帧的情况必须视为STREAM_LIMIT_ERROR类型的连接错误，更多有关错误梳理的细节详见第11章。
一旦接收方通过最大流帧推荐了一个流数量上限，再推荐一个更小的上限将不再生效。 必须忽略不会提高流数量上限的最大流帧。
正如流及连接层流量控制，本文让实现者来决定通过最大流帧发布的流数量上限的时间及数值。 QUIC实现可以选择在流关闭时提高流数量上限，从而保持对端可以使用的流的数量大体对等。
终端因对端设置的流数量上限而不能再开启新流时，应该发送一个流阻塞帧（第19.14章）。 可以认为这个信号主要用于调试。 终端必须不在对端发布额外额度前等待这个信号，因为这样做的话意味着对端会被阻塞至少一个往返周期，且若对端选择不发流阻塞帧时则等待可能会是无限期的。</description>
    </item>
    
    <item>
      <title>5.1 长包头</title>
      <link>/RFC8999_Chinese_Translation/QUIC_Packets/5.1_Long_Header/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC8999_Chinese_Translation/QUIC_Packets/5.1_Long_Header/</guid>
      <description>图2是QUIC长包头的格式。
长包头 { 包头格式 (1) = 1, 版本特定相关位 (7), 版本 (32), 目标连接ID长度 (8), 目标连接ID (0..2040), 源连接ID长度 (8), 源连接ID (0..2040), 版本特定相关数据 (..), } 图2：QUIC长包头
 QUIC长包头数据包其首字节最高比特位设置为1，其余比特位则视具体版本而定。
随后的四个字节包含一个32位版本字段，关于版本详见第5.4章。
接下来的一个字节包含紧随其后的目标连接ID字段的长度，且该长度值以字节计数，并被编码为一个8位无符号整数。目标连接ID字段紧随目标连接ID长度字段，其长度在0到255字节之间。连接ID详见第5.3章。
接下来的一个字节包含紧随其后的源连接ID字段的长度，且该长度值以字节计数，并被编码为一个8位无符号整数。源连接ID字段紧随源连接ID长度字段，其长度在0-255字节之间。
数据包接下来剩余字段包含与QUIC版本特定相关的内容。</description>
    </item>
    
    <item>
      <title>5.1.1 发布连接ID</title>
      <link>/RFC9000_Chinese_Translation/Connections/Connection_IDs/5.1.1_Issuing_Connection_IDs/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9000_Chinese_Translation/Connections/Connection_IDs/5.1.1_Issuing_Connection_IDs/</guid>
      <description>当新连接ID帧或撤销连接ID帧指向同一个值时，每个连接ID都有一个相关联的序列号用于协助检测。一个终端发出的初始连接ID是通过握手阶段（第17.2章）的长包头的源连接ID字段发送的。初始连接ID的序列号是0。如果发送了传输参数preferred_address（推荐地址），发出的连接ID的序列号就是1。
额外的连接ID通过新连接ID帧（第19.5章）传输给对方。新发出的连接ID的序列号必须递增1。客户端给其发出的第一个目标连接ID字段的连接ID及重试包的连接ID不会分配序列号。
当一个终端发出一个连接ID，其必须在连接存活期间或在对端通过撤销连接ID帧（第19.16章）取消连接前接收携带该连接ID的数据包。 连接ID被发出且没有被取消，即是活跃的；任何活跃的连接ID在连接任何时间、对其任何类型的数据包都可以有效使用。这包括被服务端通过推荐地址传输参数发出的连接ID。
终端应该确保其对端有足够数量可用且未使用的连接ID。 终端使用active_connection_id_limit（活跃连接ID限制）传输参数指定它们想要维持的活跃连接ID的数目。 一个终端必须不能提供超过对端限制数目的连接ID。 如果新连接ID帧也要求终止任何多余的连接ID，终端可以通过在“撤销前”字段包含一个足够大的值来发送临时超过对端限制数量的连接ID。
终端可以根据新连接ID帧的“撤销前”字段内容添加一些活跃连接ID并终止其他连接ID。 在处理完一个新连接ID帧，添加及撤销一些活跃连接ID后，如果活跃连接ID数量仍然超过active_connection_id_limit传输参数建议的值，终端必须以CONNECTION_ID_LIMIT_ERROR（连接ID限制）错误关闭连接。
当对端撤销一个连接ID后，终端应该提供一个新的连接ID。 如果终端提供的连接ID数目小于对端active_connection_id_limit值，则其可以在收到一个包含之前撤销的连接ID的数据包时提供一个新的连接ID。 终端也可以限制连接ID的发布以降低其维护的通道层面的状态量，例如通道验证状态，因为对端可能有多少连接ID就用多少通道与其交互。
启动连接迁移且需要非零长度连接ID的终端应该确保其连接ID池对端可得，从而使对端能在连接迁移时用新的连接ID，因为如果连接ID池耗尽，对端将无法回复。
在握手阶段选择零长度连接ID的终端不能发布新的连接ID。通过任何通道发往一个这样的终端的所有包使用零长度目标连接ID字段。</description>
    </item>
    
    <item>
      <title>5.1.2 消耗及撤销连接ID</title>
      <link>/RFC9000_Chinese_Translation/Connections/Connection_IDs/5.1.2_Consuming_and_Retiring_Connection_IDs/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9000_Chinese_Translation/Connections/Connection_IDs/5.1.2_Consuming_and_Retiring_Connection_IDs/</guid>
      <description>终端可以在连接期间任何时候将其与对端交互的连接ID更改为另一个可用的连接ID。 在对端进行迁移连接时，终端会消耗连接ID，更多详见第9.5章。
终端维护一个接收自对端的连接ID集合，其中每个ID均可用于发送数据包。当终端想要停止使用一个连接ID，其可以发送一个撤销连接ID帧给对端。 发送一个撤销连接ID帧意味着将不会再次使用该连接ID，同时请求对端通过新连接ID帧换一个新的连接ID。
如第9.5章所述，终端限制使用一个连接ID从一个单一本地地址向一个单一目标地址发送数据包。当使用连接ID的本地或目标地址不再活跃的时候，终端应该撤销这些连接ID。
在特定场合，终端可能需要停止接收先前发布的连接ID。 这种终端会导致对端通过发送带有值已增加的“撤销前”字段的新连接ID帧停用这些连接ID。 终端应该继续接收先前发布的连接ID直到它们被对端撤销。如果终端不能再处理指定的连接ID，其可以关闭连接。
一旦收到一个值增加的“撤销前”字段，对端必须停止使用相关连接ID，并在添加新提供的连接ID到活跃连接ID集合之前，通过撤销连接ID帧停用这些连接ID。 这么安排使得终端能够替换全部活跃连接ID，而不会出现对端没有可用连接ID的情况，也不会使活跃连接ID数超过对端传输参数active_connection_id_limit设下的限制，详见第18.2章。 无法停止使用连接ID可能导致连接错误，因为发布端可能不能在当前连接上继续使用这些连接ID。
如果撤销连接ID帧尚未被确认，那么终端应该限制本地已撤销连接ID的数量。 终端应该允许发送中及可追踪的撤销连接ID帧数量至少是传输参数active_connection_id_limit值的两倍。 终端必须不在没有撤销一个连接ID前忘记它，尽管其可以选择将仍然使用达到该限制而需要被撤销的连接ID的情况视为一个CONNECTION_ID_LIMIT_ERROR类型的连接错误。
在收到撤销由先前的“撤销前”字段指定的全部连接ID的撤销连接ID帧前，终端不应该发布更新“撤销前”字段。</description>
    </item>
    
    <item>
      <title>5.2 短包头</title>
      <link>/RFC8999_Chinese_Translation/QUIC_Packets/5.2_Short_Header/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC8999_Chinese_Translation/QUIC_Packets/5.2_Short_Header/</guid>
      <description>图3是QUIC短包头的格式。
短包头 { 包头格式 (1) = 0, 版本特定相关位 (7), 目标连接ID (..), 版本特定相关数据 (..), } 图3：QUIC短包头
 一个有着短包头的QUIC数据包其首字节的最高位设置为0。
短包头数据包紧随首字节之后是一个目标连接ID。短包头不会包含目标连接ID长度、源连接ID长度、源连接ID或版本字段。目标连接ID的长度不会编码在短包头数据包里，也不会受限于这个特性。
数据包接下来剩余字段有与版本特定相关的语义。</description>
    </item>
    
    <item>
      <title>5.2.1 客户端数据包处理</title>
      <link>/RFC9000_Chinese_Translation/Connections/Matching_Packets_to_Connections/5.2.1_Client_Packet_Handling/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9000_Chinese_Translation/Connections/Matching_Packets_to_Connections/5.2.1_Client_Packet_Handling/</guid>
      <description>发往客户端的有效数据包往往包含一个与客户端选择的值匹配的目标连接ID。 选择接收零长度连接ID的客户端可以使用本地地址和端口识别一个连接。 不能与已存在连接匹配的数据包——基于目标连接ID或目标连接ID为零长度时基于本地IP地址和端口——将被丢弃。
由于数据包乱序或丢失，客户端可能收到使用尚未算出的密钥加密的数据包。客户端可以丢弃这些包，也可以缓存起来以备后续数据包使其可以计算出密钥。
如果客户端收到一个包使用了与初始化阶段选择不同的QUIC版本，其必须丢弃该包。</description>
    </item>
    
    <item>
      <title>5.2.2 服务端数据包处理</title>
      <link>/RFC9000_Chinese_Translation/Connections/Matching_Packets_to_Connections/5.2.2_Server_Packet_Handling/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9000_Chinese_Translation/Connections/Matching_Packets_to_Connections/5.2.2_Server_Packet_Handling/</guid>
      <description>如果服务端收到一个来自不支持版本的数据包而其又足够初始化一个任何支持版本的新连接，服务端应该发送一个版本协商包，详见第6.1章。 服务端可以限制其回复的版本协商包的数量。 服务端必须丢弃属于不支持版本的小包。
一个不支持版本的第一个包可以对任何与具体版本有关的字段使用不同语义和编码。 尤其是不同的版本可能使用不同的数据包保护密钥。 不支持一个特定版本的服务端不太可能解密数据包的有效负载或正确解释其内容。 当数据报文足够长时，服务端应该回复一个版本协商包。
有一个支持版本或没有版本字段的数据包通过连接ID或——对于零长度连接ID的数据包——本地地址和端口与一个连接匹配，这些包在该连接上处理；否则，服务端继续做如下处理。
如果数据包是完全符合规范的初始化包，则服务端继续进行握手（第7章）。 服务端会指派为客户端选择的版本。
如果服务端拒绝接收一个新连接，它应该发送一个带连接关闭帧的初始化包给客户端，其中连接关闭帧的错误码设置为CONNECTION_REFUSED（连接拒绝）。
如果数据包是一个0-RTT包，服务端可以进行有限数量的缓存，因为后续预期会收到初始化包。 由于客户端不可能先于收到服务端回复发送握手包，所以服务端应该忽略任何这样的包。
服务端必须丢弃任何其他场合收到的数据包。</description>
    </item>
    
    <item>
      <title>5.2.3 关于简单负载均衡</title>
      <link>/RFC9000_Chinese_Translation/Connections/Matching_Packets_to_Connections/5.2.3_Considerations_for_Simple_Load_Balancers/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9000_Chinese_Translation/Connections/Matching_Packets_to_Connections/5.2.3_Considerations_for_Simple_Load_Balancers/</guid>
      <description>服务端部署可以仅仅使用源与目的IP地址和端口在服务器之间进行负载均衡。 改变客户端IP地址或端口可能导致数据包被转发到错误的服务器上。 这种服务端部署可以从如下方法中选择一个用于在客户端地址变换时维持连接。
 服务端可以使用带外机制，根据连接ID将数据包转发到正确的服务器； 如果服务器可以使用固定的IP地址或端口，且不同于客户端初始建联时访问的那个，它们可以使用传输参数preferred_address（推荐地址）请求客户端迁移到那个固定的地址上。 注意客户端可以选择不使用推荐地址。  服务端的一台服务器如果不支持在客户端改变地址时维持连接，其应该通过传输参数disable_active_migration（关闭活动迁移）告知对端当前不支持连接迁移。 在客户端预先拿到preferred_address参数后，传输参数disable_active_migration将不能阻止客户端进行连接迁移。
应用本简单形式负载均衡进行部署后，服务端必须避免创建无状态重置指示，详见第21.11章。</description>
    </item>
    
    <item>
      <title>5.3 连接ID</title>
      <link>/RFC8999_Chinese_Translation/QUIC_Packets/5.3_Connection_ID/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC8999_Chinese_Translation/QUIC_Packets/5.3_Connection_ID/</guid>
      <description>连接ID是一个任意长度的不透明字段（这里理解成这是一个二进制字段就行）。
连接ID的主要功能是确保底层协议（UDP、IP及更底层的协议栈）发生地址变更时不会导致一个QUIC连接的数据包被传输到错误的QUIC终端上。连接ID由终端及支持的中间设备用以确保每个数据包能够被调度到相应终端的正确实体上。对于终端而言，连接ID用于标识数据包对应的QUIC连接。
连接ID由每个终端根据版本特定的方式选择，而同一个QUIC连接的数据包可能使用不同的连接ID。</description>
    </item>
    
    <item>
      <title>5.3 连接操作</title>
      <link>/RFC9000_Chinese_Translation/Connections/5.3_Operations_on_Connections/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9000_Chinese_Translation/Connections/5.3_Operations_on_Connections/</guid>
      <description>本文没有定义QUIC的API，而是定义了一系列有关QUIC连接的函数，用于应用层协议进行依赖。 应用层协议可以假设一个QUIC的实现提供了一个包括本章所述操作的接口。 针对一个特定应用层协议而设计的实现可能只提供该协议用到的那些操作。
当实现用户端时，应用层协议可以：
 创建一个连接，开始进行第7章描述的交互过程； 如果支持，启用早期数据功能； 当早期数据被服务端接受或拒绝时，收到通知。  当实现服务端时，应用层协议可以：
 监听传入的连接，准备进行第7章描述的交互过程； 如果支持早期数据，在发送给客户端的TLS恢复ticket中嵌入应用层控制数据； 如果支持早期数据，从接收自客户端的恢复ticket中恢复应用层控制数据，并根据该信息接受或拒绝早期数据。  当同时实现客户端及服务端时，应用层协议可以：
 如传输参数（第7.4章）所述，为每种类型允许的流的配置最小的初始数量； 通过设置流级别及连接级别的流量控制限制，限制接收缓存区资源分配； 识别握手已经成功结束抑或仍在进行中； 保持连接不被默认关闭，即通过PING帧（第19.2章）或其他请求使得传输层在空闲超时（第10.1章）前发送额外的帧；以及 立即关闭连接（第10.2章）。  </description>
    </item>
    
    <item>
      <title>5.4 版本</title>
      <link>/RFC8999_Chinese_Translation/QUIC_Packets/5.4_Version/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC8999_Chinese_Translation/QUIC_Packets/5.4_Version/</guid>
      <description>版本字段包含一个4字节标识符。该值可供终端用以标识一个QUIC版本。一个值为0x00000000的版本字段保留给版本协商使用，详见第6章，而任何其余值均可能有效。
本文描述的属性适用于所有版本的QUIC。不符合本文所述属性的协议不是QUIC协议。后续文档可以给特定一个或一系列QUIC版本增加其他的属性。</description>
    </item>
    
    <item>
      <title>6.1 发送版本协商包</title>
      <link>/RFC9000_Chinese_Translation/Version_Negotiation/6.1_Sending_Version_Negotiation-Packets/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9000_Chinese_Translation/Version_Negotiation/6.1_Sending_Version_Negotiation-Packets/</guid>
      <description>如果客户端选择的版本服务端不接受，服务端会响应一个版本协商包，详见第17.2.1章。 版本协商包包含一个服务端支持的版本的列表。 终端必须不能给一个版本协商包回应一个版本协商包。
这个系统允许服务端处理不支持的数据包而不保持状态。 即使作为响应发出的初始包或版本协商包都可能丢失，客户端也会发新的包直到收到回复或放弃建连尝试。
服务端可以限制其发送版本协商包的数量。 例如，能识别0-RTT包的服务端可能会选择不发送版本协商包来响应0-RTT包，而是期望最终能收到初始包。</description>
    </item>
    
    <item>
      <title>6.2 处理版本协商包</title>
      <link>/RFC9000_Chinese_Translation/Version_Negotiation/6.2_Handling_Version_Negotiation_Packets/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9000_Chinese_Translation/Version_Negotiation/6.2_Handling_Version_Negotiation_Packets/</guid>
      <description>设计版本协商包的目的是为了让QUIC能够给未来定义的功能协商QUIC版本用于连接。 未来标准追踪规范可能改变支持多版本QUIC对于收到的用于回复给试图使用这个版本建立连接的版本协商包进行应对的实现方式。
仅仅支持这个版本的客户端如果收到一个版本协商包，其必须放弃当前建联尝试，除非是下述两种例外： 如果已经收到且成功处理任何其他类型的包，客户端必须忽略任何版本协商包； 客户端必须忽略包含其选择的QUIC版本的版本协商包。
如何执行版本协商留作由未来标准追踪规范定义的未来工作。 特别是，未来工作将确保在抵御版本降级攻击时具有健壮性，详见第21.12章。</description>
    </item>
    
    <item>
      <title>6.3 使用保留版本</title>
      <link>/RFC9000_Chinese_Translation/Version_Negotiation/6.3_Using_Reserved_Versions/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9000_Chinese_Translation/Version_Negotiation/6.3_Using_Reserved_Versions/</guid>
      <description>对于将来使用新版本QUIC的服务端，客户端需要正确处理不支持的版本。 一些版本号（如0x?a?a?a?a，见第15章）保留作包含版本号的字段。
终端可以添加保留版本到任意未知或不支持版本中会被忽略的字段，用以测试对端是否正确地忽略了该值。 例如，终端可以发版本协商包中包含一个保留版本，详见第17.2.1章)。 终端可以发送一个保留版本的数据包来测试对端是否会正确丢弃该包。</description>
    </item>
    
    <item>
      <title>8.1. 标准参考文献</title>
      <link>/RFC8999_Chinese_Translation/References/8.1_Normative_References/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC8999_Chinese_Translation/References/8.1_Normative_References/</guid>
      <description>[RFC2119] Bradner, S. 《RFC文档中用于指出要求级别的关键字（Key words for use in RFCs to Indicate Requirement Levels）》, BCP 14, RFC 2119, DOI 10.17487/RFC2119, March 1997, https://www.rfc-editor.org/info/rfc2119.
  [RFC8174] Leiba, B. 《RFC2119中关键字大写与小写的歧义（Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words）》, BCP 14, RFC 8174, DOI 10.17487/RFC8174, May 2017, https://www.rfc-editor.org/info/rfc8174.</description>
    </item>
    
    <item>
      <title>8.2. 非标准参考文献</title>
      <link>/RFC8999_Chinese_Translation/References/8.2_Informative_References/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC8999_Chinese_Translation/References/8.2_Informative_References/</guid>
      <description>[QUIC TLS] Thomson, M., Ed. and S. Turner, Ed. 《使用TLS加密QUIC（Using TLS to Secure QUIC）》, RFC 9001, DOI 10.17487/RFC9001, May 2021, https://www.rfc-editor.org/info/rfc9001.
  [QUIC传输协议] Iyengar, J., Ed. and M. Thomson, Ed. 《QUIC：一种基于UDP的多路复用安全传输协议（QUIC: A UDP-Based Multiplexed and Secure Transport）》, RFC 9000, DOI 10.17487/RFC9000, May 2021, https://www.rfc-editor.org/info/rfc9000.
  [RFC5116] McGrew, D. 《一种用于认证加密的接口及算法（An Interface and Algorithms for Authenticated Encryption）》, RFC 5116, DOI 10.17487/RFC5116, January 2008, https://www.rfc-editor.org/info/rfc5116.</description>
    </item>
    
    <item>
      <title>18.1 保留传输参数</title>
      <link>/RFC9000_Chinese_Translation/Transport_Parameter_Encoding/18.1_Reserved_Transport_Parameters/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9000_Chinese_Translation/Transport_Parameter_Encoding/18.1_Reserved_Transport_Parameters/</guid>
      <description>标识符为31 * N + 27——其中N为整数——的传输参数保留用于执行未知传输参数。 这些传输参数没有语义，可以携带任意值。</description>
    </item>
    
    <item>
      <title>18.2 传输参数定义</title>
      <link>/RFC9000_Chinese_Translation/Transport_Parameter_Encoding/18.2_Transport_Parameter_Definitions/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9000_Chinese_Translation/Transport_Parameter_Encoding/18.2_Transport_Parameter_Definitions/</guid>
      <description>本章描述本文定义的传输参数的细节。
这里列出的许多传输参数都是整型值。 那些整型的传输参数使用变长整数编码，详见第16章。 除非有额外说明，否则传输参数在不设置时的默认值是0。
各个传输参数具体定义如下：
 原始目标连接IDoriginal_destination_connection_id (0x00)：  这个参数是由客户端发出的第一个初始包的目标连接ID字段的值，详见第16章。 该传输参数只会由服务端发出。
 最大空闲超时时间max_idle_timeout (0x01)：  最大空闲超时是一个编码为整型的值，单位毫秒，详见第10.1章。 当双端忽略空闲超时设置其值为0时，空闲超时将被禁用。
 无状态重置令牌stateless_reset_token (0x02)：  无状态重置令牌用于验证无状态重置，详见第10.3章。 这个传输参数是一个16字节的序列。 客户端必须不能发送这个参数，但是服务端可以发送。 没有发送次参数的服务端不能对握手期间协商的连接ID使用无状态重置。
 最大UDP载荷max_udp_payload_size (0x03)：  最大UDP载荷参数是一个整型值，用于终端限制愿意接收的UDP载荷的大小。 UDP报文的载荷如果大于这个限制将不太可能被服务端处理。
  该参数默认值是最大UDP载荷65527。 该值不能小于1200。
  这个限制是对报文大小的一个与通道MTU一样的附加约束，但其是终端的属性而非通道的属性，详见第14章。 应该认为这是终端用于保存传人数据包的空间。
 初始最大数据量initial_max_data (0x04)：  初始最大数据量参数是一个包含连接可发送初始最大数据量的整型值。 等效于连接在完成握手后立即发送一个最大数据帧（MAX_DATA，详见第19.9章）。
 初始本地最大双向流数据量initial_max_stream_data_bidi_local (0x05)：  本参数是一个整型值，用于指定本地初始化的双向流的初始流量控制限制。 这个限制适用于由发送传输参数端打开的新创建双向流。 在客户端传输参数中，其适用于流标识符最低两个有效位设置为0x00的流；在服务端，其适用于流标识符最低两个有效位设置为0x01的流。
 初始远端最大双向流数据量initial_max_stream_data_bidi_remote (0x06):  本参数是一个整型值，用于指定对端初始化的双向流的初始流量控制限制。 这个限制适用于由接收传输参数端打开的新创建双向流。 在客户端传输参数中，其适用于流标识符最低两个有效位设置为0x01的流；在服务端，其适用于流标识符最低两个有效位设置为0x00的流。
 初始最大单向流数据量initial_max_stream_data_uni (0x07):  本参数是一个整型值，用于指定单向流的初始流量控制限制。 这个限制适用于接收传输参数端打开的新创建单向流。 在客户端传输参数中，其适用于流标识符最低两个有效位设置为0x03的流；在服务端，其适用于流标识符最低两个有效位设置为0x02的流。
 初始最大双向流数量initial_max_streams_bidi (0x08):  初始最大双向流数量参数是一个整型值，包含接收该传输参数的终端允许初始化的最大双向流数量。 如果这个参数未设置或置为0，则对端不能开启双向流直到发完最大流帧。 设置该参数等效于发送一个相关流类型的数值一致的最大流帧（第19.</description>
    </item>
    
    <item>
      <title>19.1 填充帧</title>
      <link>/RFC9000_Chinese_Translation/Frame_Types_and_Formats/19.1_PADDING_Frames/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9000_Chinese_Translation/Frame_Types_and_Formats/19.1_PADDING_Frames/</guid>
      <description>填充帧（PADDING frame，类型0x00）无语义值。 填充帧可以用于提高数据包大小。 填充可以用于填充初始包以达到被要求的最小包大小，或对受保护数据包进行流量分析提供保护。
填充帧的格式如图23所示，可见填充帧没有内容。 也就是说，填充帧由标识该帧类型的单个字节构成。
填充帧 { 类型 (i) = 0x00, } 图23：填充帧格式
 </description>
    </item>
    
    <item>
      <title>19.2 Ping帧</title>
      <link>/RFC9000_Chinese_Translation/Frame_Types_and_Formats/19.2_PING_Frames/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9000_Chinese_Translation/Frame_Types_and_Formats/19.2_PING_Frames/</guid>
      <description>终端可以使用Ping帧（类型为0x01）验证其对端是否仍然活跃，或检查到对端的可达性。
Ping帧格式如图24所示，可见Ping帧无内容。
填充帧 { 类型 (i) = 0x01, } 图24：Ping帧格式
 </description>
    </item>
    
    <item>
      <title>19.3.2 ECN计数</title>
      <link>/RFC9000_Chinese_Translation/Frame_Types_and_Formats/ACK_Frames/19.3.2_ECN_Counts/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9000_Chinese_Translation/Frame_Types_and_Formats/ACK_Frames/19.3.2_ECN_Counts/</guid>
      <description>ACK帧使用类型值的最小有效位（也就是类型0x03）表示ECN反馈，并通告收到在IP头部中带有与ECT(0)、ECT(1)或ECN-CE有关的ECN码点（codepoint）的QUIC数据包。 ECN计数只由类型为0x03的ACK帧携带。
ACK帧中ECN计数如图27所示。
ECN计数 { ECT0计数 (i), ECT1计数 (i), ECN-CE计数 (i), } 图27：ACK帧格式
 ECN计数各个字段分别是：
 ECT0计数：  一个可变长度整型值，表示收到的ACK帧所在数据包号空间里且携带ECT(0)码点的数据包总数。
 ECT1计数：  一个可变长度整型值，表示收到的ACK帧所在数据包号空间里且携带ECT(1)码点的数据包总数。
 ECN-CE计数：  一个可变长度整型值，表示收到的ACK帧所在数据包号空间里且携带ECN-CE码点的数据包总数。
  每个数据包号空间单独维护各自的ECN计数。</description>
    </item>
    
    <item>
      <title>19.3.1 ACK块</title>
      <link>/RFC9000_Chinese_Translation/Frame_Types_and_Formats/ACK_Frames/19.3.1_ACK_Ranges/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9000_Chinese_Translation/Frame_Types_and_Formats/ACK_Frames/19.3.1_ACK_Ranges/</guid>
      <description>每个ACK块由交替的空档和ACK块长度值构成，按包号降序排列。 ACK块可以重复。 空档和ACK块长度值的数量由ACK块计数字段决定，每个ACK块中的一个值（空档或ACK块长度）对应ACK块计数字段的每个值。
ACK块的结构如图26所示。
构成ACK块的字段是：
 空档（Gap）：  一个可变长度整型值，表示比前述ACK块中的最小数据包号小一的数据包之前连续未被确认数据包的数目。
 ACK块长度（ACK Range Length）：  一个可变长度整型值，表示先前空档确定的最大数据包号之前连续被确认数据包的数目。
  空档和ACK块长度值使用一个相对整型编码以提高效率。 即使每个编码结果是正值，但也会被减去，因此每个ACK块表示的都是包号逐渐递减的数据包。
每个ACK块确认一段包号连续的数据包，通过ACK块内包号最大的被确认数据包之前的包数指定确认范围。 值为0表示只有包号最大的数据包被确认。 更大的ACK块值表示更大的确认范围，与此同时该块内最小数据包号则更小。 换言之，给定ACK块最大数据包号，则最小数据包号通过下述公式计算：
最小数据包号 = 最大数据包号 - ACK块值 一个ACK块确认最小数据包号到最大数据包号之间的全部数据包，包含两端。
一个ACK块的最大数据包号通过累积减去先前的所有ACK块长度和空档确定。
每个空档表示一段未被确认的数据包。 空档内未被确认的数据包数目比空档字段中的编码值多1。
空档字段值使用以下公式为后续ACK块生成最大的数据包号值：
最大数据包号 = 先前最小数据包号 - 空档值 - 2 如果任何有关计算得到的数据包号是负数，则终端必须产生一个FRAME_ENCODING_ERROR类型的连接错误。</description>
    </item>
    
    <item>
      <title>19.4 重置帧</title>
      <link>/RFC9000_Chinese_Translation/Frame_Types_and_Formats/19.4_RESET_STREAM_Frames/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9000_Chinese_Translation/Frame_Types_and_Formats/19.4_RESET_STREAM_Frames/</guid>
      <description>终端使用重置帧（RESET_STREAM frame，类型为0x04）立即关闭流的发送部分。
发送完重置帧后，终端停止在相应的流上传输或重传流帧。 重置帧的接收方可以忽略任何已经在该流上收到的数据。
终端收到一条只用于发送的流的重置帧时必须以STREAM_STATE_ERROR类型错误关闭连接。
重置帧格式如图28所示。
重置帧 { 类型 (i) = 0x04, 流ID (i), 应用层协议错误码 (i), 最终大小 (i), } 图28：重置帧格式
 重置帧包含下述字段：
 流ID：  一个可变长度整型，编码需要关闭的流的流ID。
 应用层协议错误码（Application Protocol Error Code）：  一个可变长度整型值，包含表明为何关闭该流的应用层协议错误码（详见第20.2章）。
 最终大小（Final Size）：  一个可变长度整型值，表示重置帧发送方的流最终大小，单位字节，详见第4.5章。
  </description>
    </item>
    
    <item>
      <title>19.5 停止发送帧</title>
      <link>/RFC9000_Chinese_Translation/Frame_Types_and_Formats/19.5_STOP_SENDING_Frames/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9000_Chinese_Translation/Frame_Types_and_Formats/19.5_STOP_SENDING_Frames/</guid>
      <description>终端使用停止发送帧（STOP_SENDING frame，类型是0x05）告知对方收到每个应用层请求时传入的数据将被丢弃。 停止发送帧要求对端停止在某条流上传输数据。
一个停止发送帧可以在流的“接收”和“数据量确认”状态发送，详见第3.2章。 收到一条本地由初始化但是却尚未被创建的流的停止发送帧必须视为一个STREAM_STATE_ERROR类型的连接错误。 终端收到只用于接收的流的停止发送帧{&amp;lt; req_level MUST &amp;gt;}}以STREAM_STATE_ERROR类型的错误关闭连接。
停止发送帧格式如图29所示。
停止发送帧 { 类型 (i) = 0x05, 流ID (i), 应用层协议错误码 (i), } 图29：停止发送帧格式
 停止发送帧包含如下字段：
 流ID：  一个可变长度整型值，携带需要忽略其数据的流的流ID。
 应用层协议错误码（Application Protocol Error Code）：  一个可变长度整型值，包含应用层指定的发送者忽略该流数据的原因，详见第20.2章。
  </description>
    </item>
    
    <item>
      <title>19.6 加密帧</title>
      <link>/RFC9000_Chinese_Translation/Frame_Types_and_Formats/19.6_CRYPTO_Frames/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9000_Chinese_Translation/Frame_Types_and_Formats/19.6_CRYPTO_Frames/</guid>
      <description>加密帧（CRYPTO frame，类型是0x06）用于传输加密握手信息。 其可以被除0-RTT包以外的其他类型包发送。 加密帧为加密协议提供了一个有序的字节流。 加密帧除了不携带流标识符（流ID）、不进行流控，以及不携带可选偏移量、可选长度及流结束标记外，它们在功能上与流帧完全相同。
加密帧格式如图30所示。
加密帧 { 类型 (i) = 0x06, 偏移 (i), 长度 (i), 加密数据 (i), } 图30：加密帧格式
 加密帧包含下述字段：
 偏移（Offset）：  一个可变长度整型值，表示加密帧中加密数据在数据流中的字节偏移量。
 长度：  一个可变长度整型值，表示加密帧的加密数据字段携带数据长度。
 加密数据（Crypto Data）：  加密信息数据。
  每个加密级别都有一条单独的加密握手数据流，每条流都从偏移量0开始。 也就是说每个加密级别都被视为一条单独的加密数据流。
这样的数据流其最大偏移量——偏移量与数据长度之和——不能超过226-1。 收到一个超过此上限的的帧必须视为一个FRAME_ENCODING_ERROR类型或CRYPTO_BUFFER_EXCEEDED类型的连接错误。
不同于流帧有着流ID用以区分数据属于哪条流，加密帧为每个加密级别携带单条流的数据。 数据流没有一个明确的结束点，所以加密帧没有FIN位。</description>
    </item>
    
    <item>
      <title>19.7 新令牌帧</title>
      <link>/RFC9000_Chinese_Translation/Frame_Types_and_Formats/19.7_NEW_TOKEN_Frames/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9000_Chinese_Translation/Frame_Types_and_Formats/19.7_NEW_TOKEN_Frames/</guid>
      <description>服务端发送新令牌帧（NEW_TOKEN frame，类型是0x07）给客户端提供一张令牌，以便客户端在一条后续流的初始包包头中携带该令牌发送过来。
新令牌帧格式如图31所示。
新令牌帧 { 类型 (i) = 0x07, 令牌长度 (i), 令牌 (i), } 图30：新令牌帧格式
 新令牌帧包含如下字段：
 令牌长度（Token Length）：  一个可变长度整型值，表示令牌的字节长度。
 令牌：  一个不透明blob，客户端可以在后续的初始包中使用。 令牌必须不为空。 客户端必须将收到带空令牌字段的新令牌帧的情况视为一个FRAME_ENCODING_ERROR类型的连接错误。
  如果包含这类帧的数据包被误认为丢失了，那么客户端可能收到多个携带相同令牌值的新令牌帧。 客户端负责丢弃重复的令牌，这些令牌可能用于连接重试，详见第8.1.3章。
客户端必须不能发送新令牌帧。 服务端必须将收到新令牌帧视为一个PROTOCOL_VIOLATION类型连接错误。</description>
    </item>
    
    <item>
      <title>19.8 流帧</title>
      <link>/RFC9000_Chinese_Translation/Frame_Types_and_Formats/19.8_STREAM_Frames/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9000_Chinese_Translation/Frame_Types_and_Formats/19.8_STREAM_Frames/</guid>
      <description>流帧明确地创建一条流并携带流数据。 流帧的类型字段格式形如0b00001XXX（即从0x08到0x0f之间的值）。 帧类型的三个低比特位标示帧的如下字段：
 帧类型中的OFF位（0x04）用于标识帧的偏移字段。 当置为1，则表示偏移字段存在。 当置为0，则偏移字段不存在，且流数据的偏移量从0另开（也就是说，该帧携带这条流的起始字节，或该流的终点且不携带任何数据）。 帧类型的LEN位（0x02）用于标识帧的长度字段。 当置为1，则表示长度字段不存在，且流数据字段延续到数据包的末尾。 当置为1，则表示长度字段存在。 帧类型的FIN位（0x01）标志流的结束。 流的最终数据量等于偏移量与该帧的长度之和。  如果收到属于一条由本地初始化却尚未创建的流或一条只用于发送的流的流帧，则终端必须以STREAM_STATE_ERROR类型错误关闭连接。
流帧格式如图32所示。
流帧 { 类型 (i) = 0x08..0x0f, 流ID (i), [偏移 (i)], [长度 (i)], 流数据 (..), } 图32：流帧格式
 流帧包含如下字段：
 流ID：  一个可变长度整型值，表示流的流ID，详见第2.1章。
 偏移（Offset）：  一个可变长度整型值，表示流帧中的流数据在整条流中的字节偏移量。 这个字段在OFF位置为1时存在。 当偏移字段不存在时，偏移量为0。
 长度：  一个可变长度整型值，表示流帧中的流数据字段的长度。 该字段在LEN位置为1时存在。 当LEN位置为0，则流数据字段会囊括数据包的所有剩余字节。
 流数据（Stream Data）：  指定流中需要传递的字节。
  当流数据字段长度为0，流帧的偏移量就是下一个将要发送的字节的偏移量。
流的首字节的偏移量是0。 流传输的最大偏移量——帧的偏移值与数据长度之和——不能超过262-1，因为无法为这样的数据量分配流量控制额度。 收到一个超过该限制的帧的情况必须视为一个FRAME_ENCODING_ERROR类型或FLOW_CONTROL_ERROR类型的连接错误。</description>
    </item>
    
    <item>
      <title>19.9 最大数据量帧</title>
      <link>/RFC9000_Chinese_Translation/Frame_Types_and_Formats/19.9_MAX_DATA_Frames/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9000_Chinese_Translation/Frame_Types_and_Formats/19.9_MAX_DATA_Frames/</guid>
      <description>最大数据量帧（MAX_DATA frame，类型是0x10）用于流量控制，告知对端可以在整个连接上发送的最大数据量。
最大数据量帧格式如图33所示。
最大数据量帧 { 类型 (i) = 0x10, 最大数据量 (i), } 图32：最大数据量帧格式
 最大数据量帧包含下述字段：
 最大数据量（Maximum Data）：  一个可变长度整型值，表示可以在整个连接上发送的最大数据量，单位字节。
  流帧上发送的所有数据的总和趋近该限制。 所有流的最终数据量之和——包括处于关闭状态的流——必须不可超过接收方指定的这个值。 如果终端收到的数据量超过了它发出的最大数据量值，其必须以FLOW_CONTROL_ERROR类型错误关闭流。 这包括违背早期数据记录的限制，详见第7.4.1章。</description>
    </item>
    
    <item>
      <title>19.10 最大流数据量帧</title>
      <link>/RFC9000_Chinese_Translation/Frame_Types_and_Formats/19.10_MAX_STREAM_DATA_Frames/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9000_Chinese_Translation/Frame_Types_and_Formats/19.10_MAX_STREAM_DATA_Frames/</guid>
      <description>最大流数据量帧（MAX_STREAM_DATA frame，类型是0x11）用于流量控制中通知对端一条流上可以发送的最大数据量。
最大流数据量帧可以在流的“接收”状态发送，详见第3.2章。 收到一条由本地初始化却尚未创建的流的最大流数据量帧的情况必须视为一个STREAM_STATE_ERROR类型连接错误。 收到只用于发送的流的最大流数据量帧的终端必须以STREAM_STATE_ERROR类型错误关闭连接。
最大流数据量帧格式如图34所示。
最大流数据量帧 { 类型 (i) = 0x11, 流ID (i), 最大流数据量 (i), } 图34：最大流数据量帧格式
 最大流数据量帧包含如下字段：
 流ID：  被作用的流的流ID，以可变长度整数值编码。
 最大流数据量（Maximum Stream Data）：  一个可变长度整型值，表示可以在标识流上发送的最大数据量，单位字节。
  当累计数据量趋近该限制，终端统计在流上发送或接收的数据的最大接收偏移量。 丢失或乱序可能意味着一条流的最大接收数据偏移量可能会大于该流上收到的总数据量。 收到流帧可能不会提升最大接收偏移量。 流上发送的数据必须不可以超过接收方发出的最大流数据量值的最大值。 如果终端收到比其给相关流发出的最大流数据量的最大值更多的数据量，终端必须以FLOW_CONTROL_ERROR类型错误关闭连接。 这包括违背早期数据记录的限制，详见第7.4.1章。</description>
    </item>
    
    <item>
      <title>19.11 最大流帧</title>
      <link>/RFC9000_Chinese_Translation/Frame_Types_and_Formats/19.11_MAX_STREAMS_Frames/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9000_Chinese_Translation/Frame_Types_and_Formats/19.11_MAX_STREAMS_Frames/</guid>
      <description>最大流帧（MAX_STREAMS frame，类型是0x12或0x13）用于告知对端允许打开给定类型的流的累积数量。 类型0x12的最大流帧用于双向流，类型0x13的则用于单向流。
最大流帧格式如图35所示。
最大流帧 { 类型 (i) = 0x12..0x13, 最大流数 (i), } 图35：最大流帧格式
 最大流帧包含下述字段：
 最大流数：  在连接的生命周期内可以打开的相应类型流的累积总数。 该值不能超过260，因为不能编码大于260-1的流ID。 收到允许开启高于该限制数量流的最大流帧的情况必须视为一个FRAME_ENCODING_ERROR类型的连接错误。
  丢失或乱序可能导致终端收到一个最大流帧，其限制低于之前收到的最大流帧。 必须忽略不能提高流数量限制的最大流帧。
终端必须不打开超过其对端设置的当前流限制所允许的更多的流。 例如，服务端收到限制单向流数量为3，则其可以打开流3、7和11，但是不能打开流15。 如果对端打开超过其被允许的流，那么终端必须以STREAM_LIMIT_ERROR类型错误关闭连接。 这包括违背早期数据记录的限制，详见第7.4.1章。
注意这些帧（以及有关传输参数）并未描述可以并发打开的流的数量。 该限制包括已经关闭的流和打开的流。</description>
    </item>
    
    <item>
      <title>19.12 数据阻塞帧</title>
      <link>/RFC9000_Chinese_Translation/Frame_Types_and_Formats/19.12_DATA_BLOCKED_Frames/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9000_Chinese_Translation/Frame_Types_and_Formats/19.12_DATA_BLOCKED_Frames/</guid>
      <description>发送方应该在其希望发送数据却因连接级流量控制而无法发送时，发送数据阻塞帧（DATA_BLOCKED frame，类型是0x14），详见第4章。 数据阻塞帧可以用于流量控制算法的调控输入。
数据阻塞帧格式如图36所示。
数据阻塞帧 { 类型 (i) = 0x14, 最大数据量 (i), } 图36：数据阻塞帧格式
 数据阻塞帧包含下述字段：
 最大数据量：  一个可变长度整型值，表示连接阻塞时的连接级限制。
  </description>
    </item>
    
    <item>
      <title>19.13 流数据阻塞帧</title>
      <link>/RFC9000_Chinese_Translation/Frame_Types_and_Formats/19.13_STREAM_DATA_BLOCKED_Frames/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9000_Chinese_Translation/Frame_Types_and_Formats/19.13_STREAM_DATA_BLOCKED_Frames/</guid>
      <description>发送方应该在其希望发送数据却因流级流量控制而无法发送时，发送流数据阻塞帧（STREAM_DATA_BLOCKED frame，类型是0x15）。 该传输参数类似于数据阻塞帧，详见第19.12章。
收到一条只用于发送的流的流数据阻塞帧时，终端必须以STREAM_STATE_ERROR类型错误关闭连接。
流数据阻塞帧格式如图37所示。
流数据阻塞帧 { 类型 (i) = 0x15, 最大流数据量 (i), } 图37：流数据阻塞帧格式
 流数据阻塞帧包含如下字段：
 流ID：  一个可变长度整型值，表示被流量控制阻塞的流。
 最大流数据量：  一个可变长度整型值，表示阻塞发生时流的偏移量。
  </description>
    </item>
    
    <item>
      <title>19.14 流阻塞帧</title>
      <link>/RFC9000_Chinese_Translation/Frame_Types_and_Formats/19.14_STREAMS_BLOCKED_Frames/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9000_Chinese_Translation/Frame_Types_and_Formats/19.14_STREAMS_BLOCKED_Frames/</guid>
      <description>发送方应该在其希望打开一条流但是被对端设置的最大流上限（详见第19.11章）所限制时，发送流阻塞帧（STREAM_BLOCKED frame，类型是0x16或0x17）。 类型为0x16的流阻塞帧用于表示双向流达到上限，而类型0x17则表示单向流达到上限。
流阻塞帧不会打开流，而是告知对端需要打开一条流，但是当前的流数上限阻止了这条流的创建。
流阻塞帧格式如图38所示。
流阻塞帧 { 类型 (i) = 0x16..0x17, 最大流数 (i), } 图38：流阻塞帧格式
 流阻塞帧包含如下字段：
 最大流数：  一个可变长度整型值，表示该帧发送时允许创建的最大流数量。 该值不能超过260，因为不能编码超过262-1的流ID。 收到编码值超过这个限制的流阻塞帧的情况必须被视为一个STREAM_LIMIT_ERROR或FRAME_ENCODING_ERROR类型的连接错误。
  </description>
    </item>
    
    <item>
      <title>19.15 新连接ID帧</title>
      <link>/RFC9000_Chinese_Translation/Frame_Types_and_Formats/19.15_NEW_CONNECTION_ID_Frames/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9000_Chinese_Translation/Frame_Types_and_Formats/19.15_NEW_CONNECTION_ID_Frames/</guid>
      <description>终端发送新连接ID帧（NEW_CONNECTION_ID frame，类型为0x18）给对端提供可选连接ID，其可以用于连接迁移时中断连接性，详见第9.5章。
新连接ID帧格式如图39所示。
新连接ID帧 { 类型 (i) = 0x18, 序列号 (i), 停用前 (i), 长度 (i), 连接ID (8..160), 无状态重置令牌 (128), } 图39：新连接ID帧格式
 新连接ID帧包含如下字段：
 序列号：  序列号由发送方分配给连接ID，编码为可变长度整型值，详见第15.11章。
 停用前（Retire Prior To）：  一个可变长度整型值，表示被停用的连接ID（们），详见第5.1.2章。
 长度（Length）：  一个8位无符号整型值，包含连接ID的长度。 小于1或大于20的长度值均是无效的，且必须视其为一个FRAME_ENCODING_ERROR类型连接错误。
 连接ID：  一个指定长度的连接ID。
 无状态重置令牌（Stateless Reset Token）：  一个128位值，在对关联的连接ID进行无状态重置时使用，详见第10.3章。
  如果它现在需要对端使用0长度的目标连接ID发送包，终端禁止发送这个帧。
如果终端当前需要对端使用0长度的目标连接ID，那么其必须不能发送该帧。 将连接ID长度改为0长度或从0长度改为非0长度都会使得难以辨别连接ID值何时发生了改变。 终端发送0长度目标连接ID的数据包时，必须将收到新连接ID帧的情况视为一个PROTOCOL_VIOLATION类型连接错误。
传输错误、超时和重传可能导致相同的新连接ID帧被重复接收。 重复接收相同的该类帧的情况必须不能被当作连接错误处理。 接收方可以根据新连接ID帧提供的序列号处理重复收到相同新连接ID帧的情况。
如果终端收到一个新连接ID帧重复了之前发布的连接ID，却有着不同的无状态重置令牌或不同的序列号字段值或该序列号用于其他不同的连接ID，终端可以将之视为一个PROTOCOL_VIOLATION类型连接错误。
“停用前”字段适用于在连接设置期间创建的连接ID以及preferred_address传输参数，详见第5.1.2章。 “停用前”字段值必须小于或等于“序列号”字段值。 收到“停用前”字段值大于序列号字段值必须视为一个FRAME_ENCODING_ERROR类型连接错误。
一旦发生方指定了一个“停用前”字段值，在后续新连接ID帧中发送的较小值就不再发挥作用了。 接收方必须忽略任何没有提高最大“停用前”值的“停用前”字段。
收到序列号小于已收到新连接ID帧的“停用前”字段值的新连接ID帧的终端必须发送一个相应的停用新收到连接ID的停用连接ID帧，除非其已经对该序列号发过这个帧了。</description>
    </item>
    
    <item>
      <title>19.16 停用连接ID帧</title>
      <link>/RFC9000_Chinese_Translation/Frame_Types_and_Formats/19.16_RETIRE_CONNECTION_ID_Frames/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9000_Chinese_Translation/Frame_Types_and_Formats/19.16_RETIRE_CONNECTION_ID_Frames/</guid>
      <description>终端发送停用连接ID帧（RETIRE_CONNECTION_ID frame，类型是0x19）来表明其将不再使用对端发布的某个连接ID。 这包含握手期间提供的连接ID。 发送一个停用连接ID帧也作为一个请求令对端发送额外的连接ID以备后续使用，详见第5.1章。 新连接ID可以通过新连接ID帧发往对端。
停用一个连接ID会令该连接ID关联的无状态重置令牌失效。
停用连接ID帧格式如图40所示。
停用连接ID帧 { 类型 (i) = 0x19, 序列号 (i), } 图40：停用连接ID帧格式
 停用连接ID帧包含如下字段：
 序列号：  被停用的连接ID的序列号，详见第5.1.2章。
  收到包含大于任何先前发往对端的序列号的停用连接ID帧的情况必须视为一个PROTOCOL_VIOLATION类型连接错误。
停用连接ID帧指定的序列号必须不能指向包含该帧的数据包的目标连接ID。 对端可以将这种情况视为一个PROTOCOL_VIOLATION类型连接错误。
如果对端提供过一个零长度连接ID，终端不能发生这类帧。 提供零长度连接ID的终端必须将收到停用连接ID帧视为一个PROTOCOL_VIOLATION类型连接错误。</description>
    </item>
    
    <item>
      <title>19.17 通道挑战帧</title>
      <link>/RFC9000_Chinese_Translation/Frame_Types_and_Formats/19.17_PATH_CHALLENGE_Frames/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9000_Chinese_Translation/Frame_Types_and_Formats/19.17_PATH_CHALLENGE_Frames/</guid>
      <description>终端可以使用通道挑战帧（PATH_CHALLENGE frame，类型是0x1a）检查到对端的可达性以及进行连接迁移过程中的通道验证。
通道挑战帧格式如图41所示。
停用连接ID帧 { 类型 (i) = 0x1a, 数据 (64), } 图40：停用连接ID帧格式
 通道挑战帧包含如下字段：
 数据：  8字节字段包含一段任意数据。
  包含64位任意数据的通道挑战帧确保接收数据包比猜测值的正确性更简单。
接收方收到该帧后必须生成一个包含同样数据字段内容的回复通道帧（详见第19.18章）。</description>
    </item>
    
    <item>
      <title>19.18 回复通道帧</title>
      <link>/RFC9000_Chinese_Translation/Frame_Types_and_Formats/19.18_PATH_RESPONSE_Frames/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9000_Chinese_Translation/Frame_Types_and_Formats/19.18_PATH_RESPONSE_Frames/</guid>
      <description>回复通道帧（PATH_RESPONSE frame，类型为0x1b）作为通道挑战帧的响应发送。 其格式与通道挑战帧（详见第19.17章）相同。
如果回复通道帧的内容与先前发送的通道挑战帧内容不匹配，终端可以生成一个PROTOCOL_VIOLATION类型连接错误。</description>
    </item>
    
    <item>
      <title>19.19 连接关闭帧</title>
      <link>/RFC9000_Chinese_Translation/Frame_Types_and_Formats/19.19_CONNECTION_CLOSE_Frames/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9000_Chinese_Translation/Frame_Types_and_Formats/19.19_CONNECTION_CLOSE_Frames/</guid>
      <description></description>
    </item>
    
    <item>
      <title>19.20 握手完成帧</title>
      <link>/RFC9000_Chinese_Translation/Frame_Types_and_Formats/19.20_HANDSHAKE_DONE_Frames/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9000_Chinese_Translation/Frame_Types_and_Formats/19.20_HANDSHAKE_DONE_Frames/</guid>
      <description></description>
    </item>
    
    <item>
      <title>19.21 扩展帧</title>
      <link>/RFC9000_Chinese_Translation/Frame_Types_and_Formats/19.21_Extension_Frames/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9000_Chinese_Translation/Frame_Types_and_Formats/19.21_Extension_Frames/</guid>
      <description></description>
    </item>
    
    <item>
      <title></title>
      <link>/RFC9000_Chinese_Translation/README/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9000_Chinese_Translation/README/</guid>
      <description>RFC9000及相关QUIC文档翻译 本站点用来翻译RFC9000等一系列QUIC相关文档。
搭建运行环境 本站点基于hugo。下面介绍如何运行本站开发环境：
如何运行安装及运行hugo Linux下可以直接apt install hugo安装环境，mac下可以用brew命令安装，windows下则需要去hugo站点下载hugo.exe执行文件并添加到环境变量里， 使得在命令行下执行hugo --help不会提示说找不到执行文件。
更多请移步Hugo文档。
关于本人 大家好，我是文档译者秋航。QUIC是一个新兴网络传输协议，涉及网络4-7层，性能优异，影响重大。
本人水平有限，译文尚未完成，多有疏漏，还请各位多多指教！欢迎大家积极参与翻译与勘误，多多提交合并请求，感谢感谢！
翻译说明 在翻译的过程中，深刻体会到英语与汉语语法思维上的差别，其也体现在行文的方方面面。以下记录翻译QUIC系列文档时应该做的处理：
1. 方括号引用参考文献 形如：
The integration of TLS and QUIC is described in more detail in [[QUIC-TLS](#QUIC-TLS)]. [QUIC-TLS]是句子里实际提到的参考文献，这个结构本身参与语法构建，按照中文的习惯一般使用书名号《》将这种引用括起来。因此其应该翻译为：
《[QUIC TLS](#QUIC-TLS)》 但是下述这种：
QUIC integrates the TLS handshake [[TLS13](#TLS13)]. [TLS13]并不是语句的一部分，更类似于书本中的上标或下标引用。本站将其统一用html的上标引用之：
TLS握手&amp;lt;sup&amp;gt;[TLS 1.3](#TLS13)&amp;lt;/sup&amp;gt; 2. 图或表格 为了支持文档中的图及表格，这里fork了kraiklyn主题并添加了一个shortcode方法专门用来绘图及表格，例如：
&amp;lt;div id=Table_1_Stream_ID_Types class=&amp;#34;block ref&amp;#34;&amp;gt; \`\`\` |位 |流类型| |:---|:-----| |0x00|客户端创建的双向流| |0x01|服务端创建的双向流| |0x02|客户端创建的单向流| |0x03|服务端创建的单向流| \`\`\` [表格1：流类型](#Table_1_Stream_ID_Types) &amp;lt;/div&amp;gt; 这里，block_ref是专门定义的shortcode，indx用来指定锚点（请注意锚点不能使用的特殊字符），title表示图表名称。 block_ref会将title转成一个带跳转的href结构。引用该图表的方式：
[表1](#Table_1_Stream_ID_Types) 3. 何时添加英语原文 只在如下情况添加：
 在正式介绍一个名词的时候，在该章节其首次出现的地方用中文括号（）添加英语原文； 使用英语括号()括起来的一个名词或短语在翻译时使用中文括号（）括起来翻译内容，并在逗号后添加英语原文，逗号用中文；  4.</description>
    </item>
    
  </channel>
</rss>
