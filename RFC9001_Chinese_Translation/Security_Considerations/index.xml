<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>9. 关于安全性的考量 on Autumn Navigation</title>
    <link>/RFC9001_Chinese_Translation/Security_Considerations/</link>
    <description>Recent content in 9. 关于安全性的考量 on Autumn Navigation</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>cn</language><atom:link href="/RFC9001_Chinese_Translation/Security_Considerations/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>9.1. 会话的可关联性</title>
      <link>/RFC9001_Chinese_Translation/Security_Considerations/9.1_Session_Linkability/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9001_Chinese_Translation/Security_Considerations/9.1_Session_Linkability/</guid>
      <description>TLS会话票据的使用使得服务器或其他实体能够将同一客户端创建的连接相互关联起来；有关细节详见第4.5章。</description>
    </item>
    
    <item>
      <title>9.2. 与0-RTT相关的重放攻击</title>
      <link>/RFC9001_Chinese_Translation/Security_Considerations/9.2_Replay_Attacks_with_0-RTT/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9001_Chinese_Translation/Security_Considerations/9.2_Replay_Attacks_with_0-RTT/</guid>
      <description>正如《TLS13》的第8章所述，只要使用了TLS早期数据就会被暴露于重放攻击之下。QUIC的0-RTT有着类似的风险。
终端必须实现并使用《TLS13》中描述的重放保护，然而这些保护并不被认为是完美的。因此，对于重放攻击的风险还需要更多考量。
QUIC并不易受到重放攻击，除非是利用QUIC传递的应用协议信息的攻击。基于在《QUIC传输》中定义的帧类型的QUIC协议状态管理机制不易受到重放攻击。QUIC帧的处理是幂等的，在帧被重放、乱序或遭遇丢包时不会引发连接状态异常。QUIC连接期间产生的副作用在连接的生命周期结束后就会失效，除非是那些由QUIC承载的应用协议产生的副作用。
TLS会话票据和地址验证令牌被用于在不同的连接间传递QUIC配置信息，尤其是，它使得服务器能够在连接建立和地址验证时高效地恢复状态数据。必须不使用它们在终端间传递应用语义；客户端必须将它们视作为内容不透明的值。如果这些令牌有可能被重用，那么它们就需要更强的针对重放攻击的保护。
在某条连接上接受0-RTT的服务器比不接受0-RTT的服务器要消耗更多的计算资源。服务器在接受0-RTT时需要考虑到重放的可能性以及其他相关资源的消耗。
管理与0-RTT相关的重放攻击的风险，其最终的责任在于应用协议。使用QUIC的应用协议必须描述该协议会怎样使用0-RTT以及用于抵御重放攻击的手段。对于重放风险的分析需要考虑所有会传递应用语义的QUIC协议特性。
要抵御重放攻击，完全禁用0-RTT是最有效的。
QUIC扩展必须描述重放攻击会如何影响扩展的行为，或禁止与0-RTT一起被使用。应用协议必须禁止使用会在0-RTT中传递应用语义的扩展，或提供抵御重放攻击的策略。</description>
    </item>
    
    <item>
      <title>9.3. 数据包放大攻击的抵御</title>
      <link>/RFC9001_Chinese_Translation/Security_Considerations/9.3_Packet_Reflection_Attack_Mitigation/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9001_Chinese_Translation/Security_Considerations/9.3_Packet_Reflection_Attack_Mitigation/</guid>
      <description>如果一条较小的ClientHello（客户端问候）能使得服务器响应巨大的握手消息，它就能被用于数据包放大攻击，放大攻击者生成的流量。
QUIC针对此类攻击，拥有三种防御手段。首先，包含ClientHello的数据包必须被扩充至一个下限值。其次，在向未经验证的源地址响应时，服务器发送的字节数禁止超过它接收到的字节数的三倍（详见《QUIC传输》的第8.1章）。最后，因为对于握手数据包的确认是经认证的，所有对此一无所知的攻击者无法伪造它们。综合起来，这些防御手段限制了放大攻击的放大量级。</description>
    </item>
    
    <item>
      <title>9.4. 对头部保护的分析</title>
      <link>/RFC9001_Chinese_Translation/Security_Considerations/9.4_Header_Protection_Analysis/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9001_Chinese_Translation/Security_Considerations/9.4_Header_Protection_Analysis/</guid>
      <description>《NAN》分析了许多能保护随机数的认证加密算法，它们被称为“随机数隐藏”（HN）转换。本文档中的头部保护构建方法大体上可以算作是这些算法中的其中一种（HN1）。头部保护会在数据包保护AEAD之后被应用，它从AEAD的输出中采样一组字节样本（表达式中的sample），并以此方法使用伪随机函数（表达式中的PRF）来加密头部字段：
protected_field = field XOR PRF(hp_key, sample) 
 本文档中的头部保护的不同之处在于使用伪随机排列（PRP）来代替常规的PRF。然而，由于所有PRP都算作PRF（详见《IMC》），所以这种修改并不违背HN1的构建原则。
由于hp_key与数据包保护密钥不同，因此头部保护能够达到《NAN》中描述的AE2安全级别，从而保护数据包头部中的字段。将来的基于相同构建方式的头部保护变体必须使用PRF来确保获得一致的安全保障。
多次使用相同的密钥和密文样本会有使头部保护失效的风险。使用相同的密钥和密文样本来保护两份不同的包头会泄露受保护字段的异或结果。假设以AEAD作为PRF，如果采样了L个比特位，那么两份密文样本一致的概率约为2-L/2，也就是所谓的生日攻击。对于在本文档中描述的算法，这个概率为264分之一。
为了防止被攻击者修改，数据包头部会受到数据包保护的认证；整个数据包头部都是受认证的额外数据的一部分。受保护的字段有没有被篡改只能在移除数据包保护后才被检测出来。</description>
    </item>
    
    <item>
      <title>9.5. 头部保护的计时侧信道</title>
      <link>/RFC9001_Chinese_Translation/Security_Considerations/9.5_Header_Protection_Timing_Side_Channels/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9001_Chinese_Translation/Security_Considerations/9.5_Header_Protection_Timing_Side_Channels/</guid>
      <description>攻击者可以猜测数据包号或密钥阶段的值，并通过计时侧信道观察终端会不会接受这个值。类似地，对于数据包号长度也可以进行猜测和破解。如果数据包的接收方直接将数据包号重复的数据包丢弃，而没有尝试移除数据包保护，那么它们就会通过计时侧信道暴露此数据包号与一个已接收到的数据包匹配的事实。为了使认证过程不会对侧信道产生影响，必须完整地先移除头部保护、然后恢复数据包号，接着移除数据包保护，从而避免从计时或其他方面的侧信道泄露信息。
在数据包的发送方面，数据包载荷与数据包号的构建和保护过程必须不会从侧信道泄露数据包号或它的编码后长度。
在密钥更新期间，创建新密钥所花费的时间可能通过计时侧信道透露出有没有发生密钥更新。除此之外，当攻击者注入数据包时，该侧信道会泄露被注入的数据包里密钥阶段的值。在接收到密钥更新后，终端应该如第6.3章所述的那样，建立并储存下一组接受用的数据包保护密钥。通过在接收到密钥更新前就建立新密钥，数据包的接收就不会创建出会泄露密钥阶段的值的计时上的信号。
这项要求依赖于不在数据包处理期间建立新密钥，同时它可能需要终端维护三组接收用的数据包保护密钥：上一密钥阶段的、当前密钥阶段的和下一密钥阶段的。作为替代方案，终端可以选择延迟建立下一密钥阶段的数据包保护密钥，直到它弃用旧密钥为止，这使得它在同一时间只需要维护两组接收密钥。</description>
    </item>
    
    <item>
      <title>9.6. 密钥的隔离性</title>
      <link>/RFC9001_Chinese_Translation/Security_Considerations/9.6_Key_Diversity/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9001_Chinese_Translation/Security_Considerations/9.6_Key_Diversity/</guid>
      <description>在使用TLS时，会用到其核心的密钥衍生计划表。由于TLS握手消息被集成进了秘密值计算，QUIC传输参数扩展的使用能够确保握手密钥和1-RTT密钥与运行基于TCP的TLS的服务器所生成出来的密钥不一致。为了降低不同协议间出现密钥碰撞情况的可能性，有额外的措施来提高密钥的隔离性。
QUIC的数据包保护密钥和IV是使用与TLS中不同的标签来衍生的。
为了维持这种隔离性，新版本的QUIC应该为计算数据包保护密钥和IV的密钥，以及头部保护密钥，的衍生过程定义新的标签值。本版本的QUIC使用了字符串quic。其他版本可以使用与版本相关的标签来替换该字符串。
初始秘密值使用的是由协商出的QUIC版本指定的密钥。新的QUIC版本应该为秘密值的计算定义新的盐值。</description>
    </item>
    
    <item>
      <title>9.7. 随机性</title>
      <link>/RFC9001_Chinese_Translation/Security_Considerations/9.7_Randomness/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9001_Chinese_Translation/Security_Considerations/9.7_Randomness/</guid>
      <description>QUIC依赖于终端生成安全的随机数的能力，这项能力既会被直接用在协议里的一些值上，如连接ID，也会经由TLS被使用到。有关安全的随机数生成的指导，详见《RFC4086》。</description>
    </item>
    
  </channel>
</rss>
