

<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="cn" lang="cn">
<head>
  <meta name="generator" content="Hugo 0.93.0-DEV" />

  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

  
  
    
  
  <title>RFC9001中文：QUIC TLS</title>

  <link rel="shortcut icon" href="https://iknow-pic.cdn.bcebos.com/c75c10385343fbf271c706c8bb7eca8064388f76"
    type="image/x-icon">
  <link href="https://fonts.googleapis.com/css?family=Open+Sans" rel="stylesheet">
  <link rel="stylesheet" href="/css/styles.css">

  
    
    <link rel="stylesheet" href="/RFC9001_Chinese_Translation/css/RFC9001.css">
  

  <link href="/RFC9001_Chinese_Translation/index.xml" rel="alternate"
    type="application/rss+xml" title="RFC9001中文：QUIC TLS" />

</head>
<body>
<div class="sidebar sidebar-rfc9001">
    <div class="navigation">
      
        <div><a href="/">在下秋航</a></div>
        <h1 class="site-title"><a href="/RFC9001_Chinese_Translation/">RFC9001中文：QUIC TLS</a></h1>
      


        <nav class="internal">
            <ul>
    
        
            
    <li>
        <a href="#RFC9001_QUIC">RFC9001 QUIC TLS</a>

        <ul>
            
                
                    <li><a href="#Forword">前言</a></li>
                
            
                
                    <li><a href="#Abstract">摘要</a></li>
                
            
                
                    <li><a href="#Status_of_This_Memo">备忘状态</a></li>
                
            
                
                    <li><a href="#Copyright_Notice">版权声明</a></li>
                
            
        </ul>

    </li>


        
            
    <li>
        <a href="#1_Introduction">1. 介绍</a>

    </li>


        
            
    <li>
        <a href="#2_Notational_Conventions">2. 标准规范</a>

        <ul>
            
                
                    <li><a href="#2.1_TLS_Overview">2.1. TLS概述</a></li>
                
            
        </ul>

    </li>


        
            
    <li>
        <a href="#3_Protocol_Overview">3. 协议概述</a>

    </li>


        
            
    <li>
        <a href="#4_Carrying_TLS_Messages">4. 传递TLS消息</a>

        <ul>
            
                
                    
    <li>
        <a href="#4.1_Interface_to_TLS">4.1. 面向TLS的接口</a>

        <ul>
            
                
                    <li><a href="#4.1.1_Handshake_Complete">4.1.1. 握手完成</a></li>
                
            
                
                    <li><a href="#4.1.2_Handshake_Confirmed">4.1.2. 握手已确认</a></li>
                
            
                
                    <li><a href="#4.1.3_Sending_and_Receiving_Handshake_Messages">4.1.3. 发送和接收握手消息</a></li>
                
            
                
                    <li><a href="#4.1.4_Encryption_Level_Changes">4.1.4. 改变密级</a></li>
                
            
                
                    <li><a href="#4.1.5_TLS_Interface_Summary">4.1.5. TLS接口概述</a></li>
                
            
        </ul>

    </li>


                
            
                
                    <li><a href="#4.2_TLS_Version">4.2. TLS版本</a></li>
                
            
                
                    <li><a href="#4.3_ClientHello_Size">4.3. ClientHello的尺寸</a></li>
                
            
                
                    <li><a href="#4.4_Peer_Authentication">4.4. 对端验证</a></li>
                
            
                
                    <li><a href="#4.5_Session_Resumption">4.5. 会话恢复</a></li>
                
            
                
                    
    <li>
        <a href="#4.6_0-RTT">4.6. 0-RTT</a>

        <ul>
            
                
                    <li><a href="#4.6.1_Enabling_0-RTT">4.6.1. 启用0-RTT</a></li>
                
            
                
                    <li><a href="#4.6.2_Accepting_and_Rejecting_0-RTT">4.6.2. 接受与拒绝0-RTT</a></li>
                
            
                
                    <li><a href="#4.6.3_Validating_0-RTT_Configuration">4.6.3. 验证0-RTT配置</a></li>
                
            
        </ul>

    </li>


                
            
                
                    <li><a href="#4.7_HelloRetryRequest">4.7. HelloRetryRequest</a></li>
                
            
                
                    <li><a href="#4.8_TLS_Errors">4.8. TLS错误</a></li>
                
            
                
                    
    <li>
        <a href="#4.9_Discarding_Unused_Keys">4.9. 丢弃不再使用的密钥</a>

        <ul>
            
                
                    <li><a href="#4.9.1_Discarding_Initial_Keys">4.9.1. 弃用初始密钥</a></li>
                
            
                
                    <li><a href="#4.9.2_Discarding_Handshake_Keys">4.9.2. 弃用握手密钥</a></li>
                
            
                
                    <li><a href="#4.9.3_Discarding_0-RTT_Keys">4.9.3. 弃用0-RTT密钥</a></li>
                
            
        </ul>

    </li>


                
            
        </ul>

    </li>


        
            
    <li>
        <a href="#5_Packet_Protection">5. 数据包保护</a>

        <ul>
            
                
                    <li><a href="#5.1_Packet_Protection_Keys">5.1. 数据包保护密钥</a></li>
                
            
                
                    <li><a href="#5.2_Initial_Secrets">5.2. 初始秘密值</a></li>
                
            
                
                    <li><a href="#5.3_AEAD_Usage">5.3. AEAD的使用</a></li>
                
            
                
                    
    <li>
        <a href="#5.4_Header_Protection">5.4. 头部保护</a>

        <ul>
            
                
                    <li><a href="#5.4.1_Header_Protection_Application">5.4.1. 应用头部保护的过程</a></li>
                
            
                
                    <li><a href="#5.4.2_Header_Protection_Sample">5.4.2. 头部保护的采样</a></li>
                
            
                
                    <li><a href="#5.4.3_AES-Based_Header_Protection">5.4.3. 基于AES的头部保护</a></li>
                
            
                
                    <li><a href="#5.4.4_ChaCha20-Based_Header_Protection">5.4.4. 基于ChaCha20的头部保护</a></li>
                
            
        </ul>

    </li>


                
            
                
                    <li><a href="#5.5_Receiving_Protected_Packets">5.5. 接收受保护的数据包</a></li>
                
            
                
                    <li><a href="#5.6_Use_of_0-RTT_Keys">5.6. 0-RTT密钥的使用</a></li>
                
            
                
                    <li><a href="#5.7_Receiving_Out-of-Order_Protected_Packets">5.7. 接收乱序的受保护数据包</a></li>
                
            
                
                    <li><a href="#5.8_Retry_Packet_Integrity">5.8. 重试数据包的完整性</a></li>
                
            
        </ul>

    </li>


        
            
    <li>
        <a href="#6_Key_Update">6. 密钥更新</a>

        <ul>
            
                
                    <li><a href="#6.1_Initiating_a_Key_Update">6.1. 发起密钥更新</a></li>
                
            
                
                    <li><a href="#6.2_Responding_to_a_Key_Update">6.2. 响应密钥更新</a></li>
                
            
                
                    <li><a href="#6.3_Timing_of_Receive_Key_Generation">6.3. 对创建接收密钥的计时</a></li>
                
            
                
                    <li><a href="#6.4_Sending_with_Updated_Keys">6.4. 使用更新后的密钥来发送</a></li>
                
            
                
                    <li><a href="#6.5_Receiving_with_Different_Keys">6.5. 使用不同的密钥来接收</a></li>
                
            
                
                    <li><a href="#6.6_Limits_on_AEAD_Usage">6.6. AEAD的用量上限</a></li>
                
            
                
                    <li><a href="#6.7_Key_Update_Error_Code">6.7. 密钥更新的错误码</a></li>
                
            
        </ul>

    </li>


        
            
    <li>
        <a href="#7_Security_of_Initial_Messages">7. 初始消息的安全性</a>

    </li>


        
            
    <li>
        <a href="#8_QUIC-Specific_Adjustments_to_the_TLS_Handshake">8. QUIC中对TLS握手的调整</a>

        <ul>
            
                
                    <li><a href="#8.1_Protocol_Negotiation">8.1. 协议协商</a></li>
                
            
                
                    <li><a href="#8.2_QUIC_Transport_Parameters_Extension">8.2. QUIC传输参数扩展</a></li>
                
            
                
                    <li><a href="#8.3_Removing_the_EndOfEarlyData_Message">8.3. 移除EndOfEarlyData消息</a></li>
                
            
                
                    <li><a href="#8.4_Prohibit_TLS_Middlebox_Compatibility_Mode">8.4. 禁止TLS的中间设备兼容模式</a></li>
                
            
        </ul>

    </li>


        
            
    <li>
        <a href="#9_Security_Considerations">9. 关于安全性的考量</a>

        <ul>
            
                
                    <li><a href="#9.1_Session_Linkability">9.1. 会话的可关联性</a></li>
                
            
                
                    <li><a href="#9.2_Replay_Attacks_with_0-RTT">9.2. 与0-RTT相关的重放攻击</a></li>
                
            
                
                    <li><a href="#9.3_Packet_Reflection_Attack_Mitigation">9.3. 数据包放大攻击的抵御</a></li>
                
            
                
                    <li><a href="#9.4_Header_Protection_Analysis">9.4. 对头部保护的分析</a></li>
                
            
                
                    <li><a href="#9.5_Header_Protection_Timing_Side_Channels">9.5. 头部保护的计时侧信道</a></li>
                
            
                
                    <li><a href="#9.6_Key_Diversity">9.6. 密钥的隔离性</a></li>
                
            
                
                    <li><a href="#9.7_Randomness">9.7. 随机性</a></li>
                
            
        </ul>

    </li>


        
            
    <li>
        <a href="#10_IANA_Considerations">10. 关于IANA的考量</a>

    </li>


        
            
    <li>
        <a href="#11_References">11. 参考文献</a>

        <ul>
            
                
                    <li><a href="#11.1_Normative_References">11.1. 规范性参考文献</a></li>
                
            
                
                    <li><a href="#11.2_Informative_References">11.2. 资料性参考文献</a></li>
                
            
        </ul>

    </li>


        
            
    <li>
        <a href="#Appendix_A_Sample_Packet_Protection">附录A. 数据包保护样例</a>

        <ul>
            
                
                    <li><a href="#A.1_Keys">A.1. 密钥</a></li>
                
            
                
                    <li><a href="#A.2_Client_Initial">A.2. 客户端初始数据包</a></li>
                
            
                
                    <li><a href="#A.3_Server_Initial">A.3. 服务器初始数据包</a></li>
                
            
                
                    <li><a href="#A.4_Retry">A.4. 重试数据包</a></li>
                
            
                
                    <li><a href="#A.5_ChaCha20-Poly1305_Short_Header_Packet">A.5. 使用ChaCha20-Poly1305的短包头数据包</a></li>
                
            
        </ul>

    </li>


        
            
    <li>
        <a href="#Appendix_B_AEAD_Algorithm_Analysis">附录B. AEAD算法分析</a>

        <ul>
            
                
                    
    <li>
        <a href="#B.1_Analysis_of_AEAD_AES_128_GCM_and_AEAD_AES_256_GCM_Usage_Limits">B.1. 对于AEAD_AES_128_GCM和AEAD_AES_256_GCM用量上限的分析</a>

        <ul>
            
                
                    <li><a href="#B.1.1_Confidentiality_Limit">B.1.1. 可信度上限</a></li>
                
            
                
                    <li><a href="#B.1.2_Integrity_Limit">B.1.2. 完整性上限</a></li>
                
            
        </ul>

    </li>


                
            
                
                    <li><a href="#B.2_Analysis_of_AEAD_AES_128_CCM_Usage_Limits">B.2. 对于AEAD_AES_128_CCM用量上限的分析</a></li>
                
            
        </ul>

    </li>


        
            
    <li>
        <a href="#Contributors">贡献者</a>

    </li>


        
            
    <li>
        <a href="#Authors_Addresses">联系作者</a>

    </li>


        
    
</ul>

        </nav>

        <nav class="external">
          
            <ul id="shortcuts">
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
            </ul>
            <br>
          
        </nav>
    </div>

    <div class="version">
            generated on Jul 5, 2022
    </div>
</div>

<div class="content">
    
        
                <section class="page" id="RFC9001_QUIC">
    
        <h1>
    
            <a href="#RFC9001_QUIC">RFC9001 QUIC TLS</a>
    
        </h1>
    
    <div class="content">
        <br>
<br>
<table border="3" frame="void" rules="none">
  <tr>
    <td>状态：</td>
    <td colspan="2">建议标准</td>
  </tr>
  <tr>
    <td>更多信息：</td>
    <td colspan="2">
      <a href="https://datatracker.ietf.org/doc/rfc9001">数据追踪</a>|
      <a href="https://datatracker.ietf.org/ipr/search/?rfc=9001&submit=rfc">知识产权</a>|
      <a href="https://www.rfc-editor.org/info/rfc9001">信息页</a>
    </td>
  </tr>
  <tr>
    <td>组织：</td>
    <td colspan="2">互联网工程工作组（IETF）</td>
  </tr>
  <tr>
    <td>RFC编号：</td>
    <td colspan="2">
      <a href="https://www.rfc-editor.org/info/rfc9001">9001</a>
    </td>
  </tr>
  <tr>
    <td>分类：</td>
    <td colspan="2">标准追踪</td>
  </tr>
  <tr>
    <td>出版时间：</td>
    <td colspan="2">2021年5月</td>
  </tr>
  <tr>
    <td>国际标准期刊编号：</td>
    <td colspan="2">2070-1721</td>
  </tr>
  <tr>
    <td>作者：</td>
    <td>M. Thomson, Ed. <br><i>Mozilla</i></td>
    <td>S. Turner, Ed. <br><i>sn3rd</i></td>
  </tr>
</table>

    </div>
</section>


    
        
            <section class="page" id="Forword">
    
        <h2>
    
            <a href="#Forword">前言</a>
    
        </h2>
    
    <div class="content">
        <p>本文是QUIC使用TLS进行加密通信的网络规范文档译文，尚未完成翻译，欢迎指正。</p>

    </div>
</section>

        
    
        
            <section class="page" id="Abstract">
    
        <h2>
    
            <a href="#Abstract">摘要</a>
    
        </h2>
    
    <div class="content">
        <p>本文描述如何使用传输层安全协议（TLS）加密QUIC。</p>

    </div>
</section>

        
    
        
            <section class="page" id="Status_of_This_Memo">
    
        <h2>
    
            <a href="#Status_of_This_Memo">备忘状态</a>
    
        </h2>
    
    <div class="content">
        <p>本文是互联网标准追踪文档。</p>
<p>本文产自互联网工程任务组（IETF），已接受公开审查，并由互联网互联网工程指导委员会（IESG）批准出版。更多互联网标准相关信息详见<a href="https://datatracker.ietf.org/doc/rfc7841/">RFC 7841</a>第2章。</p>
<p>关于本文当前状态、勘误及反馈方式等相关信息请移步<a href="https://www.rfc-editor.org/info/rfc9001">https://www.rfc-editor.org/info/rfc9001</a>。</p>

    </div>
</section>

        
    
        
            <section class="page" id="Copyright_Notice">
    
        <h2>
    
            <a href="#Copyright_Notice">版权声明</a>
    
        </h2>
    
    <div class="content">
        <p>版权所有（c）2021 IETF信托及确认为文档作者的个人。保留所有权利。</p>
<p>本文遵守BCP 78及在本文发布之日起生效的IETF信托涉及IETF文档的法律条文（<a href="https://trustee.ietf.org/license-info">https://trustee.ietf.org/license-info</a>）。请仔细阅读相关条文，因为其描述了你对本文所有的权利及限制。从本文中摘录的代码组件必须包含信托法律条文第4.e章的简版BSD License文件，并且不附带任何该文件所描述的保证。</p>

    </div>
</section>

        
    



        
                <section class="page" id="1_Introduction">
    
        <h1>
    
            <a href="#1_Introduction">1. 介绍</a>
    
        </h1>
    
    <div class="content">
        <p>本文档描述了如何使用TLS（详见《<a href="">TLS13</a>》）来加固QUIC（详见《<a href="">QUIC传输</a>》）的安全。</p>
<p>TLS 1.3比起之前的版本，在延迟方面为连接的建立提供了重要的性能提升。在没有数据包丢包的情况下，绝大多数新连接都能够在单次往返时间内得到建立和加固；当在相同客户端和服务器间进行后续连接时，客户端通常可以立即发送应用数据，也就是，使用零往返启动来进行连接。</p>
<p>本文档描述了TLS作为QUIC的安全组件时是如何工作的。</p>

    </div>
</section>




        
                <section class="page" id="2_Notational_Conventions">
    
        <h1>
    
            <a href="#2_Notational_Conventions">2. 标准规范</a>
    
        </h1>
    
    <div class="content">
        <p>本文中的关键字“<em><strong>必须</strong></em>（<strong>MUST</strong>）”、“<em><strong>必须不</strong></em>（<strong>MUST NOT</strong>）”、“<em><strong>需要</strong></em>（<strong>REQUIRED</strong>）”、“<em><strong>强烈要求</strong></em>（<strong>SHALL</strong>）”、“<em><strong>强烈要求不</strong></em>（<strong>SHALL NOT</strong>）”、“<em><strong>应该</strong></em>（<strong>SHOULD</strong>）”、“<em><strong>不应该</strong></em>（<strong>SHOULD NOT</strong>）”、“<em><strong>推荐</strong></em>（<strong>RECOMMENDED</strong>）”、“<em><strong>不推荐</strong></em>（<strong>NOT RECOMMENDED</strong>）”、“<em><strong>可以</strong></em>（<strong>MAY</strong>）”，以及“<em><strong>可选</strong></em>（<strong>OPTIONAL</strong>）”应理解为BCP 14 《<a href="#RFC2119">RFC2119</a>》《<a href="#RFC8174">RFC8174</a>》所描述的，当且仅当它们像本段一样以斜体加粗方式出现的时候。</p>
<p>本文档使用了在《<a href="">QUIC传输</a>》中建立的术语。</p>
<p>为了简洁，缩写TLS指代的是TLS 1.3，但也可以使用更高的版本；详见<a href="">第4.2章</a>。</p>

    </div>
</section>


    
        
            <section class="page" id="2.1_TLS_Overview">
    
        <h2>
    
            <a href="#2.1_TLS_Overview">2.1. TLS概述</a>
    
        </h2>
    
    <div class="content">
        <p>TLS为两个终端提供一种经由不受信任的中间人（例如，互联网）建立通信的方法。TLS认证对端的身份并且为终端间交换的信息提供可信度和完整性保护。</p>
<p>TLS在协议内部有着不同的层，它的结构如<a href="">图1</a>所示。</p>
<blockquote>
<p>TODO：图1</p>
</blockquote>


<div id=Figure_1_TLS_Layers class="block ref">
    
        <object data="/RFC9000_Chinese_Translation/images/Figure_2_States_for_Sending_Parts_of_Streams.svg" type="image/svg+xml" style='width:93%'></object>
    
    <p><a href="#Figure_1_TLS_Layers">图1：TLS的层</a></p>
</div>
<p>每条内容层消息（例如握手、警告和应用数据）都是由记录层将其作为一系列具有类型的TLS记录来传递的。每条记录受到单独的加密保护，然后经由一种可靠的传输方式（通常是TCP）被发送出去，可靠是指它提供了有序且受保证的交付。</p>
<p>在两个终端（客户端和服务器）间会进行TLS认证密钥的交换。交换由客户端发起，服务器则负责响应。如果密钥交换顺利完成，那么客户端和服务器将就一个秘密值达成一致。TLS既支持预共享密钥（PSK），也支持基于有限域或椭圆曲线的迪菲-赫尔曼金密钥交换（(EC)DHE）。预共享密钥是早期数据（0-RTT）的基础；后者在(EC)DHE密钥被销毁时提供前向安全（Forward Secrecy）。还可以组合使用这两种模式，以在使用PSK认证时提供前向安全。</p>
<p>只要完成了TLS握手，客户端就能了解到并验证服务器的身份，而服务器能够可选地去了解和验证客户端的身份。TLS支持使用X.509（详见《<a href="">RFC5280</a>》）证书来认证服务器和客户端。当使用PSK密钥交换时（在恢复过程中会用到），有关PSK的知识也能帮助验证对端的身份。</p>
<p>TLS密钥交换能抵御攻击者的篡改，并且由它生成的共享秘密值不受任一终端的控制。</p>
<p>TLS提供两种QUIC感兴趣的基本握手模式：</p>
<ul>
<li>
<p>完整的1-RTT握手，这种情况下客户端可以在单次数据往返后发送应用数据，而服务器可以在接收到来自客户端的首条握手消息后立即作出响应。</p>
</li>
<li>
<p>0-RTT握手，这种情况下客户端使用有关服务器的已知信息来立即发送应用数据。这些应用数据可以被攻击者重放，所以0-RTT不适合用来传递被重放后可能引发意外的副作用的指令。</p>
</li>
</ul>
<p><a href="">图2</a>展示的是简化后的发送0-RTT应用数据的TLS握手过程。</p>
<blockquote>
<p>TODO：图2</p>
</blockquote>


<div id=Figure_2_TLS_Handshake_with_0-RTT class="block ref">
    
        <object data="/RFC9000_Chinese_Translation/images/Figure_2_States_for_Sending_Parts_of_Streams.svg" type="image/svg+xml" style='width:93%'></object>
    
    <p><a href="#Figure_2_TLS_Handshake_with_0-RTT">图2：使用0-RTT的TLS握手</a></p>
</div>
<p><a href="">图2</a>省略了QUIC不会使用到的<code>EndOfEarlyData</code>（早期数据结束）消息；详见<a href="">第8.3章</a>。类似地，QUIC也不会使用<code>ChangeCipherSpec</code>（更改加密设置）消息和<code>KeyUpdate</code>（密钥更新）消息。在TLS 1.3中<code>ChangeCipherSpec</code>是冗余的；详见<a href="">第8.4章</a>。QUIC有自己的密钥更新机制；详见<a href="">第6章</a>。</p>
<p>多种加密级别被用于保护数据：</p>
<ul>
<li>
<p>初始密钥</p>
</li>
<li>
<p>早期数据（0-RTT）密钥</p>
</li>
<li>
<p>握手密钥</p>
</li>
<li>
<p>应用数据（1-RTT）密钥</p>
</li>
</ul>
<p>应用数据只能出现在早期数据和应用数据这两种密级中。握手消息和警告消息可以出现在任一密级。</p>
<p>如果客户端和服务器之间曾进行过通信，那么可以使用0-RTT握手。进行1-RTT握手时，客户端只有在收到所有来自服务器的握手消息后才能发送受保护的应用数据。</p>

    </div>
</section>

        
    



        
                <section class="page" id="3_Protocol_Overview">
    
        <h1>
    
            <a href="#3_Protocol_Overview">3. 协议概述</a>
    
        </h1>
    
    <div class="content">
        <p>QUIC（详见《<a href="">QUIC传输</a>》）负责数据包的可信度和完整性保护。为此它使用了衍生自TLS握手（详见《<a href="">TLS13</a>》）的密钥，但如<a href="">图3</a>所示，TLS握手和警告消息由QUIC传输层直接传递，而不是在QUIC传输层的基础上使用TLS记录来传递（TCP是这么做的），也就是说QUIC接管了TLS记录层的职责。</p>
<blockquote>
<p>TODO：图3</p>
</blockquote>


<div id=Figure_3_QUIC_Layers class="block ref">
    
        <object data="/RFC9000_Chinese_Translation/images/Figure_2_States_for_Sending_Parts_of_Streams.svg" type="image/svg+xml" style='width:93%'></object>
    
    <p><a href="#Figure_3_QUIC_Layers">图3：QUIC的层</a></p>
</div>
<p>QUIC还依靠TLS来验证和协商那些安全和性能方面的关键参数。</p>
<p>这两种协议间没有严格的层次区分，取而代之的是它们相互合作：QUIC使用TLS的握手；TLS使用由QUIC提供的可靠性、有序交付和记录层等特性。</p>
<p>抽象地说，TLS组件和QUIC组件间主要有两类交互：</p>
<ul>
<li>
<p>TLS组件经由QUIC组件发送和接收消息，QUIC向TLS提供一种可靠的流的抽象。</p>
</li>
<li>
<p>TLS组件向QUIC组件提供一系列状态更新，包括(a)新的数据包保护密钥，和(b)状态变更，例如握手完成、服务器证书，等等。</p>
</li>
</ul>
<p><a href="">图4</a>更详细地展示了这些交互，并且把QUIC数据包保护单独提了出来。</p>
<blockquote>
<p>TODO：图4</p>
</blockquote>


<div id=Figure_4_QUIC_and_TLS_Interactions class="block ref">
    
        <object data="/RFC9000_Chinese_Translation/images/Figure_2_States_for_Sending_Parts_of_Streams.svg" type="image/svg+xml" style='width:93%'></object>
    
    <p><a href="#Figure_4_QUIC_and_TLS_Interactions">图4：QUIC和TLS的交互</a></p>
</div>
<p>不像基于TCP的TLS，想要发送数据的QUIC应用并不使用TLS应用数据记录来发送，而是将数据以QUIC<strong>流帧</strong>或其他类型的帧的形式发送，它们都是由QUIC数据包传递的。</p>

    </div>
</section>




        
                <section class="page" id="4_Carrying_TLS_Messages">
    
        <h1>
    
            <a href="#4_Carrying_TLS_Messages">4. 传递TLS消息</a>
    
        </h1>
    
    <div class="content">
        <p>QUIC使用<strong>加密帧</strong>传递TLS握手数据，每个帧由一些连续的握手数据块组成，并使用偏移值和长度值来区分数据块。这些帧被封装进QUIC数据包并受到当前密级的加密。就像基于TCP的TLS一样，一旦TLS握手数据被交付给QUIC，QUIC就有责任将数据可靠地交付给对端。每一份由TLS生成的数据分块都被关联到TLS正在使用的一组密钥。如果QUIC需要重传某份数据，那么它<em><strong>必须</strong></em>使用相同的密钥，哪怕TLS已经改用更新的密钥了。</p>
<p>每个密级对应着一个数据包号空间。正在使用的数据包号空间决定了帧的语义。在特定的数据包号空间里，有些帧是被禁止使用的；详见《<a href="">QUIC传输</a>》的<a href="">第12.5章</a>。</p>
<p>由于数据包在链路上可能出现乱序，QUIC使用数据包类型来表明用于保护给定数据包的密钥，如<a href="">表1</a>所示。当要发送不同类型的数据包时，终端<em><strong>应该</strong></em>使用合并数据包的方法从而在单个UDP数据报中发送它们。</p>
<div id=Table_1_Encryption_Keys_by_Packet_Type class="block ref">
<table>
<thead>
<tr>
<th style="text-align:left">数据包类型</th>
<th style="text-align:left">加密密钥</th>
<th style="text-align:left">数据包号空间</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><strong>初始</strong></td>
<td style="text-align:left">初始秘密值</td>
<td style="text-align:left">初始</td>
</tr>
<tr>
<td style="text-align:left"><strong>0-RTT</strong></td>
<td style="text-align:left">0-RTT</td>
<td style="text-align:left">Application data</td>
</tr>
<tr>
<td style="text-align:left"><strong>握手</strong></td>
<td style="text-align:left">握手</td>
<td style="text-align:left">握手</td>
</tr>
<tr>
<td style="text-align:left"><strong>重试</strong></td>
<td style="text-align:left">重试</td>
<td style="text-align:left">不适用</td>
</tr>
<tr>
<td style="text-align:left"><strong>版本协商</strong></td>
<td style="text-align:left">不适用</td>
<td style="text-align:left">不适用</td>
</tr>
<tr>
<td style="text-align:left"><strong>短包头</strong></td>
<td style="text-align:left">1-RTT</td>
<td style="text-align:left">应用数据</td>
</tr>
</tbody>
</table>
<p><a href="#Table_1_Encryption_Keys_by_Packet_Type">表1：数据包类型对应的加密密钥</a></p>
</div>
<p>《<a href="">QUIC传输</a>》的<a href="">第17章</a>描述了各种密级的数据包如何参与握手过程。</p>

    </div>
</section>


    
        
                <section class="page" id="4.1_Interface_to_TLS">
    
        <h2>
    
            <a href="#4.1_Interface_to_TLS">4.1. 面向TLS的接口</a>
    
        </h2>
    
    <div class="content">
        <p>如<a href="">图4</a>所示，QUIC面向TLS的接口由四个主要函数组成：</p>
<ul>
<li>
<p>发送和接收握手消息</p>
</li>
<li>
<p>处理已存储的用于恢复会话的传输状态和应用状态，并判断它们是否有效以生成或接受0-RTT数据</p>
</li>
<li>
<p>重新生成密钥（既包括发送用的也包含接收用的）</p>
</li>
<li>
<p>更新握手状态</p>
</li>
</ul>
<p>为了配置TLS，可能需要额外的函数。尤其是，QUIC和TLS需要就哪一方负责验证对端的凭据，例如证书（详见《<a href="">RFC5280</a>》），达成一致。</p>

    </div>
</section>


    
        
            <section class="page" id="4.1.1_Handshake_Complete">
    
        <h3>
    
            <a href="#4.1.1_Handshake_Complete">4.1.1. 握手完成</a>
    
        </h3>
    
    <div class="content">
        <p>在本文档中，当TLS栈报告握手已完成时，就可以认定此次TLS握手完成。这一事件会在TLS栈发送了自己的<code>Finished</code>（已结束）消息并且验证了对端的<code>Finished</code>消息时发生。验证对端的<code>Finished</code>消息使得终端能够确信之前的握手消息没有受到篡改。注意，两侧的终端不是同时认定握手完成的。所以，任何基于握手完成这一时机的要求，该时机都是由终端在具体问题中的角色决定的。</p>

    </div>
</section>

        
    
        
            <section class="page" id="4.1.2_Handshake_Confirmed">
    
        <h3>
    
            <a href="#4.1.2_Handshake_Confirmed">4.1.2. 握手已确认</a>
    
        </h3>
    
    <div class="content">
        <p>在本文档中，在握手完成的同时，服务器一侧的TLS握手就可以被认定为已确认。一旦握手完成，服务器<em><strong>必须</strong></em>立即发送<strong>握手完成帧</strong>。而在客户端一侧，只有接收到<strong>握手完成帧</strong>后才能认定握手为已确认。</p>
<p>除此之外，客户端<em><strong>可以</strong></em>在接收到对于某个1-RTT数据包的确认时将握手认定为已确认。这可以通过记录使用1-RTT密钥发送的最小数据包号，并将它与接收到的1-RTT<strong>ACK帧</strong>的最大确认数字段作比较，来实现：一旦后者大于等于前者，即可确认握手。</p>

    </div>
</section>

        
    
        
            <section class="page" id="4.1.3_Sending_and_Receiving_Handshake_Messages">
    
        <h3>
    
            <a href="#4.1.3_Sending_and_Receiving_Handshake_Messages">4.1.3. 发送和接收握手消息</a>
    
        </h3>
    
    <div class="content">
        <p>为了进行握手，TLS需要发送和接收握手消息的能力。对于这个接口，有两个基本函数：QUIC从其中一个函数获取握手消息，向另一个函数提供组成握手消息的字节数据。</p>
<p>在启动握手前，QUIC向TLS提供它想传递的传输参数（详见<a href="">第8.2章</a>）。</p>
<p>QUIC客户端以向TLS获取握手的字节数据的方式启动TLS。客户端在发送首个数据包前获取握手的字节数据。QUIC服务器则以向TLS提供客户端的握手字节数据的方式启动TLS。</p>
<p>任一终端的TLS栈都始终记录着当前的发送密级和接收密级。TLS密级决定了QUIC数据包类型和用于保护数据的密钥。</p>
<p>每个密级都关联着各自的一份字节序列，这些字节内容会由<strong>加密帧</strong>可靠地发送给对端。当TLS提供了将要发送的握手字节时，这些字节会被追加到当前密级的握手字节内容后面。该密级决定着最终发送<strong>加密帧</strong>时所用的数据包类型；详见<a href="">表1</a>。</p>
<p>四个密级分别为初始数据包、0-RTT数据包、握手数据包和1-RTT数据包生成密钥。其中只有三个密级能被用来传递<strong>加密帧</strong>，不在其中的是0-RTT这个密级。这四个密级对应着三个数据包号空间：受初始密钥和握手密钥加密的数据包分别使用各自的空间；0-RTT数据包和1-RTT数据包使用应用数据数据包号空间。</p>
<p>QUIC使用未受保护的TLS握手记录的内容作为<strong>加密帧</strong>的内容。QUIC不使用TLS的记录保护。QUIC将<strong>加密帧</strong>组装进具有QUIC数据包保护的QUIC数据包。</p>
<p>QUIC<strong>加密帧</strong>仅传递TLS握手消息。TLS警告被转换为QUIC<strong>连接关闭帧</strong>的错误码；详见<a href="">第4.8章</a>。TLS应用数据和其他内容类型不能由QUIC以任何密级传递；不应该从TLS栈接收到它们，否则这是一种错误。</p>
<p>当终端从网络接收到了一个包含<strong>加密帧</strong>的QUIC数据包时，它应该这样处理：</p>
<ul>
<li>
<p>如果数据包使用了当前的TLS接收密级，那么数据会被正常地按顺序置入输入流。和<strong>流帧</strong>一样，要使用偏移值来在数据序列中找到正确的置入位置。如果完成该过程后出现了新的可用数据，那么新数据会被有序地交付给TLS。</p>
</li>
<li>
<p>如果数据包来自之前使用过的密级，那么它包含的数据<em><strong>必须不</strong></em>扩展那个密级的数据流末尾。QUIC实现<em><strong>必须</strong></em>将任何违反这项要求的情况视作类型为<code>PROTOCOL_VIOLATION</code>（协议违反）的连接错误。</p>
</li>
<li>
<p>如果数据包来自新的密级，那么它会被保存起来，用于将来给TLS处理。一旦TLS改用此密级接收数据，暂存着的数据就可以被交给TLS。当TLS为更高的密级提供密钥时，如果还有来自之前的密级但是还未被TLS处理的数据，那么<em><strong>必须</strong></em>将该情况视作类型为<code>PROTOCOL_VIOLATION</code>的连接错误。</p>
</li>
</ul>
<p>每次将新数据交给TLS时，都会向TLS获取新的握手字节。如果TLS接收到的握手消息不完整或它没有数据需要发送，那么它可能不会提供任何字节数据。</p>
<p><strong>加密帧</strong>的内容可能会被TLS增量处理，或被缓存起来直到有完整的可用消息。TLS负责缓存按序到达的握手字节数据。QUIC负责缓存未按序到达或属于尚未可用的密级的握手字节。QUIC不会为<strong>加密帧</strong>提供任何流量控制的方法；详见《<a href="">QUIC传输</a>》的<a href="">第7.5章</a>。</p>
<p>一旦TLS握手完成，这一事件就会随着TLS要发送的最后的握手字节一起被告知给QUIC。在这个阶段，握手期间对端宣告的传输参数会被验证；详见<a href="">第8.2章</a>。</p>
<p>一旦握手完成，TLS就变得被动起来。TLS仍然可以从对端接收数据并作出响应，但它没有必要发送更多数据，除非被应用或QUIC专门提出要发送数据的请求。发送数据的可能原因之一是服务器可能想要向客户端新增或更新会话票据。</p>
<p>当握手完成后，QUIC只需要向TLS提供以<strong>加密帧</strong>的形式到达的数据。和握手期间的行为一样，处理完接收到的数据后QUIC会向TLS获取新数据。</p>

    </div>
</section>

        
    
        
            <section class="page" id="4.1.4_Encryption_Level_Changes">
    
        <h3>
    
            <a href="#4.1.4_Encryption_Level_Changes">4.1.4. 改变密级</a>
    
        </h3>
    
    <div class="content">
        <p>当某个密级的密钥对TLS可用时，TLS会告知QUIC那个密级的读取密钥或写入密钥已经变为可用了。</p>
<p>新密钥变为可用这一事件一定是因向TLS提供输入而引发的。TLS只有在（被客户端）初始化后或接收到新握手数据时才会提供新密钥。</p>
<p>然而，TLS实现可能会异步地进行某些处理过程。尤其是，验证证书的过程可能会花不少时间。当等待TLS处理时，如果终端接收到了需要用尚未可用的密钥来处理的数据包，那么终端<em><strong>应该</strong></em>将它们缓存起来。一旦TLS提供了密钥，这些数据包就能够得到处理。终端<em><strong>应该</strong></em>继续响应此时可以处理的数据包。</p>
<p>在处理完输入后，TLS可能生成出握手字节、新密级的密钥或两者兼具。</p>
<p>当新密级可用时，TLS会向QUIC提供以下三份内容：</p>
<ul>
<li>
<p>一个秘密值</p>
</li>
<li>
<p>一个带有关联数据的认证加密（AEAD）函数</p>
</li>
<li>
<p>一个密钥衍生函数（KDF）</p>
</li>
</ul>
<p>这些值源自TLS协商出的那些值，以及被QUIC用于生成数据包与头部保护密钥的那些值；详见<a href="">第5章</a>和<a href="">第5.4章</a>。</p>
<p>如果要使用0-RTT，那么0-RTT会在客户端发送了TLS的<code>ClientHello</code>消息或服务器接收到这条消息后就绪。在第一次向QUIC提供握手字节后，TLS栈可能会发送有关0-RTT密钥发生变化的信号。在服务器接收到包含<code>ClientHello</code>消息的握手字节后，TLS服务器可以发送有关0-RTT密钥变为可用的信号。</p>
<p>尽管TLS在某一时刻只会使用一个密级，QUIC却可以同时使用不止一个密级。举例来说，终端在发送完<code>Finished</code>消息后（使用的是处于握手密级的<strong>加密帧</strong>），它可以发送<strong>流帧</strong>（使用的是1-RTT加密）。如果<code>Finished</code>消息在传输过程中被丢失了，那么终端会用握手密级重传丢失的消息。数据包乱序或丢包的存在意味着QUIC可能需要同时处理处于不同密级的数据包。在握手期间，这意味着有可能需要处理位于比TLS正在使用的密级更高或更低的密级的数据包。</p>
<p>特别是，服务器上的QUIC实现需要有能力同时读取位于握手密级和位于0-RTT密级的数据包。客户端可能使0-RTT数据与受握手密钥保护的<strong>ACK帧</strong>交错传输，而服务器得处理这些确认才能检测出丢包的握手数据包。</p>
<p>QUIC还需要访问对TLS实现来说并不可用的密钥。例如，客户端可能需要在准备好发送握手密级的<strong>加密帧</strong>前确认握手数据包。因此TLS可能需要在出于自己使用的目的而生成密钥前就向QUIC提供这些密钥。</p>

    </div>
</section>

        
    
        
            <section class="page" id="4.1.5_TLS_Interface_Summary">
    
        <h3>
    
            <a href="#4.1.5_TLS_Interface_Summary">4.1.5. TLS接口概述</a>
    
        </h3>
    
    <div class="content">
        <p><a href="">图5</a>概述了客户端和服务器上的QUIC和TLS的通信过程。实线箭头表示传递握手数据的数据包，虚线箭头表示可以发送应用数据的地方。每个箭头都具有一个标签，标示着此传输使用的密级。</p>
<blockquote>
<p>TODO：图5</p>
</blockquote>


<div id=Figure_5_Interaction_Summary_between_QUIC_and_TLS class="block ref">
    
        <object data="/RFC9000_Chinese_Translation/images/Figure_2_States_for_Sending_Parts_of_Streams.svg" type="image/svg+xml" style='width:93%'></object>
    
    <p><a href="#Figure_5_Interaction_Summary_between_QUIC_and_TLS">图5：QUIC和TLS间交互的概述</a></p>
</div>
<p>从<a href="">图5</a>中可以看出，来自单次“航班”的多个数据包中的消息会被单独处理，这表示不同的传入消息触发调用了不同的行为。图中展示了多次“获取握手”的调用，它们在不同密级上获取握手消息。在处理完传入数据包后，会请求新的握手消息。</p>
<p><a href="">图5</a>展示的是简单握手通信时的一种可能的结构。准确的过程会基于终端的实现架构和数据包抵达的顺序而变化。QUIC实现可以执行与图中不同的操作或不按图中的顺序执行操作。</p>

    </div>
</section>

        
    



        
    
        
            <section class="page" id="4.2_TLS_Version">
    
        <h2>
    
            <a href="#4.2_TLS_Version">4.2. TLS版本</a>
    
        </h2>
    
    <div class="content">
        <p>本文档描述了如何与QUIC一起使用TLS 1.3（详见《<a href="">TLS13</a>》）。</p>
<p>在实际操作时，TLS握手会协商出一个要使用的TLS版本。在两侧终端都支持的情况下，它们最终可能协商出一个比<code>1.3</code>还要高的TLS版本。这是可以接受的，因为QUIC使用的TLS 1.3特性都会在更高版本中得到支持。</p>
<p>客户端<em><strong>必须不</strong></em>提供低于<code>1.3</code>的TLS版本。未恰当配置的TLS实现可能想要协商TLS 1.2或别的低版本TLS。如果协商了低于<code>1.3</code>的TLS版本，那么终端<em><strong>必须</strong></em>终止连接。</p>

    </div>
</section>

        
    
        
            <section class="page" id="4.3_ClientHello_Size">
    
        <h2>
    
            <a href="#4.3_ClientHello_Size">4.3. ClientHello的尺寸</a>
    
        </h2>
    
    <div class="content">
        <p>来自客户端的首个初始数据包包含着客户端首个加密握手消息的所有部分或起始部分，对TLS来说这个消息就是<code>ClientHello</code>（客户端问候）。服务器可能需要解析完完整的<code>ClientHello</code>（例如，为了访问服务器名称认证（SNI）和应用层协议协商（ALPN）等扩展）后才能决定要不要接受这个新传入的QUIC连接。如果<code>ClientHello</code>被拆分为多个初始数据包，那么这么做的服务器就需要缓存接收到的数据分段，这会在客户端地址尚未被验证时消耗过多资源。为了避免这一情况，服务器<em><strong>可以</strong></em>使用重试特性（详见《<a href="">QUIC传输</a>》的<a href="">第8.1章</a>）以仅缓存来自具有经验证地址的客户端的<code>ClientHello</code>消息。</p>
<p>QUIC数据包和分帧过程会向<code>ClientHello</code>消息添加至少36字节的开销。如果客户端选择了长于零字节的源连接ID字段，那么这个开销还会增加。这个开销还不包含令牌字段和长于8字节的目标连接ID字段，当服务器发送重试数据包时会需要它们。</p>
<p>一个典型的TLS<code>ClientHello</code>可以被轻松地放进1200字节的数据包中。然而，除了由QUIC引入的开销之外，还有其他因素会使得<code>ClientHello</code>的尺寸超过这一限制。较大的会话票据、多个或较大的密钥共享值和较长的受支持的加密方法、签名算法、版本、QUIC传输参数或其他可协商参数与扩展的列表都可能使得这条消息变大。</p>
<p>对服务器而言，除了连接ID和令牌外，TLS会话票据的尺寸也可能会影响客户端能否高效地进行连接。尽可能减小这些值的尺寸可以提高客户端使用它们并且仍能将整个<code>ClientHello</code>消息放进首个初始数据包的可能性。</p>
<p>TLS实现不需要确保<code>ClientHello</code>的尺寸足够大来满足QUIC对于传递初始数据包的数据报的要求；详见《<a href="">QUIC传输</a>》的<a href="">第14.1章</a>。QUIC实现会使用<strong>填充帧</strong>或数据包合并的方法来确保数据报足够大。</p>

    </div>
</section>

        
    
        
            <section class="page" id="4.4_Peer_Authentication">
    
        <h2>
    
            <a href="#4.4_Peer_Authentication">4.4. 对端验证</a>
    
        </h2>
    
    <div class="content">
        <p>有关验证的要求是视正在使用的应用协议而定的。TLS提供了验证服务器的手段，并且允许服务器请求进行客户端验证。</p>
<p>客户端<em><strong>必须</strong></em>验证服务器的身份。这通常包含两部分验证过程，一是验证证书中包含着服务器的身份，二是验证证书是由可信任的实体签发的（有关样例详见《<a href="">RFC2818</a>》）。</p>
<blockquote>
<p>注意：当服务器提供用于验证的证书时，证书链的尺寸可能消耗大量字节。控制证书链的尺寸对于QUIC的性能是十分关键的，因为服务器在验证客户端地址前可发送的字节数不能超过接收到字节数的3倍；详见《<a href="">QUIC传输</a>》的<a href="">第8.1章</a>。证书链的尺寸是可以被控制的，为此可以限制名称或扩展的数量；使用以较短的公钥表示方法，如ECDSA，表示的密钥；或使用证书压缩（详见《<a href="">COMPRESS</a>》）。</p>
</blockquote>
<p>服务器<em><strong>可以</strong></em>在握手期间请求进行客户端验证。如果客户端在被请求验证后不能够提供证明，那么服务器<em><strong>可以</strong></em>拒绝这条连接。对于客户端验证的要求会基于应用协议和部署方法的不同而不同。</p>
<p>服务器<em><strong>必须不</strong></em>使用握手后客户端验证（详见《<a href="">TLS13</a>》的<a href="">第4.6.2章</a>），因为QUIC提供的多路复用机制使得客户端不能将证书请求与触发它的应用层事件关联起来（详见《<a href="">HTTP2-TLS13</a>》）。更准确地说，在握手完成后服务器<em><strong>必须不</strong></em>发送TLS的<code>CertificateRequest</code>（证书请求）消息，并且客户端<em><strong>必须</strong></em>将接收到这种消息的情况视作类型为<code>PROTOCOL_VIOLATION</code>的连接错误。</p>

    </div>
</section>

        
    
        
            <section class="page" id="4.5_Session_Resumption">
    
        <h2>
    
            <a href="#4.5_Session_Resumption">4.5. 会话恢复</a>
    
        </h2>
    
    <div class="content">
        <p>QUIC可以使用TLS 1.3的会话恢复特性。这可以在握手完成后通过使用<strong>加密帧</strong>传递<code>NewSessionTicket</code>（新会话票据）消息的方式来做到。会话恢复可以被用于提供0-RTT，无论0-RTT是否被禁用。</p>
<p>使用会话恢复的终端可能需要在恢复会话时记录有关当前连接的一些信息。TLS会要求某些信息得到持续保留；详见《<a href="">TLS13</a>》的<a href="">第4.6.1章</a>。在恢复连接时，QUIC本身不依赖于任何被持续保留的状态，除非还使用了0-RTT；详见《<a href="">QUIC传输</a>》的<a href="">第7.4.1章</a>和<a href="">第4.6.1章</a>。应用协议可以依赖在被恢复的连接间持续保留的状态。</p>
<p>客户端可以将任何恢复会话所需的状态与会话票据一起存储起来。服务器可以使用会话票据来协助保存状态。</p>
<p>会话恢复使得服务器将原始连接上的活动与被恢复的连接关联起来，这可能涉及到客户端的隐私问题。客户端可以选择禁用恢复机制来避免建立这种关联。客户端<em><strong>不应该</strong></em>重用票据，因为这使得除服务器外的实体能够将不同连接关联起来；详见《<a href="">TLS13</a>》的<a href="">附录C.4</a>。</p>

    </div>
</section>

        
    
        
                <section class="page" id="4.6_0-RTT">
    
        <h2>
    
            <a href="#4.6_0-RTT">4.6. 0-RTT</a>
    
        </h2>
    
    <div class="content">
        <p>QUIC中的0-RTT特性使得客户端能够在握手完成前就发送应用数据。这是通过重用在先前的连接中协商的参数的方式来做到的。0-RTT的启用要求客户端记录一些关键参数，并向服务器提供一个TLS的会话票据，这个票据使得服务器能够恢复出一份与客户端所持有的信息保持一致的信息。</p>
<p>这份信息中包含了能决定TLS状态的参数（由《<a href="">TLS13</a>》管理）、QUIC传输参数、选择的应用协议和所有应用协议可能需要的信息；详见<a href="">第4.6.3章</a>。这份信息决定了如何组建0-RTT数据包和其中的内容。</p>
<p>为了确保两侧终端处的可用信息是一致的，所有用于建立0-RTT的信息均来自相同的连接。终端不能选择性地去除可能影响发送或处理0-RTT的信息。</p>
<p>《<a href="">TLS13</a>》对于原始连接和意图使用0-RTT的连接间的时间间隔设置了7天的上限。对于0-RTT的使用还存在其他限制，尤其是那些因潜在的重放攻击风险而施加的；详见<a href="">第9.2章</a>。</p>

    </div>
</section>


    
        
            <section class="page" id="4.6.1_Enabling_0-RTT">
    
        <h3>
    
            <a href="#4.6.1_Enabling_0-RTT">4.6.1. 启用0-RTT</a>
    
        </h3>
    
    <div class="content">
        <p>TLS在<code>NewSessionTicket</code>消息中定义的<code>early_data</code>（早期数据）扩展是为了（在<code>max_early_data_size</code>（最大早期数据尺寸）参数中）传达服务器愿意接受的TLS 0-RTT的数据量。QUIC并不使用TLS的早期数据。QUIC使用0-RTT数据包来传递早期数据。于是，<code>max_early_data_size</code>参数被重新定义，当它的值为<code>0xffffffff</code>时，意味着服务器愿意接受QUIC 0-RTT数据。想要表明服务器并不接受0-RTT数据，就要从<code>NewSessionTicket</code>中省略<code>early_data</code>扩展。客户端能够在QUIC 0-RTT中发送的数据量是由服务器提供的<code>initial_max_data</code>（初始最大数据量）传输参数控制的。</p>
<p>若<code>max_early_data_size</code>字段的值并非<code>0xffffffff</code>，则服务器<em><strong>必须不</strong></em>发送<code>early_data</code>扩展。如果客户端收到的<code>NewSessionTicket</code>中包含<code>early_data</code>扩展但是<code>max_early_data_size</code>是其他值，那么客户端<em><strong>必须</strong></em>将此情况视作类型为<code>PROTOCOL_VIOLATION</code>的连接错误。</p>
<p>想要发送0-RTT数据包的客户端在后续握手的<code>ClientHello</code>消息中使用<code>early_data</code>扩展；详见《<a href="">TLS13</a>》的<a href="">第4.2章</a>。然后它就能在0-RTT数据包中发送应用数据。</p>
<p>如果服务器曾发送过<strong>新令牌帧</strong>，那么尝试0-RTT的客户端可能还会提供一个地址验证令牌；详见《<a href="">QUIC传输</a>》的<a href="">第8.1章</a>。</p>

    </div>
</section>

        
    
        
            <section class="page" id="4.6.2_Accepting_and_Rejecting_0-RTT">
    
        <h3>
    
            <a href="#4.6.2_Accepting_and_Rejecting_0-RTT">4.6.2. 接受与拒绝0-RTT</a>
    
        </h3>
    
    <div class="content">
        <p>服务器通过在加密扩展（<code>EncryptedExtensions</code>）中发送<code>early_data</code>扩展的方式接受0-RTT；详见《<a href="">TLS13</a>》的<a href="">第4.2.10章</a>。随后服务器处理并确认它接收到的0-RTT数据包。</p>
<p>服务器通过发送不带<code>early_data</code>扩展的加密扩展（<code>EncryptedExtensions</code>）的方式拒绝0-RTT。如果服务器发送了TLS的<code>HelloRetryRequest</code>（问候重试请求），就意味着它拒绝了0-RTT。如果拒绝了0-RTT，那么服务器<em><strong>必须不</strong></em>处理任何0-RTT数据包，即使它有能力这么做。如果0-RTT被拒绝，那么客户端<em><strong>应该</strong></em>在有能力的情况下将收到一个对于0-RTT数据包的确认的情况视作类型为<code>PROTOCOL_VIOLATION</code>的连接错误。</p>
<p>当0-RTT被拒绝时，客户端假设的所有关于连接的特性都可能是不正确的。这包括应用协议、传输参数和任何应用配置的选择。因此客户端<em><strong>必须</strong></em>重置所有流的状态，包括与这些流相关的应用状态。</p>
<p>如果客户端接收到重试数据包或版本协商数据包，那么它<em><strong>可以</strong></em>再次尝试0-RTT。这些数据包并不标志着0-RTT被拒绝。</p>

    </div>
</section>

        
    
        
            <section class="page" id="4.6.3_Validating_0-RTT_Configuration">
    
        <h3>
    
            <a href="#4.6.3_Validating_0-RTT_Configuration">4.6.3. 验证0-RTT配置</a>
    
        </h3>
    
    <div class="content">
        <p>当服务器接收到了具有<code>early_data</code>扩展的<code>ClientHello</code>，它就必须决定是要接受还是拒绝来自客户端的0-RTT数据。TLS栈会参与这个决定（例如，检查<code>ClientHello</code>中是否包含那组恢复出来的加密套件；详见《<a href="">TLS13</a>》的<a href="">第4.2.10章</a>）。即使TLS栈没有拒绝0-RTT数据的理由，QUIC栈或使用QUIC的应用协议也可以拒绝0-RTT数据，因为与被恢复的会话关联的传输或应用配置与服务器的当前配置可能不一致。</p>
<p>为了关联0-RTT会话票据，QUIC需要额外的传输状态。一种常见的实现方法是使用无状态的会话票据并将这些状态存储在会话票据中。使用QUIC的应用协议可能对于关联和存储状态有着类似的要求。被关联的状态会被用于决定是否拒绝0-RTT。举例来说，HTTP/3设置（详见《<a href="">QUIC-HTTP</a>》）会决定怎样解释来自客户端的0-RTT数据。其他使用QUIC的应用协议为了决定接受还是拒绝0-RTT数据，可能有着不同的要求。</p>

    </div>
</section>

        
    



        
    
        
            <section class="page" id="4.7_HelloRetryRequest">
    
        <h2>
    
            <a href="#4.7_HelloRetryRequest">4.7. HelloRetryRequest</a>
    
        </h2>
    
    <div class="content">
        <p>可以使用<code>HelloRetryRequest</code>消息（详见《<a href="">TLS13</a>》的<a href="">第4.1.4章</a>）来请求客户端提供密钥共享值等新信息，或验证客户端的一些特征。在QUIC看来，<code>HelloRetryRequest</code>与其他使用初始数据包传递的加密握手消息没有差别。尽管理论上可以使用这项特性来进行地址验证，但是QUIC实现<em><strong>应该</strong></em>改用重试特性来做地址验证；详见《<a href="">QUIC传输</a>》的<a href="">第8.1章</a>。</p>

    </div>
</section>

        
    
        
            <section class="page" id="4.8_TLS_Errors">
    
        <h2>
    
            <a href="#4.8_TLS_Errors">4.8. TLS错误</a>
    
        </h2>
    
    <div class="content">
        <p>如果TLS遇到了错误，那么它会按照《<a href="">TLS13</a>》的<a href="">第6章</a>中定义的那样创建一个合适的警告。</p>
<p>TLS警告会被转换为QUIC的连接错误。为了使创建出的QUIC错误码落在为<code>CRYPTO_ERROR</code>（加密错误）保留的范围内，警告描述的值需要与<code>0x0100</code>相加；详见《<a href="">QUIC传输</a>》的<a href="">第20.1章</a>。相加的结果使用QUIC的类型为<code>0x1c</code>的<strong>连接关闭帧</strong>来发送。</p>
<p>QUIC仅仅有能力传达级别为“致命”的警告。在TLS 1.3中，“警告”级别的唯一用处是发送连接关闭的信号；详见《<a href="">TLS13</a>》的<a href="">第6.1章</a>。由于QUIC提供了关闭连接的替代机制，并且TLS连接只会在遇到错误时才被关闭，QUIC终端<em><strong>必须</strong></em>将所有来自TLS的警告都视作为“致命”级别。</p>
<p>QUIC允许使用通用的错误码来代替专门的错误码；详见《<a href="">QUIC传输</a>》的<a href="">第11章</a>。对TLS警告来说，这就表示允许将任何警告都替换为通用的警告，比如<code>handshake_failure</code>（握手失败，在QUIC中的错误码为<code>0x0128</code>）。终端<em><strong>可以</strong></em>使用通用的错误码来避免暴露加密信息。</p>

    </div>
</section>

        
    
        
                <section class="page" id="4.9_Discarding_Unused_Keys">
    
        <h2>
    
            <a href="#4.9_Discarding_Unused_Keys">4.9. 丢弃不再使用的密钥</a>
    
        </h2>
    
    <div class="content">
        <p>在QUIC移动到新的密级后，先前密级的数据包保护密钥就可以被弃用。这会在握手过程中以及密钥被更新时发生数次，详见<a href="">第6章</a>。</p>
<p>当新的数据包保护密钥可用时，先前的密钥不会被立即弃用。如果有处于较低密级的数据包包含着<strong>加密帧</strong>，那么用于重传其中数据的新帧<em><strong>必须</strong></em>使用相同密级发送。类似地，在确认这个较低密级的数据包时，终端要为这个密级的数据包创建确认。因此，在新密级密钥可用后的短暂时间内需要较低密级的密钥的情况是有可能出现的。</p>
<p>终端只有从对端收到了某个密级的所有加密握手消息并且对端也收到了所有相应消息时，才能弃用这个密级的密钥。要判断这一点，初始密钥和握手密钥使用不同的方法（详见<a href="">第4.9.1章</a>和<a href="">第4.9.2章</a>）。这些方法不会阻止数据包在某个密级上的发送与接收，因为对端可能还没有接收完所有必需的确认。</p>
<p>尽管终端可以持续保留旧的密钥，但是新数据<em><strong>必须</strong></em>使用当前可用的最高密级来发送。只有<strong>ACK帧</strong>和重传数据的<strong>加密帧</strong>会使用先前的密级来发送。这些数据包中还<em><strong>可以</strong></em>包含<strong>填充帧</strong>。</p>

    </div>
</section>


    
        
            <section class="page" id="4.9.1_Discarding_Initial_Keys">
    
        <h3>
    
            <a href="#4.9.1_Discarding_Initial_Keys">4.9.1. 弃用初始密钥</a>
    
        </h3>
    
    <div class="content">
        <p>受初始秘密值（详见<a href="">第5.2章</a>）保护的数据包是不受认证的，这意味着攻击者可以伪造数据包来干扰连接。为了限制这种攻击造成的影响，初始数据包保护密钥相比其他密钥会被更激进地弃用。</p>
<p>开始使用握手数据包就意味着不再需要交换初始数据包，因为只有在接收到所有初始数据包中的<strong>加密帧</strong>后才能创建握手密钥。因此，客户端<em><strong>必须</strong></em>在首次发送握手数据包时弃用握手密钥，同时服务器<em><strong>必须</strong></em>在首次成功处理握手数据包时弃用初始密钥。在此之后，终端<em><strong>必须不</strong></em>发送初始数据包。</p>
<p>这会丢弃初始密级的丢包恢复状态并且忽略所有未得到处理的初始数据包。</p>

    </div>
</section>

        
    
        
            <section class="page" id="4.9.2_Discarding_Handshake_Keys">
    
        <h3>
    
            <a href="#4.9.2_Discarding_Handshake_Keys">4.9.2. 弃用握手密钥</a>
    
        </h3>
    
    <div class="content">
        <p>当TLS的握手已确认（详见<a href="">第4.1.2章</a>）时，终端<em><strong>必须</strong></em>弃用它的握手密钥。</p>

    </div>
</section>

        
    
        
            <section class="page" id="4.9.3_Discarding_0-RTT_Keys">
    
        <h3>
    
            <a href="#4.9.3_Discarding_0-RTT_Keys">4.9.3. 弃用0-RTT密钥</a>
    
        </h3>
    
    <div class="content">
        <p>0-RTT数据包和1-RTT数据包共享同一个数据包号空间，并且客户端在发送了1-RTT数据包后就不会再发送0-RTT数据包（详见<a href="">第5.6章</a>）。</p>
<p>因此，客户端<em><strong>应该</strong></em>在建立了1-RTT密钥后立即弃用0-RTT密钥，因为在那之后它们不再有任何用处。</p>
<p>除此之外，服务器<em><strong>应该</strong></em>在接收到1-RTT数据包后立即弃用0-RTT密钥。然而，由于数据包乱序的存在，0-RTT数据包可能晚于1-RTT数据包到达。服务器<em><strong>应该</strong></em>暂时保留0-RTT密钥以能够解密乱序数据包而不需要等对端用1-RTT密钥重传其中的数据。在接收到1-RTT数据包后，服务器<em><strong>必须</strong></em>在一段较短的时间内弃用0-RTT密钥；<em><strong>推荐</strong></em>的时长是探测包超时时间（PTO，详见《<a href="">QUIC恢复</a>》）的三倍大小。如果服务器判断它已经接收到了所有0-RTT数据包，那么它<em><strong>可以</strong></em>提早弃用0-RTT密钥，这可以通过追踪缺失的数据包号来做到。</p>

    </div>
</section>

        
    



        
    



        
                <section class="page" id="5_Packet_Protection">
    
        <h1>
    
            <a href="#5_Packet_Protection">5. 数据包保护</a>
    
        </h1>
    
    <div class="content">
        <p>就像基于TCP的TLS一样，QUIC用衍生自TLS握手的密钥来保护数据包，使用的是由TLS协商的AEAD算法（详见《<a href="">AEAD</a>》）。</p>
<p>QUIC数据包的保护方法视数据包类型而定：</p>
<ul>
<li>
<p>版本协商数据包不受加密保护。</p>
</li>
<li>
<p>重试数据包使用<code>AEAD_AES_128_GCM</code>来提供保护以免受到意外修改，并且限制能够构造合法重试数据包的实体；详见<a href="">第5.8章</a>。</p>
</li>
<li>
<p>初始数据包使用<code>AEAD_AES_128_GCM</code>和衍生自客户端发送的首个初始数据包的目标连接ID字段的密钥；详见<a href="">第5.2章</a>。</p>
</li>
<li>
<p>所有其他类型的数据包在可信度和完整性上都受到健壮的加密保护，使用的是由TLS协商的密钥和加密算法。</p>
</li>
</ul>
<p>本章描述了怎样将数据包保护应用到握手数据包、0-RTT数据包和1-RTT数据包上。同样的数据包保护过程还会被应用到初始数据包上。然而，由于决定用于初始数据包的密钥的过程是公开的，所以这类数据包不被认为受到可信度和完整性保护。类似地，重试数据包使用了固定密钥所以也缺乏可信度和完整性保护。</p>

    </div>
</section>


    
        
            <section class="page" id="5.1_Packet_Protection_Keys">
    
        <h2>
    
            <a href="#5.1_Packet_Protection_Keys">5.1. 数据包保护密钥</a>
    
        </h2>
    
    <div class="content">
        <p>QUIC衍生数据包保护密钥的方法与TLS衍生记录保护密钥的方法是一致的。</p>
<p>每个密级在不同发送数据的方向上分别有各自的秘密值用来保护数据包。这些秘密值是由TLS衍生的（详见《<a href="">TLS13</a>》的<a href="">第7.1章</a>），并且会被QUIC用在除了初始密级外的所有其他密级上。用于初始密级的秘密值是基于客户端的初始目标连接ID计算出来的，详见<a href="">第5.2章</a>。</p>
<p>用于数据包保护的密钥是通过对TLS秘密值使用TLS提供的KDF（密钥衍生函数）的方式计算出来的。对于TLS 1.3，使用的KDF是在《<a href="">TLS13</a>》的<a href="">第7.1章</a>中介绍的<code>HKDF-Expand-Label</code>函数，协商出的加密套件中的哈希函数也会被用到。在QUIC中所有使用<code>HKDF-Expand-Label</code>的地方都使用零长度的<code>Context</code>参数。</p>
<p>注意，标签（<code>label</code>参数）是以ASCII（详见《<a href="">ASCII</a>》）字节的形式编码的字符串，其中不包含引号或任何末尾<code>NUL</code>字节。</p>
<p>为了和QUIC一起使用，其他版本的TLS<em><strong>必须</strong></em>提供类似的函数。</p>
<p>为了生成AEAD密钥，KDF的输入是当前密级的秘密值和值为<code>quic key</code>的标签；衍生初始化向量（<code>Initialization Vector</code>，IV）时，使用的标签值为<code>quic iv</code>；详见<a href="">第5.3章</a>。头部保护密钥使用的是值为<code>quic hp</code>的标签；详见<a href="">第5.4章</a>。使用以上标签能够区分QUIC和TLS的密钥；详见<a href="">第9.6章</a>。</p>
<p><code>quic key</code>和<code>quic hp</code>都被用来生成密钥，所以与这些标签一道交给<code>HKDF-Expand-Label</code>函数的<code>Length</code>字段的值是由AEAD或头部保护算法的密钥长度决定的。和<code>quic iv</code>一起使用的<code>Length</code>字段的值是AEAD随机数的最小长度，但不能小于8字节；详见《<a href="">AEAD</a>》。</p>
<p>总是使用来自TLS 1.3的<code>HKDF-Expand-Label</code>函数作为用于初始秘密值的KDF；详见<a href="">第5.2章</a>。</p>

    </div>
</section>

        
    
        
            <section class="page" id="5.2_Initial_Secrets">
    
        <h2>
    
            <a href="#5.2_Initial_Secrets">5.2. 初始秘密值</a>
    
        </h2>
    
    <div class="content">
        <p>数据包保护的过程适用于初始数据包，但是要使用的秘密值是从客户端首个初始数据包的目标连接ID字段衍生来的。</p>
<p>这个秘密值是通过对值为<code>0x38762cf7f55934b34d179ae6a4c80cadccbb7f0a</code>的盐和值为目标连接ID的输入密钥材料（IKM）应用<code>HKDF-Extract</code>（详见《<a href="">HKDF</a>》的<a href="">第2.2章</a>）来决定的。这能生成一个起中间作用的伪随机密钥（PRK），它被用来衍生出两个分别用于发送和接收的秘密值。</p>
<p>客户端用于构造初始数据包的秘密值是通过将该PRK和值为<code>client in</code>的标签输入至来自TLS（详见《<a href="">TLS13</a>》）的<code>HKDF-Expand-Label</code>函数来生成的，这会产生一个32字节长的秘密值。服务器以同样的形式并使用值为<code>server in</code>的标签来构造数据包。衍生初始秘密值和密钥时，HKDF使用的哈希函数是SHA-256（详见<a href="">SHA</a>）。</p>
<p>该过程的伪代码如下：</p>
<div id=Pseudocode_5_2_1 class="block ref">
<pre tabindex="0"><code>initial_salt = 0x38762cf7f55934b34d179ae6a4c80cadccbb7f0a
initial_secret = HKDF-Extract(initial_salt,
                              client_dst_connection_id)

client_initial_secret = HKDF-Expand-Label(initial_secret,
                                          &quot;client in&quot;, &quot;&quot;,
                                          Hash.length)
server_initial_secret = HKDF-Expand-Label(initial_secret,
                                          &quot;server in&quot;, &quot;&quot;,
                                          Hash.length)
</code></pre><p><a href="#Pseudocode_5_2_1"></a></p>
</div>
<p><code>HKDF-Expand-Label</code>使用的连接ID是客户端发送的初始数据包里的目标连接ID。它会是一个随机选择的值，除非客户端是在收到重试数据包后才创建的初始数据包，那么这时的目标连接ID是由服务器选择的。</p>
<p>将来版本的QUIC<em><strong>应该</strong></em>使用一个新的盐值，从而确保每个QUIC版本的密钥互不相同。这会使得仅能识别一种QUIC版本的中间设备无法读取或修改将来版本的数据包的内容。</p>
<p>对于初始数据包，必须使用在TLS 1.3中定义的<code>HKDF-Expand-Label</code>函数，即便可使用的TLS版本中并不包含TLS 1.3。</p>
<p>当服务器发送重试数据包以使用由服务器选择的连接ID时，用于构建后续初始数据包的秘密值会发生变化。在客户端为了响应来自服务器的初始数据包而更改目标连接ID时，这些秘密值不会发生变化。</p>
<blockquote>
<p>注意：目标连接ID字段的长度可以是不超过20字节的任意值，包括零长度，零长度的情况会在服务器发送具有零长度的源连接ID字段的重试数据包时出现。在启动重试流程后，初始密钥就不能使得客户端确信服务器接收到了它的数据包，所以客户端必须依靠包含重试数据包的通信才能验证服务器地址；详见《<a href="">QUIC传输</a>》的<a href="">第8.1章</a>。</p>
</blockquote>
<p><a href="">附录A</a>中展示了作为样例的初始数据包。</p>

    </div>
</section>

        
    
        
            <section class="page" id="5.3_AEAD_Usage">
    
        <h2>
    
            <a href="#5.3_AEAD_Usage">5.3. AEAD的使用</a>
    
        </h2>
    
    <div class="content">
        <p>QUIC数据包保护所用的带有关联数据的认证加密（AEAD）函数（详见《<a href="">AEAD</a>》）是在对TLS连接进行协商时产生的。例如，如果TLS要使用<code>TLS_AES_128_GCM_SHA256</code>这一组加密套件，那么就要使用<code>AEAD_AES_128_GCM</code>函数。</p>
<p>QUIC可以使用在《<a href="">TLS13</a>》中定义的任意一组加密套件，但是<code>TLS_AES_128_CCM_8_SHA256</code>除外。除非QUIC为某组加密套件定义了头部保护方案，否则<em><strong>必须不</strong></em>对此套件进行协商。本文档为《<a href="">TLS13</a>》中定义的除<code>TLS_AES_128_CCM_8_SHA256</code>外的所有加密套件都定义了头部保护方案。这些加密套件都具有16字节的认证标签并且会生成比输入要长16字节的输出。</p>
<p>对于一个提供了不受终端支持的加密套件的<code>ClientHello</code>（客户端问候），终端<em><strong>必须不</strong></em>拒绝它，否则将来的QUIC版本将无法部署新加密套件。此要求同样适用于<code>TLS_AES_128_CCM_8_SHA256</code>。</p>
<p>当构建数据包时，AEAD函数会在进行头部保护前被应用；详见<a href="">第5.4章</a>。未经保护的数据包头部是关联数据（A）的一部分。在处理数据包时，终端首先移除头部保护。</p>
<p>数据包的密钥和IV的计算方法如<a href="">第5.1章</a>所述。随机数，N，是通过组合数据包保护的IV和数据包号的方式来构造的。以网络字节序重建的62位QUIC数据包号会以在左侧补零的方式被扩充至IV的长度。扩充后的数据包号与IV的按位异或结果就是AEAD的随机数。</p>
<p>AEAD的关联数据，A，就是QUIC头部的内容，无论短包头还是长包头都是从首个字节开始，结束于且包含未受保护的数据包号。</p>
<p>AEAD的输入明文，P，就是QUIC数据包的载荷，如《<a href="">QUIC传输</a>》中所述。</p>
<p>AEAD的输出密文，C，会代替P被传输至对端。</p>
<p>一些AEAD函数对于在相同密钥和IV下能够加密的数据包数量有限制；详见<a href="">第6.6章</a>。这个限制值可能会低于数据包号的数量限制。在超出当前使用的AEAD所设的任何限制前，终端<em><strong>必须</strong></em>发起密钥更新（详见<a href="">第6章</a>）。</p>

    </div>
</section>

        
    
        
                <section class="page" id="5.4_Header_Protection">
    
        <h2>
    
            <a href="#5.4_Header_Protection">5.4. 头部保护</a>
    
        </h2>
    
    <div class="content">
        <p>QUIC数据包头部的一部分，尤其是数据包号字段，会受到某个密钥的保护，这个密钥单独衍生自数据包保护密钥和IV。使用值为<code>quic hp</code>的标签衍生的这个密钥被用于对那些没有暴露给路径上设备的字段提供可信度保护。</p>
<p>这项保护应用于首个字节的几个最低有效位，以及数据包号字段。对于长包头数据包，首个字节的四个最低有效位会受到保护；对于短包头数据包，首个字节的五个最低有效位会受到保护。不管是哪种形式的头部，都会覆盖到保留比特位和数据包号长度字段；短包头数据包的密钥阶段比特位也会受到保护。</p>
<p>在连接期间，即便是在经过密钥更新后（详见<a href="">第6章</a>），使用的头部保护密钥也保持不变。这使得头部保护可以被用来保护密钥阶段。</p>
<p>头部保护的过程不适用于重试数据包或版本协商数据包，这类数据包不包含受保护的载荷或任何会被此过程保护的字段。</p>

    </div>
</section>


    
        
            <section class="page" id="5.4.1_Header_Protection_Application">
    
        <h3>
    
            <a href="#5.4.1_Header_Protection_Application">5.4.1. 应用头部保护的过程</a>
    
        </h3>
    
    <div class="content">
        <p>头部保护会在数据包保护之后被应用（详见<a href="">第5.3章</a>）。数据包的密文会被采样并被用作某个加密算法的输入。使用的算法取决于协商出的AEAD。</p>
<p>该算法的输出是一个5字节的掩码，这个掩码会以按位异或的方式被应用到受保护的头部字段。数据包首个字节的几个最低有效位会被掩码首个字节的对应最低有效位掩饰起来，同时数据包号会被剩余字节掩饰起来。掩码中未使用的字节不会被使用，这种情况可能在遇到较短的数据包号编码结果时发生。</p>
<p><a href="">图6</a>展示了应用头部保护的样例算法。移除头部保护的过程只在决定数据包号长度（<code>pn_length</code>）这一步的顺序上与此有所不同（这里使用<code>^</code>来表示按位异或运算）。</p>
<div id=Figure_6_Header_Protection_Pseudocode class="block ref">
<pre tabindex="0"><code>mask = header_protection(hp_key, sample)

pn_length = (packet[0] &amp; 0x03) + 1
if (packet[0] &amp; 0x80) == 0x80:
  # 长包头: 掩饰4个比特位
  packet[0] ^= mask[0] &amp; 0x0f
else:
  # 短包头: 掩饰5个比特位
  packet[0] ^= mask[0] &amp; 0x1f

# pn_offset 是数据包号字段的起始位置
packet[pn_offset:pn_offset+pn_length] ^= mask[1:1+pn_length]
</code></pre><p><a href="#Figure_6_Header_Protection_Pseudocode">图6：头部保护的伪代码</a></p>
</div>
<p>每一组加密套件都有专门的头部保护函数的定义；详见<a href="">第5.4.3章</a>和<a href="">第5.4.4章</a>。</p>
<p><a href="">图7</a>展示了一个长包头数据包（初始数据包）和一个短包头数据包（1-RTT数据包）的样例。从<a href="">图7</a>中可以看出每种头部中被头部保护覆盖到的字段和受保护的数据包载荷中被采样的部分。</p>
<div id=Figure_7_Header_Protection_and_Ciphertext_Sample class="block ref">
<pre tabindex="0"><code>初始数据包 {
  包头形式 (1) = 1,
  固定比特位 (1) = 1,
  长数据包类型 (2) = 0,
  保留比特位 (2),      # 受保护
  数据包号长度 (2),    # 受保护
  版本 (32),
  目标连接ID长度 (8),
  目标连接ID (0..160),
  源连接ID长度 (8),
  源连接ID (0..160),
  令牌长度 (i),
  令牌 (..),
  长度 (i),
  数据包号 (8..32),   # 受保护
  数据包载荷 (0..24), # 跳过的部分
  数据包载荷 (128),   # 样本的部分
  数据包载荷 (..)     # 其余的部分
}

1-RTT数据包 {
  包头形式 (1) = 0,
  固定比特位 (1) = 1,
  自旋比特位 (1),
  保留比特位 (2),     # 受保护
  密钥阶段 (1),       # 受保护
  数据包号长度 (2),   # 受保护
  目标连接ID (0..160),
  数据包号 (8..32),   # 受保护
  数据包载荷 (0..24), # 跳过的部分
  数据包载荷 (128),   # 样本的部分
  数据包载荷 (..),    # 其余的部分
}
</code></pre><p><a href="#Figure_7_Header_Protection_and_Ciphertext_Sample">图7：头部保护与密文样本</a></p>
</div>
<p>在与QUIC共同使用TLS的某组加密套件前，<em><strong>必须</strong></em>为这组加密套件中的AEAD指定一种头部保护算法。本文档为<code>AEAD_AES_128_GCM</code>、<code>AEAD_AES_128_CCM</code>、<code>AEAD_AES_256_GCM</code>（《<a href="">AEAD</a>》中定义了这些基于AES的AEAD）和<code>AEAD_CHACHA20_POLY1305</code>（由《<a href="">CHACHA</a>》定义）定义了头部保护算法。在TLS选择加密套件之前，基于AES的头部保护（详见<a href="">第5.4.3章</a>）就会在使用<code>AEAD_AES_128_GCM</code>的数据包保护中被用到。</p>

    </div>
</section>

        
    
        
            <section class="page" id="5.4.2_Header_Protection_Sample">
    
        <h3>
    
            <a href="#5.4.2_Header_Protection_Sample">5.4.2. 头部保护的采样</a>
    
        </h3>
    
    <div class="content">
        <p>头部保护算法会用到头部保护密钥和来自数据包载荷字段的密文样本。</p>
<p>采样的字节数总是相同的，但是需要存在一种使得不知道数据包号字段的长度的接收方也有能力移除保护的方法。密文的样本采取自数据包号字段的起始位置向后偏移4个字节的位置。也就是说，在为头部保护采样数据包密文时，数据包号字段被假设为具有4个字节的长度（数据包号经编码后其长度的最大的可能值）。</p>
<p>终端<em><strong>必须</strong></em>丢弃过短以至于无法提供完整样本的数据包。</p>
<p>为了确保存在足够数据用于采样，数据包会被扩充从而使得经编码的数据包号与受保护载荷的长度之和至少要比头部保护所需样本的长度要大4个字节。《<a href="">TLS13</a>》中定义的加密套件——除<code>TLS_AES_128_CCM_8_SHA256</code>外，因为本文档没有为它定义头部保护方案——都具有16字节的扩充量和16字节的头部保护样本长度要求。这意味着如果数据包号被编码至单个字节中，那么在未经保护的载荷中需要有至少3个字节长的帧，或者在被编码至双字节中时需要有至少2个字节的帧。</p>
<p>可以使用以下伪代码来决定采样的密文：</p>
<div id=Pseudocode_5_4_2_1 class="block ref">
<pre tabindex="0"><code># pn_offset 是数据包号字段的起始位置
sample_offset = pn_offset + 4

sample = packet[sample_offset..sample_offset+sample_length]
</code></pre><p><a href="#Pseudocode_5_4_2_1"></a></p>
</div>
<p>可以这样计算短包头数据包的数据包号偏移：</p>
<div id=Pseudocode_5_4_2_2 class="block ref">
<pre tabindex="0"><code>pn_offset = 1 + len(connection_id)
</code></pre><p><a href="#Pseudocode_5_4_2_2"></a></p>
</div>
<p>而长包头数据包的数据包号偏移可以这样计算：</p>
<div id=Pseudocode_5_4_2_3 class="block ref">
<pre tabindex="0"><code>pn_offset = 7 + len(destination_connection_id) +
                len(source_connection_id) +
                len(payload_length)
if packet_type == Initial:
  pn_offset += len(token_length) +
               len(token)
</code></pre><p><a href="#Pseudocode_5_4_2_3"></a></p>
</div>
<p>举个例子，如果某个短包头数据包具有8字节的连接ID并且受到<code>AEAD_AES_128_GCM</code>的保护，那么样本就是从字节<code>13</code>至字节<code>28</code>（包含两端，且索引的起始值为<code>0</code>）。</p>
<p>单个UDP数据报中可以包含数个QUIC数据包。每个数据包都会被单独处理。</p>

    </div>
</section>

        
    
        
            <section class="page" id="5.4.3_AES-Based_Header_Protection">
    
        <h3>
    
            <a href="#5.4.3_AES-Based_Header_Protection">5.4.3. 基于AES的头部保护</a>
    
        </h3>
    
    <div class="content">
        <p>本节为<code>AEAD_AES_128_GCM</code>、<code>AEAD_AES_128_CCM</code>和<code>AEAD_AES_256_GCM</code>定义了数据包保护算法。<code>AEAD_AES_128_GCM</code>和<code>AEAD_AES_128_CCM</code>使用的是电子密码本（ECB）模式，128位的AES。<code>AEAD_AES_256_GCM</code>使用的是ECB模式，256位的AES。AES的定义详见《<a href="">AES</a>》。</p>
<p>该算法从数据包中采样16字节长的密文。这份样本会被用作AES-ECB的输入。用伪代码的方式将头部保护函数定义为：</p>
<div id=Pseudocode_5_4_3_1 class="block ref">
<pre tabindex="0"><code>header_protection(hp_key, sample):
  mask = AES-ECB(hp_key, sample)
</code></pre><p><a href="#Pseudocode_5_4_3_1"></a></p>
</div>

    </div>
</section>

        
    
        
            <section class="page" id="5.4.4_ChaCha20-Based_Header_Protection">
    
        <h3>
    
            <a href="#5.4.4_ChaCha20-Based_Header_Protection">5.4.4. 基于ChaCha20的头部保护</a>
    
        </h3>
    
    <div class="content">
        <p>若要使用<code>AEAD_CHACHA20_POLY1305</code>，进行头部保护时就要使用原始的ChaCha20函数，它被定义于《<a href="">CHACHA</a>》的<a href="">第2.4章</a>。它会使用一个256位的密钥和采样自数据包保护的输出的16个字节样本。</p>
<p>密文样本的前4个字节被用作块计数器。如果ChaCha20的实现要求计数器的输入是一个32位的整数而不是字节序列，那么这时就要将字节序列解释为一个小端编码的值。</p>
<p>剩余的12个字节被用作随机数。如果ChaCha20的实现要求随机数的输入是三个32位整数组成的数组而不是字节序列，那么这时就要将随机数的字节解释为一串小端编码的32位整数。</p>
<p>通过使用ChaCha20来保护5个值为<code>0</code>的字节，可以得到加密掩码。用伪代码的方式将头部保护函数定义为：</p>
<div id=Pseudocode_5_4_4_1 class="block ref">
<pre tabindex="0"><code>header_protection(hp_key, sample):
  counter = sample[0..3]
  nonce = sample[4..15]
  mask = ChaCha20(hp_key, counter, nonce, {0,0,0,0,0})
</code></pre><p><a href="#Pseudocode_5_4_4_1"></a></p>
</div>

    </div>
</section>

        
    



        
    
        
            <section class="page" id="5.5_Receiving_Protected_Packets">
    
        <h2>
    
            <a href="#5.5_Receiving_Protected_Packets">5.5. 接收受保护的数据包</a>
    
        </h2>
    
    <div class="content">
        <p>一旦终端成功地接收到了具有某个数据包号的数据包，那么对于相同数据包号空间中具有更高数据包号的所有数据包，如果终端无法使用相同的密钥或，如果存在密钥更新，后续的数据包保护密钥来移除它们的保护，那么它<em><strong>必须</strong></em>丢弃这些具有更高数据包号的数据包；详见<a href="">第6章</a>。类似地，看上去应该触发密钥更新却无法被成功地移除保护的数据包<em><strong>必须</strong></em>被丢弃。</p>
<p>无法移除数据包保护并不意味着受到了攻击或对端处出现了违背协议的错误。因为在数据包被严重延误时，QUIC使用的截断数据包号的编码方式有可能造成数据包号被错误地解码。</p>

    </div>
</section>

        
    
        
            <section class="page" id="5.6_Use_of_0-RTT_Keys">
    
        <h2>
    
            <a href="#5.6_Use_of_0-RTT_Keys">5.6. 0-RTT密钥的使用</a>
    
        </h2>
    
    <div class="content">
        <p>如果可以使用0-RTT密钥（详见<a href="">第4.6.1章</a>），那么在缺乏针对重放攻击的保护措施的情况下就必须限制它们的使用以避免针对QUIC协议的重放攻击。</p>
<p>在《<a href="">QUIC传输</a>》定义的各种帧中，<strong>流帧</strong>、<strong>重置流帧</strong>、<strong>停止发送帧</strong>和<strong>连接关闭帧</strong>在与0-RTT一起使用时可能是不安全的，因为它们携带着应用数据。在0-RTT中接收到的应用数据会使得客户端处的应用重复处理相同数据，而不是只处理一次。客户端如果重复处理了经重放的应用数据，那么有可能产生意外的副作用。因此客户端<em><strong>必须不</strong></em>将0-RTT用于应用数据，除非正在运行的应用有意要求这么做。</p>
<p>使用QUIC的应用协议<em><strong>必须</strong></em>提供一份文件并在其中定义允许使用0-RTT的范围；否则，0-RTT只能被用于传递没有携带应用数据的QUIC帧。例如，HTTP对应的这份内容被描述于《<a href="">HTTP-REPLAY</a>》中，并且被使用在HTTP/3里；详见《<a href="">QUIC-HTTP</a>》的<a href="">第10.9章</a>。</p>
<p>尽管重放数据包可能会引发额外的连接尝试，但是处理经重放的却未携带应用数据的帧的影响仅限于改变相关连接的状态。使用经重放的数据包无法使得TLS握手成功完成。</p>
<p>在TLS握手完成前，客户端<em><strong>可以</strong></em>对它发送的数据施加额外的限制。</p>
<p>否则，客户端将0-RTT密钥与1-RTT密钥等同对待，只不过它不能用0-RTT密钥发送特定类型的帧；详见《<a href="">QUIC传输</a>》的<a href="">第12.5章</a>。</p>
<p>如果客户端接收到了能够表明服务器已经接受0-RTT数据的信号，那么它可以继续发送0-RTT数据，直到它接收到了服务器的所有握手消息。如果客户端接收到了能够表明0-RTT数据被拒绝的信号，那么它<em><strong>应该</strong></em>停止发送0-RTT数据。</p>
<p>服务器<em><strong>必须不</strong></em>使用0-RTT密钥来保护数据包；它使用1-RTT密钥来保护对于0-RTT数据包的确认。客户端<em><strong>必须不</strong></em>尝试解密它接收到的0-RTT数据包，而是<em><strong>必须</strong></em>丢弃它们。</p>
<p>一旦客户端已经建立了1-RTT密钥，那么它<em><strong>必须不</strong></em>再发送0-RTT数据包。</p>
<blockquote>
<p>注意： 0-RTT数据可能在被服务器接收到时就得到确认，但是包含对于0-RTT数据的确认的数据包可能无法被客户端移除数据包保护，直到TLS握手完成。移除数据包保护所必需的1-RTT密钥只有在客户端接收到服务器所有的握手消息后才能被衍生出来。</p>
</blockquote>

    </div>
</section>

        
    
        
            <section class="page" id="5.7_Receiving_Out-of-Order_Protected_Packets">
    
        <h2>
    
            <a href="#5.7_Receiving_Out-of-Order_Protected_Packets">5.7. 接收乱序的受保护数据包</a>
    
        </h2>
    
    <div class="content">
        <p>因为有乱序和丢包的情况存在，受保护的数据包可能在终端接收到最后的TLS握手消息前就被接收到了。这时客户端还无法解密来自服务器的1-RTT数据包，或服务器还无法解密来自客户端的1-RTT数据包。任一终端<em><strong>必须不</strong></em>在握手完成前解密来自对端的1-RTT数据包。</p>
<p>即使服务器在接收到来自客户端的首条握手消息后就能建立1-RTT密钥，但它还不能确信此时客户端的状态：</p>
<ul>
<li>
<p>客户端还未经验证，除非服务器愿意接受预共享密钥并且已经验证过了客户端的预共享密钥绑定；详见《<a href="">TLS13</a>》的<a href="">第4.2.11章</a>。</p>
</li>
<li>
<p>客户端还未表现出活动的迹象，除非服务器已经用重试数据包或其他手段验证了客户端的地址；详见《<a href="">QUIC传输</a>》的<a href="">第8.1章</a>。</p>
</li>
<li>
<p>服务器准备对之响应的任何0-RTT数据都有可能是由重放攻击制造的。</p>
</li>
</ul>
<p>因此，服务器在握手完成前对1-RTT密钥的使用目的受限为数据的发送。服务器在TLS握手完成前<em><strong>必须不</strong></em>处理传入的受1-RTT密钥保护的数据包。因为发送确认就表明数据包中的所有帧都已经被处理了，所以服务器在TLS握手完成前不能发送对1-RTT数据包的确认。已接收到的受1-RTT密钥保护的数据包<em><strong>可以</strong></em>被存储起来，在将来握手完成时再解密和使用它们。</p>
<blockquote>
<p>注意：TLS的实现可能会在握手完成前就提供所有1-RTT秘密值。在握手完成前，QUIC的实现即使获得了1-RTT读取密钥，也不能使用这些密钥。</p>
</blockquote>
<p>服务器必须等待客户端的<code>Finished</code>（已结束）消息的这项要求意味着服务器依赖于那条消息被成功交付到服务器。客户端可以避免这种依赖暗含的队头阻塞问题，方法是将它的1-RTT数据包和一个包含着携带<code>Finished</code>消息的<strong>加密帧</strong>的握手数据包合并，直到其中一个握手数据包被确认。这使得服务器可以立即处理那些数据包。</p>
<p>服务器可能在接收到TLS的<code>ClientHello</code>前就接收到受0-RTT密钥保护的数据包。服务器<em><strong>可以</strong></em>保留这些数据包，并期待能接收到<code>ClientHello</code>以将它们解密。</p>
<p>客户端通常会在握手完成的同时得到1-RTT密钥。即使它拥有1-RTT的秘密值，客户端也<em><strong>必须不</strong></em>在TLS握手完成前处理传入的受1-RTT密钥保护的数据包。</p>

    </div>
</section>

        
    
        
            <section class="page" id="5.8_Retry_Packet_Integrity">
    
        <h2>
    
            <a href="#5.8_Retry_Packet_Integrity">5.8. 重试数据包的完整性</a>
    
        </h2>
    
    <div class="content">
        <p>重试数据包（详见《<a href="">QUIC传输</a>》的<a href="">第17.2.5章</a>）携带着重试完整性标签，该标签具有两项属性：它使得被网络意外破坏的数据包可以被丢弃，同时只有观测到初始数据包的实体才能发送合法的重试数据包。</p>
<p>重试完整性标签是一个长度为128位的字段，它是将以下参数作为<code>AEAD_AES_128_GCM</code>（详见《<a href="">AEAD</a>》）的输入而计算出的结果。</p>
<ul>
<li>
<p>密钥，K，是一个长度为128位的固定值<code>0xbe0c690b9f66575a1d766b54e368c84e</code>。</p>
</li>
<li>
<p>随机数，N，是一个长度为96位的固定值<code>0x461599d35d632bf2239825bb</code>。</p>
</li>
<li>
<p>明文，P，为空。</p>
</li>
<li>
<p>关联数据，A，是重试伪数据包的内容，如<a href="">图8</a>所示。</p>
</li>
</ul>
<p>密钥和随机数的值是通过对值为<code>0xd9c9943e6101fd200021506bcc02814c73030f25c79d71ce876eca876e6fca8e</code>的秘密值和值分别为<code>quic key</code>与<code>quic iv</code>的标签调用<code>HKDF-Expand-Label</code>而衍生出来的（详见<a href="">第5.1章</a>）。</p>
<div id=Figure_8_Retry_Pseudo-Packet class="block ref">
<pre tabindex="0"><code>重试伪数据包 {
  原始目标连接ID长度 (8),
  原始目标连接ID (0..160),
  包头形式 (1) = 1,
  固定比特位 (1) = 1,
  长数据包类型 (2) = 3,
  未使用 (4),
  版本 (32),
  目标连接ID长度 (8),
  目标连接ID (0..160),
  源连接ID长度 (8),
  源连接ID (0..160),
  重试令牌 (..),
}
</code></pre><p><a href="#Figure_8_Retry_Pseudo-Packet">图8：重试伪数据包</a></p>
</div>
<p>重试伪数据包不会被实际发送。它是通过对被实际发送的重试数据包移除重试完整性标签，再追加以下两个字段的方式来构建出来的：</p>
<dl>
<dt>原始目标连接ID长度（ODCID Length）：</dt>
<dd>
<p>原始目标连接ID长度字段中包含了跟在它后方的原始目标连接ID字段以字节为单位的长度，它被编码为一个8位无符号整型值。</p>
</dd>
<dt>原始目标连接ID（Original Destination Connection ID）：</dt>
<dd>
<p>原始目标连接ID包含了这个重试数据包正在响应的初始数据包中目标连接ID字段的值。这个字段的长度在原始目标连接ID长度字段中给出。这个字段的存在确保了合法的重试数据包只能由观测到初始数据包的实体构造出来。</p>
</dd>
</dl>

    </div>
</section>

        
    



        
                <section class="page" id="6_Key_Update">
    
        <h1>
    
            <a href="#6_Key_Update">6. 密钥更新</a>
    
        </h1>
    
    <div class="content">
        <p>当握手完成时（详见<a href="">第4.1.2章</a>），终端<em><strong>可以</strong></em>发起密钥更新。</p>
<p>使用密钥阶段比特位可以区分用于保护数据包的数据包保护密钥。密钥阶段比特位在第一组1-RTT数据包上被初始化为状态<code>0</code>，并在后续每次密钥更新时切换状态。</p>
<p>密钥阶段比特位使得接收方即使没有接收到第一个发送的会引发密钥材料变化的数据包，也能检测到这种变化。注意到密钥阶段比特位变化的终端会更新密钥，再解密那个比特位发生变化的数据包。</p>
<p>发起密钥更新会导致两侧终端均更新密钥。这与TLS不同，终端在后者中可以独立更新密钥。</p>
<p>这项机制代替了TLS的密钥更新机制，后者依赖于受到1-RTT加密密钥保护的<code>KeyUpdate</code>（密钥更新）消息。终端<em><strong>必须不</strong></em>发送TLS的<code>KeyUpdate</code>消息。终端<em><strong>必须</strong></em>将受到TLS的<code>KeyUpdate</code>消息的情况视作类型为<code>0x010a</code>的连接错误，它等价于TLS中致命级别的<code>unexpected_message</code>（意外的消息）警报；详见<a href="">第4.8章</a>。</p>
<p><a href="">图9</a>展示了密钥更新的过程，其中初始时使用的那组密钥（标记为<code>@M</code>）被更新后的密钥（标记为<code>@N</code>）代替了。密钥阶段比特位的值用中括号<code>[]</code>来表示。</p>
<blockquote>
<p>TODO：图9</p>
</blockquote>


<div id=Figure_9_Key_Update class="block ref">
    
        <object data="/RFC9000_Chinese_Translation/images/Figure_2_States_for_Sending_Parts_of_Streams.svg" type="image/svg+xml" style='width:93%'></object>
    
    <p><a href="#Figure_9_Key_Update">图9：密钥更新</a></p>
</div>

    </div>
</section>


    
        
            <section class="page" id="6.1_Initiating_a_Key_Update">
    
        <h2>
    
            <a href="#6.1_Initiating_a_Key_Update">6.1. 发起密钥更新</a>
    
        </h2>
    
    <div class="content">
        <p>终端为数据包保护维护着相互独立的读取秘密值和写入秘密值。终端通过更新数据包的写入秘密值并用它去保护新数据包的方式来发起密钥更新。终端如《<a href="">TLS13</a>》的<a href="">第7.2章</a>中所展示的那样，从已有的写入秘密值创建新的写入秘密值。这会用到由TLS提供的KDF函数和值为<code>quic ku</code>的标签。该秘密值会如<a href="">第5.1章</a>中所述的那样，创建出相应的密钥和IV。而头部保护密钥不会被更新。</p>
<p>举个例子，在使用TLS 1.3时，为了更新写入密钥，要这样使用<code>HKDF-Expand-Label</code>：</p>
<div id=Pseudocode_6_1_1 class="block ref">
<pre tabindex="0"><code>secret_&lt;n+1&gt; = HKDF-Expand-Label(secret_&lt;n&gt;, &quot;quic ku&quot;,
                                 &quot;&quot;, Hash.length)
</code></pre><p><a href="#Pseudocode_6_1_1"></a></p>
</div>
<p>终端会切换密钥阶段比特位的状态，并将更新后的密钥和IV用于保护后续数据包。</p>
<p>在握手已确认（详见<a href="">第4.1.2章</a>）前，终端<em><strong>必须不</strong></em>发起密钥更新。在终端接收到对于受当前密钥阶段的密钥保护的数据包的确认前，它<em><strong>必须不</strong></em>发起后续的密钥更新。这确保了再一次发起密钥更新前，当前密钥在两侧终端处均为可用状态。要做到这一点，可以追踪用各个密钥阶段的密钥发送的最小数据包号，以及在1-RTT空间中的最大已确认数据包号：一旦后者大于等于前者，就可以再发起一次密钥更新。</p>
<blockquote>
<p>注意：非1-RTT数据包的密钥从不会被更新；它们的密钥一定是从TLS握手状态中衍生出来的。</p>
</blockquote>
<p>发起密钥更新的终端还会更新用于接收数据包的密钥。这些密钥会在更新后被用于处理对端发送的数据包。</p>
<p>在成功移除了使用新密钥发送的数据包的保护前，终端<em><strong>必须</strong></em>保留旧密钥。在成功移除了使用新密钥发送的数据包的保护后，终端<em><strong>应该</strong></em>将旧密钥保留一段时间。过早地弃用旧密钥会导致延误的数据包被丢弃。丢弃数据包的行为会被对端当作数据包遭遇了丢包，反而会影响性能。</p>

    </div>
</section>

        
    
        
            <section class="page" id="6.2_Responding_to_a_Key_Update">
    
        <h2>
    
            <a href="#6.2_Responding_to_a_Key_Update">6.2. 响应密钥更新</a>
    
        </h2>
    
    <div class="content">
        <p>在接收到对于受当前密钥阶段的密钥保护的数据包的确认后，对端就可以发起密钥更新。终端在处理到一个密钥阶段的值与它曾发出的最后一个数据包中的值不同的数据包时，会将该情况视作为密钥更新。为了处理这个数据包，终端要使用下一阶段中的数据包保护密钥和IV。有关创建这些密钥时的考量，详见<a href="">第6.3章</a>。</p>
<p>如果某个数据包可以使用下一阶段中的密钥和IV来处理，就说明对端发起了密钥更新。作为响应，终端<em><strong>必须</strong></em>将它的发送密钥更新到相应的密钥阶段，如<a href="">第6.1章</a>所述。在发送对于使用了更新后的密钥来接收的数据包的确认前，<em><strong>必须</strong></em>更新发送密钥。通过用受更新后的密钥保护的数据包来确认触发密钥更新的数据包的方式，终端发送出密钥更新完成的信号。</p>
<p>终端可以根据自己平时的数据包发送习惯，推迟发送数据包或确认：没有必要为了响应密钥更新而立即创建新数据包。终端发送的下一个数据包会用上更新后的密钥。下一个包含确认的数据包会使得密钥更新完成。如果终端检测到了第二次密钥更新，但它这时还没有使用更新后的密钥发送包含对于触发前一次密钥更新的数据包的响应的数据包，那么这就表明对端没有等待确认就更新了密钥两次。终端<em><strong>可以</strong></em>将这样的连续密钥更新行为视作类型为<code>KEY_UPDATE_ERROR</code>（密钥更新错误）的连接错误。</p>
<p>如果终端接收到的确认来自受旧密钥保护的数据包，但确认是对于受新密钥保护的数据包的，那么它<em><strong>可以</strong></em>将这种情况视作类型为<code>KEY_UPDATE_ERROR</code>的连接错误。这表明对端已经接收到并且确认了发起密钥更新的数据包，但是在响应时没有更新密钥。</p>

    </div>
</section>

        
    
        
            <section class="page" id="6.3_Timing_of_Receive_Key_Generation">
    
        <h2>
    
            <a href="#6.3_Timing_of_Receive_Key_Generation">6.3. 对创建接收密钥的计时</a>
    
        </h2>
    
    <div class="content">
        <p>终端在响应密钥更新时<em><strong>必须不</strong></em>产生在计时侧信道上可能表明密钥阶段比特位的有效性（详见<a href="">第9.5章</a>）的信号。当未批准进行密钥更新时，终端可以假装进行密钥更新，并使用随机化的数据包保护密钥来代替因更新而被弃用的密钥。使用随机化的密钥确保了移除数据包保护的尝试不会造成计时结果的变化，且具有无效的密钥阶段比特位的数据包会被正确地拒绝。</p>
<p>在接收数据包时，创建新的数据包保护密钥的过程可能透露出这期间进行了密钥更新。终端<em><strong>可以</strong></em>将创建新密钥作为数据包处理的一部分，但是这会产生计时上的信号，这个信号会被攻击者用于学习密钥更新的发生时机，从而泄露密钥阶段比特位的值。</p>
<p>通常，当前阶段中的和下一阶段中的数据包保护密钥应该都是对终端可用的。在密钥更新完成后不超过PTO的短暂时间里，终端<em><strong>可以</strong></em>延迟下一组接收用的数据包保护密钥的建立。这使得终端只需要维护两组接收密钥；详见<a href="">第6.5章</a>。</p>
<p>下一组数据包保护密钥一旦生成就<em><strong>应该</strong></em>被持续保留，哪怕接收到的数据包后来被丢弃了。看上去包含密钥更新的数据包很容易伪造，尽管密钥更新的过程不需要大量计算资源，但是攻击者还是可以触发它来进行拒绝服务攻击。</p>
<p>因此，终端<em><strong>必须</strong></em>有能力维护两组用于接收数据包的数据包保护密钥：当前阶段中的和下一阶段中的。维护除此之外的先前的密钥可能会提升性能，但是这是不必要的。</p>

    </div>
</section>

        
    
        
            <section class="page" id="6.4_Sending_with_Updated_Keys">
    
        <h2>
    
            <a href="#6.4_Sending_with_Updated_Keys">6.4. 使用更新后的密钥来发送</a>
    
        </h2>
    
    <div class="content">
        <p>终端绝不会发送受旧密钥保护的数据包。只有当前阶段的密钥会被用到。切换到新密钥后，用于保护数据包的旧密钥可以被立即弃用。</p>
<p>用于保护具有更大数据包号的数据包的密钥<em><strong>必须</strong></em>与用于保护更小数据包号数据包的密钥一致，或比后者更新。如果终端用旧密钥移除了保护，但具有更小数据包号的数据包是受新密钥保护的，那么它<em><strong>必须</strong></em>将这种情况视作类型为<code>KEY_UPDATE_ERROR</code>的连接错误。</p>

    </div>
</section>

        
    
        
            <section class="page" id="6.5_Receiving_with_Different_Keys">
    
        <h2>
    
            <a href="#6.5_Receiving_with_Different_Keys">6.5. 使用不同的密钥来接收</a>
    
        </h2>
    
    <div class="content">
        <p>在密钥更新期间，可能会接收到受旧密钥保护的数据包，它们因为被网络延误而刚刚抵达。保留旧的数据包保护密钥使得这些数据包能够被成功处理。</p>
<p>由于受来自下一阶段的密钥保护的数据包会与受来自上一阶段的密钥保护的数据包使用相同的密钥阶段，要想处理受旧密钥保护的数据包，就有必要区分这两种数据包。这可以通过使用数据包号来做到。如果重建出来的数据包号比当前密钥阶段的任一数据包号要小，那么这些数据包就要使用上一阶段的数据包保护密钥；如果重建出来的数据包号比当前密钥阶段的任一数据包号要大，那么这些数据包就要使用下一阶段的数据包保护密钥。</p>
<p>为了确保在上一阶段、当前阶段和下一阶段的数据包保护密钥间选择的过程不会在计时侧信道上泄露最终用于移除数据包保护的是哪一组密钥，必须谨慎操作。有关更多信息，详见<a href="">第9.5章</a>。</p>
<p>作为替代方案，终端可以仅维护两组数据包保护密钥，只需在经过对网络重排序来说充足的时间后将上一阶段的密钥替换为下一阶段的密钥。在这种情况下，只需要密钥阶段比特位就足以选择密钥。</p>
<p>在将下一阶段的接收密钥提升为当前阶段后，终端<em><strong>可以</strong></em>在建立再下一组数据包保护密钥前等待一段约为一个探测包超时（PTO；详见《<a href="">QUIC恢复</a>》）的时间。这组被推迟建立的新密钥<em><strong>可以</strong></em>在经过这段等待时间后才替换上一阶段的旧密钥。只不过有一个缺点，即PTO是一个主观的测量结果——也就是说，对端对于RTT的预估可能不同——这段等待时间既应该足够长以使得所有乱序数据包哪怕被确认了也都会被对端认定为丢包，又应该足够短以使得对端可以发起后续的密钥更新。</p>
<p>在对端保留旧密钥期间，对端可能无法解密发起密钥更新的数据包，终端需要允许这种情况的存在。在接收到能够表明先前的密钥更新已经被接收到的确认后，终端在发起密钥更新前<em><strong>应该</strong></em>等待一段时长为PTO三倍大小的时间。若没有留足时间，可能导致数据包被丢弃。</p>
<p>在接收到受新密钥保护的数据包后，终端保留旧的读取密钥的时长<em><strong>应该</strong></em>不超过PTO的三倍。在这段等待时间之后，旧的读取密钥和它们对应的秘密值<em><strong>应该</strong></em>被弃用。</p>

    </div>
</section>

        
    
        
            <section class="page" id="6.6_Limits_on_AEAD_Usage">
    
        <h2>
    
            <a href="#6.6_Limits_on_AEAD_Usage">6.6. AEAD的用量上限</a>
    
        </h2>
    
    <div class="content">
        <p>本文档为AEAD设置了用量上限以确保在使用QUIC时哪怕过量使用AEAD也不会在通信的可信度和完整性上给予攻击者过多的优势。</p>
<p>TLS 1.3中定义的用量上限是为了抵御针对可信度的攻击，只有遵从这些限制，使用AEAD的保护才是有效的。认证加密中的完整性保护也依赖于对伪造数据包的尝试次数进行限制。TLS是以一遇到未通过认证校验的记录就关闭连接的方式做到这一点的。相比之下，QUIC会忽略无法通过认证的所有数据包，允许多次尝试伪造数据包。</p>
<p>QUIC为AEAD的可信度上限和完整性上限分别进行计数。在可信度方面，限制某个密钥可以加密的数据包数量。在完整性方面，限制某个连接中可以解密的数据包数量。下文是有关为各种AEAD算法施加限制的细节。</p>
<p>终端<em><strong>必须</strong></em>为每一组密钥单独计算加密数据包的数量。如果同一密钥的加密数据包总数超过了所选AEAD的可信度上限，那么终端<em><strong>必须</strong></em>停止使用这组密钥。在发送的受保护数据包数量超过所选AEAD允许的可信度上限前，终端<em><strong>必须</strong></em>发起密钥更新。如果无法进行密钥更新或触及了完整性上限，那么终端<em><strong>必须</strong></em>停止使用当前连接，并且以仅仅发送无状态重置的方式响应接收到的数据包。<em><strong>推荐</strong></em>终端在进入无法进行密钥更新的状态前立即用类型为<code>AEAD_LIMIT_REACHED</code>（触及AEAD上限）的连接错误来关闭连接。</p>
<p>对于<code>AEAD_AES_128_GCM</code>和<code>AEAD_AES_256_GCM</code>，可信度上限为<code>2<sup>23</sup></code>个加密数据包；详见<a href="">附录B.1</a>。对于<code>AEAD_CHACHA20_POLY1305</code>，其可信度上限要比可能的数据包数量（<code>2<sup>62</sup></code>）还大，因此不用考虑。对于<code>AEAD_AES_128_CCM</code>，可信度上限是<code>2<sup>21.5</sup></code>个加密数据包；详见<a href="">附录B.2</a>。</p>
<p>除了要为发送的数据包计数外，终端<em><strong>必须</strong></em>为在一条连接的存活期间内接收到但未通过认证的数据包计数。如果在某条连接中接收到但未通过认证的数据包总数，无论受什么密钥保护，超过了所选AEAD的完整性上限，那么终端<em><strong>必须</strong></em>立即用类型为<code>AEAD_LIMIT_REACHED</code>的连接错误来关闭连接，并且不再处理更多数据包。</p>
<p>对于<code>AEAD_AES_128_GCM</code>和<code>AEAD_AES_256_GCM</code>，完整性上限为<code>2<sup>52</sup></code>个非法数据包；详见<a href="">附录B.1</a>。对于<code>AEAD_CHACHA20_POLY1305</code>，完整性上限为<code>2<sup>36</sup></code>个非法数据包；详见《<a href="">AEBounds</a>》。对于<code>AEAD_AES_128_CCM</code>，完整性上限为<code>2<sup>21.5</sup></code>个非法数据包；详见<a href="">附录B.2</a>。应用这些限制能够降低攻击者成功伪造数据包的可能性；详见《<a href="">AEBounds</a>》、《<a href="">ROBUST</a>》和《<a href="">GCM-MU</a>》。</p>
<p>限制数据包尺寸的终端<em><strong>可以</strong></em>使用更高的可信度上限和完整性上限；有关细节详见<a href="">附录B</a>。</p>
<p>将来的分析与规范<em><strong>可以</strong></em>放松对于某AEAD的可信度上限或完整性上限。</p>
<p>可以被用于QUIC的任一TLS加密套件<em><strong>必须</strong></em>定义相关AEAD函数在可信度和完整性方面的用量上限。也就是说，这些限制<em><strong>必须</strong></em>准确指出允许被认证的数据包数量和允许未通过认证的数据包数量。提供一份分析如何计算该值的参考文献——并指出所有在此分析中使用到的假设——使得限制值能够变化以适应不同的使用条件。</p>

    </div>
</section>

        
    
        
            <section class="page" id="6.7_Key_Update_Error_Code">
    
        <h2>
    
            <a href="#6.7_Key_Update_Error_Code">6.7. 密钥更新的错误码</a>
    
        </h2>
    
    <div class="content">
        <p>错误码<code>KEY_UPDATE_ERROR</code>（<code>0x0e</code>）被用于发送与密钥更新相关的错误的信号。</p>

    </div>
</section>

        
    



        
                <section class="page" id="7_Security_of_Initial_Messages">
    
        <h1>
    
            <a href="#7_Security_of_Initial_Messages">7. 初始消息的安全性</a>
    
        </h1>
    
    <div class="content">
        <p>初始数据包并不受密钥的保护，因此它们可能会被攻击者篡改。QUIC提供的保护可以阻挡无法读取数据包的攻击者，但此保护并不足以抵御来自有能力观测和注入数据包的攻击者的攻击。部分形式的篡改——例如对TLS消息的修改——能被检测出来，但是另一些——例如对<strong>ACK帧</strong>的修改——则不能。</p>
<p>举例来说，攻击者可以注入一个包含虚假<strong>ACK帧</strong>的数据包，以使得某个数据包貌似还没被接收到，或者使得终端对连接的状态建立起错误印象（可以通过修改ACK延迟的方法）。注意，这样的数据包会使得本应合法的数据包被终端认定为重复而丢弃它们。对于初始数据包中包含的未经其他途径验证的数据，QUIC实现<em><strong>应该</strong></em>谨慎地使用它们。</p>
<p>攻击者还有可能篡改使用握手数据包传递的数据，但由于这类篡改依赖于对TLS握手消息的修改，所以它们会使得TLS握手失败。</p>

    </div>
</section>




        
                <section class="page" id="8_QUIC-Specific_Adjustments_to_the_TLS_Handshake">
    
        <h1>
    
            <a href="#8_QUIC-Specific_Adjustments_to_the_TLS_Handshake">8. QUIC中对TLS握手的调整</a>
    
        </h1>
    
    <div class="content">
        <p>与QUIC一起使用时，TLS某些方面的行为会发生变化。</p>
<p>QUIC还要求TLS提供额外功能。除了协商加密参数外，TLS握手还要传递和认证QUIC的传输参数。</p>

    </div>
</section>


    
        
            <section class="page" id="8.1_Protocol_Negotiation">
    
        <h2>
    
            <a href="#8.1_Protocol_Negotiation">8.1. 协议协商</a>
    
        </h2>
    
    <div class="content">
        <p>QUIC要求加密握手提供经认证的协议协商过程。TLS使用应用层协议协商（ALPN，详见《<a href="">ALPN</a>》）来选择应用协议。终端<em><strong>必须</strong></em>使用ALPN来协商应用协议，除非使用了其他机制来就应用协议达成一致。</p>
<p>在使用ALPN时，如果没有协商出应用协议，那么终端<em><strong>必须</strong></em>立即使用值为<code>no_application_protocol</code>（无应用协议）的TLS警告（QUIC的错误码为<code>0x0178</code>；详见<a href="">第4.8章</a>）来关闭连接（详见《<a href="">QUIC传输</a>》的<a href="">第10.2章</a>）。尽管《<a href="">ALPN</a>》中只规定了服务器要使用此警告，但是QUIC客户端在ALPN协商失败时<em><strong>必须</strong></em>使用类型为<code>0x0178</code>的错误来终止连接。</p>
<p>应用协议<em><strong>可以</strong></em>限制它所操作的QUIC版本。服务器<em><strong>必须</strong></em>选择一个与客户端所选QUIC版本兼容的应用协议。服务器<em><strong>必须</strong></em>将无法选出兼容的应用协议的情况视作类型为<code>0x0178</code>（相当于<code>no_application_protocol</code>）的连接错误。类似地，客户端<em><strong>必须</strong></em>将服务器选择了不兼容的应用协议的情况视作类型为<code>0x0178</code>的连接错误。</p>

    </div>
</section>

        
    
        
            <section class="page" id="8.2_QUIC_Transport_Parameters_Extension">
    
        <h2>
    
            <a href="#8.2_QUIC_Transport_Parameters_Extension">8.2. QUIC传输参数扩展</a>
    
        </h2>
    
    <div class="content">
        <p>QUIC传输参数是使用TLS扩展来传递的。不同的QUIC版本可能为传输配置的协商定义不同方法。</p>
<p>在TLS握手中包含传输参数，就可以为这些值提供完整性保护。</p>
<div id=Pseudocode_8_2_1 class="block ref">
<pre tabindex="0"><code>enum {
  quic_transport_parameters(0x39), (65535)
} ExtensionType;
</code></pre><p><a href="#Pseudocode_8_2_1"></a></p>
</div>
<p><code>quic_transport_parameters</code>（QUIC传输参数）扩展的<code>extension_data</code>（扩展数据）字段中包含的是一个由正在使用的QUIC版本定义的值。</p>
<p><code>quic_transport_parameters</code>扩展是在握手期间使用<code>ClientHello</code>（客户端问候）和<code>EncryptedExtensions</code>（加密扩展）消息来传递的。终端<em><strong>必须</strong></em>发送<code>quic_transport_parameters</code>扩展；接收到不带<code>quic_transport_parameters</code>扩展的<code>ClientHello</code>消息或<code>EncryptedExtensions</code>消息的终端<em><strong>必须</strong></em>使用类型为<code>0x016d</code>（相当于TLS中致命级别的<code>missing_extension</code>警告，详见<a href="">第4.8章</a>）的错误来关闭连接。</p>
<p>传输参数在握手完成前就会变为可用。服务器可以在握手完成前就使用这些值。不过，直到握手完成，传输参数的值都是未经认证的，所以即使提前使用这些参数也不要依赖于它们的真实性。任何对于传输参数的篡改最终都会使得握手失败。</p>
<p>终端<em><strong>必须不</strong></em>在并未使用QUIC的TLS连接中（例如在《<a href="">TLS13</a>》中定义的基于TCP的TLS连接）发送此扩展。如果在非QUIC的传输中接收到了这个扩展，那么支持此扩展的终端<em><strong>必须</strong></em>发送致命级别的<code>unsupported_extension</code>警告。</p>
<p>协商<code>quic_transport_parameters</code>扩展会使得<code>EndOfEarlyData</code>（早期数据结束）被移除；详见<a href="">第8.3章</a>。</p>

    </div>
</section>

        
    
        
            <section class="page" id="8.3_Removing_the_EndOfEarlyData_Message">
    
        <h2>
    
            <a href="#8.3_Removing_the_EndOfEarlyData_Message">8.3. 移除EndOfEarlyData消息</a>
    
        </h2>
    
    <div class="content">
        <p>QUIC中不会使用TLS的<code>EndOfEarlyData</code>消息。QUIC并不使用这条消息去标记0-RTT数据的结束位置，或去发送握手密钥发生变化的信号。</p>
<p>客户端<em><strong>必须不</strong></em>发送<code>EndOfEarlyData</code>消息。服务器<em><strong>必须</strong></em>将在0-RTT数据包中接收到<strong>加密帧</strong>的情况视作类型为<code>PROTOCOL_VIOLATION</code>（协议违背）的连接错误。</p>
<p>于是，<code>EndOfEarlyData</code>不会出现在TLS握手的记录单（<code>transcript</code>）中。</p>

    </div>
</section>

        
    
        
            <section class="page" id="8.4_Prohibit_TLS_Middlebox_Compatibility_Mode">
    
        <h2>
    
            <a href="#8.4_Prohibit_TLS_Middlebox_Compatibility_Mode">8.4. 禁止TLS的中间设备兼容模式</a>
    
        </h2>
    
    <div class="content">
        <p>《<a href="">TLS13</a>》的<a href="">附录D.4</a>描述了TLS 1.3握手的一种替代方案，并将之作为某些中间设备上程序出错时的应对措施。TLS 1.3中的这种中间设备兼容模式需要将<code>ClientHello</code>和<code>ServerHello</code>（服务器问候）中的<code>legacy_session_id</code>（兼容会话ID）字段设置为一个32字节长的值，随后发送<code>change_cipher_spec</code>（更改加密设置）记录。这个字段和记录不传递任何具有语义的内容，并且会被忽略。</p>
<p>这个模式在QUIC中没有用处，因为它只适用于会干预基于TCP的TLS的中间设备。同时QUIC也没有提供任何传递<code>change_cipher_spec</code>记录的方法。客户端<em><strong>必须不</strong></em>请求使用TLS 1.3的兼容模式。服务器<em><strong>应该</strong></em>将接收到<code>legacy_session_id</code>字段非空的TLS<code>ClientHello</code>的情况视作类型为<code>PROTOCOL_VIOLATION</code>的连接错误。</p>

    </div>
</section>

        
    



        
                <section class="page" id="9_Security_Considerations">
    
        <h1>
    
            <a href="#9_Security_Considerations">9. 关于安全性的考量</a>
    
        </h1>
    
    <div class="content">
        <p>所有适用于TLS的关于安全性的考量同样适用于QUIC中的TLS。通读《<a href="">TLS13</a>》及其附录是理解QUIC的安全属性的最佳方式。</p>
<p>本章概述了特定于TLS集成在其他协议中时的一些重要的关于安全性的考量，不过本文档中的其余部分中还有许多与安全性相关的细节。</p>

    </div>
</section>


    
        
            <section class="page" id="9.1_Session_Linkability">
    
        <h2>
    
            <a href="#9.1_Session_Linkability">9.1. 会话的可关联性</a>
    
        </h2>
    
    <div class="content">
        <p>TLS会话票据的使用使得服务器或其他实体能够将同一客户端创建的连接相互关联起来；有关细节详见<a href="">第4.5章</a>。</p>

    </div>
</section>

        
    
        
            <section class="page" id="9.2_Replay_Attacks_with_0-RTT">
    
        <h2>
    
            <a href="#9.2_Replay_Attacks_with_0-RTT">9.2. 与0-RTT相关的重放攻击</a>
    
        </h2>
    
    <div class="content">
        <p>正如《<a href="">TLS13</a>》的<a href="">第8章</a>所述，只要使用了TLS早期数据就会被暴露于重放攻击之下。QUIC的0-RTT有着类似的风险。</p>
<p>终端<em><strong>必须</strong></em>实现并使用《<a href="">TLS13</a>》中描述的重放保护，然而这些保护并不被认为是完美的。因此，对于重放攻击的风险还需要更多考量。</p>
<p>QUIC并不易受到重放攻击，除非是利用QUIC传递的应用协议信息的攻击。基于在《<a href="">QUIC传输</a>》中定义的帧类型的QUIC协议状态管理机制不易受到重放攻击。QUIC帧的处理是幂等的，在帧被重放、乱序或遭遇丢包时不会引发连接状态异常。QUIC连接期间产生的副作用在连接的生命周期结束后就会失效，除非是那些由QUIC承载的应用协议产生的副作用。</p>
<p>TLS会话票据和地址验证令牌被用于在不同的连接间传递QUIC配置信息，尤其是，它使得服务器能够在连接建立和地址验证时高效地恢复状态数据。<em><strong>必须不</strong></em>使用它们在终端间传递应用语义；客户端<em><strong>必须</strong></em>将它们视作为内容不透明的值。如果这些令牌有可能被重用，那么它们就需要更强的针对重放攻击的保护。</p>
<p>在某条连接上接受0-RTT的服务器比不接受0-RTT的服务器要消耗更多的计算资源。服务器在接受0-RTT时需要考虑到重放的可能性以及其他相关资源的消耗。</p>
<p>管理与0-RTT相关的重放攻击的风险，其最终的责任在于应用协议。使用QUIC的应用协议<em><strong>必须</strong></em>描述该协议会怎样使用0-RTT以及用于抵御重放攻击的手段。对于重放风险的分析需要考虑所有会传递应用语义的QUIC协议特性。</p>
<p>要抵御重放攻击，完全禁用0-RTT是最有效的。</p>
<p>QUIC扩展<em><strong>必须</strong></em>描述重放攻击会如何影响扩展的行为，或禁止与0-RTT一起被使用。应用协议<em><strong>必须</strong></em>禁止使用会在0-RTT中传递应用语义的扩展，或提供抵御重放攻击的策略。</p>

    </div>
</section>

        
    
        
            <section class="page" id="9.3_Packet_Reflection_Attack_Mitigation">
    
        <h2>
    
            <a href="#9.3_Packet_Reflection_Attack_Mitigation">9.3. 数据包放大攻击的抵御</a>
    
        </h2>
    
    <div class="content">
        <p>如果一条较小的<code>ClientHello</code>（客户端问候）能使得服务器响应巨大的握手消息，它就能被用于数据包放大攻击，放大攻击者生成的流量。</p>
<p>QUIC针对此类攻击，拥有三种防御手段。首先，包含<code>ClientHello</code>的数据包<em><strong>必须</strong></em>被扩充至一个下限值。其次，在向未经验证的源地址响应时，服务器发送的字节数禁止超过它接收到的字节数的三倍（详见《<a href="">QUIC传输</a>》的<a href="">第8.1章</a>）。最后，因为对于握手数据包的确认是经认证的，所有对此一无所知的攻击者无法伪造它们。综合起来，这些防御手段限制了放大攻击的放大量级。</p>

    </div>
</section>

        
    
        
            <section class="page" id="9.4_Header_Protection_Analysis">
    
        <h2>
    
            <a href="#9.4_Header_Protection_Analysis">9.4. 对头部保护的分析</a>
    
        </h2>
    
    <div class="content">
        <p>《<a href="">NAN</a>》分析了许多能保护随机数的认证加密算法，它们被称为“随机数隐藏”（HN）转换。本文档中的头部保护构建方法大体上可以算作是这些算法中的其中一种（HN1）。头部保护会在数据包保护AEAD之后被应用，它从AEAD的输出中采样一组字节样本（表达式中的<code>sample</code>），并以此方法使用伪随机函数（表达式中的<code>PRF</code>）来加密头部字段：</p>
<div id=Pseudocode_9_4_1 class="block ref">
<pre tabindex="0"><code>protected_field = field XOR PRF(hp_key, sample)
</code></pre><p><a href="#Pseudocode_9_4_1"></a></p>
</div>
<p>本文档中的头部保护的不同之处在于使用伪随机排列（PRP）来代替常规的PRF。然而，由于所有PRP都算作PRF（详见《<a href="">IMC</a>》），所以这种修改并不违背HN1的构建原则。</p>
<p>由于<code>hp_key</code>与数据包保护密钥不同，因此头部保护能够达到《<a href="">NAN</a>》中描述的AE2安全级别，从而保护数据包头部中的字段。将来的基于相同构建方式的头部保护变体<em><strong>必须</strong></em>使用PRF来确保获得一致的安全保障。</p>
<p>多次使用相同的密钥和密文样本会有使头部保护失效的风险。使用相同的密钥和密文样本来保护两份不同的包头会泄露受保护字段的异或结果。假设以AEAD作为PRF，如果采样了<code>L</code>个比特位，那么两份密文样本一致的概率约为<code>2<sup>-L/2</sup></code>，也就是所谓的生日攻击。对于在本文档中描述的算法，这个概率为<code>2<sup>64</sup></code>分之一。</p>
<p>为了防止被攻击者修改，数据包头部会受到数据包保护的认证；整个数据包头部都是受认证的额外数据的一部分。受保护的字段有没有被篡改只能在移除数据包保护后才被检测出来。</p>

    </div>
</section>

        
    
        
            <section class="page" id="9.5_Header_Protection_Timing_Side_Channels">
    
        <h2>
    
            <a href="#9.5_Header_Protection_Timing_Side_Channels">9.5. 头部保护的计时侧信道</a>
    
        </h2>
    
    <div class="content">
        <p>攻击者可以猜测数据包号或密钥阶段的值，并通过计时侧信道观察终端会不会接受这个值。类似地，对于数据包号长度也可以进行猜测和破解。如果数据包的接收方直接将数据包号重复的数据包丢弃，而没有尝试移除数据包保护，那么它们就会通过计时侧信道暴露此数据包号与一个已接收到的数据包匹配的事实。为了使认证过程不会对侧信道产生影响，<em><strong>必须</strong></em>完整地先移除头部保护、然后恢复数据包号，接着移除数据包保护，从而避免从计时或其他方面的侧信道泄露信息。</p>
<p>在数据包的发送方面，数据包载荷与数据包号的构建和保护过程<em><strong>必须</strong></em>不会从侧信道泄露数据包号或它的编码后长度。</p>
<p>在密钥更新期间，创建新密钥所花费的时间可能通过计时侧信道透露出有没有发生密钥更新。除此之外，当攻击者注入数据包时，该侧信道会泄露被注入的数据包里密钥阶段的值。在接收到密钥更新后，终端<em><strong>应该</strong></em>如<a href="">第6.3章</a>所述的那样，建立并储存下一组接受用的数据包保护密钥。通过在接收到密钥更新前就建立新密钥，数据包的接收就不会创建出会泄露密钥阶段的值的计时上的信号。</p>
<p>这项要求依赖于不在数据包处理期间建立新密钥，同时它可能需要终端维护三组接收用的数据包保护密钥：上一密钥阶段的、当前密钥阶段的和下一密钥阶段的。作为替代方案，终端可以选择延迟建立下一密钥阶段的数据包保护密钥，直到它弃用旧密钥为止，这使得它在同一时间只需要维护两组接收密钥。</p>

    </div>
</section>

        
    
        
            <section class="page" id="9.6_Key_Diversity">
    
        <h2>
    
            <a href="#9.6_Key_Diversity">9.6. 密钥的隔离性</a>
    
        </h2>
    
    <div class="content">
        <p>在使用TLS时，会用到其核心的密钥衍生计划表。由于TLS握手消息被集成进了秘密值计算，QUIC传输参数扩展的使用能够确保握手密钥和1-RTT密钥与运行基于TCP的TLS的服务器所生成出来的密钥不一致。为了降低不同协议间出现密钥碰撞情况的可能性，有额外的措施来提高密钥的隔离性。</p>
<p>QUIC的数据包保护密钥和IV是使用与TLS中不同的标签来衍生的。</p>
<p>为了维持这种隔离性，新版本的QUIC<em><strong>应该</strong></em>为计算数据包保护密钥和IV的密钥，以及头部保护密钥，的衍生过程定义新的标签值。本版本的QUIC使用了字符串<code>quic</code>。其他版本可以使用与版本相关的标签来替换该字符串。</p>
<p>初始秘密值使用的是由协商出的QUIC版本指定的密钥。新的QUIC版本<em><strong>应该</strong></em>为秘密值的计算定义新的盐值。</p>

    </div>
</section>

        
    
        
            <section class="page" id="9.7_Randomness">
    
        <h2>
    
            <a href="#9.7_Randomness">9.7. 随机性</a>
    
        </h2>
    
    <div class="content">
        <p>QUIC依赖于终端生成安全的随机数的能力，这项能力既会被直接用在协议里的一些值上，如连接ID，也会经由TLS被使用到。有关安全的随机数生成的指导，详见《<a href="">RFC4086</a>》。</p>

    </div>
</section>

        
    



        
                <section class="page" id="10_IANA_Considerations">
    
        <h1>
    
            <a href="#10_IANA_Considerations">10. 关于IANA的考量</a>
    
        </h1>
    
    <div class="content">
        <p>IANA已经在“TLS扩展类型值”注册表（详见《<a href="">TLS-REGISTRIES</a>》）中为<code>quic_transport_parameters</code>（QUIC传输参数）扩展（有关定义详见<a href="">第8.2章</a>）注册了值为<code>57</code>（也就是<code>0x39</code>）的码点。</p>
<p>该扩展的受推荐一栏被标记为“是”。TLS 1.3一栏中包含CH（<code>ClientHello</code>，客户端问候）和EE（<code>EncryptedExtensions</code>，加密扩展）。</p>
<div id=Table_2_TLS_ExtensionType_Values_Registry_Entry class="block ref">
<table>
<thead>
<tr>
<th style="text-align:left">值</th>
<th style="text-align:left">扩展名称</th>
<th style="text-align:left">TLS 1.3</th>
<th style="text-align:left">受推荐</th>
<th style="text-align:left">参考文献</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">57</td>
<td style="text-align:left">quic_transport_parameters</td>
<td style="text-align:left">CH, EE</td>
<td style="text-align:left">是</td>
<td style="text-align:left">本文档</td>
</tr>
</tbody>
</table>
<p><a href="#Table_2_TLS_ExtensionType_Values_Registry_Entry">表2：TLS扩展类型值注册项</a></p>
</div>

    </div>
</section>




        
                <section class="page" id="11_References">
    
        <h1>
    
            <a href="#11_References">11. 参考文献</a>
    
        </h1>
    
    <div class="content">
        
    </div>
</section>


    
        
            <section class="page" id="11.1_Normative_References">
    
        <h2>
    
            <a href="#11.1_Normative_References">11.1. 规范性参考文献</a>
    
        </h2>
    
    <div class="content">
        <dl>
<dt>[AEAD]：</dt>
<dd>
<p>McGrew, D., &ldquo;An Interface and Algorithms for Authenticated Encryption&rdquo;, RFC 5116, DOI 10.17487/RFC5116, January 2008, <a href="https://www.rfc-editor.org/info/rfc5116">https://www.rfc-editor.org/info/rfc5116</a>.</p>
</dd>
<dt>[AES]：</dt>
<dd>
<p>&ldquo;Advanced encryption standard (AES)&rdquo;, National Institute of Standards and Technology report, DOI 10.6028/nist.fips.197, November 2001, <a href="https://doi.org/10.6028/nist.fips.197">https://doi.org/10.6028/nist.fips.197</a>.</p>
</dd>
<dt>[ALPN]：</dt>
<dd>
<p>Friedl, S., Popov, A., Langley, A., and E. Stephan, &ldquo;Transport Layer Security (TLS) Application-Layer Protocol Negotiation Extension&rdquo;, RFC 7301, DOI 10.17487/RFC7301, July 2014, <a href="https://www.rfc-editor.org/info/rfc7301">https://www.rfc-editor.org/info/rfc7301</a>.</p>
</dd>
<dt>[CHACHA]：</dt>
<dd>
<p>Nir, Y. and A. Langley, &ldquo;ChaCha20 and Poly1305 for IETF Protocols&rdquo;, RFC 8439, DOI 10.17487/RFC8439, June 2018, <a href="https://www.rfc-editor.org/info/rfc8439">https://www.rfc-editor.org/info/rfc8439</a>.</p>
</dd>
<dt>[HKDF]：</dt>
<dd>
<p>Krawczyk, H. and P. Eronen, &ldquo;HMAC-based Extract-and-Expand Key Derivation Function (HKDF)&rdquo;, RFC 5869, DOI 10.17487/RFC5869, May 2010, <a href="https://www.rfc-editor.org/info/rfc5869">https://www.rfc-editor.org/info/rfc5869</a>.</p>
</dd>
<dt>[QUIC-RECOVERY]：</dt>
<dd>
<p>Iyengar, J., Ed. and I. Swett, Ed., &ldquo;QUIC Loss Detection and Congestion Control&rdquo;, RFC 9002, DOI 10.17487/RFC9002, May 2021, <a href="https://www.rfc-editor.org/info/rfc9002">https://www.rfc-editor.org/info/rfc9002</a>.</p>
</dd>
<dt>[QUIC-TRANSPORT]：</dt>
<dd>
<p>Iyengar, J., Ed. and M. Thomson, Ed., &ldquo;QUIC: A UDP-Based Multiplexed and Secure Transport&rdquo;, RFC 9000, DOI 10.17487/RFC9000, May 2021, <a href="https://www.rfc-editor.org/info/rfc9000">https://www.rfc-editor.org/info/rfc9000</a>.</p>
</dd>
<dt>[RFC2119]：</dt>
<dd>
<p>Bradner, S., &ldquo;Key words for use in RFCs to Indicate Requirement Levels&rdquo;, BCP 14, RFC 2119, DOI 10.17487/RFC2119, March 1997, <a href="https://www.rfc-editor.org/info/rfc2119">https://www.rfc-editor.org/info/rfc2119</a>.</p>
</dd>
<dt>[RFC4086]：</dt>
<dd>
<p>Eastlake 3rd, D., Schiller, J., and S. Crocker, &ldquo;Randomness Requirements for Security&rdquo;, BCP 106, RFC 4086, DOI 10.17487/RFC4086, June 2005, <a href="https://www.rfc-editor.org/info/rfc4086">https://www.rfc-editor.org/info/rfc4086</a>.</p>
</dd>
<dt>[RFC8174]：</dt>
<dd>
<p>Leiba, B., &ldquo;Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words&rdquo;, BCP 14, RFC 8174, DOI 10.17487/RFC8174, May 2017, <a href="https://www.rfc-editor.org/info/rfc8174">https://www.rfc-editor.org/info/rfc8174</a>.</p>
</dd>
<dt>[SHA]：</dt>
<dd>
<p>Dang, Q., &ldquo;Secure Hash Standard&rdquo;, National Institute of Standards and Technology report, DOI 10.6028/nist.fips.180-4, July 2015, <a href="https://doi.org/10.6028/nist.fips.180-4">https://doi.org/10.6028/nist.fips.180-4</a>.</p>
</dd>
<dt>[TLS-REGISTRIES]：</dt>
<dd>
<p>Salowey, J. and S. Turner, &ldquo;IANA Registry Updates for TLS and DTLS&rdquo;, RFC 8447, DOI 10.17487/RFC8447, August 2018, <a href="https://www.rfc-editor.org/info/rfc8447">https://www.rfc-editor.org/info/rfc8447</a>.</p>
</dd>
<dt>[TLS13]：</dt>
<dd>
<p>Rescorla, E., &ldquo;The Transport Layer Security (TLS) Protocol Version 1.3&rdquo;, RFC 8446, DOI 10.17487/RFC8446, August 2018, <a href="https://www.rfc-editor.org/info/rfc8446">https://www.rfc-editor.org/info/rfc8446</a>.</p>
</dd>
</dl>

    </div>
</section>

        
    
        
            <section class="page" id="11.2_Informative_References">
    
        <h2>
    
            <a href="#11.2_Informative_References">11.2. 资料性参考文献</a>
    
        </h2>
    
    <div class="content">
        <dl>
<dt>[AEBounds]：</dt>
<dd>
<p>Luykx, A. and K. Paterson, &ldquo;Limits on Authenticated Encryption Use in TLS&rdquo;, 28 August 2017, <a href="https://www.isg.rhul.ac.uk/~kp/TLS-AEbounds.pdf">https://www.isg.rhul.ac.uk/~kp/TLS-AEbounds.pdf</a>.</p>
</dd>
<dt>[ASCII]：</dt>
<dd>
<p>Cerf, V., &ldquo;ASCII format for network interchange&rdquo;, STD 80, RFC 20, DOI 10.17487/RFC0020, October 1969, <a href="https://www.rfc-editor.org/info/rfc20">https://www.rfc-editor.org/info/rfc20</a>.</p>
</dd>
<dt>[CCM-ANALYSIS]：</dt>
<dd>
<p>Jonsson, J., &ldquo;On the Security of CTR + CBC-MAC&rdquo;, Selected Areas in Cryptography, SAC 2002, Lecture Notes in Computer Science, vol 2595, pp. 76-93, DOI 10.1007/3-540-36492-7_7, 2003, <a href="https://doi.org/10.1007/3-540-36492-7_7">https://doi.org/10.1007/3-540-36492-7_7</a>.</p>
</dd>
<dt>[COMPRESS]：</dt>
<dd>
<p>Ghedini, A. and V. Vasiliev, &ldquo;TLS Certificate Compression&rdquo;, RFC 8879, DOI 10.17487/RFC8879, December 2020, <a href="https://www.rfc-editor.org/info/rfc8879">https://www.rfc-editor.org/info/rfc8879</a>.</p>
</dd>
<dt>[GCM-MU]：</dt>
<dd>
<p>Hoang, V., Tessaro, S., and A. Thiruvengadam, &ldquo;The Multi-user Security of GCM, Revisited: Tight Bounds for Nonce Randomization&rdquo;, CCS &lsquo;18: Proceedings of the 2018 ACM SIGSAC Conference on Computer and Communications Security, pp. 1429-1440, DOI 10.1145/3243734.3243816, 2018, <a href="https://doi.org/10.1145/3243734.3243816">https://doi.org/10.1145/3243734.3243816</a>.</p>
</dd>
<dt>[HTTP-REPLAY]：</dt>
<dd>
<p>Thomson, M., Nottingham, M., and W. Tarreau, &ldquo;Using Early Data in HTTP&rdquo;, RFC 8470, DOI 10.17487/RFC8470, September 2018, <a href="https://www.rfc-editor.org/info/rfc8470">https://www.rfc-editor.org/info/rfc8470</a>.</p>
</dd>
<dt>[HTTP2-TLS13]：</dt>
<dd>
<p>Benjamin, D., &ldquo;Using TLS 1.3 with HTTP/2&rdquo;, RFC 8740, DOI 10.17487/RFC8740, February 2020, <a href="https://www.rfc-editor.org/info/rfc8740">https://www.rfc-editor.org/info/rfc8740</a>.</p>
</dd>
<dt>[IMC]：</dt>
<dd>
<p>Katz, J. and Y. Lindell, &ldquo;Introduction to Modern Cryptography, Second Edition&rdquo;, ISBN 978-1466570269, 6 November 2014.</p>
</dd>
<dt>[NAN]：</dt>
<dd>
<p>Bellare, M., Ng, R., and B. Tackmann, &ldquo;Nonces Are Noticed: AEAD Revisited&rdquo;, Advances in Cryptology - CRYPTO 2019, Lecture Notes in Computer Science, vol 11692, pp. 235-265, DOI 10.1007/978-3-030-26948-7_9, 2019, <a href="https://doi.org/10.1007/978-3-030-26948-7_9">https://doi.org/10.1007/978-3-030-26948-7_9</a>.</p>
</dd>
<dt>[QUIC-HTTP]：</dt>
<dd>
<p>Bishop, M., Ed., &ldquo;Hypertext Transfer Protocol Version 3 (HTTP/3)&rdquo;, Work in Progress, Internet-Draft, draft-ietf-quic-http-34, 2 February 2021, <a href="https://tools.ietf.org/html/draft-ietf-quic-http-34">https://tools.ietf.org/html/draft-ietf-quic-http-34</a>.</p>
</dd>
<dt>[RFC2818]：</dt>
<dd>
<p>Rescorla, E., &ldquo;HTTP Over TLS&rdquo;, RFC 2818, DOI 10.17487/RFC2818, May 2000, <a href="https://www.rfc-editor.org/info/rfc2818">https://www.rfc-editor.org/info/rfc2818</a>.</p>
</dd>
<dt>[RFC5280]：</dt>
<dd>
<p>Cooper, D., Santesson, S., Farrell, S., Boeyen, S., Housley, R., and W. Polk, &ldquo;Internet X.509 Public Key Infrastructure Certificate and Certificate Revocation List (CRL) Profile&rdquo;, RFC 5280, DOI 10.17487/RFC5280, May 2008, <a href="https://www.rfc-editor.org/info/rfc5280">https://www.rfc-editor.org/info/rfc5280</a>.</p>
</dd>
<dt>[ROBUST]：</dt>
<dd>
<p>Fischlin, M., Günther, F., and C. Janson, &ldquo;Robust Channels: Handling Unreliable Networks in the Record Layers of QUIC and DTLS 1.3&rdquo;, 16 May 2020, <a href="https://eprint.iacr.org/2020/718">https://eprint.iacr.org/2020/718</a>.</p>
</dd>
</dl>

    </div>
</section>

        
    



        
                <section class="page" id="Appendix_A_Sample_Packet_Protection">
    
        <h1>
    
            <a href="#Appendix_A_Sample_Packet_Protection">附录A. 数据包保护样例</a>
    
        </h1>
    
    <div class="content">
        <p>本章展示了数据包保护的一些例子，以便于QUIC的实现可以逐步验证自己的计算结果。这里为客户端和服务器分别定义了初始数据包的样例，以及一个重试数据包。这些数据包使用了一个由客户端选择的8字节长的目标连接ID，其值为<code>0x8394c8f03e515708</code>。样例中还包含了计算过程的一些中间值。所有值都是以十六进制表示的。</p>

    </div>
</section>


    
        
            <section class="page" id="A.1_Keys">
    
        <h2>
    
            <a href="#A.1_Keys">A.1. 密钥</a>
    
        </h2>
    
    <div class="content">
        <p>在<code>HKDF-Expand-Label</code>函数的执行期间生成的标签（也就是<code>HkdfLabel.label</code>），以及传给<code>HKDF-Expand</code>函数的参数为：</p>
<p><code>client in</code>: <code>00200f746c73313320636c69656e7420696e00</code></p>
<p><code>server in</code>: <code>00200f746c7331332073657276657220696e00</code></p>
<p><code>quic key</code>: <code>00100e746c7331332071756963206b657900</code></p>
<p><code>quic iv</code>: <code>000c0d746c733133207175696320697600</code></p>
<p><code>quic hp</code>: <code>00100d746c733133207175696320687000</code></p>
<p>初始秘密值是通用的：</p>
<div id=Pseudocode_A_1_1 class="block ref">
<pre tabindex="0"><code>initial_secret = HKDF-Extract(initial_salt, cid)
    = 7db5df06e7a69e432496adedb0085192
      3595221596ae2ae9fb8115c1e9ed0a44
</code></pre><p><a href="#Pseudocode_A_1_1"></a></p>
</div>
<p>用于保护客户端数据包的秘密值为：</p>
<div id=Pseudocode_A_1_2 class="block ref">
<pre tabindex="0"><code>client_initial_secret
    = HKDF-Expand-Label(initial_secret, &quot;client in&quot;, &quot;&quot;, 32)
    = c00cf151ca5be075ed0ebfb5c80323c4
      2d6b7db67881289af4008f1f6c357aea

key = HKDF-Expand-Label(client_initial_secret, &quot;quic key&quot;, &quot;&quot;, 16)
    = 1f369613dd76d5467730efcbe3b1a22d

iv  = HKDF-Expand-Label(client_initial_secret, &quot;quic iv&quot;, &quot;&quot;, 12)
    = fa044b2f42a3fd3b46fb255c

hp  = HKDF-Expand-Label(client_initial_secret, &quot;quic hp&quot;, &quot;&quot;, 16)
    = 9f50449e04a0e810283a1e9933adedd2
</code></pre><p><a href="#Pseudocode_A_1_2"></a></p>
</div>
<p>用于保护服务器数据包的秘密值为：</p>
<div id=Pseudocode_A_1_3 class="block ref">
<pre tabindex="0"><code>server_initial_secret
    = HKDF-Expand-Label(initial_secret, &quot;server in&quot;, &quot;&quot;, 32)
    = 3c199828fd139efd216c155ad844cc81
      fb82fa8d7446fa7d78be803acdda951b

key = HKDF-Expand-Label(server_initial_secret, &quot;quic key&quot;, &quot;&quot;, 16)
    = cf3a5331653c364c88f0f379b6067e37

iv  = HKDF-Expand-Label(server_initial_secret, &quot;quic iv&quot;, &quot;&quot;, 12)
    = 0ac1493ca1905853b0bba03e

hp  = HKDF-Expand-Label(server_initial_secret, &quot;quic hp&quot;, &quot;&quot;, 16)
    = c206b8d9b9f0f37644430b490eeaa314
</code></pre><p><a href="#Pseudocode_A_1_3"></a></p>
</div>

    </div>
</section>

        
    
        
            <section class="page" id="A.2_Client_Initial">
    
        <h2>
    
            <a href="#A.2_Client_Initial">A.2. 客户端初始数据包</a>
    
        </h2>
    
    <div class="content">
        <p>客户端会发送初始数据包。该数据包未经保护的载荷中包含着<strong>加密帧</strong>，以及足够多的<strong>填充帧</strong>以使得载荷长度达到1162字节：</p>
<div id=Pseudocode_A_2_1 class="block ref">
<pre tabindex="0"><code>060040f1010000ed0303ebf8fa56f129 39b9584a3896472ec40bb863cfd3e868
04fe3a47f06a2b69484c000004130113 02010000c000000010000e00000b6578
616d706c652e636f6dff01000100000a 00080006001d00170018001000070005
04616c706e0005000501000000000033 00260024001d00209370b2c9caa47fba
baf4559fedba753de171fa71f50f1ce1 5d43e994ec74d748002b000302030400
0d0010000e0403050306030203080408 050806002d00020101001c0002400100
3900320408ffffffffffffffff050480 00ffff07048000ffff08011001048000
75300901100f088394c8f03e51570806 048000ffff
</code></pre><p><a href="#Pseudocode_A_2_1"></a></p>
</div>
<p>在未经保护的头部中，长度字段的值表示着后方数据的总长度，即1182字节：4字节长的数据包号，1162字节长的帧，还有16字节长的认证标签。头部中还包含了连接ID和值为<code>2</code>的数据包号：</p>
<div id=Pseudocode_A_2_2 class="block ref">
<pre tabindex="0"><code>c300000001088394c8f03e5157080000449e00000002
</code></pre><p><a href="#Pseudocode_A_2_2"></a></p>
</div>
<p>对载荷进行保护后，其输出密文会被头部保护采样。因为头部中的数据包号被编码为四字节，所以受保护载荷的前16个字节被作为样本（<code>sample</code>），应用在头部保护中：</p>
<div id=Pseudocode_A_2_3 class="block ref">
<pre tabindex="0"><code>sample = d1b1c98dd7689fb8ec11d242b123dc9b

mask = AES-ECB(hp, sample)[0..4]
     = 437b9aec36

header[0] ^= mask[0] &amp; 0x0f
    = c0
header[18..21] ^= mask[1..4]
    = 7b9aec34
header = c000000001088394c8f03e5157080000449e7b9aec34
</code></pre><p><a href="#Pseudocode_A_2_3"></a></p>
</div>
<p>最后，经保护的数据包的内容为：</p>
<div id=Pseudocode_A_2_4 class="block ref">
<pre tabindex="0"><code>c000000001088394c8f03e5157080000 449e7b9aec34d1b1c98dd7689fb8ec11
d242b123dc9bd8bab936b47d92ec356c 0bab7df5976d27cd449f63300099f399
1c260ec4c60d17b31f8429157bb35a12 82a643a8d2262cad67500cadb8e7378c
8eb7539ec4d4905fed1bee1fc8aafba1 7c750e2c7ace01e6005f80fcb7df6212
30c83711b39343fa028cea7f7fb5ff89 eac2308249a02252155e2347b63d58c5
457afd84d05dfffdb20392844ae81215 4682e9cf012f9021a6f0be17ddd0c208
4dce25ff9b06cde535d0f920a2db1bf3 62c23e596d11a4f5a6cf3948838a3aec
4e15daf8500a6ef69ec4e3feb6b1d98e 610ac8b7ec3faf6ad760b7bad1db4ba3
485e8a94dc250ae3fdb41ed15fb6a8e5 eba0fc3dd60bc8e30c5c4287e53805db
059ae0648db2f64264ed5e39be2e20d8 2df566da8dd5998ccabdae053060ae6c
7b4378e846d29f37ed7b4ea9ec5d82e7 961b7f25a9323851f681d582363aa5f8
9937f5a67258bf63ad6f1a0b1d96dbd4 faddfcefc5266ba6611722395c906556
be52afe3f565636ad1b17d508b73d874 3eeb524be22b3dcbc2c7468d54119c74
68449a13d8e3b95811a198f3491de3e7 fe942b330407abf82a4ed7c1b311663a
c69890f4157015853d91e923037c227a 33cdd5ec281ca3f79c44546b9d90ca00
f064c99e3dd97911d39fe9c5d0b23a22 9a234cb36186c4819e8b9c5927726632
291d6a418211cc2962e20fe47feb3edf 330f2c603a9d48c0fcb5699dbfe58964
25c5bac4aee82e57a85aaf4e2513e4f0 5796b07ba2ee47d80506f8d2c25e50fd
14de71e6c418559302f939b0e1abd576 f279c4b2e0feb85c1f28ff18f58891ff
ef132eef2fa09346aee33c28eb130ff2 8f5b766953334113211996d20011a198
e3fc433f9f2541010ae17c1bf202580f 6047472fb36857fe843b19f5984009dd
c324044e847a4f4a0ab34f719595de37 252d6235365e9b84392b061085349d73
203a4a13e96f5432ec0fd4a1ee65accd d5e3904df54c1da510b0ff20dcc0c77f
cb2c0e0eb605cb0504db87632cf3d8b4 dae6e705769d1de354270123cb11450e
fc60ac47683d7b8d0f811365565fd98c 4c8eb936bcab8d069fc33bd801b03ade
a2e1fbc5aa463d08ca19896d2bf59a07 1b851e6c239052172f296bfb5e724047
90a2181014f3b94a4e97d117b4381303 68cc39dbb2d198065ae3986547926cd2
162f40a29f0c3c8745c0f50fba3852e5 66d44575c29d39a03f0cda721984b6f4
40591f355e12d439ff150aab7613499d bd49adabc8676eef023b15b65bfc5ca0
6948109f23f350db82123535eb8a7433 bdabcb909271a6ecbcb58b936a88cd4e
8f2e6ff5800175f113253d8fa9ca8885 c2f552e657dc603f252e1a8e308f76f0
be79e2fb8f5d5fbbe2e30ecadd220723 c8c0aea8078cdfcb3868263ff8f09400
54da48781893a7e49ad5aff4af300cd8 04a6b6279ab3ff3afb64491c85194aab
760d58a606654f9f4400e8b38591356f bf6425aca26dc85244259ff2b19c41b9
f96f3ca9ec1dde434da7d2d392b905dd f3d1f9af93d1af5950bd493f5aa731b4
056df31bd267b6b90a079831aaf579be 0a39013137aac6d404f518cfd4684064
7e78bfe706ca4cf5e9c5453e9f7cfd2b 8b4c8d169a44e55c88d4a9a7f9474241
e221af44860018ab0856972e194cd934
</code></pre><p><a href="#Pseudocode_A_2_4"></a></p>
</div>

    </div>
</section>

        
    
        
            <section class="page" id="A.3_Server_Initial">
    
        <h2>
    
            <a href="#A.3_Server_Initial">A.3. 服务器初始数据包</a>
    
        </h2>
    
    <div class="content">
        <p>作为回应，服务器会发送以下载荷，其中包含一个<strong>ACK帧</strong>和一个<strong>加密帧</strong>，并且不包含<strong>填充帧</strong>：</p>
<div id=Pseudocode_A_3_1 class="block ref">
<pre tabindex="0"><code>02000000000600405a020000560303ee fce7f7b37ba1d1632e96677825ddf739
88cfc79825df566dc5430b9a045a1200 130100002e00330024001d00209d3c94
0d89690b84d08a60993c144eca684d10 81287c834d5311bcf32bb9da1a002b00
020304
</code></pre><p><a href="#Pseudocode_A_3_1"></a></p>
</div>
<p>来自服务器的头部包含着一个新的连接ID和一个值为<code>1</code>且被编码至双字节中数据包号：</p>
<div id=Pseudocode_A_3_2 class="block ref">
<pre tabindex="0"><code>c1000000010008f067a5502a4262b50040750001
</code></pre><p><a href="#Pseudocode_A_3_2"></a></p>
</div>
<p>对载荷进行保护后，从第三个密文字节起的一段数据被取作头部保护的样本。</p>
<div id=Pseudocode_A_3_3 class="block ref">
<pre tabindex="0"><code>sample = 2cd0991cd25b0aac406a5816b6394100
mask   = 2ec0d8356a
header = cf000000010008f067a5502a4262b5004075c0d9
</code></pre><p><a href="#Pseudocode_A_3_3"></a></p>
</div>
<p>最后，经保护的数据包的内容为：</p>
<div id=Pseudocode_A_3_4 class="block ref">
<pre tabindex="0"><code>cf000000010008f067a5502a4262b500 4075c0d95a482cd0991cd25b0aac406a
5816b6394100f37a1c69797554780bb3 8cc5a99f5ede4cf73c3ec2493a1839b3
dbcba3f6ea46c5b7684df3548e7ddeb9 c3bf9c73cc3f3bded74b562bfb19fb84
022f8ef4cdd93795d77d06edbb7aaf2f 58891850abbdca3d20398c276456cbc4
2158407dd074ee
</code></pre><p><a href="#Pseudocode_A_3_4"></a></p>
</div>

    </div>
</section>

        
    
        
            <section class="page" id="A.4_Retry">
    
        <h2>
    
            <a href="#A.4_Retry">A.4. 重试数据包</a>
    
        </h2>
    
    <div class="content">
        <p>这里展示了一个可以被用于响应<a href="">附录A.2</a>中的初始数据包的重试数据包。完整性检查中使用了了由客户端选择的值为<code>0x8394c8f03e515708</code>的连接ID，但是这个值不会被包含在最终的重试数据包的明文中：</p>
<div id=Pseudocode_A_4_1 class="block ref">
<pre tabindex="0"><code>ff000000010008f067a5502a4262b574 6f6b656e04a265ba2eff4d829058fb3f
0f2496ba
</code></pre><p><a href="#Pseudocode_A_4_1"></a></p>
</div>

    </div>
</section>

        
    
        
            <section class="page" id="A.5_ChaCha20-Poly1305_Short_Header_Packet">
    
        <h2>
    
            <a href="#A.5_ChaCha20-Poly1305_Short_Header_Packet">A.5. 使用ChaCha20-Poly1305的短包头数据包</a>
    
        </h2>
    
    <div class="content">
        <p>本例展示了保护短包头数据包时所需的一些步骤。本例使用了<code>AEAD_CHACHA20_POLY1305</code>。</p>
<p>在本例中，TLS生成了一个应用写入秘密值（<code>secret</code>），服务器使用<code>HKDF-Expand-Label</code>从这个秘密值生成四个值：一个密钥（<code>key</code>）、一个IV（<code>iv</code>）、一个头部保护密钥（<code>hp</code>），和一个将被在密钥被更新后使用到的秘密值（<code>ku</code>，但它在本例中没有被使用到）。</p>
<div id=Pseudocode_A_5_1 class="block ref">
<pre tabindex="0"><code>secret
    = 9ac312a7f877468ebe69422748ad00a1
      5443f18203a07d6060f688f30f21632b

key = HKDF-Expand-Label(secret, &quot;quic key&quot;, &quot;&quot;, 32)
    = c6d98ff3441c3fe1b2182094f69caa2e
      d4b716b65488960a7a984979fb23e1c8

iv  = HKDF-Expand-Label(secret, &quot;quic iv&quot;, &quot;&quot;, 12)
    = e0459b3474bdd0e44a41c144

hp  = HKDF-Expand-Label(secret, &quot;quic hp&quot;, &quot;&quot;, 32)
    = 25a282b9e82f06f21f488917a4fc8f1b
      73573685608597d0efcb076b0ab7a7a4

ku  = HKDF-Expand-Label(secret, &quot;quic ku&quot;, &quot;&quot;, 32)
    = 1223504755036d556342ee9361d25342
      1a826c9ecdf3c7148684b36b714881f9
</code></pre><p><a href="#Pseudocode_A_5_1"></a></p>
</div>
<p>下面展示了保护一个目标连接ID为空的最小数据包时所需的一些步骤。这个数据包仅包含了一个<strong>Ping帧</strong>（也就是说，载荷是<code>0x01</code>），并且其数据包号为<code>654360564</code>。在本例中，使用长度为<code>3</code>的数据包号编码方式（也就是编码为<code>49140</code>）避免了扩充数据包载荷的需要；如果数据包号被编码至更少的字节中，那么就需要<strong>填充帧</strong>。</p>
<div id=Pseudocode_A_5_2 class="block ref">
<pre tabindex="0"><code>pn                 = 654360564 # 十进制
nonce              = e0459b3474bdd0e46d417eb0
unprotected header = 4200bff4
payload plaintext  = 01
payload ciphertext = 655e5cd55c41f69080575d7999c25a5bfb
</code></pre><p><a href="#Pseudocode_A_5_2"></a></p>
</div>
<p>其结果密文的长度是在可能的范围中最小的。在为头部保护采样时，会跳过一个字节。</p>
<div id=Pseudocode_A_5_3 class="block ref">
<pre tabindex="0"><code>sample = 5e5cd55c41f69080575d7999c25a5bfb
mask   = aefefe7d03
header = 4cfe4189
</code></pre><p><a href="#Pseudocode_A_5_3"></a></p>
</div>
<p>经保护的数据包，其21字节的长度是在可能的范围中最小的。</p>
<div id=Pseudocode_A_5_4 class="block ref">
<pre tabindex="0"><code>packet = 4cfe4189655e5cd55c41f69080575d7999c25a5bfb
</code></pre><p><a href="#Pseudocode_A_5_4"></a></p>
</div>

    </div>
</section>

        
    



        
                <section class="page" id="Appendix_B_AEAD_Algorithm_Analysis">
    
        <h1>
    
            <a href="#Appendix_B_AEAD_Algorithm_Analysis">附录B. AEAD算法分析</a>
    
        </h1>
    
    <div class="content">
        <p>本章记述了在为<code>AEAD_AES_128_GCM</code>、<code>AEAD_AES_128_CCM</code>和<code>AEAD_AES_256_GCM</code>计算AEAD算法的用量上限时使用的分析方法。在下文的分析中，使用了乘法运算符号（<code>*</code>）、除法运算符号（<code>/</code>）和幂运算符号（<code>^</code>），并使用括号来指定优先级。除此之外，还使用了以下符号：</p>
<dl>
<dt><code>t</code>：</dt>
<dd>
<p>认证标签以比特为单位的长度。对于以上加密算法，<code>t</code>的值为<code>128</code>。</p>
</dd>
<dt><code>n</code>：</dt>
<dd>
<p>块函数以比特位单位的长度。对于以上算法，<code>n</code>的值为<code>128</code>。</p>
</dd>
<dt><code>k</code>：</dt>
<dd>
<p>密钥以比特为单位的长度。对于<code>AEAD_AES_128_GCM</code>和<code>AEAD_AES_128_CCM</code>，<code>n</code>的值为<code>128</code>；<code>AEAD_AES_256_GCM</code>则为256。</p>
</dd>
<dt><code>l</code>：</dt>
<dd>
<p>每个数据包中块的数量（见下文）。</p>
</dd>
<dt><code>q</code>：</dt>
<dd>
<p>终端创建和保护的真实数据包的数量。这个值的上限为终端在更新密钥前能够保护的数据包数量。</p>
</dd>
<dt><code>v</code>：</dt>
<dd>
<p>终端接受的伪造数据包的数量。这个值的上限为终端在更新密钥前能够拒绝的伪造数据包的数量。</p>
</dd>
<dt><code>o</code>：</dt>
<dd>
<p>攻击者离线进行的理想加密查询次数。</p>
</dd>
</dl>
<p>下文的分析依赖于在创建各条消息时对块操作进行计数。该分析是对尺寸不超过<code>2<sup>11</sup></code>（<code>l</code>为<code>2<sup>27</sup></code>）或<code>2<sup>16</sup></code>（<code>l</code>为<code>2<sup>12</sup></code>）的数据包进行的。<code>2<sup>11</sup></code>这个尺寸应该是一个与常见部署模式匹配的上限值，而<code>2<sup>16</sup></code>是单个QUIC数据包的所有可能的尺寸中的最大值。只有严格限制数据包尺寸的终端才能使用通过较小的数据包尺寸计算出的较大的那组可信度和完整性上限。</p>
<p>对于<code>AEAD_AES_128_GCM</code>和<code>AEAD_AES_256_GCM</code>，消息长度（<code>l</code>）是块中关联数据的长度与块中明文的长度之和。</p>
<p>对于<code>AEAD_AES_128_CCM</code>，块加密操作的总数为以下项目的总和：关联数据以块为单位的长度、密文以块为单位的长度和明文以块为单位的长度，最后再加上1。在本分析中，这个值被简化为数据包以块为单位的长度的两倍（也就是说，对于尺寸上限为<code>2<sup>11</sup></code>的数据包，<code>2l</code>为<code>2<sup>8</sup></code>，否则<code>2l</code>为<code>2<sup>13</sup></code>）。这种简化是基于包含全部关联数据和密文的数据包的。它会造成对于每个数据包中的操作数量会多计算一至三个块。</p>

    </div>
</section>


    
        
                <section class="page" id="B.1_Analysis_of_AEAD_AES_128_GCM_and_AEAD_AES_256_GCM_Usage_Limits">
    
        <h2>
    
            <a href="#B.1_Analysis_of_AEAD_AES_128_GCM_and_AEAD_AES_256_GCM_Usage_Limits">B.1. 对于AEAD_AES_128_GCM和AEAD_AES_256_GCM用量上限的分析</a>
    
        </h2>
    
    <div class="content">
        <p>《<a href="">GCM-MU</a>》具体说明了<code>AEAD_AES_128_GCM</code>和<code>AEAD_AES_256_GCM</code>被用在TLS 1.3和QUIC中时准确的用量上限。本节使用了一些经简化的假设来概述这份分析：</p>
<ul>
<li>
<p>攻击者在尝试伪造时使用的密文块数量上限为<code>v * l</code>，即尝试伪造的次数乘以每个数据包（以块为单位）的大小。</p>
</li>
<li>
<p>攻击者在线下完成的工作量在本分析的各项因素中并不占据主导地位。</p>
</li>
</ul>
<p>《<a href="">GCM-MU</a>》中设定的上限比《<a href="">AEBounds</a>》中使用的那些要更严格且更完备，这使得QUIC实现能够使用比《<a href="">TLS13</a>》中所描述的更大的限制。</p>

    </div>
</section>


    
        
            <section class="page" id="B.1.1_Confidentiality_Limit">
    
        <h3>
    
            <a href="#B.1.1_Confidentiality_Limit">B.1.1. 可信度上限</a>
    
        </h3>
    
    <div class="content">
        <p>在可信度方面，《<a href="">GCM-MU</a>》中的定理4.3指出，对于一个不会重复随机数的用户，计算攻击者随机选择的AEAD算法相比实际使用的真实AEAD算法的优势程度的表达式为：</p>
<div id=Pseudocode_B_1_1_1 class="block ref">
<pre tabindex="0"><code>2 * (q * l)^2 / 2^n
</code></pre><p><a href="#Pseudocode_B_1_1_1"></a></p>
</div>
<p>当目标优势度为<code>2<sup>-57</sup></code>时，会得到这样的关系：</p>
<div id=Pseudocode_B_1_1_2 class="block ref">
<pre tabindex="0"><code>q &lt;= 2^35 / l
</code></pre><p><a href="#Pseudocode_B_1_1_2"></a></p>
</div>
<p>因此，发送不超过<code>2<sup>11</sup></code>字节的数据包的终端无法在单条连接中保护<code>2<sup>28</sup></code>个以上的数据包却不让攻击者获得超过<code>2<sup>-57</sup></code>优势度。对于允许数据包尺寸达到<code>2<sup>16</sup></code>字节的终端，则该限制为<code>2<sup>23</sup></code>个数据包。</p>

    </div>
</section>

        
    
        
            <section class="page" id="B.1.2_Integrity_Limit">
    
        <h3>
    
            <a href="#B.1.2_Integrity_Limit">B.1.2. 完整性上限</a>
    
        </h3>
    
    <div class="content">
        <p>在完整性方面，《<a href="">GCM-MU</a>》中的定理4.3指出，攻击者在伪造数据包时次数不需要超过此值就能获得明显优势：</p>
<div id=Pseudocode_B_1_2_1 class="block ref">
<pre tabindex="0"><code>(1 / 2^(8 * n)) + ((2 * v) / 2^(2 * n))
        + ((2 * o * v) / 2^(k + n)) + (n * (v + (v * l)) / 2^k)
</code></pre><p><a href="#Pseudocode_B_1_2_1"></a></p>
</div>
<p>我们的目标是将此优势限制到<code>2<sup>-57</sup></code>以下。对于<code>AEAD_AES_128_GCM</code>，不等式中的第四项占据主导地位，所以其余项可以被移除而不会对结果产生重要影响。这会产生以下近似结果：</p>
<div id=Pseudocode_B_1_2_2 class="block ref">
<pre tabindex="0"><code>v &lt;= 2^64 / l
</code></pre><p><a href="#Pseudocode_B_1_2_2"></a></p>
</div>
<p>不会尝试对超过<code>2<sup>11</sup></code>字节的数据包移除保护的终端最多可以尝试为<code>2<sup>57</sup></code>个数据包移除保护。并不限制所处理的数据包尺寸的终端最多可以尝试为<code>2<sup>52</sup></code>个数据包移除保护。</p>
<p>对于<code>AEAD_AES_256_GCM</code>，占据主导地位的是同一项，但是较大的<code>k</code>值会产生以下近似结果：</p>
<div id=Pseudocode_B_1_2_3 class="block ref">
<pre tabindex="0"><code>v &lt;= 2^192 / l
</code></pre><p><a href="#Pseudocode_B_1_2_3"></a></p>
</div>
<p>这比对<code>AEAD_AES_128_GCM</code>的限制要大得多。但是，本文档建议对两个函数施加同样的限制，因为任一限制都是可接受且足够大的。</p>

    </div>
</section>

        
    



        
    
        
            <section class="page" id="B.2_Analysis_of_AEAD_AES_128_CCM_Usage_Limits">
    
        <h2>
    
            <a href="#B.2_Analysis_of_AEAD_AES_128_CCM_Usage_Limits">B.2. 对于AEAD_AES_128_CCM用量上限的分析</a>
    
        </h2>
    
    <div class="content">
        <p>TLS（详见《<a href="">TLS13</a>》）和《<a href="">AEBounds</a>》都没有为<code>AEAD_AES_128_CCM</code>的用量设定上限。然而，任何与QUIC一起使用的AEAD都需要在用量上设定上限以确保可信度和完整性都能得到维持。本节记述了关于此上限的分析。</p>
<p>《<a href="">CCM-ANALYSIS</a>》被用作本分析的基础。该文献中的分析结果被用于计算用量上限。</p>
<p>在可信度方面，《<a href="">CCM-ANALYSIS</a>》中的定理2指出，攻击者相比理想的伪随机排列（PRP）获得的优势不会超过此值：</p>
<div id=Pseudocode_B_2_1 class="block ref">
<pre tabindex="0"><code>(2l * q)^2 / 2^n
</code></pre><p><a href="#Pseudocode_B_2_1"></a></p>
</div>
<p>在相同消息数量的情况下，《<a href="">CCM-ANALYSIS</a>》中的定理1中的完整性上限给予了攻击者更多优势。由于可信度方面优势与完整性方面优势的目标值是相同的，所以只需要考虑定理1。</p>
<p>定理1指出，攻击者相比理想的PRP获得的优势不会超过此值：</p>
<div id=Pseudocode_B_2_2 class="block ref">
<pre tabindex="0"><code>v / 2^t + (2l * (v + q))^2 / 2^n
</code></pre><p><a href="#Pseudocode_B_2_2"></a></p>
</div>
<p>由于<code>t</code>和<code>n</code>都是<code>128</code>，第一项相比第二项变得微不足道，因此第一项可以被移除而不会对结果产生重要影响。</p>
<p>这产生了一种关系，它将加密尝试次数和解密尝试次数关联到了相同的上限值上，这个上限值是定理为可信度生成的。当目标优势度为<code>2<sup>-57</sup></code>时，这会产生以下结果：</p>
<div id=Pseudocode_B_2_3 class="block ref">
<pre tabindex="0"><code>v + q &lt;= 2^34.5 / l
</code></pre><p><a href="#Pseudocode_B_2_3"></a></p>
</div>
<p>通过设置<code>q = v</code>，可信度上限和完整性上限的值就都能被推导出来。因此限制数据包尺寸不超过<code>2<sup>11</sup></code>字节的终端使用<code>2<sup>26.5</sup></code>个数据包的可信度上限和完整性上限。不限制数据包尺寸的终端则使用值为<code>2<sup>21.5</sup></code>的上限。</p>

    </div>
</section>

        
    



        
                <section class="page" id="Contributors">
    
        <h1>
    
            <a href="#Contributors">贡献者</a>
    
        </h1>
    
    <div class="content">
        <p>IETF QUIC工作组接收到了来自许多人员的大量支持。以下人员对本文档做出了重要贡献：</p>
<ul>
<li>
<p>Adam Langley</p>
</li>
<li>
<p>Alessandro Ghedini</p>
</li>
<li>
<p>Christian Huitema</p>
</li>
<li>
<p>Christopher Wood</p>
</li>
<li>
<p>David Schinazi</p>
</li>
<li>
<p>Dragana Damjanovic</p>
</li>
<li>
<p>Eric Rescorla</p>
</li>
<li>
<p>Felix Günther</p>
</li>
<li>
<p>Ian Swett</p>
</li>
<li>
<p>Jana Iyengar</p>
</li>
<li>
<p>奥 一穂 (Kazuho Oku)</p>
</li>
<li>
<p>Marten Seemann</p>
</li>
<li>
<p>Martin Duke</p>
</li>
<li>
<p>Mike Bishop</p>
</li>
<li>
<p>Mikkel Fahnøe Jørgensen</p>
</li>
<li>
<p>Nick Banks</p>
</li>
<li>
<p>Nick Harper</p>
</li>
<li>
<p>Roberto Peon</p>
</li>
<li>
<p>Rui Paulo</p>
</li>
<li>
<p>Ryan Hamilton</p>
</li>
<li>
<p>Victor Vasiliev</p>
</li>
</ul>

    </div>
</section>




        
                <section class="page" id="Authors_Addresses">
    
        <h1>
    
            <a href="#Authors_Addresses">联系作者</a>
    
        </h1>
    
    <div class="content">
        <p><strong>Martin Thomson (编辑)</strong></p>
<p>Mozilla</p>
<p>Email: <a href="mainto:mt@lowentropy.net">mt@lowentropy.net</a></p>
<p><strong>Sean Turner (编辑)</strong></p>
<p>sn3rd</p>
<p>Email: <a href="mailto:sean@sn3rd.com">sean@sn3rd.com</a></p>
<h2 id="译">译</h2>
<ul>
<li>
<p><a href="https://github.com/YunzheZJU">Yunzhe</a></p>
<ul>
<li>Email: <a href="mailto:yunzhe@zju.edu.cn">yunzhe@zju.edu.cn</a></li>
</ul>
</li>
<li>
<p><a href="https://github.com/fangqiuhang">方秋航</a></p>
<ul>
<li>Email: <a href="mailto:fangqiuhang@163.com">fangqiuhang@163.com</a></li>
</ul>
</li>
</ul>

    </div>
</section>




        
    
</div>
  <script>
    
    var pElements = document.getElementsByTagName('p');
    
    var i;
    for (i = 0; i < pElements.length; i++) {
      var content = pElements[i].innerHTML;
      content = content.replace(/(\r)/g, "");
      content = content.replace(/(\n)/g, "");
      pElements[i].innerHTML = content;
    }
  </script>
</body>
</html>


