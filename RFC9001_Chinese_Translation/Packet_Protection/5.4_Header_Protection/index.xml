<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>5.4. 头部保护 on AUTUMN QUICHE</title>
    <link>/RFC9001_Chinese_Translation/Packet_Protection/5.4_Header_Protection/</link>
    <description>Recent content in 5.4. 头部保护 on AUTUMN QUICHE</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>cn</language><atom:link href="/RFC9001_Chinese_Translation/Packet_Protection/5.4_Header_Protection/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>5.4.1. 应用头部保护的过程</title>
      <link>/RFC9001_Chinese_Translation/Packet_Protection/5.4_Header_Protection/5.4.1_Header_Protection_Application/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9001_Chinese_Translation/Packet_Protection/5.4_Header_Protection/5.4.1_Header_Protection_Application/</guid>
      <description>头部保护会在数据包保护之后被应用（详见第5.3章）。数据包的密文会被采样并被用作某个加密算法的输入。使用的算法取决于协商出的AEAD。
该算法的输出是一个5字节的掩码，这个掩码会以按位异或的方式被应用到受保护的头部字段。数据包首个字节的几个最低有效位会被掩码首个字节的对应最低有效位掩饰起来，同时数据包号会被剩余字节掩饰起来。掩码中未使用的字节不会被使用，这种情况可能在遇到较短的数据包号编码结果时发生。
图6展示了应用头部保护的样例算法。移除头部保护的过程只在决定数据包号长度（pn_length）这一步的顺序上与此有所不同（这里使用^来表示按位异或运算）。
mask = header_protection(hp_key, sample) pn_length = (packet[0] &amp;amp; 0x03) + 1 if (packet[0] &amp;amp; 0x80) == 0x80: # 长包头: 掩饰4个比特位 packet[0] ^= mask[0] &amp;amp; 0x0f else: # 短包头: 掩饰5个比特位 packet[0] ^= mask[0] &amp;amp; 0x1f # pn_offset 是数据包号字段的起始位置 packet[pn_offset:pn_offset+pn_length] ^= mask[1:1+pn_length] 图6：头部保护的伪代码
 每一组加密套件都有专门的头部保护函数的定义；详见第5.4.3章和第5.4.4章。
图7展示了一个长包头数据包（初始数据包）和一个短包头数据包（1-RTT数据包）的样例。从图7中可以看出每种头部中被头部保护覆盖到的字段和受保护的数据包载荷中被采样的部分。
初始数据包 { 包头形式 (1) = 1, 固定比特位 (1) = 1, 长数据包类型 (2) = 0, 保留比特位 (2), # 受保护 数据包号长度 (2), # 受保护 版本 (32), 目标连接ID长度 (8), 目标连接ID (0.</description>
    </item>
    
    <item>
      <title>5.4.2. 头部保护的采样</title>
      <link>/RFC9001_Chinese_Translation/Packet_Protection/5.4_Header_Protection/5.4.2_Header_Protection_Sample/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9001_Chinese_Translation/Packet_Protection/5.4_Header_Protection/5.4.2_Header_Protection_Sample/</guid>
      <description>头部保护算法会用到头部保护密钥和来自数据包载荷字段的密文样本。
采样的字节数总是相同的，但是需要存在一种使得不知道数据包号字段的长度的接收方也有能力移除保护的方法。密文的样本采取自数据包号字段的起始位置向后偏移4个字节的位置。也就是说，在为头部保护采样数据包密文时，数据包号字段被假设为具有4个字节的长度（数据包号经编码后其长度的最大的可能值）。
终端必须丢弃过短以至于无法提供完整样本的数据包。
为了确保存在足够数据用于采样，数据包会被扩充从而使得经编码的数据包号与受保护载荷的长度之和至少要比头部保护所需样本的长度要大4个字节。《TLS13》中定义的加密套件——除TLS_AES_128_CCM_8_SHA256外，因为本文档没有为它定义头部保护方案——都具有16字节的扩充量和16字节的头部保护样本长度要求。这意味着如果数据包号被编码至单个字节中，那么在未经保护的载荷中需要有至少3个字节长的帧，或者在被编码至双字节中时需要有至少2个字节的帧。
可以使用以下伪代码来决定采样的密文：
# pn_offset 是数据包号字段的起始位置 sample_offset = pn_offset + 4 sample = packet[sample_offset..sample_offset+sample_length] 
 可以这样计算短包头数据包的数据包号偏移：
pn_offset = 1 + len(connection_id) 
 而长包头数据包的数据包号偏移可以这样计算：
pn_offset = 7 + len(destination_connection_id) + len(source_connection_id) + len(payload_length) if packet_type == Initial: pn_offset += len(token_length) + len(token) 
 举个例子，如果某个短包头数据包具有8字节的连接ID并且受到AEAD_AES_128_GCM的保护，那么样本就是从字节13至字节28（包含两端，且索引的起始值为0）。
单个UDP数据报中可以包含数个QUIC数据包。每个数据包都会被单独处理。</description>
    </item>
    
    <item>
      <title>5.4.3. 基于AES的头部保护</title>
      <link>/RFC9001_Chinese_Translation/Packet_Protection/5.4_Header_Protection/5.4.3_AES-Based_Header_Protection/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9001_Chinese_Translation/Packet_Protection/5.4_Header_Protection/5.4.3_AES-Based_Header_Protection/</guid>
      <description>本节为AEAD_AES_128_GCM、AEAD_AES_128_CCM和AEAD_AES_256_GCM定义了数据包保护算法。AEAD_AES_128_GCM和AEAD_AES_128_CCM使用的是电子密码本（ECB）模式，128位的AES。AEAD_AES_256_GCM使用的是ECB模式，256位的AES。AES的定义详见《AES》。
该算法从数据包中采样16字节长的密文。这份样本会被用作AES-ECB的输入。用伪代码的方式将头部保护函数定义为：
header_protection(hp_key, sample): mask = AES-ECB(hp_key, sample) 
 </description>
    </item>
    
    <item>
      <title>5.4.4. 基于ChaCha20的头部保护</title>
      <link>/RFC9001_Chinese_Translation/Packet_Protection/5.4_Header_Protection/5.4.4_ChaCha20-Based_Header_Protection/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9001_Chinese_Translation/Packet_Protection/5.4_Header_Protection/5.4.4_ChaCha20-Based_Header_Protection/</guid>
      <description>若要使用AEAD_CHACHA20_POLY1305，进行头部保护时就要使用原始的ChaCha20函数，它被定义于《CHACHA》的第2.4章。它会使用一个256位的密钥和采样自数据包保护的输出的16个字节样本。
密文样本的前4个字节被用作块计数器。如果ChaCha20的实现要求计数器的输入是一个32位的整数而不是字节序列，那么这时就要将字节序列解释为一个小端编码的值。
剩余的12个字节被用作随机数。如果ChaCha20的实现要求随机数的输入是三个32位整数组成的数组而不是字节序列，那么这时就要将随机数的字节解释为一串小端编码的32位整数。
通过使用ChaCha20来保护5个值为0的字节，可以得到加密掩码。用伪代码的方式将头部保护函数定义为：
header_protection(hp_key, sample): counter = sample[0..3] nonce = sample[4..15] mask = ChaCha20(hp_key, counter, nonce, {0,0,0,0,0}) 
 </description>
    </item>
    
  </channel>
</rss>
