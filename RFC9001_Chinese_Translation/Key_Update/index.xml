<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>6. 密钥更新 on Autumn Navigation</title>
    <link>/RFC9001_Chinese_Translation/Key_Update/</link>
    <description>Recent content in 6. 密钥更新 on Autumn Navigation</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>cn</language><atom:link href="/RFC9001_Chinese_Translation/Key_Update/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>6.1. 发起密钥更新</title>
      <link>/RFC9001_Chinese_Translation/Key_Update/6.1_Initiating_a_Key_Update/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9001_Chinese_Translation/Key_Update/6.1_Initiating_a_Key_Update/</guid>
      <description>终端为数据包保护维护着相互独立的读取秘密值和写入秘密值。终端通过更新数据包的写入秘密值并用它去保护新数据包的方式来发起密钥更新。终端如《TLS13》的第7.2章中所展示的那样，从已有的写入秘密值创建新的写入秘密值。这会用到由TLS提供的KDF函数和值为quic ku的标签。该秘密值会如第5.1章中所述的那样，创建出相应的密钥和IV。而头部保护密钥不会被更新。
举个例子，在使用TLS 1.3时，为了更新写入密钥，要这样使用HKDF-Expand-Label：
secret_&amp;lt;n+1&amp;gt; = HKDF-Expand-Label(secret_&amp;lt;n&amp;gt;, &amp;quot;quic ku&amp;quot;, &amp;quot;&amp;quot;, Hash.length) 
 终端会切换密钥阶段比特位的状态，并将更新后的密钥和IV用于保护后续数据包。
在握手已确认（详见第4.1.2章）前，终端必须不发起密钥更新。在终端接收到对于受当前密钥阶段的密钥保护的数据包的确认前，它必须不发起后续的密钥更新。这确保了再一次发起密钥更新前，当前密钥在两侧终端处均为可用状态。要做到这一点，可以追踪用各个密钥阶段的密钥发送的最小数据包号，以及在1-RTT空间中的最大已确认数据包号：一旦后者大于等于前者，就可以再发起一次密钥更新。
 注意：非1-RTT数据包的密钥从不会被更新；它们的密钥一定是从TLS握手状态中衍生出来的。
 发起密钥更新的终端还会更新用于接收数据包的密钥。这些密钥会在更新后被用于处理对端发送的数据包。
在成功移除了使用新密钥发送的数据包的保护前，终端必须保留旧密钥。在成功移除了使用新密钥发送的数据包的保护后，终端应该将旧密钥保留一段时间。过早地弃用旧密钥会导致延误的数据包被丢弃。丢弃数据包的行为会被对端当作数据包遭遇了丢包，反而会影响性能。</description>
    </item>
    
    <item>
      <title>6.2. 响应密钥更新</title>
      <link>/RFC9001_Chinese_Translation/Key_Update/6.2_Responding_to_a_Key_Update/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9001_Chinese_Translation/Key_Update/6.2_Responding_to_a_Key_Update/</guid>
      <description>在接收到对于受当前密钥阶段的密钥保护的数据包的确认后，对端就可以发起密钥更新。终端在处理到一个密钥阶段的值与它曾发出的最后一个数据包中的值不同的数据包时，会将该情况视作为密钥更新。为了处理这个数据包，终端要使用下一阶段中的数据包保护密钥和IV。有关创建这些密钥时的考量，详见第6.3章。
如果某个数据包可以使用下一阶段中的密钥和IV来处理，就说明对端发起了密钥更新。作为响应，终端必须将它的发送密钥更新到相应的密钥阶段，如第6.1章所述。在发送对于使用了更新后的密钥来接收的数据包的确认前，必须更新发送密钥。通过用受更新后的密钥保护的数据包来确认触发密钥更新的数据包的方式，终端发送出密钥更新完成的信号。
终端可以根据自己平时的数据包发送习惯，推迟发送数据包或确认：没有必要为了响应密钥更新而立即创建新数据包。终端发送的下一个数据包会用上更新后的密钥。下一个包含确认的数据包会使得密钥更新完成。如果终端检测到了第二次密钥更新，但它这时还没有使用更新后的密钥发送包含对于触发前一次密钥更新的数据包的响应的数据包，那么这就表明对端没有等待确认就更新了密钥两次。终端可以将这样的连续密钥更新行为视作类型为KEY_UPDATE_ERROR（密钥更新错误）的连接错误。
如果终端接收到的确认来自受旧密钥保护的数据包，但确认是对于受新密钥保护的数据包的，那么它可以将这种情况视作类型为KEY_UPDATE_ERROR的连接错误。这表明对端已经接收到并且确认了发起密钥更新的数据包，但是在响应时没有更新密钥。</description>
    </item>
    
    <item>
      <title>6.3. 对创建接收密钥的计时</title>
      <link>/RFC9001_Chinese_Translation/Key_Update/6.3_Timing_of_Receive_Key_Generation/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9001_Chinese_Translation/Key_Update/6.3_Timing_of_Receive_Key_Generation/</guid>
      <description>终端在响应密钥更新时必须不产生在计时侧信道上可能表明密钥阶段比特位的有效性（详见第9.5章）的信号。当未批准进行密钥更新时，终端可以假装进行密钥更新，并使用随机化的数据包保护密钥来代替因更新而被弃用的密钥。使用随机化的密钥确保了移除数据包保护的尝试不会造成计时结果的变化，且具有无效的密钥阶段比特位的数据包会被正确地拒绝。
在接收数据包时，创建新的数据包保护密钥的过程可能透露出这期间进行了密钥更新。终端可以将创建新密钥作为数据包处理的一部分，但是这会产生计时上的信号，这个信号会被攻击者用于学习密钥更新的发生时机，从而泄露密钥阶段比特位的值。
通常，当前阶段中的和下一阶段中的数据包保护密钥应该都是对终端可用的。在密钥更新完成后不超过PTO的短暂时间里，终端可以延迟下一组接收用的数据包保护密钥的建立。这使得终端只需要维护两组接收密钥；详见第6.5章。
下一组数据包保护密钥一旦生成就应该被持续保留，哪怕接收到的数据包后来被丢弃了。看上去包含密钥更新的数据包很容易伪造，尽管密钥更新的过程不需要大量计算资源，但是攻击者还是可以触发它来进行拒绝服务攻击。
因此，终端必须有能力维护两组用于接收数据包的数据包保护密钥：当前阶段中的和下一阶段中的。维护除此之外的先前的密钥可能会提升性能，但是这是不必要的。</description>
    </item>
    
    <item>
      <title>6.4. 使用更新后的密钥来发送</title>
      <link>/RFC9001_Chinese_Translation/Key_Update/6.4_Sending_with_Updated_Keys/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9001_Chinese_Translation/Key_Update/6.4_Sending_with_Updated_Keys/</guid>
      <description>终端绝不会发送受旧密钥保护的数据包。只有当前阶段的密钥会被用到。切换到新密钥后，用于保护数据包的旧密钥可以被立即弃用。
用于保护具有更大数据包号的数据包的密钥必须与用于保护更小数据包号数据包的密钥一致，或比后者更新。如果终端用旧密钥移除了保护，但具有更小数据包号的数据包是受新密钥保护的，那么它必须将这种情况视作类型为KEY_UPDATE_ERROR的连接错误。</description>
    </item>
    
    <item>
      <title>6.5. 使用不同的密钥来接收</title>
      <link>/RFC9001_Chinese_Translation/Key_Update/6.5_Receiving_with_Different_Keys/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9001_Chinese_Translation/Key_Update/6.5_Receiving_with_Different_Keys/</guid>
      <description>在密钥更新期间，可能会接收到受旧密钥保护的数据包，它们因为被网络延误而刚刚抵达。保留旧的数据包保护密钥使得这些数据包能够被成功处理。
由于受来自下一阶段的密钥保护的数据包会与受来自上一阶段的密钥保护的数据包使用相同的密钥阶段，要想处理受旧密钥保护的数据包，就有必要区分这两种数据包。这可以通过使用数据包号来做到。如果重建出来的数据包号比当前密钥阶段的任一数据包号要小，那么这些数据包就要使用上一阶段的数据包保护密钥；如果重建出来的数据包号比当前密钥阶段的任一数据包号要大，那么这些数据包就要使用下一阶段的数据包保护密钥。
为了确保在上一阶段、当前阶段和下一阶段的数据包保护密钥间选择的过程不会在计时侧信道上泄露最终用于移除数据包保护的是哪一组密钥，必须谨慎操作。有关更多信息，详见第9.5章。
作为替代方案，终端可以仅维护两组数据包保护密钥，只需在经过对网络重排序来说充足的时间后将上一阶段的密钥替换为下一阶段的密钥。在这种情况下，只需要密钥阶段比特位就足以选择密钥。
在将下一阶段的接收密钥提升为当前阶段后，终端可以在建立再下一组数据包保护密钥前等待一段约为一个探测包超时（PTO；详见《QUIC恢复》）的时间。这组被推迟建立的新密钥可以在经过这段等待时间后才替换上一阶段的旧密钥。只不过有一个缺点，即PTO是一个主观的测量结果——也就是说，对端对于RTT的预估可能不同——这段等待时间既应该足够长以使得所有乱序数据包哪怕被确认了也都会被对端认定为丢包，又应该足够短以使得对端可以发起后续的密钥更新。
在对端保留旧密钥期间，对端可能无法解密发起密钥更新的数据包，终端需要允许这种情况的存在。在接收到能够表明先前的密钥更新已经被接收到的确认后，终端在发起密钥更新前应该等待一段时长为PTO三倍大小的时间。若没有留足时间，可能导致数据包被丢弃。
在接收到受新密钥保护的数据包后，终端保留旧的读取密钥的时长应该不超过PTO的三倍。在这段等待时间之后，旧的读取密钥和它们对应的秘密值应该被弃用。</description>
    </item>
    
    <item>
      <title>6.6. AEAD的用量上限</title>
      <link>/RFC9001_Chinese_Translation/Key_Update/6.6_Limits_on_AEAD_Usage/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9001_Chinese_Translation/Key_Update/6.6_Limits_on_AEAD_Usage/</guid>
      <description>本文档为AEAD设置了用量上限以确保在使用QUIC时哪怕过量使用AEAD也不会在通信的可信度和完整性上给予攻击者过多的优势。
TLS 1.3中定义的用量上限是为了抵御针对可信度的攻击，只有遵从这些限制，使用AEAD的保护才是有效的。认证加密中的完整性保护也依赖于对伪造数据包的尝试次数进行限制。TLS是以一遇到未通过认证校验的记录就关闭连接的方式做到这一点的。相比之下，QUIC会忽略无法通过认证的所有数据包，允许多次尝试伪造数据包。
QUIC为AEAD的可信度上限和完整性上限分别进行计数。在可信度方面，限制某个密钥可以加密的数据包数量。在完整性方面，限制某个连接中可以解密的数据包数量。下文是有关为各种AEAD算法施加限制的细节。
终端必须为每一组密钥单独计算加密数据包的数量。如果同一密钥的加密数据包总数超过了所选AEAD的可信度上限，那么终端必须停止使用这组密钥。在发送的受保护数据包数量超过所选AEAD允许的可信度上限前，终端必须发起密钥更新。如果无法进行密钥更新或触及了完整性上限，那么终端必须停止使用当前连接，并且以仅仅发送无状态重置的方式响应接收到的数据包。推荐终端在进入无法进行密钥更新的状态前立即用类型为AEAD_LIMIT_REACHED（触及AEAD上限）的连接错误来关闭连接。
对于AEAD_AES_128_GCM和AEAD_AES_256_GCM，可信度上限为223个加密数据包；详见附录B.1。对于AEAD_CHACHA20_POLY1305，其可信度上限要比可能的数据包数量（262）还大，因此不用考虑。对于AEAD_AES_128_CCM，可信度上限是221.5个加密数据包；详见附录B.2。
除了要为发送的数据包计数外，终端必须为在一条连接的存活期间内接收到但未通过认证的数据包计数。如果在某条连接中接收到但未通过认证的数据包总数，无论受什么密钥保护，超过了所选AEAD的完整性上限，那么终端必须立即用类型为AEAD_LIMIT_REACHED的连接错误来关闭连接，并且不再处理更多数据包。
对于AEAD_AES_128_GCM和AEAD_AES_256_GCM，完整性上限为252个非法数据包；详见附录B.1。对于AEAD_CHACHA20_POLY1305，完整性上限为236个非法数据包；详见《AEBounds》。对于AEAD_AES_128_CCM，完整性上限为221.5个非法数据包；详见附录B.2。应用这些限制能够降低攻击者成功伪造数据包的可能性；详见《AEBounds》、《ROBUST》和《GCM-MU》。
限制数据包尺寸的终端可以使用更高的可信度上限和完整性上限；有关细节详见附录B。
将来的分析与规范可以放松对于某AEAD的可信度上限或完整性上限。
可以被用于QUIC的任一TLS加密套件必须定义相关AEAD函数在可信度和完整性方面的用量上限。也就是说，这些限制必须准确指出允许被认证的数据包数量和允许未通过认证的数据包数量。提供一份分析如何计算该值的参考文献——并指出所有在此分析中使用到的假设——使得限制值能够变化以适应不同的使用条件。</description>
    </item>
    
    <item>
      <title>6.7. 密钥更新的错误码</title>
      <link>/RFC9001_Chinese_Translation/Key_Update/6.7_Key_Update_Error_Code/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9001_Chinese_Translation/Key_Update/6.7_Key_Update_Error_Code/</guid>
      <description>错误码KEY_UPDATE_ERROR（0x0e）被用于发送与密钥更新相关的错误的信号。</description>
    </item>
    
  </channel>
</rss>
