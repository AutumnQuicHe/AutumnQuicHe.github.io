<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>4.1. 面向TLS的接口 on AUTUMN QUICHE</title>
    <link>/RFC9001_Chinese_Translation/Carrying_TLS_Messages/Interface_to_TLS/</link>
    <description>Recent content in 4.1. 面向TLS的接口 on AUTUMN QUICHE</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>cn</language><atom:link href="/RFC9001_Chinese_Translation/Carrying_TLS_Messages/Interface_to_TLS/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>4.1.1. 握手完成</title>
      <link>/RFC9001_Chinese_Translation/Carrying_TLS_Messages/Interface_to_TLS/4.1.1_Handshake_Complete/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9001_Chinese_Translation/Carrying_TLS_Messages/Interface_to_TLS/4.1.1_Handshake_Complete/</guid>
      <description>在本文档中，当TLS栈报告握手已完成时，就可以认定此次TLS握手完成。这一事件会在TLS栈发送了自己的Finished（已结束）消息并且验证了对端的Finished消息时发生。验证对端的Finished消息使得终端能够确信之前的握手消息没有受到篡改。注意，两侧的终端不是同时认定握手完成的。所以，任何基于握手完成这一时机的要求，该时机都是由终端在具体问题中的角色决定的。</description>
    </item>
    
    <item>
      <title>4.1.2. 握手已确认</title>
      <link>/RFC9001_Chinese_Translation/Carrying_TLS_Messages/Interface_to_TLS/4.1.2_Handshake_Confirmed/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9001_Chinese_Translation/Carrying_TLS_Messages/Interface_to_TLS/4.1.2_Handshake_Confirmed/</guid>
      <description>在本文档中，在握手完成的同时，服务器一侧的TLS握手就可以被认定为已确认。一旦握手完成，服务器必须立即发送握手完成帧。而在客户端一侧，只有接收到握手完成帧后才能认定握手为已确认。
除此之外，客户端可以在接收到对于某个1-RTT数据包的确认时将握手认定为已确认。这可以通过记录使用1-RTT密钥发送的最小数据包号，并将它与接收到的1-RTTACK帧的最大确认数字段作比较，来实现：一旦后者大于等于前者，即可确认握手。</description>
    </item>
    
    <item>
      <title>4.1.3. 发送和接收握手消息</title>
      <link>/RFC9001_Chinese_Translation/Carrying_TLS_Messages/Interface_to_TLS/4.1.3_Sending_and_Receiving_Handshake_Messages/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9001_Chinese_Translation/Carrying_TLS_Messages/Interface_to_TLS/4.1.3_Sending_and_Receiving_Handshake_Messages/</guid>
      <description>为了进行握手，TLS需要发送和接收握手消息的能力。对于这个接口，有两个基本函数：QUIC从其中一个函数获取握手消息，向另一个函数提供组成握手消息的字节数据。
在启动握手前，QUIC向TLS提供它想传递的传输参数（详见第8.2章）。
QUIC客户端以向TLS获取握手的字节数据的方式启动TLS。客户端在发送首个数据包前获取握手的字节数据。QUIC服务器则以向TLS提供客户端的握手字节数据的方式启动TLS。
任一终端的TLS栈都始终记录着当前的发送密级和接收密级。TLS密级决定了QUIC数据包类型和用于保护数据的密钥。
每个密级都关联着各自的一份字节序列，这些字节内容会由加密帧可靠地发送给对端。当TLS提供了将要发送的握手字节时，这些字节会被追加到当前密级的握手字节内容后面。该密级决定着最终发送加密帧时所用的数据包类型；详见表1。
四个密级分别为初始数据包、0-RTT数据包、握手数据包和1-RTT数据包生成密钥。其中只有三个密级能被用来传递加密帧，不在其中的是0-RTT这个密级。这四个密级对应着三个数据包号空间：受初始密钥和握手密钥加密的数据包分别使用各自的空间；0-RTT数据包和1-RTT数据包使用应用数据数据包号空间。
QUIC使用未受保护的TLS握手记录的内容作为加密帧的内容。QUIC不使用TLS的记录保护。QUIC将加密帧组装进具有QUIC数据包保护的QUIC数据包。
QUIC加密帧仅传递TLS握手消息。TLS警告被转换为QUIC连接关闭帧的错误码；详见第4.8章。TLS应用数据和其他内容类型不能由QUIC以任何密级传递；不应该从TLS栈接收到它们，否则这是一种错误。
当终端从网络接收到了一个包含加密帧的QUIC数据包时，它应该这样处理：
  如果数据包使用了当前的TLS接收密级，那么数据会被正常地按顺序置入输入流。和流帧一样，要使用偏移值来在数据序列中找到正确的置入位置。如果完成该过程后出现了新的可用数据，那么新数据会被有序地交付给TLS。
  如果数据包来自之前使用过的密级，那么它包含的数据必须不扩展那个密级的数据流末尾。QUIC实现必须将任何违反这项要求的情况视作类型为PROTOCOL_VIOLATION（协议违反）的连接错误。
  如果数据包来自新的密级，那么它会被保存起来，用于将来给TLS处理。一旦TLS改用此密级接收数据，暂存着的数据就可以被交给TLS。当TLS为更高的密级提供密钥时，如果还有来自之前的密级但是还未被TLS处理的数据，那么必须将该情况视作类型为PROTOCOL_VIOLATION的连接错误。
  每次将新数据交给TLS时，都会向TLS获取新的握手字节。如果TLS接收到的握手消息不完整或它没有数据需要发送，那么它可能不会提供任何字节数据。
加密帧的内容可能会被TLS增量处理，或被缓存起来直到有完整的可用消息。TLS负责缓存按序到达的握手字节数据。QUIC负责缓存未按序到达或属于尚未可用的密级的握手字节。QUIC不会为加密帧提供任何流量控制的方法；详见《QUIC传输》的第7.5章。
一旦TLS握手完成，这一事件就会随着TLS要发送的最后的握手字节一起被告知给QUIC。在这个阶段，握手期间对端宣告的传输参数会被验证；详见第8.2章。
一旦握手完成，TLS就变得被动起来。TLS仍然可以从对端接收数据并作出响应，但它没有必要发送更多数据，除非被应用或QUIC专门提出要发送数据的请求。发送数据的可能原因之一是服务器可能想要向客户端新增或更新会话票据。
当握手完成后，QUIC只需要向TLS提供以加密帧的形式到达的数据。和握手期间的行为一样，处理完接收到的数据后QUIC会向TLS获取新数据。</description>
    </item>
    
    <item>
      <title>4.1.4. 改变密级</title>
      <link>/RFC9001_Chinese_Translation/Carrying_TLS_Messages/Interface_to_TLS/4.1.4_Encryption_Level_Changes/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9001_Chinese_Translation/Carrying_TLS_Messages/Interface_to_TLS/4.1.4_Encryption_Level_Changes/</guid>
      <description>当某个密级的密钥对TLS可用时，TLS会告知QUIC那个密级的读取密钥或写入密钥已经变为可用了。
新密钥变为可用这一事件一定是因向TLS提供输入而引发的。TLS只有在（被客户端）初始化后或接收到新握手数据时才会提供新密钥。
然而，TLS实现可能会异步地进行某些处理过程。尤其是，验证证书的过程可能会花不少时间。当等待TLS处理时，如果终端接收到了需要用尚未可用的密钥来处理的数据包，那么终端应该将它们缓存起来。一旦TLS提供了密钥，这些数据包就能够得到处理。终端应该继续响应此时可以处理的数据包。
在处理完输入后，TLS可能生成出握手字节、新密级的密钥或两者兼具。
当新密级可用时，TLS会向QUIC提供以下三份内容：
  一个秘密值
  一个带有关联数据的认证加密（AEAD）函数
  一个密钥衍生函数（KDF）
  这些值源自TLS协商出的那些值，以及被QUIC用于生成数据包与头部保护密钥的那些值；详见第5章和第5.4章。
如果要使用0-RTT，那么0-RTT会在客户端发送了TLS的ClientHello消息或服务器接收到这条消息后就绪。在第一次向QUIC提供握手字节后，TLS栈可能会发送有关0-RTT密钥发生变化的信号。在服务器接收到包含ClientHello消息的握手字节后，TLS服务器可以发送有关0-RTT密钥变为可用的信号。
尽管TLS在某一时刻只会使用一个密级，QUIC却可以同时使用不止一个密级。举例来说，终端在发送完Finished消息后（使用的是处于握手密级的加密帧），它可以发送流帧（使用的是1-RTT加密）。如果Finished消息在传输过程中被丢失了，那么终端会用握手密级重传丢失的消息。数据包乱序或丢包的存在意味着QUIC可能需要同时处理处于不同密级的数据包。在握手期间，这意味着有可能需要处理位于比TLS正在使用的密级更高或更低的密级的数据包。
特别是，服务器上的QUIC实现需要有能力同时读取位于握手密级和位于0-RTT密级的数据包。客户端可能使0-RTT数据与受握手密钥保护的ACK帧交错传输，而服务器得处理这些确认才能检测出丢包的握手数据包。
QUIC还需要访问对TLS实现来说并不可用的密钥。例如，客户端可能需要在准备好发送握手密级的加密帧前确认握手数据包。因此TLS可能需要在出于自己使用的目的而生成密钥前就向QUIC提供这些密钥。</description>
    </item>
    
    <item>
      <title>4.1.5. TLS接口概述</title>
      <link>/RFC9001_Chinese_Translation/Carrying_TLS_Messages/Interface_to_TLS/4.1.5_TLS_Interface_Summary/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9001_Chinese_Translation/Carrying_TLS_Messages/Interface_to_TLS/4.1.5_TLS_Interface_Summary/</guid>
      <description>图5概述了客户端和服务器上的QUIC和TLS的通信过程。实线箭头表示传递握手数据的数据包，虚线箭头表示可以发送应用数据的地方。每个箭头都具有一个标签，标示着此传输使用的密级。
 TODO：图5
  图5：QUIC和TLS间交互的概述
 从图5中可以看出，来自单次“航班”的多个数据包中的消息会被单独处理，这表示不同的传入消息触发调用了不同的行为。图中展示了多次“获取握手”的调用，它们在不同密级上获取握手消息。在处理完传入数据包后，会请求新的握手消息。
图5展示的是简单握手通信时的一种可能的结构。准确的过程会基于终端的实现架构和数据包抵达的顺序而变化。QUIC实现可以执行与图中不同的操作或不按图中的顺序执行操作。</description>
    </item>
    
  </channel>
</rss>
