<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>8.1 连接建立期间的地址验证 on Autumn Navigation</title>
    <link>/RFC9000_Chinese_Translation/Address_Validation/Address_Validation_during_Connection_Establishment/</link>
    <description>Recent content in 8.1 连接建立期间的地址验证 on Autumn Navigation</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>cn</language><atom:link href="/RFC9000_Chinese_Translation/Address_Validation/Address_Validation_during_Connection_Establishment/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>8.1.1 令牌构建</title>
      <link>/RFC9000_Chinese_Translation/Address_Validation/Address_Validation_during_Connection_Establishment/8.1.1_Token_Construction/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9000_Chinese_Translation/Address_Validation/Address_Validation_during_Connection_Establishment/8.1.1_Token_Construction/</guid>
      <description>构建在新令牌帧或重试数据包中发送的令牌时，必须使用一种能够令服务器识别出令牌提供给客户端的途径的方法。这些令牌被携带于相同字段中但是需要服务器进行不同的处理。</description>
    </item>
    
    <item>
      <title>8.1.2 使用重试数据包进行地址验证</title>
      <link>/RFC9000_Chinese_Translation/Address_Validation/Address_Validation_during_Connection_Establishment/8.1.2_Address_Validation_Using_Retry_Packets/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9000_Chinese_Translation/Address_Validation/Address_Validation_during_Connection_Establishment/8.1.2_Address_Validation_Using_Retry_Packets/</guid>
      <description>当接收到客户端的初始数据包时，服务器可以通过发送包含令牌的重试数据包（详见第17.2.5章）来请求地址验证。接收到重试数据包之后，客户端必须在为那条连接发送的所有初始数据包中重复这个令牌。
作为处理包含了曾在重试数据包中提供的令牌的初始数据包的回应，服务器不能再发送重试数据包；它只能拒绝那条连接或允许连接继续进行。
只要不存在攻击者为它自己的地址生成一个有效令牌（详见第8.1.4章）的可能性，并且客户端有能力将那个令牌返回给服务器，就能证实客户端接收到了令牌。
服务器还能使用重试数据包来推迟连接建立所需的状态数据和处理的成本。要求服务器提供一个不同的连接ID，以及在第18.2章中定义的传输参数original_destination_connection_id（原始目标连接ID），能强制服务器表明它，或和它一起工作的实体，从客户端接收到了原始的初始数据包。提供一个不同的连接ID还确保服务器对后续数据包如何路由有一定的控制能力。这可以被用来将连接指向不同的服务器实例。
如果服务器接收到了一个除了无效的重试令牌字段外都合法的客户端初始数据包，那么它能肯定客户端不会接收另一个重试令牌。服务器可以丢弃这样的数据包，并且允许客户端以超时的形式检测到本次握手的失败，但这会对客户端施加强烈的延迟惩罚。取而代之的是，服务器应该使用错误INVALID_TOKEN（无效令牌）立即关闭（详见第10.2章）连接。注意，服务器在这个时候还没有为连接建立任何状态数据所以不会进入到关闭状态。
图9展示的是关于重试数据包的使用的流程图。
 TODO：图9
  图9：使用重试的握手样例
 </description>
    </item>
    
    <item>
      <title>8.1.3 为将来的连接进行地址验证</title>
      <link>/RFC9000_Chinese_Translation/Address_Validation/Address_Validation_during_Connection_Establishment/8.1.3_Address_Validation_for_Future_Connections/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9000_Chinese_Translation/Address_Validation/Address_Validation_during_Connection_Establishment/8.1.3_Address_Validation_for_Future_Connections/</guid>
      <description>在一条连接进行期间，服务器可以向客户端提供一个可以被用于后续连接的地址验证令牌。地址验证对于0-RTT特别重要，因为服务器响应0-RTT数据时可能向客户端发送大量的数据。
服务器使用新令牌帧（详见第19.7章）来向客户端提供一个可以被用于验证将来的连接的地址验证令牌。在将来的连接中，客户端将这个令牌包含在初始数据包中来提供地址验证。客户端必须将令牌包含在所有它发送的初始数据包中，除非有重试数据包将令牌替换为新的值。客户端必须不在将来的连接中使用重试数据包里提供的令牌。服务器可以丢弃任何没有携带期望的令牌的初始数据包。
不像为重试数据包创建的令牌要被立即使用掉，在新令牌帧中发送的令牌即使经过了一段时间也能使用。因此，令牌应该具有一个过期时间，它既可以是一个显式的过期时间，也可以是一个可以被用来动态计算过期时间的签发时间戳。服务器可以将过期时间存储起来或将它以加密的形式包含在令牌中。
使用新令牌帧签发的令牌必须不包含会令观测者将之关联到被签发令牌所在的连接上的信息。例如，它不能包含先前的连接ID或地址信息，除非这些值是经过加密的。除了因为先前发送的新令牌帧遭遇丢包而重新发送的那些帧外，服务器必须确保它发送的任何新令牌帧在所有客户端间都是唯一的。允许服务器区分令牌是来自重试数据包还是新令牌帧的信息还会被并非服务器的实体访问到。
客户端的端口号在两条不同的连接间保持相同是不太可能的；因此验证端口不太可能成功。
如果与某服务器间的连接具有权威性（例如，服务器的名称是被包含在证书中的），那么在新令牌帧中接收到的令牌应该适用于这台服务器。当客户端连接到一台服务器且它对此服务器仍保有对此服务器适用的且未使用的令牌时，它应该在初始数据包的令牌字段中使用令牌。使用令牌可以允许服务器不需要额外花费往返时间就验证客户端地址。客户端必须不在连接到服务器时使用不适用于此服务器的令牌，除非客户端知道签发令牌的服务器和它正在连接的服务器是共享令牌的管理机制的。客户端可以使用来自任何先前与那台服务器的连接的令牌。
令牌允许服务器将令牌签发时所在的连接和任何它被使用时所在的连接间的网络活动关联起来。想要打破在某个服务器上的身份连续性的客户端可以丢弃使用新连接帧提供的令牌。相反，在重试数据包中获取的令牌必须在连接尝试期间被立即使用且不能被用于后续的连接尝试。
客户端不应该在不同的连接尝试间重用来自新令牌帧的令牌。重用令牌使得连接会被网络路径上的实体关联起来；详见第9.5章。
客户端可能在单条连接上接收到数个令牌。只要记得防止可关联性，任何令牌可以被用于任何连接尝试。服务器可以发送额外的令牌既可以为多次连接尝试提供地址验证，又可以取代可能会变为无效的旧令牌。对于客户端来说，这种不明确的目的意味着发送最近的未使用的令牌是最有可能有效的。尽管保存并使用更旧的令牌没有负面影响，但是客户端可以将更旧的令牌视为更不太可能会对此服务器的地址验证有效。
当服务器接收到具有地址验证令牌的初始数据包时，它必须尝试验证令牌，除非它已经完成了地址验证。如果令牌是无效的，那么服务器应该表现得就好像客户端的地址未经验证一样，这包括在必要时发送重试数据包。使用新令牌帧和重试数据包提供的令牌能够被服务器区分（详见第8.1.1章），并且后者会被更严格地验证。如果验证通过，服务器随后应该允许握手继续进行。
 注意：将客户端地址视为未经验证的而不是丢弃数据包的原因是，客户端可能是在之前的连接中从新令牌帧中获得令牌的，并且如果服务器丢失过状态，它就可能无法验证令牌，此时若丢弃数据包则会导致连接失败。
 在无状态的设计中，服务器可以使用经过加密和认证的令牌来将信息传递给客户端，随后从中恢复信息并用它来验证客户端的地址。令牌没有被整合进加密握手，所以它们是未经认证的。这意味着，客户端将可以重用令牌。为了避免利用这一属性的攻击，服务器可以将令牌中的信息限制为仅仅验证客户端地址时所需要的那些信息。
客户端可以将从一条连接中获取的令牌用于任何使用相同版本的连接尝试。当选择使用的令牌时，客户端不需要考虑正在尝试的连接的其他属性，包括应用协议、会话票证或其他连接属性的可能的选择。</description>
    </item>
    
    <item>
      <title>8.1.4 地址验证令牌完整性</title>
      <link>/RFC9000_Chinese_Translation/Address_Validation/Address_Validation_during_Connection_Establishment/8.1.4_Address_Validation_Token_Integrity/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9000_Chinese_Translation/Address_Validation/Address_Validation_during_Connection_Establishment/8.1.4_Address_Validation_Token_Integrity/</guid>
      <description>地址验证令牌必须是难以猜测的。在令牌中包含一个有着至少128位的熵的随机值会是足够的，但是这需要服务器记录它发送给客户端的值。
基于令牌的方案允许服务器将关于验证的状态数据带来的负载转移到客户端上。要使这种设计正常工作，令牌必须被能够抵御客户端修改或伪造的完整性保护所覆盖。要是没有完整性保护，恶意的客户端就能生成或猜测会被服务器接收的令牌值。只有服务器需要访问令牌的完整性保护密钥。
对令牌制定单一的定义良好的格式是没有必要的，因为服务器即使生成者又是消费者。在重试数据包中发送的令牌应该包含允许服务器验证客户端数据包中的源IP地址和端口是否保持不变的信息。
在新令牌帧中发送的令牌必须包含允许服务器验证客户端的IP地址是否和令牌签发时的值一致的信息。服务器可以使用来自新令牌帧的令牌来做出不发送重试数据包的决定，即使客户端地址已经改变。如果客户端的IP地址已经改变，那么服务器必须遵守抗放大上限；详见第8章。注意，由于NAT的存在，这项要求可能不足以保护其他共享NAT的主机免于放大攻击。
攻击者可能在DDoS攻击中重放令牌来将服务器用作放大器。为了抵御这种攻击，服务器必须确保令牌的重放是被阻止或限制的。服务器应该确保在重试数据包中发送的令牌仅会在一段较短时间内被接受，因为它们会被客户端立即返回。在新令牌帧（详见第19.7章）中提供的令牌应该有更长的有效时间但是不应该能被多次接受。建议服务器尽可能只允许令牌被使用一次；令牌可以包含关于客户端的额外信息来进一步缩减适用范围或重用机会。</description>
    </item>
    
  </channel>
</rss>
