<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>17.2 长包头数据包 on AUTUMN QUICHE</title>
    <link>/RFC9000_Chinese_Translation/Packet_Formats/Long_Header_Packets/</link>
    <description>Recent content in 17.2 长包头数据包 on AUTUMN QUICHE</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>cn</language><atom:link href="/RFC9000_Chinese_Translation/Packet_Formats/Long_Header_Packets/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>17.2.1 版本协商数据包</title>
      <link>/RFC9000_Chinese_Translation/Packet_Formats/Long_Header_Packets/17.2.1_Version_Negotiation_Packet/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9000_Chinese_Translation/Packet_Formats/Long_Header_Packets/17.2.1_Version_Negotiation_Packet/</guid>
      <description>版本协商数据包（Version Negotiation packet）本质上不是版本特定的。客户端收到后，将根据版本字段值为0将其识别为版本协商数据包。
版本协商数据包是对一个包含了服务器不支持的版本的客户端数据包的响应。它只能被服务器发送。
一个版本协商数据包的结构如下：
版本协商数据包 { 包头形式 (1) = 1, 未使用 (7), 版本 (32) = 0, 目标连接ID长度 (8), 目标连接ID (0...2040), 源连接ID长度 (8), 源连接ID (0...2040), 支持的版本 (32) ..., } 图14：版本协商数据包
 未使用字段中的值由服务器设置为任意值。客户端必须忽略此字段的值。当QUIC可能被与其他协议多路复用时（详见RFC7983），服务器应该将这个字段的最高有效位（0x40）设置为1以使得版本协商数据包看起来具有固定比特位字段。要注意的是其他版本的QUIC不一定做出类似的推荐。
版本协商数据包的版本字段必须被设置为0x00000000。
服务器在目标连接ID字段中使用的值必须来自接收到的那个数据包的源连接ID字段。源连接ID字段的值必须是从接收到的那个数据包的目标连接ID字段中拷贝来的，这是个来自客户端的随机选择的值。回显两个连接ID可以让客户端确信服务器收到了数据包，并且版本协商数据包不是由没有观察初始数据包的实体生成的。
将来版本的QUIC可以对连接ID的长度有不同要求。特别是，连接ID可能具有更小的最小长度或更大的最大长度。
版本协商数据包的剩余部分是一个列表，包含服务器支持的一个个32位长的版本号。
版本协商包不会被确认。它只会作为一个使用了不受支持的版本的数据包的响应而被发送，详见第5.2.2章。
版本协商数据包不包含在其他使用了长包头形式的数据包中存在的数据包号和长度字段。因此，一个版本协商数据包消耗一整个UDP数据报。
服务器必须不对单个UDP数据报响应超过1个版本协商数据包。
有关版本协商的过程，详见第6章。</description>
    </item>
    
    <item>
      <title>17.2.3 0-RTT</title>
      <link>/RFC9000_Chinese_Translation/Packet_Formats/Long_Header_Packets/17.2.3_0-RTT/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9000_Chinese_Translation/Packet_Formats/Long_Header_Packets/17.2.3_0-RTT/</guid>
      <description>0-RTT数据包使用类型值为0x01的长包头，后面跟着长度和数据包号字段，详见第17.2章。首个字节包含保留比特位和数据包号长度比特位，详见第17.2章。0-RTT数据包被用来在握手完成前，携带来自客户端的“早期”数据，作为第一轮通信的一部分被发向服务器。
有关0-RTT数据及其局限的讨论，详见《TLS13》的第2.3章。
初始数据包 { 包头形式 (1) = 1, 固定比特位 (1) = 1, 长数据包类型 (2) = 1, 保留比特位 (2), 数据包号长度 (2), 版本 (32), 目标连接ID长度 (8), 目标连接ID (0..160), 源连接ID长度 (8), 源连接ID (0..160), 长度 (i), 数据包号 (8..32), 数据包载荷 (8..), } 图16：0-RTT数据包
 受0-RTT保护的数据包，与受1-RTT保护的数据包使用相同的数据包号空间。
在客户端接收到重试数据包时，0-RTT数据包有可能是被弄丢了，或者被服务器丢弃了。客户端应该在发送新的初始数据包后尝试用0-RTT数据包重新发送数据。所有新发送的数据包都必须使用新的数据包号；如第17.2.5.3章所述，重用数据包号可能使数据包保护失效。
客户端只有在握手完成后才会收到0-RTT数据包的确认，如《QUIC-TLS》的第4.1.1章所述。
一旦客户端开始处理来自服务器的1-RTT数据包，它就必须不再发送0-RTT数据包。这意味着0-RTT数据包不能包含任何对于来自1-RTT数据包中的帧的回复。比如说，客户端不能在0-RTT数据包中发送ACK帧，因为它只能被用来确认1-RTT数据包。必须用1-RTT数据包来携带对于1-RTT数据包的确认。
服务器必须视违反已记录的限制的情况为一个合适类型的连接错误（例如，超过流数据限制时使用FLOW_CONTROL_ERROR（流量控制错误））。</description>
    </item>
    
    <item>
      <title>17.2.4 握手数据包</title>
      <link>/RFC9000_Chinese_Translation/Packet_Formats/Long_Header_Packets/17.2.4_Handshake_Packet/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9000_Chinese_Translation/Packet_Formats/Long_Header_Packets/17.2.4_Handshake_Packet/</guid>
      <description>握手数据包（Handshake packet）使用类型值为0x02的长包头，后面跟着长度和数据包号字段，详见第17.2章。首个字节包含保留比特位和数据包号长度比特位，详见第17.2章。这种数据包被用来携带来自服务器和客户端的加密握手消息和确认。
握手数据包 { 包头形式 (1) = 1, 固定比特位 (1) = 1, 长数据包类型 (2) = 2, 保留比特位 (2), 数据包号长度 (2), 版本 (32), 目标连接ID长度 (8), 目标连接ID (0..160), 源连接ID长度 (8), 源连接ID (0..160), 长度 (i), 数据包号 (8..32), 数据包载荷 (8..), } 图17：受握手保护的数据包
 一旦客户端接收到了来自服务器的握手数据包，它就开始使用握手数据包来向服务器发送后续加密握手消息和确认。
握手数据包的目标连接ID字段包含一个由数据包接收方选择的连接ID；源连接ID包含的是数据包的发送方想要使用的连接ID，详见第7.2章。
握手数据包有它们自己的数据包号空间，因此由服务器发送的首个握手数据包使用的是值为0的数据包号。
这种数据包的载荷是加密帧，也可以包含Ping帧、填充帧或ACK帧。握手数据包可以包含类型为0x1c的连接关闭帧。若握手数据包中出现了其他种类的帧，则接收到该数据包的终端必须将该情况视作一个类型为PROTOCOL_VIOLATION（协议违背）的连接错误。
如初始数据包一样（详见第17.2.2.1章），当握手保护密钥被弃用时，握手数据包中的加密帧里的数据会被丢弃且不再重新传输。</description>
    </item>
    
  </channel>
</rss>
