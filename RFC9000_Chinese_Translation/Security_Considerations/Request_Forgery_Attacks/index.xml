<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>21.5. 请求伪造攻击 on AUTUMN QUICHE</title>
    <link>/RFC9000_Chinese_Translation/Security_Considerations/Request_Forgery_Attacks/</link>
    <description>Recent content in 21.5. 请求伪造攻击 on AUTUMN QUICHE</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>cn</language><atom:link href="/RFC9000_Chinese_Translation/Security_Considerations/Request_Forgery_Attacks/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>21.5.1. 控制终端的途径</title>
      <link>/RFC9000_Chinese_Translation/Security_Considerations/Request_Forgery_Attacks/21.5.1_Control_Options_for_Endpoints/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9000_Chinese_Translation/Security_Considerations/Request_Forgery_Attacks/21.5.1_Control_Options_for_Endpoints/</guid>
      <description>QUIC给了攻击者一些影响或操纵其对端的UDP数据报发送目标的机会：
  初始的连接建立（详见第7章），此时服务器拥有操纵客户端的数据包发送目标的能力——例如，通过填写DNS记录的方式；
  首选地址（详见第9.6章），此时服务器拥有操纵客户端的数据包发送目标的能力；
  虚假的连接迁移（详见第9.3.1章），此时客户端具有使用伪造的源地址来操纵服务器后续数据报的发送目标的能力；以及
  伪造的数据包，这能令服务器发送版本协商数据包（详见第21.5.5章）。
  在任一情况下，攻击者都能令其对端向某个受害者发送数据报，无论受害者能不能理解QUIC。也就是说，这些数据包会在对端进行地址验证前就被发送出去；详见第8章。
在数据包经加密的部分之外，QUIC给予了终端一些可选项，用于控制其对端发送的UDP数据报的内容。目标连接ID字段提供了针对对端发送的数据包中位置靠前的字节的直接控制；详见第5.1章。初始数据包中的令牌字段提供了针对初始数据包中其他字节的控制；详见第17.2.2章。
在本QUIC版本中没有任何方法来阻止针对数据包中经加密的部分的间接控制。假定终端能够控制对端所发送的帧内容是很有必要的，尤其是那些传递应用数据的帧，例如流帧。尽管它在一定程度上依赖于应用协议的细节部分，但是在多数协议的使用场景中都有可能出现某种程度的控制能力。只要攻击者能访问到数据包保护密钥，它们就有能力预测对端会如何加密后续数据包。于是，要成功控制数据报内容，只需要攻击者有能力预测数据包号和数据包中的帧大概会出现的位置。
本节假定了我们无法限制攻击者对数据报内容的控制。在后续章节中，抵御手段的重点在于限制数据报会在进行地址验证前就被发送出去的情况，以防止它们被用于进行请求伪造。</description>
    </item>
    
    <item>
      <title>21.5.2. 使用客户端初始数据包的请求伪造</title>
      <link>/RFC9000_Chinese_Translation/Security_Considerations/Request_Forgery_Attacks/21.5.2_Request_Forgery_with_Client_Initial_Packets/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9000_Chinese_Translation/Security_Considerations/Request_Forgery_Attacks/21.5.2_Request_Forgery_with_Client_Initial_Packets/</guid>
      <description>假扮成服务器的攻击者可以自由宣称自己所在的IP地址和端口，所以发送自客户端的初始数据包被假定为可以用于此类攻击。在握手中隐含着的地址验证确保了——在建立新连接时——客户端不会向一个不理解QUIC或不愿意接受QUIC连接的目标发送其他类型的数据包。
初始数据包保护（详见《QUIC-TLS》的第5.2章）使得服务器难以操纵由客户端发送的初始数据包内容。客户端会选择一个不可预测的目标连接ID，确保了服务器无法操纵客户端初始数据包中任何经加密的部分。
然而，令牌字段是开放给服务器去控制的，并且它确实允许服务器利用客户端来进行请求伪造攻击。使用由新令牌帧（详见第8.1.3章）提供的令牌成为了在连接建立期间进行请求伪造的唯一途径。
不过，客户端并没有一定要使用新令牌帧的义务。只需要客户端在服务器的地址与发送新令牌帧时的不同的情况下发送空的令牌字段，依赖于令牌字段的请求伪造攻击就可以被避免。
客户端可以在服务器地址变化时避免使用新令牌帧。然而，不使用令牌字段会对性能产生不利影响。服务器可能依赖于新令牌帧以在发送数据时超过三倍限制；详见第8.1章。尤其是，这会影响客户端使用0-RTT来从服务器请求数据的情况。
重试数据包为服务器提供了改变令牌字段的一种途径。在发送了重试数据包后，服务器还可以控制客户端后续初始数据包中的目标连接ID字段。这还有可能实现对初始数据包中经加密的内容的间接控制。然而，有关重试数据包的通信验证了服务器的地址，于是阻止了将后续初始数据包用于请求伪造。</description>
    </item>
    
    <item>
      <title>21.5.3. 使用首选地址的请求伪造</title>
      <link>/RFC9000_Chinese_Translation/Security_Considerations/Request_Forgery_Attacks/21.5.3_Request_Forgery_with_Preferred_Addresses/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9000_Chinese_Translation/Security_Considerations/Request_Forgery_Attacks/21.5.3_Request_Forgery_with_Preferred_Addresses/</guid>
      <description>服务器可以指定首选地址，客户端在确认完握手之后就会发起迁移；详见第9.6章。客户端发向首选地址的数据包中的目标连接ID字段可以被用于请求伪造。
客户端必须不在验证某首选地址前就向它发送非探测帧；详见第8章。这极大地减少了服务器能够操纵数据报中经加密的部分的途径数量。
本文档没有提供额外的与使用首选地址有关的和能够由终端实现的对抗措施。在第21.5.6章中描述的通用措施可以被用作更进一步的抵御手段。</description>
    </item>
    
    <item>
      <title>21.5.4. 使用虚假迁移的请求伪造</title>
      <link>/RFC9000_Chinese_Translation/Security_Considerations/Request_Forgery_Attacks/21.5.4_Request_Forgery_with_Spoofed_Migration/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9000_Chinese_Translation/Security_Considerations/Request_Forgery_Attacks/21.5.4_Request_Forgery_with_Spoofed_Migration/</guid>
      <description>客户端能够在连接迁移中使用伪造的源地址，使得服务器向该地址发送数据报。
服务器后续向这个假地址发送的任何数据包中的目标连接ID字段都能被用于请求伪造。客户端可能还有影响密文的能力。
在进行地址验证前只会向该地址发送探测数据包（详见第9.1章）的服务器让攻击者对数据报中经加密的部分仅持有有限的控制。然而，尤其是对NAT重绑定来说，这会对性能产生不利影响。如果服务器发送了携带着应用数据的帧，那么攻击者就可能控制数据报中的绝大多数内容。
除了在第21.5.6章中描述的通用措施外，本文档没有提供终端能够实现的专门的对抗措施。然而，在网络层面的针对地址伪造的对抗措施——尤其是传入流量过滤（详见BCP38）——对于使用伪造地址且源自外部网络的攻击是极其有效的。</description>
    </item>
    
    <item>
      <title>21.5.5. 使用版本协商的请求伪造</title>
      <link>/RFC9000_Chinese_Translation/Security_Considerations/Request_Forgery_Attacks/21.5.5_Request_Forgery_with_Version_Negotiation/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9000_Chinese_Translation/Security_Considerations/Request_Forgery_Attacks/21.5.5_Request_Forgery_with_Version_Negotiation/</guid>
      <description>有能力在数据包中使用虚假源地址的客户端能够令服务器向该地址发送版本协商数据包（详见第17.2.1章）。
在未知版本的数据包中对于连接ID字段长度限制的缺失提高了客户端能够在产生的数据报中控制的数据量。该数据包的首个字节不在客户端控制之下，并且后四个字节均为零，但是客户端可以控制从第五个字节开始的至多512个字节。
针对此类攻击，没有提供专门的对抗措施，不过通用的保护手段（详见第21.5.6章）是适用的。在这种情况下，传入流量过滤（详见《BCP38》）也是有效的。</description>
    </item>
    
    <item>
      <title>21.5.6. 针对请求伪造的通用对抗措施</title>
      <link>/RFC9000_Chinese_Translation/Security_Considerations/Request_Forgery_Attacks/21.5.6_Generic_Request_Forgery_Countermeasures/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9000_Chinese_Translation/Security_Considerations/Request_Forgery_Attacks/21.5.6_Generic_Request_Forgery_Countermeasures/</guid>
      <description>针对请求伪造攻击的最有效防御方法就是修改易受攻击的服务，让它使用强有力的鉴权认证。然而，这一点并不总是在QUIC部署的控制之下。本节概述了QUIC终端可以单方面采取的一些其他措施。这些额外措施都应该酌情使用，因为根据情况的不同，它们可能干涉或阻止QUIC的正常工作。
通过回环接口提供的服务通常缺乏恰当的鉴权认证。终端可以阻止指向回环地址的连接尝试或迁移。当指向的服务曾在另一个接口上开放过，或者指向的回环地址是由位于非回环地址的服务提供的，那么终端不应该批准指向这个回环地址的连接或迁移。依赖于这些能力的终端可以提供一个可以禁用这些保护的选项。
类似地，终端可以将从全球唯一地址、唯一本地地址（详见《RFC4193》）或非私有地址变更到链路本地地址（详见《RFC4291》）或处于私有使用范围的地址（详见《RFC1918》）的情况视作潜在的对请求伪造的企图。终端可以完全拒绝使用以上地址，但是要承担干涉QUIC合法用途的巨大风险。终端不应该拒绝使用某个地址，除非它对于网络的先验知识告诉它向某范围内的未经验证的地址发送数据报是不安全的。
终端可以选择以不使用来自初始数据包中新令牌帧的值的方式或只有在完成地址验证后才在数据包中发送探测帧的方式来减少请求伪造的风险。注意，这不能阻止攻击者将目标连接ID用于攻击中。
终端不需要专门持有容易成为请求伪造攻击目标的服务器的位置信息。然而，经过一段时间后，识别出某些常常成为攻击目标的UDP端口或被用于进行攻击的数据报中的特定模式是有可能的。终端可以选择避免向那些端口发送数据报或不在验证目标地址前发送符合这种模式的数据包。终端可以撤销符合已知可能产生问题的模式的连接ID而不使用它们。
注意： 修改终端来应用以上保护措施比起部署基于网络的保护措施要更高效，因为终端在向经验证的地址发送数据时不需要进行额外的处理。</description>
    </item>
    
  </channel>
</rss>
