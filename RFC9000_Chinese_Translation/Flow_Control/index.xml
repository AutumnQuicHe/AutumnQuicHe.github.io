<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>4. 流量控制 on Autumn Navigation</title>
    <link>/RFC9000_Chinese_Translation/Flow_Control/</link>
    <description>Recent content in 4. 流量控制 on Autumn Navigation</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>cn</language><atom:link href="/RFC9000_Chinese_Translation/Flow_Control/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>4.1. 数据流量控制</title>
      <link>/RFC9000_Chinese_Translation/Flow_Control/4.1_Data_Flow_Control/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9000_Chinese_Translation/Flow_Control/4.1_Data_Flow_Control/</guid>
      <description>QUIC使用一个基于限制的流量控制模型，接收者给出其准备在给定流或整个连接上准备接收的总字节数的上限。 这使得QUIC中存在两层数据流量控制：
 流的流量控制：通过限制每条流可以发送的数据量，防止单条流耗尽一条连接的全部接收缓冲区； 连接流量控制：通过限制所有流经由流帧可以发送的数据量，防止发送方超过连接接收方的缓冲区容量。  发送方发送数据必须不能超过上述任何一个限制。
接收方可以通过发送一个含相关流ID的最大流数据帧告知对方提高流接收缓存区上限。 最大流数据帧表示流的最大绝对字节偏移量。 接收方可以根据当前流消耗数据的偏移量确定后续发出的流量控制的偏移量。
接收方可以通过发送一个最大数据帧告知对方提高连接的接收缓存区上限，亦即所有流绝对字节偏移量之和的上限。 接收方维护一个在所有流上累计接收数据的总字节数，用以检查是否超过了连接或流流量控制上限。 接收方可以基于在所有流上消耗数据总字节数确定后续发出的最大数据偏移量。
接收方发布连接或流的流量控制上限若低于之前的上限，这不是错误，只是这个更低的上限不会生效而已。
如果发送方违反了推荐的连接或流的流量控制上限，接收方必须以FLOW_CONTROL_ERROR类型错误关闭连接，更多错误处理相关细节详见第11章。
发送方必须忽略任何不会提高流量控制上限的最大流数据帧或最大数据帧。
如果发送方发送数据达到了流量控制上限，其将不能再发送新数据，且应认为其被阻塞住了。 发送方应该发送一个流数据阻塞帧或数据阻塞帧来告知接收方其有数据要写出但是被流量控制所阻塞。 如果发送方被阻塞的时间超过空等超时时间（第10.1章），接收方可以关闭连接，即便发送方有可传输的数据。 为了保持连接不被关闭，在没有可引发ACK的数据包处于传输中时，被流量控制限制所阻塞的发送方应该定期发送一个流数据阻塞帧或数据阻塞帧。</description>
    </item>
    
    <item>
      <title>4.2. 提高流量控制限制</title>
      <link>/RFC9000_Chinese_Translation/Flow_Control/4.2_Increasing_Flow_Control_Limits/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9000_Chinese_Translation/Flow_Control/4.2_Increasing_Flow_Control_Limits/</guid>
      <description>QUIC实现决定什么时候以什么额度通过最大流数据帧及最大数据帧提高流量控制限制，但是本章提出了一些注意事项。
为了避免阻塞发送方，接收方可以在一个往返时间（RTT）内多次发送一个最大流数据帧或最大数据帧，或者尽可能早地发送，从而为帧的丢失及随后的恢复留出时间。
控制帧也会引入连接开销。 也就是说频繁发送最大流数据帧及最大数据帧做极其微小的调整是不可取的。 另一方面，如果更新不够频繁，每次更新时就要对接收方上限做更大幅度的提升以防发送方被阻塞，使得接收方耗费需要更多资源。 因此，确定决定接收方推荐上限需要权衡资源耗费与连接开销。
接收方可以使用一个常见于TCP实现的基于往返时间及接收数据应用层消耗速率的自动调谐机制来调整推荐接收上限的频率和增量。 作为优化，终端只有在有其他帧要发送时才可以发送流量控制相关帧，以确保流量控制不会导致额外的数据包发送。
被阻塞发送方不需要发送流阻塞帧或数据阻塞帧。 也就是说，接收方必须不能在发送最大流数据帧及最大数据帧前等待接收流阻塞帧或数据阻塞帧，否则可能导致发送方在连接的其余部分被阻塞。 即使发送方发送了这些帧，等待它们也会导致发送方至少被阻塞一个完整的往返周期。
当终端在阻塞期间收到可发送数据额度时，它可能会回复大量数据，造成短暂的拥塞，详见《QUIC快速恢复》第7.7章有关终端如何避免这类拥塞的讨论。
秋航注：这里将credit翻译为额度、增量等，指的是最大流数据帧及最大数据帧所带来的接收方新流量控制上限相对之前的提升量，这个提升量是发送方后续可发送新数据的空间。
 </description>
    </item>
    
    <item>
      <title>4.3. 流量控制性能</title>
      <link>/RFC9000_Chinese_Translation/Flow_Control/4.3_Flow_Control_Performance/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9000_Chinese_Translation/Flow_Control/4.3_Flow_Control_Performance/</guid>
      <description>如果终端不能确保其对端始终在该连接上有大于对端带宽时延积的流量控制额度，其接收吞吐量将被流量控制限制。
包丢失会导致接收缓冲区出现空隙，从而阻碍应用层消耗数据并释放接收缓冲空间。
及时发送流量控制上限更新能提高性能。 发送只包含流量控制更新的数据包会增加网络负载，对性能产生不利影响。 将流量控制更新与其他帧一起发出，例如如ACK帧，可以降低此类更新带来的消耗。</description>
    </item>
    
    <item>
      <title>4.4. 处理流取消</title>
      <link>/RFC9000_Chinese_Translation/Flow_Control/4.4_Handling_Stream_Cancellation/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9000_Chinese_Translation/Flow_Control/4.4_Handling_Stream_Cancellation/</guid>
      <description>终端之间最终必须在每条流消耗的流量控制额度上达成一致，从而能够计算出连接级流量控制的字节数。
收到流重置帧后，终端就会关闭相应流的状态，并忽略后续从该流上收到的数据。
流重置帧会立即中止流的一个方向。 对于一条双向流，流重置帧不会影响另一个方向的数据流。 双端必须给一条流尚未关闭的方向维持流量控制状态直到该方向转入终止状态。
秋航注：“中止”与“终止”的区别在于“中止”强调突然地、异常地结束一个过程，而“终止”没有这种强调意味。可以认为，“终止”包含流程的正常结束和异常“中止”两种情况。
 </description>
    </item>
    
    <item>
      <title>4.5. 流的最终数据量</title>
      <link>/RFC9000_Chinese_Translation/Flow_Control/4.5_Stream_Final_Size/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9000_Chinese_Translation/Flow_Control/4.5_Stream_Final_Size/</guid>
      <description>流的最终数据量是流消耗的流量控制额度的总量。 假设流的每个连续的字节只被发送一次，那么其最终数据量就是发出的总字节数。 更一般地来说，这比流上发送的最大偏移的字节高1，若无字节发送则为0。
不管流是如何终止的，发送方始终试图将流的最终数据量可靠地发送给接收方。 最终数据量是 带有FIN置位的流帧的Offset（下标）和Length（长度）字段值的总和，注意这些字段可能是隐式的。 或者，流重置帧的Final Size字段也可以携带最终数据量值。 这保证了双端发送方在该流上消耗的流量控制额度上达成一致。
终端在流的接收部分转入“数据量确认”或“重置接收”状态（第3章）后将得知最终数据量。 接收方必须根据流的最终数据量在其连接层流量控制上统计该流发送的字节数。
终端在一条流上发送的数据必须不能大于或等于其最终数据量。
一旦流的最终数据量得到确认，就不能再更改。 如果收到流重置神或流帧表示要修改流的最终数据量，终端应该回复一个FINAL_SIZE_ERROR类型的错误，更多细节详见第11章有关错误处理部分。 接收方应该将收到达到或超过最终数据量数据的情况视为FINAL_SIZE_ERROR类型的错误，即使是在关闭后收到的。 并不强制要求生成这些错误，因为终端若要做到这一点往往意味着终端需要给已关闭流维持一个最终数据量状态，也就意味着需要增加一个重要的状态确认。</description>
    </item>
    
    <item>
      <title>4.6. 并发控制</title>
      <link>/RFC9000_Chinese_Translation/Flow_Control/4.6_Controlling_Concurrency/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9000_Chinese_Translation/Flow_Control/4.6_Controlling_Concurrency/</guid>
      <description>终端限制对端累计可以开启的流的数量。 只有流ID小于(max_streams * 4 + first_stream_id_of_type)的流可以被开启，详见表1。 初始化限制由传输参数设置，详见第18.2章。 随后的限制由最大流帧推出，详见第19.11。 针对单向及双向流由单独的限制。
如果经由max_streams传输参数或最大流帧收到的值大于260，这将使得最大流ID不能表示为变长整数，详见第16章。 如果收到了这两者的其中一个，必须立即关闭连接： 如果这个值是通过传输参数收到的，就以TRANSPORT_PARAMETER_ERROR错误关闭连接；如果是通过帧收到的，就以FRAME_ENCODING_ERROR错误关闭连接，详见第10.2章。
终端必须不能触达对端设置的流数量限制。 终端收到一个有个触达其设置的流数量上限的流ID的帧的情况必须视为STREAM_LIMIT_ERROR类型的连接错误，更多有关错误梳理的细节详见第11章。
一旦接收方通过最大流帧推荐了一个流数量上限，再推荐一个更小的上限将不再生效。 必须忽略不会提高流数量上限的最大流帧。
正如流及连接层流量控制，本文让实现者来决定通过最大流帧发布的流数量上限的时间及数值。 QUIC实现可以选择在流关闭时提高流数量上限，从而保持对端可以使用的流的数量大体对等。
终端因对端设置的流数量上限而不能再开启新流时，应该发送一个流阻塞帧（第19.14章）。 可以认为这个信号主要用于调试。 终端必须不在对端发布额外额度前等待这个信号，因为这样做的话意味着对端会被阻塞至少一个往返周期，且若对端选择不发流阻塞帧时则等待可能会是无限期的。</description>
    </item>
    
  </channel>
</rss>
