<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>3. 流状态 on Autumn Navigation</title>
    <link>/RFC9000_Chinese_Translation/Stream_States/</link>
    <description>Recent content in 3. 流状态 on Autumn Navigation</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>cn</language><atom:link href="/RFC9000_Chinese_Translation/Stream_States/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>3.1. 流发送状态</title>
      <link>/RFC9000_Chinese_Translation/Stream_States/3.1_Sending_Stream_States/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9000_Chinese_Translation/Stream_States/3.1_Sending_Stream_States/</guid>
      <description>图2展示了通过流向对端发送发送数据的状态。
 图2：流数据发送部分状态
 终端发起的流的发送部分（客户端发起的流类型是0和2，1和3则是由服务端发起的）由应用层打开。 用于发送的流数据可能被缓存起来。
发送首个流帧（STREAM）或流阻塞帧（STREAM_DATA_BLOCKED）使流的发送部分进入“发送”状态。 QUIC实现可以选择延迟分配流ID直到其发送首个流帧并进入“发送”状态，这样可以实现更好的流优先级。
由对端发起的双向流的发送部分（服务端发起的流类型是0，客户端发起的是1）在接收部分创建时就已处于“就绪”状态，并从此状态开始。
在“发送”状态，终端通过流帧传输——必要时重传——流数据。 终端遵从其对端设置的流量控制限制，同时持续接收与处理最大流数据帧（MAX_STREAM_DATA）。 当发送过程被流的流量控制限制（第4.1章）所阻塞时，处在“发送”状态的终端会生成流阻塞帧。
在应用层表示所有应用数据及一个带FIN置位的流帧都发送完成后，流的发送部分进入“发送完成”状态。 从这个状态开始，终端只会做必要的数据重传。 在对端收到最终流下标前，都有可能收到最大流数据帧。 处与此状态的终端可以忽略任何其收到的最大流数据帧，这样是安全的。
当所有流数据都被成功确认后，发送部分进入“接收完成”状态，这是一个最终状态。
处在“就绪”、“发送”及“发送完成”状态中的任何一个状态时，应用层都可以提出取消发送流数据。 相应地，终端也可能从其对端收到一个停止发送帧（STOP_SENDING）。 不论哪种情况，终端都会发送流重置帧（RESET_STREAM），随后流进入“重置发送”状态。
终端可以发送一个流重置帧作为流的首个帧，这会导致该流的发送部分开启然后立即转到“重置发送”状态。
一旦一个包含流重置帧的数据包被确认，流的发送部分即进入“重置接收”状态，这也是一个最终状态。</description>
    </item>
    
    <item>
      <title>3.2. 接收流状态</title>
      <link>/RFC9000_Chinese_Translation/Stream_States/3.2_Receiving_Stream_States/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9000_Chinese_Translation/Stream_States/3.2_Receiving_Stream_States/</guid>
      <description>图3展示了通过流从对端接收数据的状态。 流的接收部分只会反映对端流发送部分的一些状态。 流的接收部分不能追踪发送部分那些不可见的状态，例如“就绪”状态。 相反，流的接收部分追踪向应用层传递的数据，其中一些数据对发送端不可见。
 图3：流数据接收部分状态
 由对端发起的流（客户端发起的流类型是1和3，服务端发起的是0和2）的接收部分在收到该流的第一个流帧、流阻塞帧或流重置帧时创建。 对于由对端创建的双向流，发送部分收到最大流数据帧或停止发送帧时也会创建该流的接收部分。 流的接收部分的初始状态是“发送”状态。
由本端发起的双向流（客户端发起的流类型是0，服务端发起的是1），当其发送部分进入“就绪”状态时，其接收部分进入“接收”状态。
终端在收到最大流数据帧或停止发送帧后打开一条双向流。 接收到一条未开启的流的最大流数据帧意味着对端已经开启了该流，并开始支持流量控制信用。 而接收到一条未开启流的停止发送帧意味着对端不会再从该流接收数据。 无论这两种帧的哪一种都可能先于流帧或流阻塞帧到达本端，原因是包丢失或乱序。
在一条流创建前，所有数值小于该流ID的同类型流都必须被创建。 这样能确保双端流的创建次序保持一致。
在“接收”状态，终端接收流帧和流阻塞帧。 传入数据将被缓存，并可以按照正确顺序重组以便递给应用层。 随着应用层不断消耗数据，缓冲区重新空出来，终端发送最大流数据帧告知对端可以发送更多数据。
当收到一个带FIN置位的流帧时，数据的最终大小确定下来，详见第4.5章。 流的接收部分随后转到“数据量确认”状态。 在此状态，终端不再需要发送最大流数据帧，只需要接收重传数据即可。
一旦收完了一条流的所有数据，流的接收部分转入“接收完成”状态。 【TODO further transmition】 在接收到导致状态转换到“接收量确认”的流帧后，可能同时导致转入“接收完成”状态。 在所有数据都收完后，可以丢弃该流的任何流帧或流阻塞帧。
“接收完成”状态会一直持续直到数据全部传递到应用层。 一旦流数据传递完成，即转到“读取完成”状态，这是一个最终状态。
如果在“接收”或“数据量确认”状态收到一个流重置帧，将导致流转到“重置接收”状态。 这可能打断流数据传递到应用层。
流重置帧也有可能在所有流数据都收完后才收到（即在“接收完成”阶段）。 同样地，也可能在收完流重置帧后收到了剩下的流数据（即在“重置接收”状态）。 在QUIC的具体实现上，可以自由选择如何处理这两种情况。
发送流重置帧意味着终端不能保证流数据的传输。 然而，并没有要求在收到流重置帧后不传输流数据。 QUIC实现可以打断流数据的传输，丢弃任何没有被消耗的数据，并通知对端收到了流重置帧。 如果流数据完成了接收并被缓存起来以供应用层读取，此时收到流重置帧信号，则该信号可能被抑制或扣留。 如果流重置帧被抑制，流的接收部分仍然维持在“接收完成”状态。
一旦应用层收到流被重置的信号，流的接收部分转到“重置读取”阶段，这是一个最终状态。</description>
    </item>
    
    <item>
      <title>3.3. 许可帧</title>
      <link>/RFC9000_Chinese_Translation/Stream_States/3.3_Permitted_Frame_Types/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9000_Chinese_Translation/Stream_States/3.3_Permitted_Frame_Types/</guid>
      <description>流的发送端发送的帧只有三种能同时影响发送端和接收端状态：流帧（第19.8章）、流阻塞帧（第19.13章），以及流重置帧（第19.4章）。
发送端必须不在最终状态（“接收完成”或“重置接收”）发送任何这些帧。当流处在“重置发送”或任何最终状态时，发送端必须不发送流帧或流阻塞帧——也就是说，在发送完一个流重置帧后。接收端可以在任何状态接收这三种帧，原因在于被延迟的包可能携带这些帧。
流的接收端发送最大流数据帧（第19.19章）及停止发送帧（第19.5章）。
接收端只可以在“接收”状态发送最大流数据帧。如果接收端尚未收到过流重置帧，其可以在任何状态发送一个停止发送帧——也就是除“重置接收”、“重置读取”之外的状态。然而，在“接收完成”状态发送停止发送帧意义不大，因为所有流数据都已经收到了。由于可能存在数据包延迟，因此发送端可以在任何状态接收这两种帧。</description>
    </item>
    
    <item>
      <title>3.4. 双向流状态</title>
      <link>/RFC9000_Chinese_Translation/Stream_States/3.4_Bidirectional_Stream_States/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9000_Chinese_Translation/Stream_States/3.4_Bidirectional_Stream_States/</guid>
      <description>双向流同时包括接收部分和发送部分。 QUIC的实现可以将双向流的状态表示成发送及接收流状态的组合状态。 在最简单的模型里，当发送和接收部分均处在非最终状态时，表示流处于“打开”状态；当两者均处于最终状态时，表示流处于“关闭”状态。
表格2展示了一个更复杂的双向流状态映射，粗略对应HTTP/2（HTTP2）中定义的流状态。 这表明流的发送或接收部分多个状态映射到同一个组合状态。 注意这仅仅是一个可能的映射，这种映射需要数据全部被确认后才能转入“关闭”或“半关闭”状态。
   发送部分 接收部分 组合状态     无流、就绪 无流、接收① 空闲   就绪、发送、发送完成 接收、数据量确认 打开   就绪、发送、发送完成 接收完成、读取完成 半关闭（对端）   就绪、发送、发送完成 重置接收、重置读取 半关闭（对端）   接收完成 接收、数据量确认 半关闭（本端）   重置发送、重置接收 接收、数据量确认 半关闭（本端）   重置发送、重置接收 接收完成、读取完成 关闭   重置发送、重置接收 重置接收、重置读取 关闭   接收完成 接收完成、读取完成 关闭   接收完成 重置接收、重置读取 关闭    表2：流状态到HTTP/2间可能的映射方式
  注意（①）：如果一条流尚未被创建或其接收部分处于“接收”状态而尚未收到任何帧，则流处于“空闲”状态。</description>
    </item>
    
    <item>
      <title>3.5. 请求状态转换</title>
      <link>/RFC9000_Chinese_Translation/Stream_States/3.5_Solicited_State_Transitions/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9000_Chinese_Translation/Stream_States/3.5_Solicited_State_Transitions/</guid>
      <description>如果应用层不再需要流接收到的数据，应用层可以中止流的读取，并指定一个应用层错误码。
如果流处在“接收”或“数据量确认”状态，传输层应该发送一个停止发送帧通知对端及时在反方向关闭流。 这通常表明接收方应用层不再读取流接收到的数据，但这并不意味着传入的数据一定会被忽略。
在发送完停止发送帧后收到的流帧仍然会被连接及流级别的流量控制统计，即使这些帧可能在接收时即被丢弃。
停止发送帧请求接收端发送一个流重置帧。 如果流处在“就绪”或“发送”状态，收到停止发送帧的一端必须发送一个流重置帧。 如果流处在“发送完成”状态，终端可以推迟发送流重置帧直到含有未发完数据的数据包被确认或明确的被丢弃。 如果任何未发完数据得到明确被丢弃了，终端应该发送一个流重置帧而非重传数据。
终端应该从停止发送帧复制错误码到要发出的流重置帧，但是其可以使用任何应用层错误码。 发送停止发送帧的终端可以忽略任何随后被流接收到的流重置帧里的错误码。
停止发送帧应该只能在流尚未被对端重置前发送出去。 停止发送帧主要在流的“接收”或“数据量确认”状态使用。
如果包含前一个停止发送帧的数据包丢失了，期望终端发送另外的停止发送帧。 然而，一旦流收到了所有流数据或一个流重置帧——也就是说流处在“接收”或“数据量确认”之外的状态——发送停止发送帧就不再必要了。
如果双向流的一端想要将流的两个方向同时关闭，那么其可以通过发送一个流重置帧关闭一个方向，并发送一个停止发送帧促使相反方向也迅速得到关闭。</description>
    </item>
    
  </channel>
</rss>
