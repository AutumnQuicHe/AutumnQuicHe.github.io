<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>10.3 无状态重置 on AUTUMN QUICHE</title>
    <link>/RFC9000_Chinese_Translation/Connection_Termination/Stateless_Reset/</link>
    <description>Recent content in 10.3 无状态重置 on AUTUMN QUICHE</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>cn</language><atom:link href="/RFC9000_Chinese_Translation/Connection_Termination/Stateless_Reset/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>10.3.1 检测无状态重置</title>
      <link>/RFC9000_Chinese_Translation/Connection_Termination/Stateless_Reset/10.3.1_Detecting_a_Stateless_Reset/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9000_Chinese_Translation/Connection_Termination/Stateless_Reset/10.3.1_Detecting_a_Stateless_Reset/</guid>
      <description>终端使用UDP数据报末尾的16个字节检测可能的无状态重置。终端记录所有无状态重置令牌，这些令牌关联着连接ID和终端最近发送的数据报的目标远程地址。这些令牌来自新连接ID帧的无状态重置令牌字段和服务器的传输参数，但不包含那些与未使用的或已停用的连接ID关联的无状态重置令牌。终端通过比较数据报的最后16个字节和所有与发送数据报的远程地址关联的无状态重置令牌，来将接收到的数据报识别为无状态重置。
这种比较可以为每个传入数据报进行。如果来自某个数据报的数据包被成功处理了，那么终端可以跳过这个检查。然而，如果一个传入数据报的首个数据包不能与一条连接关联上，或不能被解密，那么必须进行这种比较。
终端必须不为任何关联到它尚未使用或已停用的连接ID上的无状态重置令牌做检查。
在将数据报和无状态重置令牌的值比较时，终端必须在不泄露令牌的值的前提下进行比较。比如，用固定时间进行比较能保护无状态重置令牌免于利用计时侧信道的信息泄露。另一种方法是存储并比较经转换的无状态重置令牌值而不是原始的令牌值，这种转换指的是使用密钥并在密码学上安全的伪随机函数（例如数据块加密算法和散列消息认证码（HMAC，详见《RFC2104》））。终端不必保护有关数据包是否被成功解密和有效的无状态重置令牌数量的信息。
如果数据报的最后16个字节与无状态重置令牌的值一致，那么终端必须进入排空状态，并且在此连接上不再发送数据包。</description>
    </item>
    
    <item>
      <title>10.3.2 计算无状态重置令牌</title>
      <link>/RFC9000_Chinese_Translation/Connection_Termination/Stateless_Reset/10.3.2_Calculating_a_Stateless_Reset_Token/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9000_Chinese_Translation/Connection_Termination/Stateless_Reset/10.3.2_Calculating_a_Stateless_Reset_Token/</guid>
      <description>无状态重置令牌必须难以被猜测。为了创建无状态重置令牌，终端可以为每一个它创建的连接随机生成（详见《RANDOM》）一个秘密值。然而，当集群中有多个实例时它会带来协调上的问题，以及在终端丢失状态时带来存储上的问题。无状态重置是为了处理状态丢失的情况而专门设计的，因此这个方法不是最理想的。
通过使用以固定密钥和由终端选择的连接ID（详见第5.1章）作为输入的伪随机函数来生成令牌，单个固定密钥可以被用于与同一个终端有关的所有连接。终端可以使用HMAC（详见《RFC2104》）（例如，HMAC(固定密钥, 连接ID)）或基于HMAC的密钥衍生函数（HKDF，详见《RFC5869》）（例如，使用固定密钥作为输入密钥材料，使用连接ID作为盐）。这个函数的输出被截断至16字节来作为连接的无状态重置令牌。
丢失状态的终端可以使用相同的方法来生成有效的无状态重置令牌。连接ID来自终端接收到的那个数据包。
这种设计要求对端总是在数据包中发送连接ID，这样终端才可以使用来自数据包的连接ID来重置连接。使用这种设计的终端必须要么为所有连接使用相同长度的连接ID，要么将连接ID长度编码进连接ID以使得它可以在没有状态的情况下恢复。除此之外，它不能提供零长度连接ID。
泄露无状态重置令牌将允许任何实体终止连接，所以一个令牌值只能被使用一次。这种选择无状态重置令牌的方法意味着相同连接ID和固定密钥的组合必须不被用于另一个连接。如果共享同一个固定密钥的实例还使用了相同的连接ID，或者攻击者可以使数据包被路由到没有状态但是使用相同固定密钥的实例，那么就有可能发起拒绝服务攻击；详见第21.11章。如果一个连接ID所在的连接已通过使用无状态重置令牌的方法重置过，那么在共享相同固定密钥的节点上必须不将这个连接ID用于新的连接。
同一个无状态重置令牌必须不被用于多个连接ID。终端不需要将新的令牌值与所有先前的值进行比较，但是重复的值可能被视作类型为PROTOCOL_VIOLATION（协议违反）的连接错误。
注意，无状态重置不受到任何加密保护。</description>
    </item>
    
    <item>
      <title>10.3.3 死循环</title>
      <link>/RFC9000_Chinese_Translation/Connection_Termination/Stateless_Reset/10.3.3_Looping/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9000_Chinese_Translation/Connection_Termination/Stateless_Reset/10.3.3_Looping/</guid>
      <description>无状态重置的设计使得在不知道无状态重置令牌的情况下无法将它与合法的数据包区分开来。举例来说，如果一个服务器往另一个服务器发送了无状态重置，那么作为响应它可能收到另一个无状态重置，这会导致无尽的数据包交换。
终端必须确保每一个它发出的无状态重置都比触发它的数据包要小，除非终端维护着足以避免死循环的状态数据。在循环出现的情况下，这使得数据包最终变得过小而不能触发响应。
终端可以记录它已发送的无状态重置数量并且一旦到达限制数量就不再创建新的无状态重置。为不同的远程地址使用单独的限制可以确保其他对端或连接已到达限制时还能够使用无状态重置来关闭连接。
取决于对端的连接ID长度，小于41字节的无状态重置可能被观察者识别为无状态重置。反过来，对小型数据包不响应无状态重置可能导致无状态重置不能有效地检测连接损坏但是只有小型数据包被发送的情况；这样的失败可能只能被其他方法检测出来，例如计时器。</description>
    </item>
    
  </channel>
</rss>
