<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>13.2 生成确认 on AUTUMN QUICHE</title>
    <link>/RFC9000_Chinese_Translation/Packetization_and_Reliability/Generating_Acknowledgments/</link>
    <description>Recent content in 13.2 生成确认 on AUTUMN QUICHE</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>cn</language><atom:link href="/RFC9000_Chinese_Translation/Packetization_and_Reliability/Generating_Acknowledgments/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>13.2.1 发送ACK帧</title>
      <link>/RFC9000_Chinese_Translation/Packetization_and_Reliability/Generating_Acknowledgments/13.2.1_Sending_ACK_Frames/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9000_Chinese_Translation/Packetization_and_Reliability/Generating_Acknowledgments/13.2.1_Sending_ACK_Frames/</guid>
      <description>所有数据包都应该被确认至少一次，ACK触发包必须在终端使用传输参数max_ack_delay（最大ACK延迟）沟通的最大延迟时间内被确认至少一次，详见第18.2章。max_ack_delay 声明了一个显式的约定：终端承诺不会故意拖延ACK触发包的确认以致延迟时间超过那个约定值。如果它这么做了，那么超出量会积累到RTT预估值上，并且导致来自对端的无效的或延迟的重传。发送方使用接收方的max_ack_delay值来决定基于计时器的重传的超时时间，详见《QUIC恢复》的第6.2章。
除了以下例外，终端必须立即确认所有引发确认的初始数据包和握手数据包，并且在它宣告的max_ack_delay之内确认所有引发确认的0-RTT数据包和1-RTT数据包。终端如果在握手确认前就收到了握手数据包、0-RTT数据包和1-RTT数据包，那么它可能还没有用来解密这些数据包的数据包保护密钥。因此它可以缓存这些数据包，等得到了必要的密钥再确认它们。
由于仅包含ACK帧的数据包不受拥塞控制，终端在响应一个ACK触发包时，必须不发送超过一个这样的数据包。
终端在响应非ACK触发包时，必须不发送非ACK触发包，即便在接收到的数据包前存在数据包空档。这避免了用确认响应确认的无限循环，避免连接无法进入闲置状态。非ACK触发包最终会在终端响应其他事件而发送的ACK帧中被确认。
一味发送ACK帧的终端不会从对端收到确认，除非这些帧和ACK触发帧一起被包含在数据包中。当有新的ACK触发包要确认时，终端应该将这些ACK帧一块发送。当只有非ACK触发包要确认时，终端可以选择等接收到一个ACK触发包时再将这些ACK帧一块发送。
只发送非ACK触发包的终端可以选择偶尔添加一个ACK触发帧到这些数据包中以确保它能收到确认，详见第13.2.4章。在那种情况下，终端必须不在所有本来不引发确认的数据包中都添加ACK触发帧，以避免用确认响应确认的无限循环。
为了辅助发送方的丢包检测，在以下情况中若收到一个ACK触发包，终端应该立即生成并发送ACK帧：
  当接收到的数据包的数据包号小于另一个已经被接收到的ACK触发包的时；
  当接收到的数据包的数据包号大于已接收到的ACK触发包的数据包号最大值，且在它们之间有缺失的数据包时。
  类似地，标记了IP头部的ECN拥塞预警（CE）码点的数据包应该被立即确认，以减少对端对拥塞事件的响应时间。
对没有遵守以上指导的接收方，《QUIC恢复》中的算法应当是能适应的。即使如此，QUIC实现也应该在谨慎地考虑任何变更会对性能的影响之后，再违背这些要求，既要考虑对终端建立的连接的性能影响，也要考虑对网络中其他用户的性能影响。</description>
    </item>
    
    <item>
      <title>13.2.2 确认频率</title>
      <link>/RFC9000_Chinese_Translation/Packetization_and_Reliability/Generating_Acknowledgments/13.2.2_Acknowledgment_Frequency/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9000_Chinese_Translation/Packetization_and_Reliability/Generating_Acknowledgments/13.2.2_Acknowledgment_Frequency/</guid>
      <description>作为ACK触发包的响应而发送的确认，其频率是由接收方决定的。这个决策包含了一种权衡。
终端依靠及时的确认以检测丢包，详见《QUIC恢复》的第6章。基于窗口的拥塞控制器，例如《QUIC恢复》的第7章中描述的那个，依靠确认来管理它们的拥塞窗口。在这两种情况中，延迟确认都会对性能产生不利影响。
另一方面，降低仅携带确认的数据包的频率能同时减少两个终端在传输和处理上的资源消耗。它能提高在极端不对称的链路上的连接吞吐量，并使用返回路径的容量来减少因确认而产生的流量，详见《RFC3449》的第3章。
接收方在接收到至少两个ACK触发包后应该发送一个ACK帧。这一推荐做法本质上是通用的，并且和TCP终端行为（《RFC5681》）的推荐做法是一致的。有关网络条件的知识、有关对端拥塞控制器的知识或将来的研究和实验可能建议替代本做法的有着更好的性能特征的确认策略。
接收方可以在决定是否要发送ACK帧作为响应前先处理掉几个可用的数据包。</description>
    </item>
    
    <item>
      <title>13.2.3 管理ACK块</title>
      <link>/RFC9000_Chinese_Translation/Packetization_and_Reliability/Generating_Acknowledgments/13.2.3_Managing_ACK_Ranges/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9000_Chinese_Translation/Packetization_and_Reliability/Generating_Acknowledgments/13.2.3_Managing_ACK_Ranges/</guid>
      <description>被发送的ACK帧中包含一个或多个已确认数据包的块。包含对更早期的数据包的确认减少了因之前发送的ACK帧丢包而引起无效重传的可能性，代价是ACK帧会变得更大。
ACK帧应该始终确认最近接收到的数据包，同时接收到的数据包越是乱序，尽快发送更新后的ACK帧就越是重要，以避免对端将某个数据包认定为丢包而对其中包含的帧进行无效的重传。一个ACK帧应当能被放进单个QUIC数据包中。如果不能，那么更早期的块（有着最小的数据包号的那些）会被省略。
接收方限制它记录的ACK块（详见第19.3.1章）的数量和在ACK帧中发送的ACK块的数量，这既是为了限制ACK帧的尺寸也是为了避免耗尽资源。在接收到对一个ACK帧的确认后，接收方应该停止追踪那些在帧中被确认的ACK块。发送方可以期待绝大多数数据包都被确认，但是QUIC不保证接收方处理的所有数据包的确认都被对端接收到。
因保留了许多ACK块而使得ACK帧变得过大是有可能的。接收方可以丢弃未被确认的ACK块以限制ACK帧的尺寸，代价是来自发送方的更多重传。如果一个ACK帧大到放不进一个数据包中，那么就有必要这么做。接收方还可以进一步限制ACK帧的尺寸来为其他帧腾出空间，或为了限制确认所消耗的数据包容量。
除非接收方能确信它后续接收到的数据包号不会落在某个ACK块中，否则它必须保留那个块。使用最少的状态来做到这一点的方法之一是维护一个最小的数据包号，它会随着块被丢弃而增大。
接收方可以丢弃所有ACK块，但是必须保留最大的已被成功处理的数据包号，因为它被用于从后续数据包中恢复数据包号，详见第17.1章。
接收方应该在所有ACK帧中包含最大的已接收到的数据包号。这个最大确认数字段被用于在发送方一侧进行的ECN验证，使用一个比先前发送的ACK帧中的更小的值会造成ECN被不必要地禁用，详见第13.4.2章。
第13.2.4章描述了一个如何决定在各个ACK帧中分别确认哪些数据包的示例方法。尽管这个算法的目标是为每个已处理的数据包生成一个确认，但是确认依旧有可能遭遇丢包。</description>
    </item>
    
    <item>
      <title>13.2.4 通过追踪ACK帧来限制块</title>
      <link>/RFC9000_Chinese_Translation/Packetization_and_Reliability/Generating_Acknowledgments/13.2.4_Limiting_Ranges_by_Tracking_ACK_Frames/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9000_Chinese_Translation/Packetization_and_Reliability/Generating_Acknowledgments/13.2.4_Limiting_Ranges_by_Tracking_ACK_Frames/</guid>
      <description>当发送包含某个ACK帧的数据包时，可以记录那个帧中的最大确认数。当接收到包含某个ACK帧的数据包的确认时，如果某个数据包的数据包号小于等于为那个ACK帧记录的最大确认数，那么接收方就可以不再确认这个数据包。
只发送非ACK触发包，例如ACK帧，的接收方可能很长一段时间都接收不到确认。这会导致接收方需要为大量ACK帧的状态维护很长一段时间，同时它发送的ACK帧会不必要地变得特别大。在这种情况下，接收方可以偶尔，比如每经过一轮往返时间就进行一次，发送一个Ping帧或其他小型的ACK触发帧，来引发来自对端的ACK帧。
在ACK帧没有遇到丢包的情况下，这个算法在每至少1RTT内提供一次重排ACK块的机会。在ACK帧遇到丢包和乱序的情况下，这个方法并不能保证所有确认都在它们不再被包含进ACK帧前就被发送方接收到。数据包还有可能在接收时已经被打乱顺序，或者所有后续包含它们的数据包号的ACK帧都遇到丢包。在这种情况下，丢包恢复算法可能引起无效的重传，但是发送方会继续进行有效的传输。</description>
    </item>
    
    <item>
      <title>13.2.5 测量和报告主机延迟</title>
      <link>/RFC9000_Chinese_Translation/Packetization_and_Reliability/Generating_Acknowledgments/13.2.5_Measuring_and_Reporting_Host_Delay/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9000_Chinese_Translation/Packetization_and_Reliability/Generating_Acknowledgments/13.2.5_Measuring_and_Reporting_Host_Delay/</guid>
      <description>从具有最大数据包号的数据包被接收到的那一刻起，到对于它的确认被发送时，这期间的时间会作为一个被有意引入的延迟而被终端测量。终端将这个确认延迟编码在ACK帧的ACK延迟字段，详见第19.3章。这使得这个ACK帧的接收方能够获知这些有意引入的延迟并作出调整，当确认出现延误时这一调整对更好地评估路径RTT是很重要的。
在得到处理前，数据包可能被暂留在操作系统内核或主机的其他什么地方。在填写ACK帧的ACK延迟字段时，终端必须不在值中包括不受它控制的延迟。然而，终端应该在值中包含由缺少解密密钥造成的缓存延迟，因为这些延迟可以变得很大，而且有可能是非重复出现的。
当测量到的确认延迟比max_ack_delay大时，终端应该报告这个测量到的延迟。这个信息在握手期间延迟可能会很大的情况下是特别有用的，详见第13.2.1章。</description>
    </item>
    
    <item>
      <title>13.2.6 ACK帧和数据包保护</title>
      <link>/RFC9000_Chinese_Translation/Packetization_and_Reliability/Generating_Acknowledgments/13.2.6_ACK_Frames_and_Packet_Protection/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9000_Chinese_Translation/Packetization_and_Reliability/Generating_Acknowledgments/13.2.6_ACK_Frames_and_Packet_Protection/</guid>
      <description>ACK帧必须被携带于一个和正在确认的数据包的数据包号空间相同的数据包中，详见第12.1章。举个例子，受1-RTT密钥保护的数据包必须在同样被1-RTT密钥保护的数据包中被确认。
客户端发送的受0-RTT数据包保护的数据包必须被服务器在受1-RTT密钥保护的数据包中确认。这意味着如果服务器的加密握手消息被延误或丢失，则客户端有可能无法使用这些确认。注意，同样的限制还适用于服务器发送的受1-RTT密钥保护的其他数据。</description>
    </item>
    
    <item>
      <title>13.2.7 填充帧消耗拥塞窗口</title>
      <link>/RFC9000_Chinese_Translation/Packetization_and_Reliability/Generating_Acknowledgments/13.2.7_PADDING_Frames_Consume_Congestion_Window/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9000_Chinese_Translation/Packetization_and_Reliability/Generating_Acknowledgments/13.2.7_PADDING_Frames_Consume_Congestion_Window/</guid>
      <description>包含填充帧的数据包会被纳入拥塞控制的考量，详见《QUIC恢复》。而仅仅包含填充帧的数据包虽然会消耗拥塞窗口但是不会引发确认来恢复拥塞窗口。为了避免死锁，发送方应该确保每隔一段时间会发送一次除填充帧外的其他帧，来引发来自接收方的确认。</description>
    </item>
    
  </channel>
</rss>
