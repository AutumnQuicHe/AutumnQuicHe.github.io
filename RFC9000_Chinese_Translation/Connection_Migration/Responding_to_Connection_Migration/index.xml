<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>9.3 响应连接迁移 on AUTUMN QUICHE</title>
    <link>/RFC9000_Chinese_Translation/Connection_Migration/Responding_to_Connection_Migration/</link>
    <description>Recent content in 9.3 响应连接迁移 on AUTUMN QUICHE</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>cn</language><atom:link href="/RFC9000_Chinese_Translation/Connection_Migration/Responding_to_Connection_Migration/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>9.3.1 来自对端的地址伪造</title>
      <link>/RFC9000_Chinese_Translation/Connection_Migration/Responding_to_Connection_Migration/9.3.1_Peer_Address_Spoofing/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9000_Chinese_Translation/Connection_Migration/Responding_to_Connection_Migration/9.3.1_Peer_Address_Spoofing/</guid>
      <description>对端有可能伪造它的源地址来使得终端向不愿意接收的主机发送过量数据。如果终端发送的数据量比正在伪造的对端发送的要多得多，那么连接迁移可能被用来放大攻击者能够向受害者发送的数据量。
如第9.3章中所述，终端应该验证对端的新地址以确认对端在新地址上拥有处理能力。在对端的地址被认定为有效前，终端限制它向那个地址发送的数据量，详见第8章。如果没有这个限制，终端就要承担被用于针对毫无戒备的受害者的拒绝服务攻击的风险。
如果终端如上文一般跳过了对端地址验证，那么它就不需要限制它的发送速率。</description>
    </item>
    
    <item>
      <title>9.3.2 来自路径上设备的地址伪造</title>
      <link>/RFC9000_Chinese_Translation/Connection_Migration/Responding_to_Connection_Migration/9.3.2_On-Path_Address_Spoofing/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9000_Chinese_Translation/Connection_Migration/Responding_to_Connection_Migration/9.3.2_On-Path_Address_Spoofing/</guid>
      <description>在路径上的攻击者可以通过拷贝并转发具有伪造地址的数据包并使它比原始数据包更早到达的方式引发虚假的连接迁移。具有伪造地址的数据包将被视为来自连接迁移，而原始数据包将被视为重复并被丢弃。在一次虚假迁移之后，对源地址的验证将会失败，因为在源地址上的实体没有读取或响应发给它的通道挑战帧所需的加密密钥，哪怕它真的想这么做。
为了保护连接免于因为这样的虚假迁移而失败，当对于新对端地址的验证失败后，终端必须回退并使用最后一个经验证的对端地址。除此之外，从合法对端地址接收到具有最大数据包号的数据包，将触发另一次连接迁移。这将使得对虚假迁移的地址的验证被放弃，其中正包括由注入单个数据包的攻击者发起的迁移。
如果终端没有关于最后一个经验证的对端地址的状态，它必须以丢弃所有此连接的状态数据的方式静默地关闭连接。这会造成这条连接上的新数据包被以常规方式处理。例如，终端可以在响应将来的传入数据包时发送无状态重置。</description>
    </item>
    
    <item>
      <title>9.3.3 来自非路径上设备的数据包转发</title>
      <link>/RFC9000_Chinese_Translation/Connection_Migration/Responding_to_Connection_Migration/9.3.3_Off-Path_Packet_Forwarding/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9000_Chinese_Translation/Connection_Migration/Responding_to_Connection_Migration/9.3.3_Off-Path_Packet_Forwarding/</guid>
      <description>不在路径上的但能观测数据包的攻击者可以将真实数据包的副本转发到终端上。如果数据包副本比真实数据包更早到达，这就会表现得像是NAT重绑定一样。任何真实数据包都会因为重复而被丢弃。如果攻击者有能力继续转发数据包，它就有可能使得迁移的路径经过攻击者。这会使得攻击者位于路径上，给予它观测或丢弃任何后续数据包的能力。
这种形式的攻击要求攻击者使用一条有着和终端间的直连路径近乎相似的特征的路径。如果发送的数据包相对较少，或数据包丢包与计划的攻击同时发生，那么这种攻击的成功率就更加可靠。
在原始路径上接收到的会增加最大的已接收到的数据包号的非探测数据包将使得终端移动回那条路径。在这条路径上引发数据包增加了攻击失败的可能性。因此，这种攻击的抵御依赖于触发数据包交换。
在响应一个看起来很像的迁移时，终端必须使用通道挑战帧验证先前的活跃路径。这能在那条路径上引入新数据包的发送。如果那条路径不再可用，那么验证路径的尝试会超时并失败；如果路径时可用的但是不再被需要，验证就会成功但是仅仅使得那条路径上被多发送了几个探测数据包。
在活跃路径上接收到通道挑战帧的终端应该在发送非探测数据包作为响应。如果这个非探测数据包比任何攻击者创建的副本到达得都要早，这就能使得连接被迁移回原始路径。任何后续去往另一条路径的迁移都会重启上述整个过程。
这种防御是不完美的，但是它不被认为是一个严肃的问题。如果在尝试过数次原始路径的情况下，通过攻击者的路径还总是比原始路径更快，那么这很难说究竟是一次攻击，还是对路由的优化。
终端还可以使用启发式的方法来提升对这种形式的攻击的检测。例如，如果最近在旧路径上接收到过数据包，那么NAT重绑定是不太可能发生的；类似地，重绑定在IPv6路径上是很少见的。终端也可以寻找有没有重复的数据包。或者换个思路，连接ID上的改变更有可能表明这是一次有意的迁移，而不是一次攻击。</description>
    </item>
    
  </channel>
</rss>
