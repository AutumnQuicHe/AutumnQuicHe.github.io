<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>7. 加密与传输握手 on AUTUMN QUICHE</title>
    <link>/RFC9000_Chinese_Translation/Cryptographic_and_Transport_Handshake/</link>
    <description>Recent content in 7. 加密与传输握手 on AUTUMN QUICHE</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>cn</language><atom:link href="/RFC9000_Chinese_Translation/Cryptographic_and_Transport_Handshake/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>7.1. 握手流程示例</title>
      <link>/RFC9000_Chinese_Translation/Cryptographic_and_Transport_Handshake/7.1_Example_Handshake_Flows/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9000_Chinese_Translation/Cryptographic_and_Transport_Handshake/7.1_Example_Handshake_Flows/</guid>
      <description>关于TLS如何与QUIC整合的更多细节详见《QUIC-TLS》，但在此举出一些范例。 用以支持客户端地址验证的这种交换的一个扩展详见第8.1.2章。
一旦完成任何地址验证交换，加密握手将用于协商密钥。 加密握手由初始包（第17.2.2章）和握手包（第17.2.4章）携带。
图5展示了1-RTT握手过程的概况。 每行展示一个QUIC数据包，首先展示其包类型和包号，紧接着展示这类包通常包含的帧。 例如首包通常是初始包，包号是0，且包含一个携带ClientHello内容的加密帧。
多个QUIC包——甚至包类型各不相同——可以合并成一个UDP报文，详见第12.2章。 因此，这次握手可能由仅仅4个或更少的UDP报文组成（受限于协议固有的诸如拥塞控制和反放大机制）。 例如，服务端的首个报文包含初始包、握手包及包含“0.5-RTT数据”的1-RTT包。
 TODO：图5
  图5：1-RTT握手示例
 图6是一个0-RTT握手连接的示例，并且其中一个数据包携带0-RTT数据。 注意，如第12.3章所述，服务端在1-RTT包中对0-RTT数据进行确认，并且客户端发送的1-RTT包处于同一个包号空间。
 TODO：图6
  图6：0-RTT握手示例
 </description>
    </item>
    
    <item>
      <title>7.2. 协商连接ID</title>
      <link>/RFC9000_Chinese_Translation/Cryptographic_and_Transport_Handshake/7.2_Negotiating_Connection_IDs/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9000_Chinese_Translation/Cryptographic_and_Transport_Handshake/7.2_Negotiating_Connection_IDs/</guid>
      <description>连接ID用于确保数据包稳定路由，详见第5.1章。 长包头包含两个连接ID：目标连接ID由接收方指定并用于提供稳定路由；源连接ID供对端设置为目标连接ID。
在握手期间，带有长包头（详见第17.2章）的数据包用于设置双端所使用的连接ID。 每端的源连接ID会作为发往该端的数据包的目标连接ID。 在处理完首个初始数据包后，每端将后续发送数据包的目标连接ID字段值设置为其接收的源连接ID字段值。
当客户端发送初始包之前未从服务端收到过初始数据包或重试数据包，则生成不可预测值填充发送的初始包的目标连接ID字段。 目标连接ID的长度必须至少8字节。 客户端在一条连接上必须使用同一个目标连接ID，直到收到服务端发来的数据包为止。
客户端发送的首个初始数据包的目标连接ID字段用于确定初始数据包的包保护密钥。 这些密钥在收到重试数据包后变更，详见QUIC-TLS第5.2章。
客户端选择一个值填充源连接ID字段，并设置源连接ID长度字段以标识其长度。
客户端发送的首个0-RTT数据包使用其发送的首个初始数据包一致的源连接ID和目标连接ID。
在首次收到从服务端发来的初始数据包或重试数据包后，客户端将服务的提供的源连接ID作为后续发送数据包的目标连接ID，包括任何0-RTT包。 这意味着客户端可能需要在连接建立阶段将目标连接ID字段的值变更两次： 一次是响应服务端发来的重试数据包，一次是响应服务端发来的初始数据包。 一旦客户端收到一个从服务端发来的有效的初始数据包，则其必须丢弃在该连接上后续接收到的任何带有不同源连接ID值的数据包。
客户端必须在收到首个初始数据包或首个重试数据包后，更改其后续发送数据包时的目标连接ID值。 服务端必须基于收到的首个初始数据包设置发送数据包的目标连接ID。 任何针对目标连接ID的后续改动，只允许通过新连接ID帧携带的值进行； 如果后续的初始数据包包含不同的源连接ID，则必须将该包丢弃。 这避免了对多个具有不同源连接ID的初始数据包进行无状态处理可能导致的不可预测的结果。
终端发出的目标连接ID可以在一条连接的生命周期内变更，尤其是在响应连接迁移（第9章），详见第5.1.1章。</description>
    </item>
    
    <item>
      <title>7.3. 验证连接ID</title>
      <link>/RFC9000_Chinese_Translation/Cryptographic_and_Transport_Handshake/7.3_Authenticating_Connection_IDs/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9000_Chinese_Translation/Cryptographic_and_Transport_Handshake/7.3_Authenticating_Connection_IDs/</guid>
      <description>终端在握手期间的连接ID做出的选择，通过包括传输参数的所有的值验证，详见第7.4章。 这确保所有用于握手的连接ID也同时通过加密握手得到认证了。
终端将其发出的首个初始数据包的源连接ID字段值包含在initial_source_connection_id传输参数中，详见第18.2章。 服务端将其接收到的首个初始数据包中的目标连接ID值包含在original_destination_connection_id传输参数中；如果服务端发送了一个重试数据包，则其对应的是发送该包之前收到的首个初始数据包。 如果发送重试数据包，服务端也会将重试数据包的源连接ID字段包含在retry_source_connection_id传输参数中。
来自对端的传输参数中的值必须与终端 在其发送的（对于服务端，则同时包括其接收到的）初始数据包的目标连接ID和源连接ID字段所使用的值保持一致。 终端必须验证其接收到的传输参数匹配接收到的连接ID值。 将连接ID值包含在传输参数中并认证，从而确保攻击者不能在握手期间通过插入携带有攻击者选择的连接ID的数据包影响连接ID的选择。
终端必须将 任意终端缺失initial_source_connection_id传输参数以及服务端缺失original_destination_connection_id传输参数视为TRANSPORT_PARAMETER_ERROR类型的连接错误。
终端必须将下述情况视为TRANSPORT_PARAMETER_ERROR或PROTOCOL_VIOLATION类型的连接错误：
 服务端在接收到一个重试数据包后，缺失retry_source_connection_id传输参数， 未接收到重试数据包，但是却存在retry_source_connection_id传输参数，或 从对端接收到的传输参数中的值与发送的初始数据包中相应目标连接ID或源连接ID字段不一致。  如果选择了一个零长度连接ID，则相应的传输参数包含一个零长度值。
图7展示了一个完整握手过程中连接ID的使用（其中DCID表示目标连接ID，SCID表示源连接ID）。 图中展示了初始数据包如何交换，以及随后1-RTT数据包的交换，其中包括握手期间创建的连接ID。
 TODO：图7
  图7：握手期间连接ID的使用
 图8展示了包含重试数据包的握手过程。
 TODO：图8
  图8：使用重试数据包的握手中连接ID的使用
 在上述两种情况（图7和图8）下，客户端设置其initial_source_connection_id传输参数值为C1。
当握手过程没有出现重试数据包（图7），服务端设置original_destination_connection_id为S1（注意该值是客户端选择的），设置initial_source_connection_id为S3。 在这种情况下，服务端不包含retry_source_connection_id传输参数。
When the handshake includes a Retry (Figure 8), the server sets original_destination_connection_id to S1, retry_source_connection_id to S2, and initial_source_connection_id to S3.
当握手过程出现了重试数据包（图8），服务端设置original_destination_connection_id为S1，设置retry_source_connection_id为S2，设置initial_source_connection_id为S3。</description>
    </item>
    
    <item>
      <title>7.5. 加密信息缓存</title>
      <link>/RFC9000_Chinese_Translation/Cryptographic_and_Transport_Handshake/7.5_Cryptographic_Message_Buffering/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9000_Chinese_Translation/Cryptographic_and_Transport_Handshake/7.5_Cryptographic_Message_Buffering/</guid>
      <description>QUIC实现需要维护一个用于保存乱序接收到的加密数据的缓存区。 由于加密帧没有流量控制，终端有可能强制对端缓存无限量的数据。
QUIC实现必须支持缓存至少4096字节从乱序加密帧收到的数据。 终端可以选择允许在握手期间缓存更多的数据。 更大的缓存上限意味着可以交换更大的密钥或证书。 终端的缓存区大小不必在整个连接生命周期内保持不变。
握手期间无法缓存加密帧可能导致连接失败。 如果终端的缓存区在握手期间溢出，则其可以通过暂时扩大缓存空间确保握手完成。 如果终端不扩大其缓存，则其必须以错误码CRYPTO_BUFFER_EXCEEDED关闭连接。
Once the handshake completes, if an endpoint is unable to buffer all data in a CRYPTO frame, it MAY discard that CRYPTO frame and all CRYPTO frames received in the future, or it MAY close the connection with a CRYPTO_BUFFER_EXCEEDED error code. Packets containing discarded CRYPTO frames MUST be acknowledged because the packet has been received and processed by the transport even though the CRYPTO frame was discarded.</description>
    </item>
    
  </channel>
</rss>
