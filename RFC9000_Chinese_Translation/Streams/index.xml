<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>2. 流 on Autumn Navigation</title>
    <link>/RFC9000_Chinese_Translation/Streams/</link>
    <description>Recent content in 2. 流 on Autumn Navigation</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>cn</language><atom:link href="/RFC9000_Chinese_Translation/Streams/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>2.1. 流类型及标识符</title>
      <link>/RFC9000_Chinese_Translation/Streams/2.1_Stream_Types_and_Identifiers/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9000_Chinese_Translation/Streams/2.1_Stream_Types_and_Identifiers/</guid>
      <description>流可以是单向或双向的。单向流往一个方向传输数据：从流发起端向对端发送；双向流允许双端向对端发送数据。
在连接中，流以一个数字值标识，称为流ID。一个流ID是一个62比特的整数（0-262-1），且与同连接中其他流的流ID严格区分。流ID编码为一个可变长度整型，详见第16章。一个QUIC终端必须不能在同一个连接的不同流上重复使用同一个数值作为流ID。
流ID的最小有效位（0x01）标识流的发起者。 客户端发起的流的ID是偶数（该位被置为0），服务端发起的流的ID是奇数（该位被置为1）。
流ID的次小有效位（0x02）标识流是双向流（该位被置为0）抑或单向流（该位被置为1）。
也就是说，流ID的最小两个有效位用来标识一条流是总共四种流类型中的哪一种，总结在如下表格1中：
   位 流类型     0x00 客户端创建的双向流   0x01 服务端创建的双向流   0x02 客户端创建的单向流   0x03 服务端创建的单向流    表格1：流类型
 每种流类型的流空间从其最小值开始（依次从0x00到0x03）；每种流的每个流ID根据创建顺序依次线性递增。 如果不按顺序地使用了一个流ID，将导致相同流类型的所有具有更小的流ID的流都被开启。</description>
    </item>
    
    <item>
      <title>2.2. 数据发送与接收</title>
      <link>/RFC9000_Chinese_Translation/Streams/2.2_Sending_and_Receiving_Data/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9000_Chinese_Translation/Streams/2.2_Sending_and_Receiving_Data/</guid>
      <description>流帧（第19.8章）封装应用层发送的数据。 终端使用流帧的流ID及偏移字段整理数据。
终端必须将流数据以一个有序字节流传递给应用层。 传递一个有序字节流需要终端缓存任何接收到的乱序数据，直到到达了建议的流量控制限制的上限。
QUIC对于传递流的无序数据并没有做额外的打算。 然而，实现上 可以选择支持传递无序数据给应用层接收。
终端可以从一条流的同一个偏移位置多次接收数据。 如果数据已经被接收过了，就会直接被丢弃。 处在任何偏移位置的数据如果被重复发送，其必须不能更改。 终端可以将在流的同一偏移处收到不同数据的情况视为PROTOCOL_VIOLATION类型（违反协议）的连接错误。
流是一个抽象的有序字节流，QUIC不感知除此以外的任何结构。 流帧的边界在数据被传输、丢包后重传以及被传递给应用层接收者后，不会继续保留。
终端必须不能在对端设置的流量控制限制之外发送任何数据。流量控制详见第4章。</description>
    </item>
    
    <item>
      <title>2.3. 流优先级</title>
      <link>/RFC9000_Chinese_Translation/Streams/2.3_Stream_Prioritization/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9000_Chinese_Translation/Streams/2.3_Stream_Prioritization/</guid>
      <description>如果资源以正确的优先级分配给多条流，那么流的多路复用可以对应用性能产生显著影响。
QUIC并不支持交换优先级信息，相反，其依赖从应用层接收的优先级信息。
QUIC在实现上应该提供某种方法使得应用层能够因此确定各条流的相对优先级。 一种实现是使用应用层提供的信息决定分配多少资源来激活流。</description>
    </item>
    
    <item>
      <title>2.4. 流操作</title>
      <link>/RFC9000_Chinese_Translation/Streams/2.4._Operations_on_Streams/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/RFC9000_Chinese_Translation/Streams/2.4._Operations_on_Streams/</guid>
      <description>本文没有定义QUIC API，而是定义了一系列流操作相关的函数可以用于应用层协议的构建。 应用层协议可以假定QUIC有关实现提供了本章描述的操作对应的接口。 为一个特定应用层协议设计实现的QUIC协议可能仅仅提供该协议需要的这些操作。
在流的发送部分，应用层协议可以：
 写数据，只有当流量控制给数据写出留足空间（第4.1章）才能成功写出； 结束流（清理并关闭），发送一个设置FIN位为1的流帧（第19.8章）； 重置流（中止并关闭），当流未处在终止状态时发送一个RESET_STREAM帧（第19.4章）。  在流的接收部分，应用层协议可以：
 读数据，以及 中止读取流数据并请求关闭流，该操作可能需要发送STOP_SENDING帧（第19.5章）。  应用层协议也可以请求在流状态改变的时候收到通知信息，包括当对端开启或重置流、对端中止流数据读取、有新数据可以读取、以及数据可以写出或因流控不能写出。</description>
    </item>
    
  </channel>
</rss>
